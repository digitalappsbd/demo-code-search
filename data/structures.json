[{"structure_type": "function", "name": "setUp", "docstring": "", "module": "config", "file_path": "core/config/quran_screen.dart", "file_name": "quran_screen.dart", "line": 45, "line_from": 45, "line_to": 283, "snippet": "  static void setUp(BuildContext context) {\n    final Size size = MediaQuery.sizeOf(context);\n    _height = size.height;\n    _width = size.width;\n    _resetIfInvalid();\n  }\n\n  static double? _width;\n  static double? _height;\n\n  static Size get _size => MediaQuery.sizeOf(QuranMajeed.globalContext);\n\n  static double get width {\n    _width ??= _size.width;\n    return _width!;\n  }\n\n  static double get height {\n    _height ??= _size.height;\n    return _height!;\n  }\n\n  static void _resetIfInvalid() {\n    if (_width! < 10 || _height! < 10) {\n      logErrorStatic(\n        'QuranScreen size not initialized. Please initialize QuranScreen and try again.',\n        \"quran_screen\",\n      );\n      _width = null;\n      _height = null;\n    }\n  }\n}\n\nextension QuranScreenWidth on Widget {\n  static double? _onePercentWidth;\n\n  double get onePercentWidth {\n    const double onePercent = 0.01;\n    _onePercentWidth ??= QuranScreen.width * onePercent;\n    return _onePercentWidth!;\n  }\n\n  static double? _twoPercentWidth;\n\n  double get twoPercentWidth {\n    const double twoPercent = 0.02;\n    _twoPercentWidth ??= QuranScreen.width * twoPercent;\n    return _twoPercentWidth!;\n  }\n\n  static double? _fiftyPercentHeight;\n\n  double get fiftyPercentHeight {\n    const double fiftyPercent = 0.50;\n    _fiftyPercentHeight ??= QuranScreen.height * fiftyPercent;\n    return _fiftyPercentHeight!;\n  }\n\n  static double? _threePercentWidth;\n\n  double get threePercentWidth {\n    const double threePercent = 0.03;\n    _threePercentWidth ??= QuranScreen.width * threePercent;\n    return _threePercentWidth!;\n  }\n\n  static double? _fourPercentWidth;\n\n  double get fourPercentWidth {\n    _fourPercentWidth ??= 4.percentWidth;\n    return _fourPercentWidth!;\n  }\n\n  static double? _fivePercentWidth;\n\n  double get fivePercentWidth {\n    _fivePercentWidth ??= 5.percentWidth;\n    return _fivePercentWidth!;\n  }\n\n  static double? _sixPercentWidth;\n\n  double get sixPercentWidth {\n    const double sixPercent = 0.06;\n    _sixPercentWidth ??= QuranScreen.width * sixPercent;\n    return _sixPercentWidth!;\n  }\n\n  static double? _sevenPercentWidth;\n\n  double get sevenPercentWidth {\n    const double sevenPercent = 0.07;\n    _sevenPercentWidth ??= QuranScreen.width * sevenPercent;\n    return _sevenPercentWidth!;\n  }\n\n  static double? _eightPercentWidth;\n\n  double get eightPercentWidth {\n    const double eightPercent = 0.08;\n    _eightPercentWidth ??= QuranScreen.width * eightPercent;\n    return _eightPercentWidth!;\n  }\n\n  static double? _tenPercentWidth;\n\n  double get tenPercentWidth {\n    const double tenPercentWidth = 0.10;\n    _tenPercentWidth ??= QuranScreen.width * tenPercentWidth;\n    return _tenPercentWidth!;\n  }\n\n  static double? _fortyPercentWidth;\n\n  double get fortyPercentWidth {\n    const double fortyPercent = 0.40;\n    _fortyPercentWidth ??= QuranScreen.width * fortyPercent;\n    return _fortyPercentWidth!;\n  }\n\n  static double? _thirtyPercentWidth;\n\n  double get thirtyPercentWidth {\n    const double thirtyPercentWidth = 0.32;\n    _thirtyPercentWidth ??= QuranScreen.width * thirtyPercentWidth;\n    return _thirtyPercentWidth!;\n  }\n\n  static double? _sixtySixPercentWidth;\n\n  double get sixtySixPercentWidth {\n    _sixtySixPercentWidth ??= 66.percentWidth;\n    return _sixtySixPercentWidth!;\n  }\n\n  static double? _fiftyFivePercentWidth;\n\n  double get fiftyFivePercentWidth {\n    _fiftyFivePercentWidth ??= 55.percentWidth;\n    return _fiftyFivePercentWidth!;\n  }\n\n  static double? _seventyPercentWidth;\n\n  double get seventyPercentWidth {\n    const double seventyPercent = 0.70;\n    _seventyPercentWidth ??= QuranScreen.width * seventyPercent;\n    return _seventyPercentWidth!;\n  }\n\n  static double? _tweentyEightPercentWidth;\n\n  double get tweentyEightPercentWidth {\n    const double tweentyEightPercentWidth = 0.28;\n    _tweentyEightPercentWidth ??= QuranScreen.width * tweentyEightPercentWidth;\n    return _tweentyEightPercentWidth!;\n  }\n\n  static double? _twentyPercentWidth;\n\n  double get twentyPercentWidth {\n    const double twentyPercentWidth = 0.20;\n    _twentyPercentWidth ??= QuranScreen.width * twentyPercentWidth;\n    return _twentyPercentWidth!;\n  }\n\n  static double? _twentyFivePercentWidth;\n\n  double get twentyFivePercentWidth {\n    const double twentyFivePercentWidth = 0.25;\n    _twentyFivePercentWidth ??= QuranScreen.width * twentyFivePercentWidth;\n    return _twentyFivePercentWidth!;\n  }\n\n  static double? _twentySixPercentWidth;\n\n  double get twentySixPercentWidth {\n    const double twentySixPercentWidth = 0.26;\n    _twentySixPercentWidth ??= QuranScreen.width * twentySixPercentWidth;\n    return _twentySixPercentWidth!;\n  }\n\n  static double? _twentyThreePercentWidth;\n\n  double get twentyThreePercentWidth {\n    const double twentyThreePercentWidth = 0.23;\n    _twentyThreePercentWidth ??= QuranScreen.width * twentyThreePercentWidth;\n    return _twentyThreePercentWidth!;\n  }\n\n  static double? _fourtyPercentWidth;\n\n  double get fourtyPercentWidth {\n    const double fourtyPercentWidth = 0.40;\n    _fourtyPercentWidth ??= QuranScreen.width * fourtyPercentWidth;\n    return _fourtyPercentWidth!;\n  }\n\n  static double? _twentyPercentHeight;\n\n  double get twentyPercentHeight {\n    const double twentyPercent = 0.20;\n    _twentyPercentHeight ??= QuranScreen.height * twentyPercent;\n    return _twentyPercentHeight!;\n  }\n\n  static double? _tenPercentHeight;\n\n  double get tenPercentHeight {\n    const double tenPercentHeight = 0.10;\n    _tenPercentHeight ??= QuranScreen.height * tenPercentHeight;\n    return _tenPercentHeight!;\n  }\n\n  static double? _twelvePercentHeight;\n\n  double get twelvePercentHeight {\n    const double twentyPercent = 0.12;\n    _twelvePercentHeight ??= QuranScreen.height * twentyPercent;\n    return _twelvePercentHeight!;\n  }\n\n  static double? _fourteenPercentHeight;\n\n  double get fourteenPercentHeight {\n    const double fourteenPercentHeight = 0.14;\n    _fourteenPercentHeight ??= QuranScreen.height * fourteenPercentHeight;\n    return _fourteenPercentHeight!;\n  }\n\n  static double? _tweentyPercentHeight;\n\n  double get tweentyPercentHeight {\n    const double tweentyPercentHeight = 0.20;\n    _tweentyPercentHeight ??= QuranScreen.height * tweentyPercentHeight;\n    return _tweentyPercentHeight!;\n  }\n}"}, {"structure_type": "class", "name": "to implement this in whatever way makes sense", "docstring": "The progress indicator's background color.\n", "module": "external_libs", "file_path": "core/external_libs/capped_progress_indicator.dart", "file_name": "capped_progress_indicator.dart", "line": 76, "line_from": 76, "line_to": 247, "snippet": "  /// It is up to the subclass to implement this in whatever way makes sense\n  /// for the given use case. See the subclass documentation for details.\n  final Color? backgroundColor;\n\n  /// The progress indicator's color.\n  ///\n  /// This is only used if [CappedProgressIndicator.valueColor] is null.\n  /// If [CappedProgressIndicator.color] is also null, then the ambient\n  /// [ProgressIndicatorThemeData.color] will be used. If that\n  /// is null then the current theme's [ColorScheme.primary] will\n  /// be used by default.\n  final Color? color;\n\n  /// The progress indicator's color as an animated value.\n  ///\n  /// If null, the progress indicator is rendered with [color]. If that is null,\n  /// then it will use the ambient [ProgressIndicatorThemeData.color]. If that\n  /// is also null then it defaults to the current theme's [ColorScheme.primary].\n  final Animation<Color?>? valueColor;\n\n  /// The [SemanticsProperties.label] for this progress indicator.\n  ///\n  /// This value indicates the purpose of the progress bar, and will be\n  /// read out by screen readers to indicate the purpose of this progress\n  /// indicator.\n  final String? semanticsLabel;\n\n  /// The [SemanticsProperties.value] for this progress indicator.\n  ///\n  /// This will be used in conjunction with the [semanticsLabel] by\n  /// screen reading software to identify the widget, and is primarily\n  /// intended for use with determinate progress indicators to announce\n  /// how far along they are.\n  ///\n  /// For determinate progress indicators, this will be defaulted to\n  /// [CappedProgressIndicator.value] expressed as a percentage, i.e. `0.1` will\n  /// become '10%'.\n  final String? semanticsValue;\n\n  Color _getValueColor(BuildContext context) {\n    return valueColor?.value ??\n        color ??\n        ProgressIndicatorTheme.of(context).color ??\n        Theme.of(context).colorScheme.primary;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(PercentProperty('value', value,\n        showName: false, ifNull: '<indeterminate>'));\n  }\n\n  Widget _buildSemanticsWrapper({\n    required BuildContext context,\n    required Widget child,\n  }) {\n    String? expandedSemanticsValue = semanticsValue;\n    if (value != null) {\n      expandedSemanticsValue ??= '${(value! * 100).round()}%';\n    }\n    return Semantics(\n      label: semanticsLabel,\n      value: expandedSemanticsValue,\n      child: child,\n    );\n  }\n}\n\nclass _LinearCappedProgressIndicatorPainter extends CustomPainter {\n  const _LinearCappedProgressIndicatorPainter({\n    required this.backgroundColor,\n    required this.valueColor,\n    this.value,\n    this.cornerRadius,\n    required this.animationValue,\n    required this.textDirection,\n  });\n\n  final Color backgroundColor;\n  final Color valueColor;\n  final double? value;\n  final double? cornerRadius;\n  final double animationValue;\n  final TextDirection textDirection;\n\n  // The indeterminate progress animation displays two lines whose leading (head)\n  // and trailing (tail) endpoints are defined by the following four curves.\n  static const Curve line1Head = Interval(\n    0.0,\n    750.0 / _kIndeterminateLinearDuration,\n    curve: Cubic(0.2, 0.0, 0.8, 1.0),\n  );\n  static const Curve line1Tail = Interval(\n    333.0 / _kIndeterminateLinearDuration,\n    (333.0 + 750.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.4, 0.0, 1.0, 1.0),\n  );\n  static const Curve line2Head = Interval(\n    1000.0 / _kIndeterminateLinearDuration,\n    (1000.0 + 567.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.0, 0.0, 0.65, 1.0),\n  );\n  static const Curve line2Tail = Interval(\n    1267.0 / _kIndeterminateLinearDuration,\n    (1267.0 + 533.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.10, 0.0, 0.45, 1.0),\n  );\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Paint paint = Paint()\n      ..color = backgroundColor\n      ..style = PaintingStyle.fill;\n    canvas.drawRRect(\n      RRect.fromRectAndRadius(\n        Offset.zero & size,\n        Radius.circular(cornerRadius ?? size.height / 2),\n      ),\n      paint,\n    );\n\n    paint.color = valueColor;\n\n    void drawBar(double x, double width) {\n      if (width <= 0.0) {\n        return;\n      }\n\n      final double left;\n      switch (textDirection) {\n        case TextDirection.rtl:\n          left = size.width - width - x;\n          break;\n        case TextDirection.ltr:\n          left = x;\n          break;\n      }\n      canvas.drawRRect(\n        RRect.fromRectAndRadius(\n          Offset(left, 0.0) & Size(width, size.height),\n          Radius.circular(cornerRadius ?? size.height / 2),\n        ),\n        paint,\n      );\n    }\n\n    if (value != null) {\n      drawBar(0.0, clampDouble(value!, 0.0, 1.0) * size.width);\n    } else {\n      final double x1 = size.width * line1Tail.transform(animationValue);\n      final double width1 =\n          size.width * line1Head.transform(animationValue) - x1;\n\n      final double x2 = size.width * line2Tail.transform(animationValue);\n      final double width2 =\n          size.width * line2Head.transform(animationValue) - x2;\n\n      drawBar(x1, width1);\n      drawBar(x2, width2);\n    }\n  }\n\n  @override\n  bool shouldRepaint(_LinearCappedProgressIndicatorPainter oldPainter) {\n    return oldPainter.backgroundColor != backgroundColor ||\n        oldPainter.valueColor != valueColor ||\n        oldPainter.value != value ||\n        oldPainter.animationValue != animationValue ||\n        oldPainter.textDirection != textDirection;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/fancy_scaffold.dart", "file_name": "fancy_scaffold.dart", "line": 9, "line_from": 9, "line_to": 63, "snippet": "  final void Function(double position)? onSlide;\n  final VoidCallback? onOpened;\n  final VoidCallback? onClosed;\n  final FloatingWidgetState defaultState;\n  final Color backdropColor;\n  final double backdropOpacity;\n  final double? maxHeight;\n  final double minHeight;\n  final bool isPanelVisible;\n  final EdgeInsetsGeometry margin;\n  final EdgeInsetsGeometry padding;\n\n  const FloatingWidgetConfig({\n    this.backdropEnabled = true,\n    this.onSlide,\n    this.onOpened,\n    this.onClosed,\n    this.defaultState = FloatingWidgetState.closed,\n    this.backdropColor = Colors.black,\n    this.backdropOpacity = 0.5,\n    this.maxHeight,\n    this.minHeight = kToolbarHeight * 1.6,\n    this.isPanelVisible = true,\n    this.margin = EdgeInsets.zero,\n    this.padding = const EdgeInsets.all(4),\n  });\n}\n\nclass FancyScaffold extends StatefulWidget {\n  final Widget body;\n  final Widget? appBar;\n  final Widget? bottomNavigationBar;\n  final bool? resizeToAvoidBottomInset;\n  final Color? backgroundColor;\n  final FloatingWidgetController? floatingWidgetController;\n  final FloatingWidgetConfig floatingWidgetConfig;\n  final double? bottomNavigationBarHeight;\n  final bool isAudioPlaying;\n\n  const FancyScaffold({\n    required this.body,\n    this.appBar,\n    this.bottomNavigationBar,\n    this.resizeToAvoidBottomInset,\n    this.backgroundColor,\n    this.floatingWidgetConfig = const FloatingWidgetConfig(),\n    this.floatingWidgetController,\n    this.bottomNavigationBarHeight,\n    this.isAudioPlaying = false,\n    super.key,\n  });\n\n  @override\n  FancyScaffoldState createState() => FancyScaffoldState();\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/fancy_scaffold.dart", "file_name": "fancy_scaffold.dart", "line": 90, "line_from": 90, "line_to": 373, "snippet": "  void initState() {\n    super.initState();\n    floatingWidgetAnimationController.addListener(_floatingWidgetListener);\n    _floatingWidgetScrollController.addListener(_scrollListener);\n  }\n\n  void hideAppBar() {\n    if (navigationBarAnimationController.value != 0) {\n      navigationBarAnimationController.animateTo(0);\n    }\n  }\n\n  void showAppBar() {\n    if (navigationBarAnimationController.value != 1) {\n      navigationBarAnimationController.animateTo(1);\n    }\n  }\n\n  void _floatingWidgetListener() {\n    if (widget.floatingWidgetConfig.onSlide != null) {\n      widget.floatingWidgetConfig\n          .onSlide!(floatingWidgetAnimationController.value);\n    }\n\n    if (widget.floatingWidgetConfig.onOpened != null &&\n        floatingWidgetAnimationController.value == 1.0) {\n      widget.floatingWidgetConfig.onOpened!();\n    }\n\n    if (widget.floatingWidgetConfig.onClosed != null &&\n        floatingWidgetAnimationController.value == 0.0) {\n      widget.floatingWidgetConfig.onClosed!();\n    }\n\n    if (!navigationBarScrolledDown) {\n      navigationBarAnimationController.value =\n          1 - floatingWidgetAnimationController.value;\n    }\n  }\n\n  void _scrollListener() {\n    if (!_scrollingEnabled) {\n      _floatingWidgetScrollController.jumpTo(0);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    widget.floatingWidgetController?._addState(this);\n    final double systemTopPadding = MediaQuery.of(context).padding.top;\n    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;\n    final double appBarHeight = widget.appBar != null ? kToolbarHeight : 0;\n\n    return CustomStatusBarColor(\n      statusBarColor: context.color.gradientTop,\n      statusBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      navigationBarColor: Theme.of(context).cardColor,\n      navigationBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      child: AnimatedBuilder(\n        animation: floatingWidgetAnimationController,\n        builder: (context, mainChild) {\n          return AnimatedBuilder(\n            animation: navigationBarAnimationController,\n            builder: (context, child) {\n              return Stack(\n                children: [\n                  Positioned.fill(\n                    child: Column(\n                      children: [\n                        Container(\n                            color: context.color.gradientTop,\n                            height: systemTopPadding +\n                                appBarHeight *\n                                    navigationBarAnimationController.value +\n                                2),\n                        Expanded(\n                          child: child!,\n                        ),\n                      ],\n                    ),\n                  ),\n                  if (widget.appBar != null)\n                    Positioned(\n                      top: -kToolbarHeight *\n                              (1 - navigationBarAnimationController.value) +\n                          systemTopPadding +\n                          2,\n                      left: 0,\n                      right: 0,\n                      child: widget.appBar!,\n                    ),\n                  if (widget.bottomNavigationBar != null)\n                    Positioned(\n                      bottom: -(widget.bottomNavigationBarHeight ?? 80) *\n                          (1 - navigationBarAnimationController.value),\n                      left: 0,\n                      right: 0,\n                      child: Container(\n                        width: double.infinity,\n                        color: Colors.transparent,\n                        height: (widget.bottomNavigationBarHeight ?? 73) +\n                            systemBottomPadding,\n                        child: Column(\n                          children: [\n                            Expanded(\n                              child: SingleChildScrollView(\n                                physics: const NeverScrollableScrollPhysics(),\n                                child: widget.bottomNavigationBar,\n                              ),\n                            ),\n                            Container(\n                              color: Theme.of(context).cardColor,\n                            ),\n                          ],\n                        ),\n                      ),\n                    ),\n                ],\n              );\n            },\n            child: Listener(\n              onPointerUp: _handlePointerUp,\n              child: NotificationListener<ScrollUpdateNotification>(\n                onNotification: _handleScrollNotification,\n                child: mainChild!,\n              ),\n            ),\n          );\n        },\n        child: widget.body,\n      ),\n    );\n  }\n\n  void _handlePointerUp(_) {\n    pixelsScrolled = 0;\n    if (navigationBarAnimationController.value > 0.5) {\n      navigationBarAnimationController.animateTo(1);\n      navigationBarScrolledDown = false;\n    } else {\n      navigationBarAnimationController.animateTo(0);\n      navigationBarScrolledDown = false;\n    }\n  }\n\n  bool _handleScrollNotification(ScrollUpdateNotification details) {\n    if (widget.floatingWidgetController?.lockNotificationListener ?? false) {\n      return false;\n    }\n    if (details.metrics.axis == Axis.horizontal) {\n      return false;\n    }\n\n    // Check if audio is playing\n    if (widget.isAudioPlaying) {\n      return false;\n    }\n\n    pixelsScrolled =\n        (pixelsScrolled + (details.scrollDelta ?? 0).abs()).clamp(0, 100) / 100;\n    if ((details.scrollDelta ?? 0) > 0.0 &&\n        details.metrics.axis == Axis.vertical) {\n      navigationBarAnimationController.value -= pixelsScrolled;\n    } else {\n      navigationBarAnimationController.value += pixelsScrolled;\n    }\n    return false;\n  }\n\n  Future<void> _close() {\n    return floatingWidgetAnimationController.fling(velocity: -1.0);\n  }\n\n  Future<void> _open() {\n    return floatingWidgetAnimationController.fling(velocity: 1.0);\n  }\n\n  Future<void> _animatePanelToPosition(\n    double value, {\n    Duration duration = const Duration(milliseconds: 200),\n    Curve curve = Curves.linear,\n  }) {\n    assert(0.0 <= value && value <= 1.0);\n    return floatingWidgetAnimationController.animateTo(value,\n        duration: duration, curve: curve);\n  }\n\n  set _panelPosition(double value) {\n    assert(0.0 <= value && value <= 1.0);\n    floatingWidgetAnimationController.value = value;\n  }\n\n  double get _panelPosition => floatingWidgetAnimationController.value;\n\n  bool get _isPanelAnimating => floatingWidgetAnimationController.isAnimating;\n\n  bool get _isPanelOpen => floatingWidgetAnimationController.value == 1.0;\n\n  bool get _isPanelClosed => floatingWidgetAnimationController.value == 0.0;\n}\n\nclass FloatingWidgetController {\n  FancyScaffoldState? _scaffoldState;\n\n  void _addState(FancyScaffoldState panelState) {\n    _scaffoldState = panelState;\n  }\n\n  GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  bool lockNotificationListener = false;\n\n  bool get isAttached => _scaffoldState != null;\n\n  AnimationController get animationController =>\n      _scaffoldState!.floatingWidgetAnimationController;\n  AnimationController get navbarAnimationController =>\n      _scaffoldState!.navigationBarAnimationController;\n  bool get navbarScrolledDown => _scaffoldState!.navigationBarScrolledDown;\n  set navbarScrolledDown(bool value) {\n    _scaffoldState!.navigationBarScrolledDown = value;\n  }\n\n  void hideAppBar() {\n    assert(isAttached,\n        \"FloatingWidgetController must be attached to a FancyScaffold\");\n    _scaffoldState!.hideAppBar();\n  }\n\n  void showAppBar() {\n    assert(isAttached,\n        \"FloatingWidgetController must be attached to a FancyScaffold\");\n    _scaffoldState!.showAppBar();\n  }\n\n  Future<void> close() {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._close();\n  }\n\n  Future<void> open() {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._open();\n  }\n\n  Future<void> animatePanelToPosition(\n    double value, {\n    Duration duration = const Duration(milliseconds: 200),\n    Curve curve = Curves.linear,\n  }) {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    assert(0.0 <= value && value <= 1.0);\n    return _scaffoldState!\n        ._animatePanelToPosition(value, duration: duration, curve: curve);\n  }\n\n  set panelPosition(double value) {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    assert(0.0 <= value && value <= 1.0);\n    _scaffoldState!._panelPosition = value;\n  }\n\n  double get panelPosition {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._panelPosition;\n  }\n\n  bool get isPanelAnimating {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelAnimating;\n  }\n\n  bool get isPanelOpen {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelOpen;\n  }\n\n  bool get isPanelClosed {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelClosed;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/positioned_scroll_bar.dart", "file_name": "positioned_scroll_bar.dart", "line": 18, "line_from": 18, "line_to": 35, "snippet": "  final void Function({required bool dragging})? onDragging;\n\n  @override\n  Widget build(BuildContext context) {\n    if (!showScrollBar) return listView;\n\n    return DraggableScrollbarPositionedList.arrows(\n      key: const Key('PositionedScrollBar'),\n      backgroundColor: isDarkMode(context)\n          ? context.color.bottomSheetHeader\n          : Theme.of(context).primaryColor,\n      padding: const EdgeInsets.only(right: 2),\n      onDragging: onDragging,\n      controller: controller,\n      child: listView,\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/presentable_widget_builder.dart", "file_name": "presentable_widget_builder.dart", "line": 19, "line_from": 19, "line_to": 60, "snippet": "  final Widget Function() builder;\n\n  @override\n  State<PresentableWidgetBuilder<T>> createState() => _PresentableWidgetBuilderState<T>();\n}\n\nclass _PresentableWidgetBuilderState<T extends DisposableInterface> extends State<PresentableWidgetBuilder<T>> {\n  T? _previousState;\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.onInit != null) {\n      widget.onInit!();\n    }\n    if (widget.presenter != null) {\n      Get.put(widget.presenter!);\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.dispose != null) {\n      widget.dispose!();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Obx(() {\n      final currentState = widget.presenter;\n      if (widget.shouldRebuild != null) {\n        if (!widget.shouldRebuild!(_previousState, currentState)) {\n          return widget.builder();\n        }\n      }\n      _previousState = currentState;\n      return widget.builder();\n    });\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "The builder of title.\n\nTypically a [Button] widget that call [toggleFunction] when pressed.", "module": "external_libs", "file_path": "core/external_libs/expansion_widget.dart", "file_name": "expansion_widget.dart", "line": 26, "line_from": 26, "line_to": 83, "snippet": "  final Widget Function(double animationValue, double easeInValue,\n      bool isExpanded, Function({bool animated}) toggleFunction) titleBuilder;\n\n  /// Function to save expansion state\n  /// Called when expansion state changed\n  final void Function(bool isExpanded)? onSaveState;\n\n  /// function to restore expansion state.\n  /// Return null if there is no state to store;\n  /// in this case, [initiallyExpanded] will be used\n  final bool? Function()? onRestoreState;\n\n  /// The length of time of animation\n  final Duration duration;\n\n  /// Called when the widget expands or collapses.\n  ///\n  /// When the widget starts expanding, this function is called with the value\n  /// true. When the tile starts collapsing, this function is called with\n  /// the value false.\n  final void Function(bool)? onExpansionChanged;\n\n  /// Called when the widget will change expanded state.\n  ///\n  /// When the widget is going to start expanding/collapsing, this function is\n  /// called with the value true/false.\n  ///\n  /// Return false to prevent expanded state to change.\n  /// Return true(default) to allow expanded state changing.\n  final bool Function(bool)? onExpansionWillChange;\n\n  /// The widget that are displayed when the expansionWidget expands.\n  final Widget content;\n\n  /// Specifies if the expansionWidget is initially expanded (true) or collapsed (false, the default).\n  final bool initiallyExpanded;\n\n  /// Specifies whether the state of the content is maintained when the expansionWidget expands and collapses.\n  ///\n  /// When true, the content are kept in the tree while the expansionWidget is collapsed.\n  /// When false (default), the content are removed from the tree when the expansionWidget is\n  /// collapsed and recreated upon expansion.\n  final bool maintainState;\n\n  /// Specifies the alignment of [content], which are arranged in a column when\n  /// the expansionWidget is expanded.\n  ///\n  /// The internals of the expanded expansionWidget make use of a [Column] widget for\n  /// [content], and [Align] widget to align the column. The `expandedAlignment`\n  /// parameter is passed directly into the [Align].\n  ///\n  /// Modifying this property controls the alignment of the column within the\n  /// expanded expansionWidget.\n  final Alignment expandedAlignment;\n\n  @override\n  ExpansionWidgetState createState() => ExpansionWidgetState();\n}"}, {"structure_type": "function", "name": "cancel", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/throttle_service.dart", "file_name": "throttle_service.dart", "line": 51, "line_from": 51, "line_to": 73, "snippet": "  static void cancel(String tag) {\n    _operations[tag]?.timer.cancel();\n    _operations.remove(tag);\n  }\n\n  static void cancelAll() {\n    for (final _ThrottleOperation operation in _operations.values) {\n      operation.timer.cancel();\n    }\n    _operations.clear();\n  }\n\n  static int count() => _operations.length;\n}\n\ntypedef EasyDebounceCallback = void Function();\n\nclass _EasyDebounceOperation {\n  _EasyDebounceOperation(this.callback, this.timer);\n\n  EasyDebounceCallback callback;\n  Timer timer;\n}"}, {"structure_type": "function", "name": "onReady;", "docstring": "", "module": "carousel_slider", "file_path": "core/external_libs/carousel_slider/carousel_controller.dart", "file_name": "carousel_controller.dart", "line": 13, "line_from": 13, "line_to": 26, "snippet": "  Future<void> get onReady;\n\n  Future<void> nextPage({Duration? duration, Curve? curve});\n\n  Future<void> previousPage({Duration? duration, Curve? curve});\n\n  void jumpToPage(int page);\n\n  Future<void> animateToPage(int page, {Duration? duration, Curve? curve});\n\n  void startAutoPlay();\n\n  void stopAutoPlay();\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "carousel_slider", "file_path": "core/external_libs/carousel_slider/carousel_slider.dart", "file_name": "carousel_slider.dart", "line": 12, "line_from": 12, "line_to": 409, "snippet": "typedef ExtendedIndexedWidgetBuilder = Widget Function(\n  BuildContext context,\n  int index,\n  int realIndex,\n);\n\nclass CarouselSlider extends StatefulWidget {\n  CarouselSlider({\n    required this.items,\n    required this.options,\n    this.disableGesture,\n    CarouselControllerHelper? carouselController,\n    super.key,\n  })  : itemBuilder = null,\n        itemCount = items != null ? items.length : 0,\n        _carouselController = carouselController != null\n            ? carouselController as CarouselControllerImpl\n            : CarouselControllerHelper() as CarouselControllerImpl;\n\n  CarouselSlider.builder({\n    required this.itemCount,\n    required this.itemBuilder,\n    required this.options,\n    this.disableGesture,\n    CarouselControllerHelper? carouselController,\n    super.key,\n  })  : items = null,\n        _carouselController = carouselController != null\n            ? carouselController as CarouselControllerImpl\n            : CarouselControllerHelper() as CarouselControllerImpl;\n\n  final CarouselOptions options;\n\n  final bool? disableGesture;\n\n  final List<Widget>? items;\n\n  final ExtendedIndexedWidgetBuilder? itemBuilder;\n\n  final CarouselControllerImpl _carouselController;\n\n  final int? itemCount;\n\n  @override\n  // ignore: no_logic_in_create_state\n  CarouselSliderState createState() => CarouselSliderState(_carouselController);\n}\n\nclass CarouselSliderState extends State<CarouselSlider>\n    with TickerProviderStateMixin {\n  CarouselSliderState(this.carouselController);\n\n  final CarouselControllerImpl carouselController;\n  Timer? timer;\n\n  CarouselOptions get options => widget.options;\n\n  CarouselState? carouselState;\n\n  PageController? pageController;\n\n  CarouselPageChangedReason _mode = CarouselPageChangedReason.controller;\n\n  set mode(CarouselPageChangedReason mode) => _mode = mode;\n\n  @override\n  void didUpdateWidget(CarouselSlider oldWidget) {\n    carouselState!.options = options;\n    carouselState!.itemCount = widget.itemCount;\n\n    // pageController needs to be re-initialized to respond to state changes\n    pageController = PageController(\n      viewportFraction: options.viewportFraction,\n      initialPage: carouselState!.realPage,\n    );\n    carouselState!.pageController = pageController;\n\n    // handle autoplay when state changes\n    handleAutoPlay();\n\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    carouselState =\n        CarouselState(options, clearTimer, resumeTimer, (m) => mode = m);\n\n    carouselState!.itemCount = widget.itemCount;\n    carouselController.state = carouselState;\n    carouselState!.initialPage = widget.options.initialPage;\n    carouselState!.realPage = options.enableInfiniteScroll\n        ? carouselState!.realPage + carouselState!.initialPage\n        : carouselState!.initialPage;\n    handleAutoPlay();\n\n    pageController = PageController(\n      viewportFraction: options.viewportFraction,\n      initialPage: carouselState!.realPage,\n    );\n\n    carouselState!.pageController = pageController;\n  }\n\n  Timer? getTimer() {\n    return catchAndReturn(() {\n      if (!widget.options.autoPlay) throw Exception(\"Autoplay is not enabled\");\n\n      return Timer.periodic(widget.options.autoPlayInterval, (_) {\n        if (!mounted) {\n          clearTimer();\n          return;\n        }\n\n        final ModalRoute<Object?>? route = ModalRoute.of(context);\n        if (route?.isCurrent == false) return;\n\n        final CarouselPageChangedReason previousReason = _mode;\n        mode = CarouselPageChangedReason.timed;\n\n        final int currentPage =\n            carouselState?.pageController?.page?.round() ?? 0;\n        int nextPage = currentPage + 1;\n        final int itemCount = widget.itemCount ?? widget.items?.length ?? 1;\n\n        if (nextPage >= itemCount &&\n            widget.options.enableInfiniteScroll == false) {\n          if (widget.options.pauseAutoPlayInFiniteScroll) {\n            clearTimer();\n            return;\n          }\n          nextPage = 0;\n        }\n\n        carouselState?.pageController\n            ?.animateToPage(\n              nextPage,\n              duration: widget.options.autoPlayAnimationDuration,\n              curve: widget.options.autoPlayCurve,\n            )\n            .then((_) => mode = previousReason);\n      });\n    });\n  }\n\n  void clearTimer() {\n    if (timer != null) {\n      timer?.cancel();\n      timer = null;\n    }\n  }\n\n  void resumeTimer() {\n    timer ??= getTimer();\n  }\n\n  void handleAutoPlay() {\n    final bool autoPlayEnabled = widget.options.autoPlay;\n\n    if (autoPlayEnabled && timer != null) return;\n\n    clearTimer();\n    if (autoPlayEnabled) {\n      resumeTimer();\n    }\n  }\n\n  Widget getGestureWrapper(Widget child) {\n    Widget wrapper;\n    if (widget.options.height != null) {\n      wrapper = SizedBox(height: widget.options.height, child: child);\n    } else {\n      wrapper =\n          AspectRatio(aspectRatio: widget.options.aspectRatio, child: child);\n    }\n\n    if (true == widget.disableGesture) {\n      return NotificationListener(\n        onNotification: (Notification notification) {\n          if (widget.options.onScrolled != null &&\n              notification is ScrollUpdateNotification) {\n            widget.options.onScrolled!(carouselState!.pageController!.page);\n          }\n          return false;\n        },\n        child: wrapper,\n      );\n    }\n\n    return RawGestureDetector(\n      behavior: HitTestBehavior.opaque,\n      gestures: {\n        _MultipleGestureRecognizer:\n            GestureRecognizerFactoryWithHandlers<_MultipleGestureRecognizer>(\n                _MultipleGestureRecognizer.new,\n                (_MultipleGestureRecognizer instance) {\n          instance\n            ..onStart = (_) {\n              onStart();\n            }\n            ..onDown = (_) {\n              onPanDown();\n            }\n            ..onEnd = (_) {\n              onPanUp();\n            }\n            ..onCancel = onPanUp;\n        }),\n      },\n      child: NotificationListener(\n        onNotification: (Notification notification) {\n          if (widget.options.onScrolled != null &&\n              notification is ScrollUpdateNotification) {\n            widget.options.onScrolled!(carouselState!.pageController!.page);\n          }\n          return false;\n        },\n        child: wrapper,\n      ),\n    );\n  }\n\n  Widget getCenterWrapper(Widget child) {\n    if (widget.options.disableCenter) {\n      return Container(\n        child: child,\n      );\n    }\n    return Center(child: child);\n  }\n\n  Widget getEnlargeWrapper(\n    Widget? child, {\n    double? width,\n    double? height,\n    double? scale,\n    required double itemOffset,\n  }) {\n    if (widget.options.enlargeStrategy == CenterPageEnlargeStrategy.height) {\n      return SizedBox(width: width, height: height, child: child);\n    }\n    if (widget.options.enlargeStrategy == CenterPageEnlargeStrategy.zoom) {\n      late Alignment alignment;\n      final bool horizontal = options.scrollDirection == Axis.horizontal;\n      if (itemOffset > 0) {\n        alignment = horizontal ? Alignment.centerRight : Alignment.bottomCenter;\n      } else {\n        alignment = horizontal ? Alignment.centerLeft : Alignment.topCenter;\n      }\n      return Transform.scale(scale: scale, alignment: alignment, child: child);\n    }\n    return Transform.scale(\n      scale: scale,\n      child: SizedBox(width: width, height: height, child: child),\n    );\n  }\n\n  void onStart() {\n    mode = CarouselPageChangedReason.manual;\n  }\n\n  void onPanDown() {\n    if (widget.options.pauseAutoPlayOnTouch) {\n      clearTimer();\n    }\n\n    mode = CarouselPageChangedReason.manual;\n  }\n\n  void onPanUp() {\n    if (widget.options.pauseAutoPlayOnTouch) {\n      resumeTimer();\n    }\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    clearTimer();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return getGestureWrapper(\n      PageView.builder(\n        padEnds: widget.options.padEnds,\n        scrollBehavior: ScrollConfiguration.of(context).copyWith(\n          scrollbars: false,\n          overscroll: false,\n          dragDevices: {\n            PointerDeviceKind.touch,\n            PointerDeviceKind.mouse,\n          },\n        ),\n        clipBehavior: widget.options.clipBehavior,\n        physics: widget.options.scrollPhysics,\n        scrollDirection: widget.options.scrollDirection,\n        pageSnapping: widget.options.pageSnapping,\n        controller: carouselState!.pageController,\n        reverse: widget.options.reverse,\n        itemCount:\n            widget.options.enableInfiniteScroll ? null : widget.itemCount,\n        onPageChanged: (int index) {\n          final int currentPage = getRealIndex(\n            index + carouselState!.initialPage,\n            carouselState!.realPage,\n            widget.itemCount,\n          );\n          widget.options.onPageChanged?.call(currentPage, _mode);\n        },\n        itemBuilder: (BuildContext context, int idx) {\n          final int index = getRealIndex(\n            idx + carouselState!.initialPage,\n            carouselState!.realPage,\n            widget.itemCount,\n          );\n\n          return AnimatedBuilder(\n            animation: carouselState!.pageController!,\n            child: (widget.items != null)\n                ? (widget.items!.isNotEmpty\n                    ? widget.items![index]\n                    : Container())\n                : widget.itemBuilder!(context, index, idx),\n            builder: (BuildContext context, child) {\n              double distortionValue = 1;\n              // if `enlargeCenterPage` is true, we must calculate the carousel item's height\n              // to display the visual effect\n              double itemOffset = 0;\n              if (widget.options.enlargeCenterPage != null &&\n                  (widget.options.enlargeCenterPage ?? false)) {\n                // pageController.page can only be accessed after the first build,\n                // so in the first build we calculate the itemoffset manually\n                final position = carouselState?.pageController?.position;\n                if (position != null &&\n                    position.hasPixels &&\n                    position.hasContentDimensions) {\n                  final page = carouselState?.pageController?.page;\n                  if (page != null) {\n                    itemOffset = page - idx;\n                  }\n                } else {\n                  final BuildContext storageContext = carouselState!\n                      .pageController!.position.context.storageContext;\n                  final double? previousSavedPosition =\n                      PageStorage.of(storageContext).readState(storageContext)\n                          as double?;\n                  if (previousSavedPosition != null) {\n                    itemOffset = previousSavedPosition - idx.toDouble();\n                  } else {\n                    itemOffset =\n                        carouselState!.realPage.toDouble() - idx.toDouble();\n                  }\n                }\n\n                final double enlargeFactor =\n                    options.enlargeFactor.clamp(0.0, 1.0);\n                final num distortionRatio =\n                    (1 - (itemOffset.abs() * enlargeFactor)).clamp(0.0, 1.0);\n                distortionValue =\n                    Curves.easeOut.transform(distortionRatio as double);\n              }\n\n              final double height = widget.options.height ??\n                  MediaQuery.of(context).size.width *\n                      (1 / widget.options.aspectRatio);\n\n              if (widget.options.scrollDirection == Axis.horizontal) {\n                return getCenterWrapper(\n                  getEnlargeWrapper(\n                    child,\n                    height: distortionValue * height,\n                    scale: distortionValue,\n                    itemOffset: itemOffset,\n                  ),\n                );\n              } else {\n                return getCenterWrapper(\n                  getEnlargeWrapper(\n                    child,\n                    width: distortionValue * MediaQuery.of(context).size.width,\n                    scale: distortionValue,\n                    itemOffset: itemOffset,\n                  ),\n                );\n              }\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _MultipleGestureRecognizer extends PanGestureRecognizer {}\n"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "draggable_scrollbar_positioned_list", "file_path": "core/external_libs/draggable_scrollbar_positioned_list/draggable_scrollbar_positioned_list.dart", "file_name": "draggable_scrollbar_positioned_list.dart", "line": 63, "line_from": 63, "line_to": 152, "snippet": "  final void Function({required bool dragging})? onDragging;\n\n  @override\n  DraggableScrollbarPositionedListState createState() =>\n      DraggableScrollbarPositionedListState();\n\n  static Widget buildScrollThumb({\n    required Widget scrollThumb,\n    required Color backgroundColor,\n    required Animation<double> thumbAnimation,\n    required bool alwaysVisibleScrollThumb,\n  }) {\n    if (alwaysVisibleScrollThumb) return scrollThumb;\n\n    return SlideFadeTransition(\n      key: const ValueKey('SlideFadeTransition2938492'),\n      animation: thumbAnimation,\n      child: scrollThumb,\n    );\n  }\n\n  static ScrollThumbBuilder _thumbArrowBuilder(\n    Key? scrollThumbKey,\n    bool alwaysVisibleScrollThumb,\n  ) {\n    return (\n      Color backgroundColor,\n      Animation<double> thumbAnimation,\n      double height,\n    ) {\n      // creates a ClipPath widget named scrollThumb that represents a scroll\n      // thumb used in a scrollbar. The scroll thumb is a rectangular container\n      // with rounded corners, and it uses an ArrowClipper as its clipper to\n      // give it an arrow-shaped appearance.\n      final ClipPath scrollThumb = ClipPath(\n        key: const Key(\"ScrollThumbBuilderClipPath\"),\n        child: Container(\n          key: scrollThumbKey,\n          alignment: Alignment.center,\n          height: 40,\n          width: 16,\n          decoration: BoxDecoration(\n            color: backgroundColor,\n            borderRadius: BorderRadius.circular(4),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              SvgPicture.asset(\n                'assets/images/svg/chevrons_left.svg',\n              ),\n              SvgPicture.asset(\n                'assets/images/svg/chevrons_right.svg',\n              ),\n            ],\n          ),\n        ),\n      );\n      // final ClipPath scrollThumb = ClipPath(\n      //   key: const Key(\"ScrollThumbBuilderClipPath\"),\n      //   // clipper: ArrowClipper(),\n      //   child: Container(\n      //     key: scrollThumbKey,\n      //     height: 50,\n      //     width: 50,\n      //     decoration: BoxDecoration(\n      //       color: backgroundColor,\n      //       borderRadius: const BorderRadius.only(\n      //         topLeft: Radius.circular(50),\n      //         bottomLeft: Radius.circular(50),\n      //         topRight: Radius.circular(50),\n      //       ),\n      //     ),\n      //     child: Icon(\n      //       Icons.unfold_more,\n      //       color: Colors.grey.shade100,\n      //     ),\n      //   ),\n      // );\n\n      return buildScrollThumb(\n        scrollThumb: scrollThumb,\n        backgroundColor: backgroundColor,\n        thumbAnimation: thumbAnimation,\n        alwaysVisibleScrollThumb: alwaysVisibleScrollThumb,\n      );\n    };\n  }\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "circular_seek_bar-master", "file_path": "core/external_libs/circular_seek_bar-master/circular_seek_bar.dart", "file_name": "circular_seek_bar.dart", "line": 142, "line_from": 142, "line_to": 628, "snippet": "  void initState() {\n    super.initState();\n    _progress = widget.progress;\n  }\n\n  /// Reset CircularSeekBar's progress.\n  @override\n  void didUpdateWidget(CircularSeekBar oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.progress != widget.progress) {\n      _progress = widget.progress;\n    }\n  }\n\n  /// Get size of CircularSeekBar with RenderBox.\n  // Size _getSize(GlobalKey key) {\n  //   final RenderBox renderBox =\n  //       key.currentContext!.findRenderObject() as RenderBox;\n  //   Size size = renderBox.size;\n  //   return size;\n  // }\n\n  /// Converts the x and y coordinate values received by the onTapDown callback to progress.\n  // void _handleGesture(details) {\n  //   double dx = details.localPosition.dx;\n  //   double dy = details.localPosition.dy;\n  //   Size size = _getSize(_key);\n  //   double centerX = size.width / 2.0;\n  //   double centerY = size.height / 2.0;\n  //   double angle = _getTouchedDegrees(centerX, dx, centerY, dy);\n  //   double progress = (widget.dashWidth > 0 && widget.dashGap > 0)\n  //       ? _angleToDashedProgress(\n  //           angle > 0 ? angle : angle + 360,\n  //           widget.startAngle,\n  //           widget.sweepAngle,\n  //           widget.dashWidth,\n  //           widget.dashGap)\n  //       : _angleToProgress(angle > 0 ? angle : angle + 360, widget.startAngle,\n  //           widget.sweepAngle);\n  //   if (progress >= widget.minProgress && progress <= widget.maxProgress) {\n  //     setState(() {\n  //       _progress = progress;\n  //     });\n  //   }\n  // }\n\n  // /// Method to get relative angle of CircularSeekBar.\n  // double _getRelativeAngle(double angle, double startAngle) {\n  //   return (angle - startAngle) >= 0\n  //       ? (angle - startAngle)\n  //       : (360 - startAngle + angle);\n  // }\n\n  /// Convert (x, y) coordinates to an angle.\n  // double _getTouchedDegrees(\n  //     double centerX, double dx, double centerY, double dy) {\n  //   return _radiansToDegrees(atan2(centerX - dx, dy - centerY));\n  // }\n\n  /// Convert angle to progress.\n  // double _angleToProgress(double angle, double startAngle, double sweepAngle) {\n  //   double relativeAngle = _getRelativeAngle(angle, startAngle);\n  //   return (relativeAngle / sweepAngle) * 100;\n  // }\n\n  // /// Convert the angle of dashed seekbar to progress\n  // double _angleToDashedProgress(double angle, double startAngle,\n  //     double sweepAngle, double dashWidth, double dashGap) {\n  //   double relativeAngle = (angle - startAngle) >= 0\n  //       ? (angle - startAngle)\n  //       : (360 - startAngle + angle);\n  //   double dashSum = dashWidth + dashGap;\n\n  //   int trackDashCounts =\n  //       sweepAngle >= (sweepAngle ~/ dashSum) * dashSum + dashWidth\n  //           ? (sweepAngle ~/ dashSum) + 1\n  //           : (sweepAngle ~/ dashSum);\n  //   double totalTrackDashWidth = dashWidth * trackDashCounts;\n\n  //   for (int i = 0; i <= trackDashCounts; i++) {\n  //     double relativeDashStartAngle = dashSum * i;\n  //     double relativeDashEndAngle = (relativeDashStartAngle + dashWidth) % 360;\n\n  //     if (relativeAngle >= relativeDashStartAngle &&\n  //         relativeAngle <= relativeDashEndAngle) {\n  //       double totalFilledDashRatio =\n  //           (dashWidth * i) / totalTrackDashWidth.toDouble();\n  //       double totalHalfWidthDashRatio =\n  //           ((relativeAngle - dashSum * i) / dashWidth.toDouble()) /\n  //               trackDashCounts;\n\n  //       return _lerp(widget.minProgress, widget.maxProgress,\n  //           totalFilledDashRatio + totalHalfWidthDashRatio);\n  //     }\n  //   }\n  //   return -1;\n  // }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animation) {\n      return GestureDetector(\n        key: _key,\n        onTapDown: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        onPanUpdate: (details) {\n          if (widget.interactive) {\n          //  _handleGesture(details);\n          }\n        },\n        child: TweenAnimationBuilder(\n            duration: Duration(milliseconds: widget.animDurationMillis),\n            tween: Tween(begin: widget.minProgress, end: _progress!),\n            curve: widget.curves,\n            onEnd: widget.onEnd,\n            builder: (BuildContext context, double progress, __) {\n              widget.valueNotifier?.value = progress;\n              return CustomPaint(\n                size: Size(widget.width, widget.height),\n                painter: _SeekBarPainter(\n                  progress: progress,\n                  minProgress: widget.minProgress,\n                  maxProgress: widget.maxProgress,\n                  startAngle: widget.startAngle,\n                  sweepAngle: widget.sweepAngle,\n                  barWidth: widget.barWidth,\n                  trackColor: widget.trackColor,\n                  trackGradientColors: widget.trackGradientColors,\n                  progressColor: widget.progressColor,\n                  progressGradientColors: widget.progressGradientColors,\n                  strokeCap: widget.strokeCap,\n                  innerThumbRadius: widget.innerThumbRadius,\n                  innerThumbStrokeWidth: widget.innerThumbStrokeWidth,\n                  innerThumbColor: widget.innerThumbColor,\n                  outerThumbRadius: widget.outerThumbRadius,\n                  outerThumbStrokeWidth: widget.outerThumbStrokeWidth,\n                  outerThumbColor: widget.outerThumbColor,\n                  dashWidth: widget.dashWidth,\n                  dashGap: widget.dashGap,\n                ),\n                child: SizedBox(\n                  width: widget.width,\n                  height: widget.height,\n                  child: widget.child,\n                ),\n              );\n            }),\n      );\n    } else {\n      widget.valueNotifier?.value = _progress!;\n      return GestureDetector(\n        key: _key,\n        onTapDown: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        onPanUpdate: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        child: CustomPaint(\n          size: Size(widget.width, widget.height),\n          painter: _SeekBarPainter(\n            progress: _progress!,\n            minProgress: widget.minProgress,\n            maxProgress: widget.maxProgress,\n            startAngle: widget.startAngle,\n            sweepAngle: widget.sweepAngle,\n            barWidth: widget.barWidth,\n            trackColor: widget.trackColor,\n            trackGradientColors: widget.trackGradientColors,\n            progressColor: widget.progressColor,\n            progressGradientColors: widget.progressGradientColors,\n            strokeCap: widget.strokeCap,\n            innerThumbRadius: widget.innerThumbRadius,\n            innerThumbStrokeWidth: widget.innerThumbStrokeWidth,\n            innerThumbColor: widget.innerThumbColor,\n            outerThumbRadius: widget.outerThumbRadius,\n            outerThumbStrokeWidth: widget.outerThumbStrokeWidth,\n            outerThumbColor: widget.outerThumbColor,\n            dashWidth: widget.dashWidth,\n            dashGap: widget.dashGap,\n          ),\n          child: SizedBox(\n            width: widget.width,\n            height: widget.height,\n            child: widget.child,\n          ),\n        ),\n      );\n    }\n  }\n}\n\nclass _SeekBarPainter extends CustomPainter {\n  /// Current value of seek bar.\n  final double progress;\n\n  /// Minimum value of seek bar.\n  final double minProgress;\n\n  /// Maximum value of seek bar.\n  final double maxProgress;\n\n  /// The Angle to start drawing this seek bar from\n  final double startAngle;\n\n  /// The Angle through which to draw the seek bar\n  final double sweepAngle;\n\n  /// The thickness of the seek bar.\n  final double barWidth;\n\n  /// Background track color of seek bar.\n  final Color trackColor;\n\n  /// Background track gradient colors of seek bar.\n  final List<Color> trackGradientColors;\n\n  /// Foreground progress color of seek bar.\n  final Color progressColor;\n\n  /// Foreground trackGradientColors of seek bar.\n  final List<Color> progressGradientColors;\n\n  /// Styles to use for arcs endings.\n  final StrokeCap strokeCap;\n\n  /// The radius of the seekbar inner thumb.\n  final double innerThumbRadius;\n\n  /// The stroke width of the seekbar inner thumb.\n  final double innerThumbStrokeWidth;\n\n  /// Color of the seekbar inner thumb.\n  final Color innerThumbColor;\n\n  /// The radius of the seekbar outer thumb.\n  final double outerThumbRadius;\n\n  /// The stroke width of the seekbar outer thumb.\n  final double outerThumbStrokeWidth;\n\n  /// Color of the seekbar outer thumb.\n  final Color outerThumbColor;\n\n  /// Dash width of seek bar\n  final double dashWidth;\n\n  /// Dash gap of seek bar.\n  final double dashGap;\n\n  /// The initial rotational offset 90\n  static const double angleOffset = 90;\n\n  _SeekBarPainter(\n      {required this.progress,\n      required this.minProgress,\n      required this.maxProgress,\n      required this.startAngle,\n      required this.sweepAngle,\n      required this.barWidth,\n      required this.trackColor,\n      required this.trackGradientColors,\n      required this.progressColor,\n      required this.progressGradientColors,\n      required this.strokeCap,\n      required this.innerThumbRadius,\n      required this.innerThumbStrokeWidth,\n      required this.innerThumbColor,\n      required this.outerThumbRadius,\n      required this.outerThumbStrokeWidth,\n      required this.outerThumbColor,\n      required this.dashWidth,\n      required this.dashGap});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    if (sweepAngle > 0.0) {\n      Paint trackPaint = Paint()\n        ..style = PaintingStyle.stroke\n        ..color = trackColor\n        ..strokeCap = strokeCap\n        ..strokeWidth = barWidth;\n\n      Paint progressPaint = Paint()\n        ..style = PaintingStyle.stroke\n        ..color = progressColor\n        ..strokeCap = strokeCap\n        ..strokeWidth = barWidth;\n\n      final Offset center = Offset(size.width / 2, size.height / 2);\n      final double largerThumbWidth =\n          (outerThumbRadius / 2 + outerThumbStrokeWidth / 2) >=\n                  (innerThumbRadius / 2 + innerThumbStrokeWidth / 2)\n              ? (outerThumbRadius / 2 + outerThumbStrokeWidth / 2)\n              : (innerThumbRadius / 2 + innerThumbStrokeWidth / 2);\n      final double seekBarMargin =\n          largerThumbWidth >= (barWidth / 2) ? largerThumbWidth : barWidth / 2;\n      final double radius = min(center.dx, center.dy) - seekBarMargin;\n      double realStartAngle = startAngle + angleOffset;\n\n      double startAngleWithOffsetRadian = _degreesToRadians(realStartAngle);\n      Rect rect = Rect.fromCenter(\n          center: center, width: 2 * radius, height: 2 * radius);\n\n      double sweepAngleRadian = _degreesToRadians(sweepAngle);\n\n      // Set gradients\n      if (trackGradientColors.isNotEmpty) {\n        Gradient trackGradient = SweepGradient(\n          center: Alignment.center,\n          startAngle: 0,\n          endAngle: sweepAngleRadian,\n          tileMode: TileMode.mirror,\n          colors: trackGradientColors,\n          transform: GradientRotation(\n              startAngleWithOffsetRadian - asin((barWidth / 2) / radius)),\n        );\n        trackPaint.shader = trackGradient.createShader(rect);\n      }\n\n      if (progressGradientColors.isNotEmpty) {\n        Gradient progressGradient = SweepGradient(\n          center: Alignment.center,\n          startAngle: 0,\n          endAngle: sweepAngleRadian,\n          tileMode: TileMode.mirror,\n          colors: progressGradientColors,\n          transform: GradientRotation(\n              startAngleWithOffsetRadian - asin((barWidth / 2) / radius)),\n        );\n\n        progressPaint.shader = progressGradient.createShader(rect);\n      }\n\n      if (dashWidth > 0 && dashGap > 0) {\n        double dashSum = dashWidth + dashGap;\n        double dashWidthRadian = _degreesToRadians(dashWidth);\n        double dashSumRadian = _degreesToRadians(dashSum);\n\n        int trackDashCounts =\n            sweepAngle >= (sweepAngle ~/ dashSum) * dashSum + dashWidth\n                ? (sweepAngle ~/ dashSum) + 1\n                : (sweepAngle ~/ dashSum);\n        int progressDashCounts =\n            (trackDashCounts * _lerpRatio(minProgress, maxProgress, progress))\n                .floor();\n        double fullProgressRatio =\n            (progressDashCounts / trackDashCounts.toDouble());\n\n        // Draw track dashes.\n        for (int i = 0; i < trackDashCounts; i++) {\n          canvas.drawArc(\n            rect,\n            startAngleWithOffsetRadian + dashSumRadian * i,\n            dashWidthRadian,\n            false,\n            trackPaint,\n          );\n        }\n\n        // Draw progress dashes.\n        for (int i = 0; i < progressDashCounts; i++) {\n          canvas.drawArc(\n            rect,\n            startAngleWithOffsetRadian + dashSumRadian * i,\n            dashWidthRadian,\n            false,\n            progressPaint,\n          );\n        }\n\n        canvas.drawArc(\n          rect,\n          startAngleWithOffsetRadian + dashSumRadian * (progressDashCounts),\n          dashWidthRadian *\n              (_lerpRatio(minProgress, maxProgress, progress) -\n                  fullProgressRatio) *\n              trackDashCounts,\n          false,\n          progressPaint,\n        );\n\n        double totalTrackDashWidth = dashWidth * trackDashCounts;\n        double totalRatio = _lerpRatio(minProgress, maxProgress, progress);\n        double totalFilledAngleRatio =\n            (dashWidth * progressDashCounts) / totalTrackDashWidth.toDouble();\n        double totalHalfWidthAngleRatio = totalRatio - totalFilledAngleRatio;\n        double halfWidthAngleRatio = totalHalfWidthAngleRatio * trackDashCounts;\n\n        double halfWidthProgressAngle =\n            _lerp(0, dashWidth, halfWidthAngleRatio);\n        double filledProgressAngle = trackDashCounts >= progressDashCounts + 1\n            ? dashSum * progressDashCounts\n            : dashSum * (progressDashCounts - 1) + dashWidth;\n        double progressAngle = filledProgressAngle + halfWidthProgressAngle;\n\n        double thumbX = center.dx -\n            sin(_degreesToRadians(startAngle + progressAngle)) * radius;\n        double thumbY = center.dy +\n            cos(_degreesToRadians(startAngle + progressAngle)) * radius;\n        Offset thumbCenter = Offset(thumbX, thumbY);\n\n        canvas.drawCircle(\n            thumbCenter,\n            outerThumbRadius,\n            Paint()\n              ..color = outerThumbColor\n              ..style = PaintingStyle.stroke\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = outerThumbStrokeWidth);\n\n        canvas.drawCircle(\n            thumbCenter,\n            innerThumbRadius,\n            Paint()\n              ..color = innerThumbColor\n              ..style = PaintingStyle.fill\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = innerThumbStrokeWidth);\n      } else {\n        double progressAngle = _lerp(\n            0, sweepAngle, _lerpRatio(minProgress, maxProgress, progress));\n        double progressAngleRadian = _degreesToRadians(progressAngle);\n\n        canvas.drawArc(rect, startAngleWithOffsetRadian, sweepAngleRadian,\n            false, trackPaint);\n        canvas.drawArc(rect, startAngleWithOffsetRadian, progressAngleRadian,\n            false, progressPaint);\n\n        double thumbX = center.dx -\n            sin(_degreesToRadians(startAngle + progressAngle)) * radius;\n        double thumbY = center.dy +\n            cos(_degreesToRadians(startAngle + progressAngle)) * radius;\n\n        Offset thumbCenter = Offset(thumbX, thumbY);\n\n        canvas.drawCircle(\n            thumbCenter,\n            outerThumbRadius,\n            Paint()\n              ..color = outerThumbColor\n              ..style = PaintingStyle.stroke\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = outerThumbStrokeWidth);\n\n        canvas.drawCircle(\n            thumbCenter,\n            innerThumbRadius,\n            Paint()\n              ..color = innerThumbColor\n              ..style = PaintingStyle.fill\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = innerThumbStrokeWidth);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant _SeekBarPainter oldDelegate) {\n    return oldDelegate.progress != progress ||\n        oldDelegate.minProgress != minProgress ||\n        oldDelegate.maxProgress != maxProgress ||\n        oldDelegate.startAngle != startAngle ||\n        oldDelegate.sweepAngle != sweepAngle ||\n        oldDelegate.barWidth != barWidth ||\n        oldDelegate.trackColor != trackColor ||\n        oldDelegate.trackGradientColors != trackGradientColors ||\n        oldDelegate.progressColor != progressColor ||\n        oldDelegate.progressGradientColors != progressGradientColors ||\n        oldDelegate.strokeCap != strokeCap ||\n        oldDelegate.innerThumbRadius != innerThumbRadius ||\n        oldDelegate.innerThumbStrokeWidth != innerThumbStrokeWidth ||\n        oldDelegate.innerThumbColor != innerThumbColor ||\n        oldDelegate.outerThumbRadius != outerThumbRadius ||\n        oldDelegate.outerThumbStrokeWidth != outerThumbStrokeWidth ||\n        oldDelegate.outerThumbColor != outerThumbColor ||\n        oldDelegate.dashWidth != dashWidth ||\n        oldDelegate.dashGap != dashGap;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "expandable_bottom_sheet", "file_path": "core/external_libs/expandable_bottom_sheet/expandable_bottom_sheet.dart", "file_name": "expandable_bottom_sheet.dart", "line": 42, "line_from": 42, "line_to": 382, "snippet": "  final void Function()? onIsExtendedCallback;\n\n  final void Function()? onIsContractedCallback;\n\n  final bool enableToggle;\n\n  final bool isDraggable;\n  bool isExpanded;\n\n  ExpandableBottomSheetState? expandableBottomSheetState;\n\n  // // ignore: no_logic_in_create_state\n  // ExpandableBottomSheetState createState() {\n  //   expandableBottomSheetState = ExpandableBottomSheetState();\n  //   return expandableBottomSheetState;\n  // }\n  @override\n  ExpandableBottomSheetState createState() => ExpandableBottomSheetState();\n}\n\nclass ExpandableBottomSheetState extends State<ExpandableBottomSheet>\n    with TickerProviderStateMixin {\n  final GlobalKey _contentKey = GlobalKey(debugLabel: 'contentKey');\n  final GlobalKey _headerKey = GlobalKey(debugLabel: 'headerKey');\n  final GlobalKey _footerKey = GlobalKey(debugLabel: 'footerKey');\n\n  late AnimationController _controller;\n\n  double _draggableHeight = 0;\n  double? _positionOffset;\n  double _startOffsetAtDragDown = 0;\n  double? _startPositionAtDragDown = 0;\n\n  double _minOffset = 0;\n  double _maxOffset = 0;\n  double _animationMinOffset = 0;\n\n  AnimationStatus _oldStatus = AnimationStatus.dismissed;\n\n  bool _useDrag = true;\n  bool _callCallbacks = false;\n\n  void expand() {\n    _afterUpdateWidgetBuild(false);\n    _callCallbacks = true;\n    widget.isExpanded = true;\n    _animateToTop();\n  }\n\n  void contract() {\n    _afterUpdateWidgetBuild(false);\n    _callCallbacks = true;\n    _animateToBottom();\n  }\n\n  ExpansionStatus get expansionStatus {\n    if (_positionOffset == null) return ExpansionStatus.contracted;\n    if (_positionOffset == _maxOffset) return ExpansionStatus.contracted;\n    if (_positionOffset == _minOffset) return ExpansionStatus.expanded;\n    return ExpansionStatus.middle;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this);\n    _controller.addStatusListener(_handleAnimationStatusUpdate);\n    WidgetsBinding.instance\n        .addPostFrameCallback((_) => _afterUpdateWidgetBuild(true));\n   \n  }\n  \n\n  @override\n  Widget build(BuildContext context) {\n    WidgetsBinding.instance\n        .addPostFrameCallback((_) => _afterUpdateWidgetBuild(false));\n    return Column(\n      children: <Widget>[\n        Expanded(\n          child: Stack(\n            children: <Widget>[\n              Align(\n                alignment: Alignment.topLeft,\n                child: InkWell(\n                  onTap: () => context.navigatorPop<void>(),\n                  child: widget.background,\n                ),\n              ),\n              AnimatedBuilder(\n                animation: _controller,\n                builder: (_, Widget? child) {\n                  if (_controller.isAnimating) {\n                    _positionOffset = _animationMinOffset +\n                        _controller.value * _draggableHeight;\n                  }\n                  return Positioned(\n                    top: _positionOffset,\n                    right: 0,\n                    left: 0,\n                    child: child!,\n                  );\n                },\n                child: GestureDetector(\n                  onTap: _toggle,\n                  onVerticalDragDown: widget.isDraggable ? _dragDown : (_) {},\n                  onVerticalDragUpdate:\n                      widget.isDraggable ? _dragUpdate : (_) {},\n                  onVerticalDragEnd: widget.isDraggable ? _dragEnd : (_) {},\n                  child: Padding(\n                    padding: const EdgeInsets.only(top: 40),\n                    child: Column(\n                      mainAxisSize: MainAxisSize.min,\n                      children: <Widget>[\n                        Container(\n                          key: _headerKey,\n                          child: widget.persistentHeader ?? Container(),\n                        ),\n                        Container(\n                          key: _contentKey,\n                          child: widget.expandableContent,\n                        ),\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n        Container(\n          key: _footerKey,\n          child: widget.persistentFooter ?? Container(),\n        ),\n      ],\n    );\n  }\n\n  void _handleAnimationStatusUpdate(AnimationStatus status) {\n    if (status == AnimationStatus.completed) {\n      if (_oldStatus == AnimationStatus.forward) {\n        setState(() {\n          _draggableHeight = _maxOffset - _minOffset;\n          _positionOffset = _minOffset;\n        });\n        if (widget.onIsExtendedCallback != null && _callCallbacks) {\n          widget.onIsExtendedCallback!();\n        }\n      }\n      if (_oldStatus == AnimationStatus.reverse) {\n        setState(() {\n          _draggableHeight = _maxOffset - _minOffset;\n          _positionOffset = _maxOffset;\n        });\n        if (widget.onIsContractedCallback != null && _callCallbacks) {\n          widget.onIsContractedCallback!();\n        }\n      }\n    }\n  }\n\n  void _afterUpdateWidgetBuild(bool isFirstBuild) {\n    final double headerHeight = _headerKey.currentContext!.size!.height;\n    final double footerHeight = _footerKey.currentContext!.size!.height;\n    final double contentHeight = _contentKey.currentContext!.size!.height;\n\n    final double checkedPersistentContentHeight =\n        (widget.persistentContentHeight < contentHeight)\n            ? widget.persistentContentHeight\n            : contentHeight;\n\n    _minOffset =\n        context.size!.height - headerHeight - contentHeight - footerHeight;\n    _maxOffset = context.size!.height -\n        headerHeight -\n        footerHeight -\n        checkedPersistentContentHeight;\n\n    if (!isFirstBuild) {\n      _positionOutOfBounds();\n    } else {\n      setState(() {\n        _positionOffset = _maxOffset;\n        _draggableHeight = _maxOffset - _minOffset;\n      });\n    }\n  }\n\n  void _positionOutOfBounds() {\n    if (_positionOffset! < _minOffset) {\n      //the extend is larger than contentHeight\n      _callCallbacks = false;\n      _animateToMin();\n    } else {\n      if (_positionOffset! > _maxOffset) {\n        //the extend is smaller than persistentContentHeight\n        _callCallbacks = false;\n        _animateToMax();\n      } else {\n        _draggableHeight = _maxOffset - _minOffset;\n      }\n    }\n  }\n\n  void _animateOnIsAnimating() {\n    if (_controller.isAnimating) {\n      _controller.stop();\n    }\n  }\n\n  void _toggle() {\n    if (widget.enableToggle) {\n      if (expansionStatus == ExpansionStatus.expanded) {\n        _callCallbacks = true;\n        _animateToBottom();\n      }\n      if (expansionStatus == ExpansionStatus.contracted) {\n        _callCallbacks = true;\n        _animateToTop();\n      }\n    }\n  }\n\n  void _dragDown(DragDownDetails details) {\n    if (_controller.isAnimating) {\n      _useDrag = false;\n    } else {\n      _useDrag = true;\n      _startOffsetAtDragDown = details.localPosition.dy;\n      _startPositionAtDragDown = _positionOffset;\n    }\n  }\n\n  void _dragUpdate(DragUpdateDetails details) {\n    if (!_useDrag) return;\n    final double offset = details.localPosition.dy;\n    final double newOffset =\n        _startPositionAtDragDown! + offset - _startOffsetAtDragDown;\n    if (_minOffset <= newOffset && _maxOffset >= newOffset) {\n      setState(() {\n        _positionOffset = newOffset;\n      });\n    } else {\n      if (_minOffset > newOffset) {\n        setState(() {\n          _positionOffset = _minOffset;\n        });\n      }\n      if (_maxOffset < newOffset) {\n        setState(() {\n          _positionOffset = _maxOffset;\n        });\n      }\n    }\n  }\n\n  void _dragEnd(DragEndDetails details) {\n    if (_startPositionAtDragDown == _positionOffset || !_useDrag) return;\n    if (details.primaryVelocity! < -250) {\n      //drag up ended with high speed\n      _callCallbacks = true;\n      _animateToTop();\n    } else {\n      if (details.primaryVelocity! > 250) {\n        //drag down ended with high speed\n        _callCallbacks = true;\n        _animateToBottom();\n      } else {\n        if (_positionOffset == _maxOffset &&\n            widget.onIsContractedCallback != null) {\n          widget.onIsContractedCallback!();\n        }\n        if (_positionOffset == _minOffset &&\n            widget.onIsExtendedCallback != null) {\n          widget.onIsExtendedCallback!();\n        }\n      }\n    }\n  }\n\n  void _animateToTop() {\n    // booksC.isBottomSheetExpanded.value = true;\n    _animateOnIsAnimating();\n    _controller.value = (_positionOffset! - _minOffset) / _draggableHeight;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.forward;\n    _controller.animateTo(\n      .001,\n      duration: widget.animationDurationExtend,\n      curve: widget.animationCurveExpand,\n    );\n  }\n\n  void _animateToBottom() {\n    // booksC.isBottomSheetExpanded.value = false;\n    _animateOnIsAnimating();\n\n    _controller.value = (_positionOffset! - _minOffset) / _draggableHeight;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.reverse;\n    _controller.animateTo(\n      0.999,\n      duration: widget.animationDurationContract,\n      curve: widget.animationCurveContract,\n    );\n  }\n\n  void _animateToMax() {\n    _animateOnIsAnimating();\n\n    _controller.value = 1.0;\n    _draggableHeight = _positionOffset! - _maxOffset;\n    _animationMinOffset = _maxOffset;\n    _oldStatus = AnimationStatus.reverse;\n    _controller.animateTo(\n      0.001,\n      duration: widget.animationDurationExtend,\n      curve: widget.animationCurveExpand,\n    );\n  }\n\n  void _animateToMin() {\n    _animateOnIsAnimating();\n\n    _controller.value = 1.0;\n    _draggableHeight = _positionOffset! - _minOffset;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.forward;\n    _controller.animateTo(\n      0.0001,\n      duration: widget.animationDurationContract,\n      curve: widget.animationCurveContract,\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/zooms.dart", "file_name": "zooms.dart", "line": 21, "line_from": 21, "line_to": 94, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  ZoomInState createState() => ZoomInState();\n}\n\nclass ZoomInState extends State<ZoomIn> with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> fade;\n  late Animation<double> opacity;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n    fade = Tween(begin: 0.001, end: widget.from)\n        .animate(CurvedAnimation(curve: Curves.easeOut, parent: controller!));\n\n    opacity = Tween<double>(begin: 0, end: 1).animate(\n      CurvedAnimation(parent: controller!, curve: const Interval(0, 0.65)),\n    );\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: fade,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.scale(\n          scale: fade.value,\n          child: Opacity(\n            opacity: opacity.value,\n            child: widget.child,\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/fades.dart", "file_name": "fades.dart", "line": 20, "line_from": 20, "line_to": 85, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n\n  @override\n  FadeInState createState() => FadeInState();\n}\n\nclass FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n\n  bool disposed = false;\n\n  late Animation<double> animation;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n    animation = CurvedAnimation(curve: Curves.easeOut, parent: controller!);\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: animation,\n      builder: (BuildContext context, Widget? child) {\n        return Opacity(\n          opacity: animation.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/bounces.dart", "file_name": "bounces.dart", "line": 21, "line_from": 21, "line_to": 93, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  BounceInDownState createState() => BounceInDownState();\n}\n\nclass BounceInDownState extends State<BounceInDown>\n    with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> animation;\n  late Animation<double> opacity;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n\n    opacity = Tween<double>(begin: 0, end: 1).animate(\n      CurvedAnimation(parent: controller!, curve: const Interval(0, 0.65)),\n    );\n\n    animation = Tween<double>(begin: widget.from * -1, end: 0)\n        .animate(CurvedAnimation(parent: controller!, curve: Curves.bounceOut));\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: controller!,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.translate(\n          offset: Offset(0, animation.value),\n          child: Opacity(opacity: opacity.value, child: widget.child),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/slides.dart", "file_name": "slides.dart", "line": 21, "line_from": 21, "line_to": 88, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  SlideInUpState createState() => SlideInUpState();\n}\n\nclass SlideInUpState extends State<SlideInUp>\n    with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> animation;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n\n    animation = Tween<double>(begin: widget.from, end: 0)\n        .animate(CurvedAnimation(parent: controller!, curve: Curves.easeOut));\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: controller!,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.translate(\n          offset: Offset(0, animation.value),\n          child: widget.child,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "core/external_libs/flutter_animated_dialog/src/custom_dialog_transitions.dart", "file_name": "custom_dialog_transitions.dart", "line": 20, "line_from": 20, "line_to": 57, "snippet": "  Widget build(BuildContext context) {\n    final double turnsValue = turns.value;\n    final Matrix4 transform = Matrix4.identity()\n      ..setEntry(3, 2, 0.0006)\n      ..rotateY(turnsValue);\n    return Transform(\n      transform: transform,\n      alignment: FractionalOffset.center,\n      child: child,\n    );\n  }\n}\n\nclass CustomRotationTransition extends AnimatedWidget {\n  const CustomRotationTransition({\n    super.key,\n    required Animation<double> turns,\n    this.alignment = Alignment.center,\n    this.child,\n  }) : super(listenable: turns);\n\n  Animation<double> get turns => listenable as Animation<double>;\n\n  final Alignment? alignment;\n\n  final Widget? child;\n\n  @override\n  Widget build(BuildContext context) {\n    final double turnsValue = turns.value;\n    final Matrix4 transform = Matrix4.rotationZ(turnsValue * math.pi);\n    return Transform(\n      transform: transform,\n      alignment: alignment,\n      child: child,\n    );\n  }\n}"}, {"structure_type": "function", "name": "Builder", "docstring": "", "module": "src", "file_path": "core/external_libs/flutter_animated_dialog/src/animated_dialog.dart", "file_name": "animated_dialog.dart", "line": 53, "line_from": 53, "line_to": 289, "snippet": "      final Widget pageChild = Builder(builder: builder);\n      return SafeArea(\n        top: false,\n        child: Builder(\n          builder: (BuildContext context) {\n            return Theme(data: theme, child: pageChild);\n          },\n        ),\n      );\n    },\n    barrierDismissible: barrierDismissible,\n    barrierLabel: \"Close dialog\",\n    barrierColor: barrierColor ?? Colors.black54,\n    transitionDuration: duration ?? const Duration(milliseconds: 400),\n    transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      switch (animationType) {\n        case DialogTransitionType.fade:\n          return FadeTransition(opacity: animation, child: child);\n        case DialogTransitionType.slideFromRight:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromLeft:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(-1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromRightFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromLeftFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(-1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromTop:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(0, -1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromTopFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(0, -1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromBottom:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(0, 1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromBottomFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(0, 1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.scale:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: child,\n          );\n        case DialogTransitionType.fadeScale:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: FadeTransition(\n              opacity: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.scaleRotate:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: CustomRotationTransition(\n              alignment: alignment,\n              turns: Tween<double>(begin: 1, end: 2).animate(\n                CurvedAnimation(\n                  parent: animation,\n                  curve: Interval(0, 1, curve: curve),\n                ),\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.rotate:\n          return CustomRotationTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: 1, end: 2).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: child,\n          );\n        case DialogTransitionType.fadeRotate:\n          return CustomRotationTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: 1, end: 2).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: FadeTransition(\n              opacity: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.rotate3D:\n          return Rotation3DTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: math.pi, end: 2.0 * math.pi).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: FadeTransition(\n              opacity: Tween<double>(begin: 0, end: 1).animate(\n                CurvedAnimation(\n                  parent: animation,\n                  curve: const Interval(0.5, 1, curve: Curves.elasticOut),\n                ),\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.size:\n          return Align(\n            alignment: alignment,\n            child: SizeTransition(\n              sizeFactor: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              axis: axis ?? Axis.vertical,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.sizeFade:\n          return Align(\n            alignment: alignment,\n            child: SizeTransition(\n              sizeFactor: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: FadeTransition(\n                opacity: CurvedAnimation(\n                  parent: animation,\n                  curve: curve,\n                ),\n                child: child,\n              ),\n            ),\n          );\n        case DialogTransitionType.none:\n          return child;\n      }\n    },"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "core/external_libs/flutter_animated_dialog/src/animated_dialog.dart", "file_name": "animated_dialog.dart", "line": 338, "line_from": 338, "line_to": 497, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final DialogThemeData dialogTheme = DialogTheme.of(context);\n    final List<Widget> children = <Widget>[];\n    String? label = semanticLabel;\n\n    if (title != null) {\n      children.add(\n        Padding(\n          padding: titlePadding ?? EdgeInsets.fromLTRB(24, 24, 24, content == null ? 20.0 : 0.0),\n          child: DefaultTextStyle(\n            style: (titleTextStyle ?? dialogTheme.titleTextStyle ?? theme.textTheme.titleLarge)!,\n            child: Semantics(\n              namesRoute: true,\n              container: true,\n              child: title,\n            ),\n          ),\n        ),\n      );\n    } else {\n      switch (defaultTargetPlatform) {\n        case TargetPlatform.iOS:\n          label = semanticLabel;\n        case TargetPlatform.android:\n        case TargetPlatform.fuchsia:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n        case TargetPlatform.linux:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n        case TargetPlatform.macOS:\n          label = semanticLabel;\n        case TargetPlatform.windows:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n      }\n    }\n\n    if (content != null) {\n      children.add(\n        Flexible(\n          child: Padding(\n            padding: contentPadding!,\n            child: DefaultTextStyle(\n              style: (contentTextStyle ?? dialogTheme.contentTextStyle ?? theme.textTheme.titleMedium)!,\n              child: content!,\n            ),\n          ),\n        ),\n      );\n    }\n\n    if (bottomWidget != null) {\n      children.add(bottomWidget!);\n    } else if (actions != null) {\n      children.add(\n        ButtonBarTheme(\n          data: ButtonBarTheme.of(context),\n          // ignore: deprecated_member_use\n          child: ButtonBar(\n            children: actions!,\n          ),\n        ),\n      );\n    }\n\n    Widget dialogChild = IntrinsicWidth(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: children,\n      ),\n    );\n\n    if (label != null) {\n      dialogChild = Semantics(\n        namesRoute: true,\n        label: label,\n        child: dialogChild,\n      );\n    }\n\n    dialogChild = CustomDialog(\n      backgroundColor: backgroundColor,\n      elevation: elevation,\n      minWidth: minWidth,\n      shape: shape,\n      child: dialogChild,\n    );\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(\n      value: SystemUiOverlayStyle.light.copyWith(\n        statusBarIconBrightness: Brightness.light,\n        statusBarColor: Colors.transparent,\n        systemNavigationBarColor: Colors.white,\n        systemNavigationBarIconBrightness: Brightness.dark,\n      ),\n      child: dialogChild,\n    );\n  }\n}\n\nclass CustomDialog extends StatelessWidget {\n  const CustomDialog({\n    super.key,\n    this.backgroundColor,\n    this.elevation,\n    this.insetAnimationDuration = const Duration(milliseconds: 100),\n    this.insetAnimationCurve = Curves.decelerate,\n    this.minWidth = 280.0,\n    this.shape,\n    this.child,\n  });\n\n  final Color? backgroundColor;\n\n  final double? elevation;\n\n  final Duration? insetAnimationDuration;\n\n  final Curve? insetAnimationCurve;\n\n  final double? minWidth;\n\n  final ShapeBorder? shape;\n\n  final Widget? child;\n\n  static const RoundedRectangleBorder _defaultDialogShape = RoundedRectangleBorder(\n    borderRadius: BorderRadius.all(Radius.circular(2)),\n  );\n  static const double _defaultElevation = 24;\n\n  @override\n  Widget build(BuildContext context) {\n    final DialogThemeData dialogTheme = DialogTheme.of(context);\n    return AnimatedPadding(\n      padding: MediaQuery.of(context).viewInsets + const EdgeInsets.symmetric(horizontal: 40, vertical: 24),\n      duration: insetAnimationDuration!,\n      curve: insetAnimationCurve!,\n      child: MediaQuery.removeViewInsets(\n        removeLeft: true,\n        removeTop: true,\n        removeRight: true,\n        removeBottom: true,\n        context: context,\n        child: Center(\n          child: ConstrainedBox(\n            constraints: BoxConstraints(minWidth: minWidth ?? 280.0),\n            child: Material(\n              color: backgroundColor ?? dialogTheme.backgroundColor,\n              elevation: elevation ?? dialogTheme.elevation ?? _defaultElevation,\n              shape: shape ?? dialogTheme.shape ?? _defaultDialogShape,\n              type: MaterialType.card,\n              child: child,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 10, "line_from": 10, "line_to": 23, "snippet": "  final Widget child;\n\n  final ValueNotifier<Set<Element>?>? elementNotifier;\n\n  @override\n  State<StatefulWidget> createState() => _RegistryWidgetState();\n}\n\nclass RegisteredElementWidget extends ProxyWidget {\n  const RegisteredElementWidget({super.key, required super.child});\n\n  @override\n  Element createElement() => _RegisteredElement(this);\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 29, "line_from": 29, "line_to": 45, "snippet": "  Widget build(BuildContext context) => _InheritedRegistryWidget(\n        state: this,\n        child: widget.child,\n      );\n}\n\nclass _InheritedRegistryWidget extends InheritedWidget {\n  const _InheritedRegistryWidget({\n    required this.state,\n    required super.child,\n  });\n\n  final _RegistryWidgetState state;\n\n  @override\n  bool updateShouldNotify(InheritedWidget oldWidget) => true;\n}"}, {"structure_type": "function", "name": "notifyClients", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 51, "line_from": 51, "line_to": 84, "snippet": "  void notifyClients(ProxyWidget oldWidget) {}\n\n  late _RegistryWidgetState _registryWidgetState;\n\n  @override\n  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    final inheritedRegistryWidget =\n        dependOnInheritedWidgetOfExactType<_InheritedRegistryWidget>()!;\n    _registryWidgetState = inheritedRegistryWidget.state;\n    _registryWidgetState.registeredElements.add(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final inheritedRegistryWidget =\n        dependOnInheritedWidgetOfExactType<_InheritedRegistryWidget>()!;\n    _registryWidgetState = inheritedRegistryWidget.state;\n    _registryWidgetState.registeredElements.add(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n  }\n\n  @override\n  void unmount() {\n    _registryWidgetState.registeredElements.remove(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n    super.unmount();\n  }\n}"}, {"structure_type": "function", "name": "jumpTo", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/scrollable_positioned_list.dart", "file_name": "scrollable_positioned_list.dart", "line": 119, "line_from": 119, "line_to": 178, "snippet": "  void jumpTo({required int index, double alignment = 0}) {\n    _scrollableListState?._jumpTo(index: index, alignment: alignment);\n  }\n\n  Future<void> scrollTo({\n    required int index,\n    double alignment = 0,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    List<double> opacityAnimationWeights = const [40, 20, 40],\n  }) {\n    assert(_scrollableListState != null);\n    assert(opacityAnimationWeights.length == 3);\n    assert(duration > Duration.zero);\n    return _scrollableListState!._scrollTo(\n      index: index,\n      alignment: alignment,\n      duration: duration,\n      curve: curve,\n      opacityAnimationWeights: opacityAnimationWeights,\n    );\n  }\n\n  void _attach(_ScrollablePositionedListState scrollableListState) {\n    assert(_scrollableListState == null);\n    _scrollableListState = scrollableListState;\n  }\n\n  void _detach() {\n    _scrollableListState = null;\n  }\n}\n\nclass ScrollOffsetController {\n  Future<void> animateScroll({\n    required double offset,\n    required Duration duration,\n    Curve curve = Curves.linear,\n  }) async {\n    final currentPosition =\n        _scrollableListState!.primary.scrollController.offset;\n    final newPosition = currentPosition + offset;\n    await _scrollableListState!.primary.scrollController.animateTo(\n      newPosition,\n      duration: duration,\n      curve: curve,\n    );\n  }\n\n  _ScrollablePositionedListState? _scrollableListState;\n\n  void _attach(_ScrollablePositionedListState scrollableListState) {\n    assert(_scrollableListState == null);\n    _scrollableListState = scrollableListState;\n  }\n\n  void _detach() {\n    _scrollableListState = null;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/scrollable_positioned_list.dart", "file_name": "scrollable_positioned_list.dart", "line": 188, "line_from": 188, "line_to": 544, "snippet": "  void Function() startAnimationCallback = () {};\n\n  bool _isTransitioning = false;\n\n  late AnimationController _animationController =\n      AnimationController(vsync: this);\n\n  double previousOffset = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    final ItemPosition? initialPosition =\n        PageStorage.of(context).readState(context) as ItemPosition?;\n    primary = _ListDisplayDetails(\n      const ValueKey('Ping'),\n      widget.itemScrollController?.scrollController ??\n          ScrollController(keepScrollOffset: false),\n    );\n    secondary = _ListDisplayDetails(\n      const ValueKey('Pong'),\n      ScrollController(keepScrollOffset: false),\n    );\n    primary\n      ..target = initialPosition?.index ?? widget.initialScrollIndex\n      ..alignment = initialPosition?.itemLeadingEdge ?? widget.initialAlignment;\n    if (widget.itemCount > 0 && primary.target > widget.itemCount - 1) {\n      primary.target = widget.itemCount - 1;\n    }\n    widget.itemScrollController?._attach(this);\n    widget.scrollOffsetController?._attach(this);\n    primary.itemPositionsNotifier.itemPositions.addListener(_updatePositions);\n    secondary.itemPositionsNotifier.itemPositions.addListener(_updatePositions);\n    primary.scrollController.addListener(() {\n      final currentOffset = primary.scrollController.offset;\n      final offsetChange = currentOffset - previousOffset;\n      previousOffset = currentOffset;\n      if (!_isTransitioning |\n          (widget.scrollOffsetNotifier?.recordProgrammaticScrolls ?? false)) {\n        widget.scrollOffsetNotifier?.changeController.add(offsetChange);\n      }\n    });\n  }\n\n  @override\n  void activate() {\n    super.activate();\n    widget.itemScrollController?._attach(this);\n    widget.scrollOffsetController?._attach(this);\n  }\n\n  @override\n  void deactivate() {\n    widget.itemScrollController?._detach();\n    widget.scrollOffsetController?._detach();\n    super.deactivate();\n  }\n\n  @override\n  void dispose() {\n    primary.itemPositionsNotifier.itemPositions\n        .removeListener(_updatePositions);\n    secondary.itemPositionsNotifier.itemPositions\n        .removeListener(_updatePositions);\n    // _animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(ScrollablePositionedList oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.itemScrollController?._scrollableListState == this) {\n      oldWidget.itemScrollController?._detach();\n    }\n    if (widget.itemScrollController?._scrollableListState != this) {\n      widget.itemScrollController?._detach();\n      widget.itemScrollController?._attach(this);\n    }\n\n    if (widget.itemCount == 0) {\n      setState(() {\n        primary.target = 0;\n        secondary.target = 0;\n      });\n    } else {\n      if (primary.target > widget.itemCount - 1) {\n        setState(() {\n          primary.target = widget.itemCount - 1;\n        });\n      }\n      if (secondary.target > widget.itemCount - 1) {\n        setState(() {\n          secondary.target = widget.itemCount - 1;\n        });\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final cacheExtent = _cacheExtent(constraints);\n        return Listener(\n          onPointerDown: (_) => _stopScroll(canceled: true),\n          child: Stack(\n            children: <Widget>[\n              PostMountCallback(\n                key: primary.key,\n                callback: startAnimationCallback,\n                child: FadeTransition(\n                  opacity: ReverseAnimation(opacity),\n                  child: NotificationListener<ScrollNotification>(\n                    onNotification: (_) => _isTransitioning,\n                    child: PositionedList(\n                      itemBuilder: widget.itemBuilder,\n                      separatorBuilder: widget.separatorBuilder,\n                      itemCount: widget.itemCount,\n                      positionedIndex: primary.target,\n                      controller: primary.scrollController,\n                      itemPositionsNotifier: primary.itemPositionsNotifier,\n                      scrollDirection: widget.scrollDirection,\n                      reverse: widget.reverse,\n                      cacheExtent: cacheExtent,\n                      alignment: primary.alignment,\n                      physics: widget.physics,\n                      shrinkWrap: widget.shrinkWrap,\n                      addSemanticIndexes: widget.addSemanticIndexes,\n                      semanticChildCount: widget.semanticChildCount,\n                      padding: widget.padding,\n                      addAutomaticKeepAlives: widget.addAutomaticKeepAlives,\n                      addRepaintBoundaries: widget.addRepaintBoundaries,\n                    ),\n                  ),\n                ),\n              ),\n              if (_isTransitioning)\n                PostMountCallback(\n                  key: secondary.key,\n                  callback: startAnimationCallback,\n                  child: FadeTransition(\n                    opacity: opacity,\n                    child: NotificationListener<ScrollNotification>(\n                      onNotification: (_) => false,\n                      child: PositionedList(\n                        itemBuilder: widget.itemBuilder,\n                        separatorBuilder: widget.separatorBuilder,\n                        itemCount: widget.itemCount,\n                        itemPositionsNotifier: secondary.itemPositionsNotifier,\n                        positionedIndex: secondary.target,\n                        controller: secondary.scrollController,\n                        scrollDirection: widget.scrollDirection,\n                        reverse: widget.reverse,\n                        cacheExtent: cacheExtent,\n                        alignment: secondary.alignment,\n                        physics: widget.physics,\n                        shrinkWrap: widget.shrinkWrap,\n                        addSemanticIndexes: widget.addSemanticIndexes,\n                        semanticChildCount: widget.semanticChildCount,\n                        padding: widget.padding,\n                        addAutomaticKeepAlives: widget.addAutomaticKeepAlives,\n                        addRepaintBoundaries: widget.addRepaintBoundaries,\n                      ),\n                    ),\n                  ),\n                ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n\n  double _cacheExtent(BoxConstraints constraints) => max(\n        (widget.scrollDirection == Axis.vertical\n                ? constraints.maxHeight\n                : constraints.maxWidth) *\n            _screenScrollCount,\n        widget.minCacheExtent ?? 0,\n      );\n\n  void _jumpTo({required int index, required double alignment}) {\n    _stopScroll(canceled: true);\n    if (index > widget.itemCount - 1) {\n      index = widget.itemCount - 1;\n    }\n    setState(() {\n      primary.scrollController.jumpTo(0);\n      primary\n        ..target = index\n        ..alignment = alignment;\n    });\n  }\n\n  Future<void> _scrollTo({\n    required int index,\n    required double alignment,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    required List<double> opacityAnimationWeights,\n  }) async {\n    if (index > widget.itemCount - 1) {\n      index = widget.itemCount - 1;\n    }\n    if (_isTransitioning) {\n      final scrollCompleter = Completer<void>();\n      _stopScroll(canceled: true);\n      SchedulerBinding.instance.addPostFrameCallback((_) async {\n        await _startScroll(\n          index: index,\n          alignment: alignment,\n          duration: duration,\n          curve: curve,\n          opacityAnimationWeights: opacityAnimationWeights,\n        );\n        scrollCompleter.complete();\n      });\n      await scrollCompleter.future;\n    } else {\n      await _startScroll(\n        index: index,\n        alignment: alignment,\n        duration: duration,\n        curve: curve,\n        opacityAnimationWeights: opacityAnimationWeights,\n      );\n    }\n  }\n\n  Future<void> _startScroll({\n    required int index,\n    required double alignment,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    required List<double> opacityAnimationWeights,\n  }) async {\n    final direction = index > primary.target ? 1 : -1;\n    final itemPosition = primary.itemPositionsNotifier.itemPositions.value\n        .firstWhereOrNull((itemPosition) => itemPosition.index == index);\n    if (itemPosition != null) {\n      final localScrollAmount = itemPosition.itemLeadingEdge *\n          primary.scrollController.position.viewportDimension;\n      await primary.scrollController.animateTo(\n        primary.scrollController.offset +\n            localScrollAmount -\n            alignment * primary.scrollController.position.viewportDimension,\n        duration: duration,\n        curve: curve,\n      );\n    } else {\n      final scrollAmount = _screenScrollCount *\n          primary.scrollController.position.viewportDimension;\n      final startCompleter = Completer<void>();\n      final endCompleter = Completer<void>();\n      startAnimationCallback = () {\n        SchedulerBinding.instance.addPostFrameCallback((_) {\n          startAnimationCallback = () {};\n          _animationController.dispose();\n          _animationController =\n              AnimationController(vsync: this, duration: duration)..forward();\n          opacity.parent = _opacityAnimation(opacityAnimationWeights)\n              .animate(_animationController);\n          secondary.scrollController.jumpTo(\n            -direction *\n                (_screenScrollCount *\n                        primary.scrollController.position.viewportDimension -\n                    alignment *\n                        secondary.scrollController.position.viewportDimension),\n          );\n\n          startCompleter.complete(\n            primary.scrollController.animateTo(\n              primary.scrollController.offset + direction * scrollAmount,\n              duration: duration,\n              curve: curve,\n            ),\n          );\n          endCompleter.complete(\n            secondary.scrollController\n                .animateTo(0, duration: duration, curve: curve),\n          );\n        });\n      };\n      setState(() {\n        secondary\n          ..target = index\n          ..alignment = alignment;\n        _isTransitioning = true;\n      });\n      await Future.wait<void>([startCompleter.future, endCompleter.future]);\n      _stopScroll();\n    }\n  }\n\n  void _stopScroll({bool canceled = false}) {\n    if (!_isTransitioning) {\n      return;\n    }\n\n    if (canceled) {\n      if (primary.scrollController.hasClients) {\n        primary.scrollController.jumpTo(primary.scrollController.offset);\n      }\n      if (secondary.scrollController.hasClients) {\n        secondary.scrollController.jumpTo(secondary.scrollController.offset);\n      }\n    }\n    if (mounted) {\n      setState(() {\n        if (opacity.value >= 0.5) {\n          final temp = primary;\n          primary = secondary;\n          secondary = temp;\n        }\n        _isTransitioning = false;\n        opacity.parent = const AlwaysStoppedAnimation<double>(0);\n      });\n    }\n  }\n\n  Animatable<double> _opacityAnimation(List<double> opacityAnimationWeights) {\n    const startOpacity = 0.0;\n    const endOpacity = 1.0;\n    return TweenSequence<double>(<TweenSequenceItem<double>>[\n      TweenSequenceItem<double>(\n        tween: ConstantTween<double>(startOpacity),\n        weight: opacityAnimationWeights[0],\n      ),\n      TweenSequenceItem<double>(\n        tween: Tween<double>(begin: startOpacity, end: endOpacity),\n        weight: opacityAnimationWeights[1],\n      ),\n      TweenSequenceItem<double>(\n        tween: ConstantTween<double>(endOpacity),\n        weight: opacityAnimationWeights[2],\n      ),\n    ]);\n  }\n\n  void _updatePositions() {\n    final itemPositions =\n        primary.itemPositionsNotifier.itemPositions.value.where(\n      (position) =>\n          position.itemLeadingEdge < 1 && position.itemTrailingEdge > 0,\n    );\n    if (itemPositions.isNotEmpty) {\n      PageStorage.of(context).writeState(\n        context,\n        itemPositions.reduce(\n          (value, element) =>\n              value.itemLeadingEdge < element.itemLeadingEdge ? value : element,\n        ),\n      );\n    }\n    widget.itemPositionsNotifier?.itemPositions.value = itemPositions;\n  }\n}"}, {"structure_type": "function", "name": "updateRenderObject", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 70, "line_from": 70, "line_to": 348, "snippet": "  void updateRenderObject(\n    BuildContext context,\n    CustomRenderShrinkWrappingViewport renderObject,\n  ) {\n    renderObject\n      ..axisDirection = axisDirection\n      ..crossAxisDirection = crossAxisDirection ??\n          Viewport.getDefaultCrossAxisDirection(context, axisDirection)\n      ..anchor = anchor\n      ..offset = offset\n      ..cacheExtent = cacheExtent\n      ..cacheExtentStyle = cacheExtentStyle\n      ..clipBehavior = clipBehavior;\n  }\n}\n\n/// A render object that is bigger on the inside and shrink wraps its children\n/// in the main axis.\n///\n/// [RenderShrinkWrappingViewport] displays a subset of its children according\n/// to its own dimensions and the given [offset]. As the offset varies, different\n/// children are visible through the viewport.\n///\n/// [RenderShrinkWrappingViewport] differs from [RenderViewport] in that\n/// [RenderViewport] expands to fill the main axis whereas\n/// [RenderShrinkWrappingViewport] sizes itself to match its children in the\n/// main axis. This shrink wrapping behavior is expensive because the children,\n/// and hence the viewport, could potentially change size whenever the [offset]\n/// changes (e.g., because of a collapsing header).\n///\n/// [RenderShrinkWrappingViewport] cannot contain [RenderBox] children directly.\n/// Instead, use a [RenderSliverList], [RenderSliverFixedExtentList],\n/// [RenderSliverGrid], or a [RenderSliverToBoxAdapter], for example.\n///\n/// See also:\n///\n///  * [RenderViewport], a viewport that does not shrink-wrap its contents.\n///  * [RenderSliver], which explains more about the Sliver protocol.\n///  * [RenderBox], which explains more about the Box protocol.\n///  * [RenderSliverToBoxAdapter], which allows a [RenderBox] object to be\n///    placed inside a [RenderSliver] (the opposite of this class).\nclass CustomRenderShrinkWrappingViewport extends CustomRenderViewport {\n  /// Creates a viewport (for [RenderSliver] objects) that shrink-wraps its\n  /// contents.\n  ///\n  /// The [offset] must be specified. For testing purposes, consider passing a\n  /// [ViewportOffset.zero] or [ViewportOffset.fixed].\n  CustomRenderShrinkWrappingViewport({\n    super.axisDirection,\n    required super.crossAxisDirection,\n    required super.offset,\n    double anchor = 0.0,\n    super.children,\n    super.center,\n    super.cacheExtent,\n  }) : _anchor = anchor;\n\n  double _anchor;\n\n  @override\n  double get anchor => _anchor;\n\n  @override\n  bool get sizedByParent => false;\n\n  double lastMainAxisExtent = -1;\n\n  @override\n  set anchor(double value) {\n    if (value == _anchor) return;\n    _anchor = value;\n    markNeedsLayout();\n  }\n\n  late double _shrinkWrapExtent;\n\n  /// This value is set during layout based on the [CacheExtentStyle].\n  ///\n  /// When the style is [CacheExtentStyle.viewport], it is the main axis extent\n  /// of the viewport multiplied by the requested cache extent, which is still\n  /// expressed in pixels.\n  double? _calculatedCacheExtent;\n\n  /// While List in a wrapping container, eg. ListView\uff0cthe mainAxisExtent will\n  /// be infinite. This time need to change mainAxisExtent to this value.\n  final double _maxMainAxisExtent = double.maxFinite;\n\n  @override\n  void performLayout() {\n    if (center == null) {\n      assert(firstChild == null);\n      _minScrollExtent = 0.0;\n      _maxScrollExtent = 0.0;\n      _hasVisualOverflow = false;\n      offset.applyContentDimensions(0, 0);\n      return;\n    }\n\n    assert(center!.parent == this);\n\n    final BoxConstraints constraints = this.constraints;\n    if (firstChild == null) {\n      switch (axis) {\n        case Axis.vertical:\n          assert(constraints.hasBoundedWidth);\n          size = Size(constraints.maxWidth, constraints.minHeight);\n        case Axis.horizontal:\n          assert(constraints.hasBoundedHeight);\n          size = Size(constraints.minWidth, constraints.maxHeight);\n      }\n      offset.applyViewportDimension(0);\n      _maxScrollExtent = 0.0;\n      _shrinkWrapExtent = 0.0;\n      _hasVisualOverflow = false;\n      offset.applyContentDimensions(0, 0);\n      return;\n    }\n\n    double mainAxisExtent;\n    final double crossAxisExtent;\n    switch (axis) {\n      case Axis.vertical:\n        assert(constraints.hasBoundedWidth);\n        mainAxisExtent = constraints.maxHeight;\n        crossAxisExtent = constraints.maxWidth;\n      case Axis.horizontal:\n        assert(constraints.hasBoundedHeight);\n        mainAxisExtent = constraints.maxWidth;\n        crossAxisExtent = constraints.maxHeight;\n    }\n\n    if (mainAxisExtent.isInfinite) {\n      mainAxisExtent = _maxMainAxisExtent;\n    }\n\n    final centerOffsetAdjustment = center!.centerOffsetAdjustment;\n\n    double correction = 0;\n    double effectiveExtent = 0;\n    do {\n      correction = _attemptLayout(\n        mainAxisExtent,\n        crossAxisExtent,\n        offset.pixels + centerOffsetAdjustment,\n      );\n      if (correction != 0.0) {\n        offset.correctBy(correction);\n      } else {\n        switch (axis) {\n          case Axis.vertical:\n            effectiveExtent = constraints.constrainHeight(_shrinkWrapExtent);\n          case Axis.horizontal:\n            effectiveExtent = constraints.constrainWidth(_shrinkWrapExtent);\n        }\n        // *** Difference from [RenderViewport].\n        final top = _minScrollExtent + mainAxisExtent * anchor;\n        final bottom = _maxScrollExtent - mainAxisExtent * (1.0 - anchor);\n\n        final double maxScrollOffset = math.max(math.min(0, top), bottom);\n        final double minScrollOffset = math.min(top, maxScrollOffset);\n\n        final bool didAcceptViewportDimension =\n            offset.applyViewportDimension(effectiveExtent);\n        final bool didAcceptContentDimension =\n            offset.applyContentDimensions(minScrollOffset, maxScrollOffset);\n        if (didAcceptViewportDimension && didAcceptContentDimension) {\n          break;\n        }\n      }\n    } while (int.tryParse(\"1\") == 1);\n    switch (axis) {\n      case Axis.vertical:\n        size =\n            constraints.constrainDimensions(crossAxisExtent, effectiveExtent);\n      case Axis.horizontal:\n        size =\n            constraints.constrainDimensions(effectiveExtent, crossAxisExtent);\n    }\n  }\n\n  double _attemptLayout(\n    double mainAxisExtent,\n    double crossAxisExtent,\n    double correctedOffset,\n  ) {\n    assert(!mainAxisExtent.isNaN);\n    assert(mainAxisExtent >= 0.0);\n    assert(crossAxisExtent.isFinite);\n    assert(crossAxisExtent >= 0.0);\n    assert(correctedOffset.isFinite);\n    _minScrollExtent = 0.0;\n    _maxScrollExtent = 0.0;\n    _hasVisualOverflow = false;\n    _shrinkWrapExtent = 0.0;\n\n    // centerOffset is the offset from the leading edge of the RenderViewport\n    // to the zero scroll offset (the line between the forward slivers and the\n    // reverse slivers).\n    final centerOffset = mainAxisExtent * anchor - correctedOffset;\n    final reverseDirectionRemainingPaintExtent =\n        centerOffset.clamp(0.0, mainAxisExtent);\n    final forwardDirectionRemainingPaintExtent =\n        (mainAxisExtent - centerOffset).clamp(0.0, mainAxisExtent);\n\n    switch (cacheExtentStyle) {\n      case CacheExtentStyle.pixel:\n        _calculatedCacheExtent = cacheExtent;\n      case CacheExtentStyle.viewport:\n        _calculatedCacheExtent = mainAxisExtent * cacheExtent!;\n    }\n\n    final fullCacheExtent = mainAxisExtent + 2 * _calculatedCacheExtent!;\n    final centerCacheOffset = centerOffset + _calculatedCacheExtent!;\n    final reverseDirectionRemainingCacheExtent =\n        centerCacheOffset.clamp(0.0, fullCacheExtent);\n    final forwardDirectionRemainingCacheExtent =\n        (fullCacheExtent - centerCacheOffset).clamp(0.0, fullCacheExtent);\n\n    final leadingNegativeChild = childBefore(center!);\n\n    if (leadingNegativeChild != null) {\n      // negative scroll offsets\n      final result = layoutChildSequence(\n        child: leadingNegativeChild,\n        scrollOffset: math.max(mainAxisExtent, centerOffset) - mainAxisExtent,\n        overlap: 0,\n        layoutOffset: forwardDirectionRemainingPaintExtent,\n        remainingPaintExtent: reverseDirectionRemainingPaintExtent,\n        mainAxisExtent: mainAxisExtent,\n        crossAxisExtent: crossAxisExtent,\n        growthDirection: GrowthDirection.reverse,\n        advance: childBefore,\n        remainingCacheExtent: reverseDirectionRemainingCacheExtent,\n        cacheOrigin: (mainAxisExtent - centerOffset)\n            .clamp(-_calculatedCacheExtent!, 0.0),\n      );\n      if (result != 0.0) return -result;\n    }\n\n    // positive scroll offsets\n    return layoutChildSequence(\n      child: center,\n      scrollOffset: math.max(0, -centerOffset),\n      overlap: leadingNegativeChild == null ? math.min(0, -centerOffset) : 0.0,\n      layoutOffset: centerOffset >= mainAxisExtent\n          ? centerOffset\n          : reverseDirectionRemainingPaintExtent,\n      remainingPaintExtent: forwardDirectionRemainingPaintExtent,\n      mainAxisExtent: mainAxisExtent,\n      crossAxisExtent: crossAxisExtent,\n      growthDirection: GrowthDirection.forward,\n      advance: childAfter,\n      remainingCacheExtent: forwardDirectionRemainingCacheExtent,\n      cacheOrigin: centerOffset.clamp(-_calculatedCacheExtent!, 0.0),\n    );\n  }\n\n  @override\n  bool get hasVisualOverflow => _hasVisualOverflow;\n\n  @override\n  void updateOutOfBandData(\n    GrowthDirection growthDirection,\n    SliverGeometry childLayoutGeometry,\n  ) {\n    switch (growthDirection) {\n      case GrowthDirection.forward:\n        _maxScrollExtent += childLayoutGeometry.scrollExtent;\n      case GrowthDirection.reverse:\n        _minScrollExtent -= childLayoutGeometry.scrollExtent;\n    }\n    if (childLayoutGeometry.hasVisualOverflow) _hasVisualOverflow = true;\n    _shrinkWrapExtent += childLayoutGeometry.maxPaintExtent;\n    growSize = _shrinkWrapExtent;\n  }\n\n  @override\n  String labelForChild(int index) => 'child $index';\n}"}, {"structure_type": "function", "name": "slivers.where", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 404, "line_from": 404, "line_to": 551, "snippet": "              slivers.where((Widget child) => child.key == center).length == 1,\n        ),\n        assert(\n          cacheExtentStyle != CacheExtentStyle.viewport || cacheExtent != null,\n        ),\n        super(children: slivers);\n\n  /// The direction in which the [offset]'s [ViewportOffset.pixels] increases.\n  ///\n  /// For example, if the [axisDirection] is [AxisDirection.down], a scroll\n  /// offset of zero is at the top of the viewport and increases towards the\n  /// bottom of the viewport.\n  final AxisDirection axisDirection;\n\n  /// The direction in which child should be laid out in the cross axis.\n  ///\n  /// If the [axisDirection] is [AxisDirection.down] or [AxisDirection.up], this\n  /// property defaults to [AxisDirection.left] if the ambient [Directionality]\n  /// is [TextDirection.rtl] and [AxisDirection.right] if the ambient\n  /// [Directionality] is [TextDirection.ltr].\n  ///\n  /// If the [axisDirection] is [AxisDirection.left] or [AxisDirection.right],\n  /// this property defaults to [AxisDirection.down].\n  final AxisDirection? crossAxisDirection;\n\n  /// The relative position of the zero scroll offset.\n  ///\n  /// For example, if [anchor] is 0.5 and the [axisDirection] is\n  /// [AxisDirection.down] or [AxisDirection.up], then the zero scroll offset is\n  /// vertically centered within the viewport. If the [anchor] is 1.0, and the\n  /// [axisDirection] is [AxisDirection.right], then the zero scroll offset is\n  /// on the left edge of the viewport.\n  final double anchor;\n\n  /// Which part of the content inside the viewport should be visible.\n  ///\n  /// The [ViewportOffset.pixels] value determines the scroll offset that the\n  /// viewport uses to select which part of its content to display. As the user\n  /// scrolls the viewport, this value changes, which changes the content that\n  /// is displayed.\n  ///\n  /// Typically a [ScrollPosition].\n  final ViewportOffset offset;\n\n  /// The first child in the [GrowthDirection.forward] growth direction.\n  ///\n  /// Children after [center] will be placed in the [axisDirection] relative to\n  /// the [center]. Children before [center] will be placed in the opposite of\n  /// the [axisDirection] relative to the [center].\n  ///\n  /// The [center] must be the key of a child of the viewport.\n  final Key? center;\n\n  /// {@macro flutter.rendering.RenderViewportBase.cacheExtent}\n  ///\n  /// See also:\n  ///\n  ///  * [cacheExtentStyle], which controls the units of the [cacheExtent].\n  final double? cacheExtent;\n\n  /// {@macro flutter.rendering.RenderViewportBase.cacheExtentStyle}\n  final CacheExtentStyle cacheExtentStyle;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Given a [BuildContext] and an [AxisDirection], determine the correct cross\n  /// axis direction.\n  ///\n  /// This depends on the [Directionality] if the `axisDirection` is vertical;\n  /// otherwise, the default cross axis direction is downwards.\n  static AxisDirection getDefaultCrossAxisDirection(\n    BuildContext context,\n    AxisDirection axisDirection,\n  ) {\n    switch (axisDirection) {\n      case AxisDirection.up:\n        assert(\n          debugCheckHasDirectionality(\n            context,\n            why:\n                \"to determine the cross-axis direction when the viewport has an 'up' axisDirection\",\n            alternative:\n                \"Alternatively, consider specifying the 'crossAxisDirection' argument on the Viewport.\",\n          ),\n        );\n        return textDirectionToAxisDirection(Directionality.of(context));\n      case AxisDirection.right:\n        return AxisDirection.down;\n      case AxisDirection.down:\n        assert(\n          debugCheckHasDirectionality(\n            context,\n            why:\n                \"to determine the cross-axis direction when the viewport has a 'down' axisDirection\",\n            alternative:\n                \"Alternatively, consider specifying the 'crossAxisDirection' argument on the Viewport.\",\n          ),\n        );\n        return textDirectionToAxisDirection(Directionality.of(context));\n      case AxisDirection.left:\n        return AxisDirection.down;\n    }\n  }\n\n  @override\n  CustomRenderViewport createRenderObject(BuildContext context);\n\n  @override\n  ViewportElement createElement() => ViewportElement(this);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty<AxisDirection>('axisDirection', axisDirection))\n      ..add(\n        EnumProperty<AxisDirection>(\n          'crossAxisDirection',\n          crossAxisDirection,\n          defaultValue: null,\n        ),\n      )\n      ..add(DoubleProperty('anchor', anchor))\n      ..add(DiagnosticsProperty<ViewportOffset>('offset', offset));\n    if (center != null) {\n      properties.add(DiagnosticsProperty<Key>('center', center));\n    } else if (children.isNotEmpty && children.first.key != null) {\n      properties.add(\n        DiagnosticsProperty<Key>(\n          'center',\n          children.first.key,\n          tooltip: 'implicit',\n        ),\n      );\n    }\n    properties\n      ..add(DiagnosticsProperty<double>('cacheExtent', cacheExtent))\n      ..add(\n        DiagnosticsProperty<CacheExtentStyle>(\n          'cacheExtentStyle',\n          cacheExtentStyle,\n        ),\n      );\n  }\n}"}, {"structure_type": "function", "name": "mount", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 565, "line_from": 565, "line_to": 612, "snippet": "  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    _updateCenter();\n  }\n\n  @override\n  void update(MultiChildRenderObjectWidget newWidget) {\n    super.update(newWidget);\n    _updateCenter();\n  }\n\n  void _updateCenter() {\n    if (widget.center != null) {\n      renderObject.center = children\n          .singleWhere((Element element) => element.widget.key == widget.center)\n          .renderObject as RenderSliver?;\n    } else if (children.isNotEmpty) {\n      renderObject.center = children.first.renderObject as RenderSliver?;\n    } else {\n      renderObject.center = null;\n    }\n  }\n\n  @override\n  void debugVisitOnstageChildren(ElementVisitor visitor) {\n    children.where((Element e) {\n      final RenderSliver renderSliver = e.renderObject! as RenderSliver;\n      return renderSliver.geometry!.visible;\n    }).forEach(visitor);\n  }\n}\n\nclass CustomSliverPhysicalContainerParentData\n    extends SliverPhysicalContainerParentData {\n  /// The position of the child relative to the zero scroll offset.\n  ///\n  /// The number of pixels from from the zero scroll offset of the parent sliver\n  /// (the line at which its [SliverConstraints.scrollOffset] is zero) to the\n  /// side of the child closest to that offset. A [layoutOffset] can be null\n  /// when it cannot be determined. The value will be set after layout.\n  ///\n  /// In a typical list, this does not change as the parent is scrolled.\n  ///\n  /// Defaults to null.\n  double? layoutOffset;\n\n  GrowthDirection? growthDirection;\n}"}, {"structure_type": "function", "name": "child;", "docstring": "The widget below this widget in the tree.", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/post_mount_callback.dart", "file_name": "post_mount_callback.dart", "line": 13, "line_from": 13, "line_to": 34, "snippet": "  final Widget child;\n\n  /// Callback to call when the element for this widget is mounted.\n  final void Function()? callback;\n\n  @override\n  StatelessElement createElement() => _PostMountCallbackElement(this);\n\n  @override\n  Widget build(BuildContext context) => child;\n}\n\nclass _PostMountCallbackElement extends StatelessElement {\n  _PostMountCallbackElement(PostMountCallback super.widget);\n\n  @override\n  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    final PostMountCallback postMountCallback = widget as PostMountCallback;\n    postMountCallback.callback?.call();\n  }\n}"}, {"structure_type": "function", "name": "dismiss", "docstring": "", "module": "services", "file_path": "core/external_libs/services/keyboard_service.dart", "file_name": "keyboard_service.dart", "line": 24, "line_from": 24, "line_to": 43, "snippet": "  static void dismiss({BuildContext? context, FocusNode? focusNode}) =>\n      catchVoid(() {\n        final BuildContext anyContext = (context != null && context.mounted)\n            ? context\n            : QuranMajeed.globalContext;\n\n        if (!isVisible(anyContext)) return;\n\n        SystemChannels.textInput.invokeMethod<void>('TextInput.hide');\n\n        // Focus handling\n        if (focusNode != null) {\n          if (focusNode.hasFocus || focusNode.hasPrimaryFocus) {\n            focusNode.unfocus();\n          }\n        } else {\n          FocusScope.of(anyContext).unfocus();\n        }\n      });\n}"}, {"structure_type": "function", "name": "toggleLoading", "docstring": "", "module": "base", "file_path": "core/base/base_presenter.dart", "file_name": "base_presenter.dart", "line": 19, "line_from": 19, "line_to": 96, "snippet": "  Future<void> toggleLoading({required bool loading});\n\n  // Function to add user message\n  Future<void> addUserMessage(String message);\n\n  // Function to handle stream events\n  @protected\n  Future<void> handleStreamEvents<T>({\n    required Stream<Either<String, T>> stream,\n    required void Function(T) onData,\n    required StreamSubscription<Either<String, T>>? subscription,\n  }) async {\n    await subscription?.cancel();\n    subscription = stream.listen(\n      (result) => result.fold(addUserMessage, onData),\n      onError: (Object e) => logDebugStatic('Error in handleStreamEvents:', e.toString()),\n      onDone: () async => subscription?.cancel(),\n    );\n  }\n\n  // Function to execute a task with loading state\n  @protected\n  Future<void> executeTaskWithLoading(FutureOr<void> Function() task) async {\n    await toggleLoading(loading: true);\n    await task();\n    await toggleLoading(loading: false);\n  }\n\n  // Function to execute a use case that only shows a message\n  @protected\n  Future<void> executeMessageOnlyUseCase(\n    FutureOr<Either<String, String>> Function() task, {\n    bool showMessage = true,\n    VoidCallback? onSuccess,\n  }) async {\n    await toggleLoading(loading: true);\n    final Either<String, String> result = await task();\n    await result.fold(addUserMessage, (message) async {\n      if (showMessage) await addUserMessage(message);\n      onSuccess?.call();\n    });\n    await toggleLoading(loading: false);\n  }\n\n  // Function to parse data from Either with user message\n  @protected\n  Future<void> parseDataFromEitherWithUserMessage<T>({\n    required FutureOr<Either<String, T>> Function() task,\n    required void Function(T) onDataLoaded,\n    bool showLoading = false,\n    T? valueOnError,\n  }) async {\n    if (showLoading) await toggleLoading(loading: true);\n    final Either<String, T> result = await task();\n    result.fold(\n      (message) {\n        addUserMessage(message);\n        if (valueOnError != null) onDataLoaded(valueOnError);\n      },\n      onDataLoaded,\n    );\n    if (showLoading) await toggleLoading(loading: false);\n  }\n\n  // Function to map data from Either with user message\n  @protected\n  Future<T?> mapDataFromEitherWithUserMessage<T>({\n    required FutureOr<Either<String, T>> Function() task,\n    bool showLoading = false,\n  }) async {\n    T? data;\n    if (showLoading) await toggleLoading(loading: true);\n    final Either<String, T> result = await task();\n    if (showLoading) await toggleLoading(loading: false);\n    result.fold(addUserMessage, (d) => data = d);\n    return data;\n  }\n}"}, {"structure_type": "function", "name": "fontExists", "docstring": "", "module": "utility", "file_path": "core/utility/font_manager.dart", "file_name": "font_manager.dart", "line": 21, "line_from": 21, "line_to": 151, "snippet": "  Future<bool> fontExists(int pageNumber, String fontDir) async {\n    final File fontFile = File('$fontDir/${FontConstants.getFontFileName(pageNumber)}');\n    return fontFile.exists();\n  }\n\n  // Get font file path\n  String getFontPath(int pageNumber, String fontDir) {\n    return '$fontDir/${FontConstants.getFontFileName(pageNumber)}';\n  }\n\n  // Load and register a font\n  Future<String> loadAndRegisterFont(int pageNumber, String fontDir) async {\n    // Check if font is already loaded\n    if (_loadedFonts.containsKey(pageNumber)) {\n      // Update LRU queue (move to front)\n      _fontUsageQueue.remove(pageNumber);\n      _fontUsageQueue.insert(0, pageNumber);\n      return _loadedFonts[pageNumber]!;\n    }\n\n    final String fontFamily = FontConstants.getFontFamilyForPage(pageNumber);\n    final String fontPath = getFontPath(pageNumber, fontDir);\n\n    try {\n      // Check if font file exists\n      final File fontFile = File(fontPath);\n      if (!await fontFile.exists()) {\n        logErrorStatic('Font file does not exist: $fontPath', _tag);\n        return FontConstants.defaultFontFamily;\n      }\n\n      // Read font file bytes\n      final Uint8List fontBytes = await fontFile.readAsBytes();\n      if (fontBytes.isEmpty) {\n        logErrorStatic('Font file is empty: $fontPath', _tag);\n        return FontConstants.defaultFontFamily;\n      }\n\n      // Load font using the Flutter font loader\n      final font = FontLoader(fontFamily);\n      font.addFont(Future.value(ByteData.view(fontBytes.buffer)));\n      await font.load();\n\n      // Manage cache size\n      if (_loadedFonts.length >= FontConstants.maxFontCacheSize && _fontUsageQueue.isNotEmpty) {\n        final int oldestPage = _fontUsageQueue.removeLast();\n        _loadedFonts.remove(oldestPage);\n      }\n\n      // Add to cache\n      _loadedFonts[pageNumber] = fontFamily;\n      _fontUsageQueue.insert(0, pageNumber);\n\n      logInfoStatic('Successfully loaded font for page $pageNumber', _tag);\n      return fontFamily;\n    } catch (e, s) {\n      logErrorStatic('Error loading font for page $pageNumber: $e\\n$s', _tag);\n      return FontConstants.defaultFontFamily;\n    }\n  }\n\n  // Preload fonts for upcoming pages\n  Future<void> preloadFonts(int currentPage, int totalPages, String fontDir) async {\n    // Preload next N fonts\n    for (int i = 1; i <= FontConstants.fontsToPreload; i++) {\n      final int pageToLoad = currentPage + i;\n      if (pageToLoad <= totalPages && !_loadedFonts.containsKey(pageToLoad)) {\n        final bool exists = await fontExists(pageToLoad, fontDir);\n        if (exists) {\n          // Load in background with lower priority\n          unawaited(_loadFontInBackground(pageToLoad, fontDir));\n        }\n      }\n    }\n\n    // Optionally preload previous pages as well\n    for (int i = 1; i <= FontConstants.fontsToPreload; i++) {\n      final int pageToLoad = currentPage - i;\n      if (pageToLoad > 0 && !_loadedFonts.containsKey(pageToLoad)) {\n        final bool exists = await fontExists(pageToLoad, fontDir);\n        if (exists) {\n          // Load in background with lower priority\n          unawaited(_loadFontInBackground(pageToLoad, fontDir));\n        }\n      }\n    }\n  }\n\n  // Helper to load a font in the background\n  Future<void> _loadFontInBackground(int pageNumber, String fontDir) async {\n    try {\n      final String fontFamily = FontConstants.getFontFamilyForPage(pageNumber);\n      final String fontPath = getFontPath(pageNumber, fontDir);\n\n      // Read font file bytes\n      final File fontFile = File(fontPath);\n      final Uint8List fontBytes = await fontFile.readAsBytes();\n\n      // Load font\n      final font = FontLoader(fontFamily);\n      font.addFont(Future.value(ByteData.view(fontBytes.buffer)));\n      await font.load();\n\n      // Manage cache size\n      if (_loadedFonts.length >= FontConstants.maxFontCacheSize && _fontUsageQueue.isNotEmpty) {\n        final int oldestPage = _fontUsageQueue.removeLast();\n        _loadedFonts.remove(oldestPage);\n      }\n\n      // Add to cache\n      _loadedFonts[pageNumber] = fontFamily;\n      _fontUsageQueue.add(pageNumber); // Add to end since it's preloaded\n    } catch (e) {\n      logErrorStatic('Error preloading font for page $pageNumber: $e', _tag);\n    }\n  }\n\n  // Clear all loaded fonts from cache\n  void clearFontCache() {\n    _loadedFonts.clear();\n    _fontUsageQueue.clear();\n  }\n}\n\n// Helper extension to mark futures as unawaited\nvoid unawaited(Future<void> future) {\n  // Explicitly handle errors so they don't get lost\n  future.catchError((error, stackTrace) {\n    logErrorStatic('Unawaited future error: $error\\n$stackTrace', 'unawaited');\n  });\n}"}, {"structure_type": "function", "name": "BaseUiState>", "docstring": "", "module": "utility", "file_path": "core/utility/ui_helper.dart", "file_name": "ui_helper.dart", "line": 18, "line_from": 18, "line_to": 142, "snippet": "  static Future<void> onMessage<T extends BaseUiState>(\n    Obs<T> uiStateStream,\n  ) async {\n    StreamSubscription<T>? subscription;\n    await doOnPageLoaded(() {\n      try {\n        subscription = uiStateStream.listen(\n          (uiState) => showMessage(message: uiState.userMessage),\n          onDone: () => subscription?.cancel(),\n          onError: (e) => subscription?.cancel(),\n          cancelOnError: true,\n        );\n      } catch (e) {\n        logErrorStatic(e, _fileName);\n        subscription?.cancel();\n        subscription = null;\n      }\n    });\n  }\n\n  static bool onScrollNotification({\n    required ScrollNotification scrollNotification,\n    required void Function({required bool toTop}) onScrolled,\n  }) {\n    if (scrollNotification is! ScrollUpdateNotification) return false;\n    final bool reachedAtTop = scrollNotification.metrics.pixels == 0;\n    onScrolled(toTop: reachedAtTop);\n    return false;\n  }\n\n  static Future<void> doOnPageLoaded(void Function() onLoaded) async {\n    // Takes a callback function onLoaded as a parameter. When called, this\n    // method schedules the onLoaded callback to be executed after the current\n    // frame has finished rendering, by adding it to the end of the post-frame\n    // callbacks list using WidgetsBinding.instance.addPostFrameCallback.\n    //\n    // To add a slight delay to the execution of the onLoaded callback, the\n    // method also uses Future.delayed to wait for 64 milliseconds before\n    // invoking the callback. The entire method is wrapped in a\n    // catchFutureOrVoid function which catches any exceptions thrown during the\n    // execution of the callback and handles them appropriately.\n    await catchFutureOrVoid(() async {\n      WidgetsBinding.instance.addPostFrameCallback((timeStamp) async {\n        onLoaded();\n      });\n    });\n  }\n\n  static void doOnPageDestroy(VoidCallback onDestroy) {\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      onDestroy();\n    });\n  }\n\n  static Future<void> toggleFullScreen({required bool makeFullScreen}) async {\n    await catchFutureOrVoid(() async {\n      await SystemChrome.setEnabledSystemUIMode(\n        SystemUiMode.manual,\n        overlays: makeFullScreen ? [] : SystemUiOverlay.values,\n      );\n    });\n  }\n\n  /// Listens to the scroll events and triggers the provided callback function when scrolled.\n  ///\n  /// The [scrollController] is an instance of [ItemScrollController] that controls the scrolling behavior.\n  /// The [onScrolled] is a callback function that takes a boolean parameter [toTop] indicating whether the scroll is towards the top or not.\n  ///\n  /// Example usage:\n  /// ```dart\n  /// await UiHelper.listenToScroll(\n  ///   scrollController: myScrollController,\n  ///   onScrolled: ({required bool toTop}) {\n  ///     // Handle scroll event\n  ///   },\n  /// );\n  /// ```\n  static Future<void> listenToScroll({\n    required ItemScrollController scrollController,\n    required void Function({required bool toTop}) onScrolled,\n  }) async {\n    await UiHelper.doOnPageLoaded(() async {\n      onScrolled(toTop: false);\n\n      if (!scrollController.isAttached) return;\n      final ScrollController? rootScrollController =\n          scrollController.scrollController;\n      if (rootScrollController == null) return;\n      if (!rootScrollController.hasClients) return;\n\n      rootScrollController.addListener(() {\n        Throttle.throttle(\n          _onListScrollingToTopThrottleTag,\n          480.inMilliseconds,\n          () {\n            final bool scrollingFromBottomToTop =\n                rootScrollController.position.userScrollDirection.name ==\n                    'reverse';\n            onScrolled(toTop: scrollingFromBottomToTop);\n          },\n        );\n      });\n    });\n  }\n\n  static const String _onListScrollingToTopThrottleTag =\n      'onListScrollingToTopThrottleTag';\n}\n\nclass UpgradeAppDialogContainer extends StatelessWidget {\n  const UpgradeAppDialogContainer({\n    super.key,\n    required this.child,\n  });\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    return UpgradeAlert(\n      upgrader: Upgrader(),\n      child: child,\n    );\n  }\n}"}, {"structure_type": "function", "name": "logError", "docstring": "Logs an error message with the provided [exception].\n\nIf [showLog] is false, nothing will be logged.\n\nExample usage:\n\n```dart\n\nfinal error = Exception('Something went wrong');\nthis.logError();\n\n[MyClass] [ERROR] - 2023-04-08 11:30:00\nException: Something went wrong\n#0 main (file:///path/to/main.dart:10:11)\n\n```\n", "module": "utility", "file_path": "core/utility/logger_utility.dart", "file_name": "logger_utility.dart", "line": 122, "line_from": 122, "line_to": 171, "snippet": "  void logError(Object? exception) {\n    // to avoid runtimeType.toString() in release mode\n    // as this can hamper performance, we use showLog\n    // to check if we are in debug mode or not\n    if (!showLog) return;\n    // we are logging only in debug mode, so the performance hit can be ignored\n    // ignore: no_runtimeType_toString\n    logErrorStatic(exception, runtimeType.toString());\n  }\n\n  /// Logs a debug message with the provided [object].\n  ///\n  /// If [showLog] is false, nothing will be logged.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  ///\n  /// this.logDebug('This is a debug message');\n  ///\n  /// [MyClass] [DEBUG] - 2023-04-08 11:30:00\n  /// This is a debug message\n  ///\n  /// ```\n  ///\n  void logDebug(Object object) {\n    // to avoid runtimeType.toString() in release mode\n    // as this can hamper performance, we use showLog\n    // to check if we are in debug mode or not\n    if (!showLog) return;\n    // we are logging only in debug mode, so the performance hit can be ignored\n    // ignore: no_runtimeType_toString\n    logDebugStatic(object, runtimeType.toString());\n  }\n}\n\n/// A utility class for logging messages\nclass Logger {\n  static void info(String message, [String tag = '']) {\n    logInfoStatic(message, tag);\n  }\n\n  static void error(String message, [String tag = '']) {\n    logErrorStatic(message, tag);\n  }\n\n  static void debug(String message, [String tag = '']) {\n    logDebugStatic(message, tag);\n  }\n}"}, {"structure_type": "function", "name": "navigatorPush<T>", "docstring": "", "module": "utility", "file_path": "core/utility/utility.dart", "file_name": "utility.dart", "line": 43, "line_from": 43, "line_to": 155, "snippet": "  Future<T?> navigatorPush<T>(Widget page) async {\n    try {\n      if (!mounted) return null;\n      final CupertinoPageRoute<T> route = CupertinoPageRoute<T>(builder: (context) => page);\n      return Navigator.push<T>(this, route);\n    } catch (e) {\n      logError(\"Failed to navigate to ${e.runtimeType} -> $e\");\n      return null;\n    }\n  }\n\n  // Generic navigation method with custom transition\n  void customNavigatorPush(BuildContext context, Widget nextPage) {\n    Navigator.push(\n      context,\n      PageRouteBuilder(\n        transitionDuration: const Duration(milliseconds: 500),\n        pageBuilder: (context, animation, secondaryAnimation) => nextPage,\n        transitionsBuilder: (context, animation, secondaryAnimation, child) {\n          Offset begin = const Offset(0.0, 1.0);\n          Offset end = Offset.zero;\n          Tween<Offset> tween = Tween(begin: begin, end: end);\n          Animation<Offset> offsetAnimation = animation.drive(tween);\n\n          return SlideTransition(\n            position: offsetAnimation,\n            child: child,\n          );\n        },\n      ),\n    );\n  }\n\n  Future<T?> navigatorPushReplacement<T>(Widget page) async {\n    try {\n      if (!mounted) return null;\n      final CupertinoPageRoute<T> route = CupertinoPageRoute<T>(builder: (context) => page);\n      return Navigator.pushReplacement(this, route);\n    } catch (e) {\n      logError(\"Failed to navigate to ${e.runtimeType} -> $e\");\n      return null;\n    }\n  }\n\n  Future<T?> showBottomSheetLegacy<T>(Widget bottomSheet) async {\n    return Get.bottomSheet<T>(\n      bottomSheet,\n      isScrollControlled: true,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n    );\n  }\n\n  Future<T?> showBottomSheet<T>(\n    Widget bottomSheet,\n    BuildContext context,\n  ) async {\n    if (!mounted) return null;\n    final T? result = await showModalBottomSheet<T>(\n      context: context,\n      builder: (_) => bottomSheet,\n      backgroundColor: Colors.transparent,\n      isScrollControlled: true,\n      enableDrag: true,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n    );\n    return result;\n  }\n\n  void navigatorPop<T>({T? result}) {\n    if (!mounted) return;\n    Navigator.pop(this, result);\n  }\n}\n\nFuture<T?> showSlideDownDialog<T>({\n  required Widget content,\n  required BuildContext context,\n  bool barrierDismissible = true,\n  Duration transitionDuration = const Duration(milliseconds: 300),\n  Color? barrierColor,\n}) async {\n  if (!context.mounted) return null;\n\n  final T? result = await showGeneralDialog<T>(\n    context: context,\n    barrierDismissible: barrierDismissible,\n    barrierColor: barrierColor ?? Colors.black.withOpacityInt(0.4),\n    barrierLabel: '',\n    transitionDuration: transitionDuration,\n    transitionBuilder: (context, animation, __, Widget child) {\n      return SlideTransition(\n        position: Tween<Offset>(\n          begin: const Offset(0, -1), // Top to bottom\n          end: Offset.zero,\n        ).animate(animation),\n        child: child,\n      );\n    },\n    pageBuilder: (context, animation, __) => content,\n  );\n\n  return result;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "utility", "file_path": "core/utility/utility.dart", "file_name": "utility.dart", "line": 1238, "line_from": 1238, "line_to": 1266, "snippet": "  required void Function(String) onError,\n}) async {\n  try {\n    if (!await file.exists()) {\n      onError(\"Downloaded file is incomplete. Please try again.\");\n      return false;\n    }\n\n    // Try to read the first few bytes to verify file integrity\n    try {\n      await file.openRead(0, 1024).first;\n      return true;\n    } catch (e) {\n      logErrorStatic(\"Error validating file integrity: $e\", \"FileValidation\");\n      await file.delete();\n      if (context?.mounted ?? false) {\n        onError(\"Downloaded file is corrupted. Please try again.\");\n      }\n      return false;\n    }\n  } catch (e) {\n    logErrorStatic(\"Error validating downloaded file: $e\", \"FileValidation\");\n    await file.delete();\n    if (context?.mounted ?? false) {\n      onError(\"Failed to validate downloaded file. Please try again.\");\n    }\n    return false;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "nuzul", "file_path": "data/repository/nuzul/nuzul_repository_impl.dart", "file_name": "nuzul_repository_impl.dart", "line": 78, "line_from": 78, "line_to": 95, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _remoteDataSource.downloadResourceDatabase(\n        fileName: _nuzulDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Nuzul database download was cancelled', 'NuzulRepositoryImpl');\n        rethrow;\n      }\n      logErrorStatic('Error downloading nuzul database: $e', 'NuzulRepositoryImpl');\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "getAllPages", "docstring": "", "module": "page", "file_path": "data/repository/page/page_repository_impl.dart", "file_name": "page_repository_impl.dart", "line": 14, "line_from": 14, "line_to": 37, "snippet": "  Future<Either<String, List<PageEntity>>> getAllPages() async {\n    try {\n      final pages = await _localDataSource.getAllPages();\n      final mappedPages = await compute(_mapToEntities, pages);\n      return Right(mappedPages);\n    } catch (e) {\n      return Left(e.toString());\n    }\n  }\n}\n\n// Compute function for mapping PageTableData to PageEntity\nList<PageEntity> _mapToEntities(List<PageTableData> tableData) {\n  return tableData\n      .map((page) => PageEntity(\n            id: page.id,\n            startSurahNo: page.startSurahNo,\n            endSurahNo: page.endSurahNo,\n            startAyatNo: page.startAyatNo,\n            endAyatNo: page.endAyatNo,\n            arabicInitial: page.arabicInitial,\n          ))\n      .toList();\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "grammar", "file_path": "data/repository/grammar/grammar_repository_impl.dart", "file_name": "grammar_repository_impl.dart", "line": 45, "line_from": 45, "line_to": 62, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _remoteDataSource.downloadResourceDatabase(\n        fileName: _grammarDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Grammar database download was cancelled', _tag);\n        rethrow;\n      }\n      logErrorStatic('Error downloading grammar database: $e', _tag);\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation", "file_path": "data/repository/translation/translation_repository_impl.dart", "file_name": "translation_repository_impl.dart", "line": 24, "line_from": 24, "line_to": 38, "snippet": "    required void Function(int percentage) onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await remoteDataSource.downloadDatabase(\n        fileName: fileName,\n        url: downloadLink,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) return;\n      logErrorStatic(\"Error downloading file: $e\", \"TranslationRepositoryImpl\");\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation", "file_path": "data/repository/translation/translation_repository_impl.dart", "file_name": "translation_repository_impl.dart", "line": 43, "line_from": 43, "line_to": 58, "snippet": "    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final dbFile = File(await getDatabaseFilePath(file.fileName));\n\n    if (!await dbFile.exists()) {\n      await _downloadDatabaseFile(\n        fileName: file.fileName,\n        downloadLink: file.link,\n        onProgress: onProgress!,\n        cancelToken: cancelToken,\n      );\n    } else {\n      await selectTranslation(file: file);\n    }\n  }"}, {"structure_type": "function", "name": "searchAcrossTranslations", "docstring": "", "module": "search", "file_path": "data/repository/search/search_repository_impl.dart", "file_name": "search_repository_impl.dart", "line": 27, "line_from": 27, "line_to": 380, "snippet": "  Future<List<SearchResultEntity>> searchAcrossTranslations({\n    required String query,\n    required List<String> databaseFiles,\n    required SearchTypeEntity searchType,\n  }) async {\n    final Map<String, List<Verse>> results = {};\n\n    for (String dbFile in databaseFiles) {\n      if (['bn_bayaan', 'en_sahih'].contains(dbFile)) {\n        try {\n          final List<Verse> verses = await _searchLocalDataSource.searchTranslation(\n            query: query,\n            language: dbFile == 'bn_bayaan' ? 'bn' : 'en',\n            searchType: searchType,\n          );\n          results[dbFile] = verses;\n        } catch (e) {\n          logDebugStatic('Error searching in $dbFile: $e', 'SearchRepositoryImpl');\n          continue;\n        }\n      } else {\n        final database = TranslationDatabase(File(await getDatabaseFilePath(dbFile)));\n        try {\n          final List<Verse> verses = await database.searchVerses(\n            query: query,\n            searchType: searchType,\n          );\n          results[dbFile] = verses;\n        } finally {\n          await database.close();\n        }\n      }\n    }\n\n    return _processResults(results);\n  }\n\n  List<SearchResultEntity> _processResults(Map<String, List<Verse>> results) {\n    final Map<String, Map<String, String>> groupedResults = {};\n\n    results.forEach((String dbFile, List<Verse> verses) {\n      for (Verse verse in verses) {\n        final String key = '${verse.suraId}-${verse.ayahId}';\n        groupedResults.putIfAbsent(key, () => {});\n        if (verse.verseText != null) {\n          groupedResults[key]![dbFile] = verse.verseText!;\n        }\n      }\n    });\n\n    return groupedResults.entries.map((MapEntry<String, Map<String, String>> entry) {\n      final List<String> parts = entry.key.split('-');\n      return SearchResultEntity(\n        surahId: int.parse(parts[0]),\n        ayahId: int.parse(parts[1]),\n        resultText: entry.value,\n      );\n    }).toList();\n  }\n\n  @override\n  Future<List<SearchResultEntity>> searchAcrossTafseers({\n    required String query,\n    required List<String> databaseFiles,\n    required SearchTypeEntity searchType,\n  }) async {\n    final Map<String, List<Map<String, dynamic>>> results = {};\n\n    await Future.wait(databaseFiles.map((dbFile) async {\n      final mainFile = File(await getDatabaseFilePath(dbFile));\n      if (!await mainFile.exists()) {\n        const String assetPath = \"assets/database\";\n        final String dbPath = \"$assetPath/$dbFile.db\";\n        await moveDatabaseFromAssetToInternal(file: mainFile, assetPath: dbPath);\n      }\n      final database = TafseerDatabase(mainFile);\n      try {\n        final TafseerType tafseerType = determineTafseerType(dbFile);\n        switch (tafseerType) {\n          case TafseerType.common:\n            final List<CommonTafseerTableData> tafseer = await database.searchTafsirTextFromCommonTafseerTable(\n              query: query,\n              searchType: searchType,\n            );\n            if (tafseer.isNotEmpty) {\n              results[dbFile] = tafseer.map((t) => t.toJson()).toList();\n            }\n            break;\n          case TafseerType.unique:\n            final List<UniqueTafseerTableData> tafseer = await database.searchTafsirTextFromUniqueTafseerTable(\n              query: query,\n              searchType: searchType,\n            );\n            if (tafseer.isNotEmpty) {\n              results[dbFile] = tafseer.map((t) => t.toJson()).toList();\n            }\n            break;\n        }\n      } finally {\n        await database.close();\n      }\n    }));\n\n    return _processTafseerResults(results, query, searchType);\n  }\n\n  List<SearchResultEntity> _processTafseerResults(\n      Map<String, List<Map<String, dynamic>>> results, String query, SearchTypeEntity searchType) {\n    final Map<String, Map<String, String>> mergedAyahTexts = {};\n\n    for (final MapEntry<String, List<Map<String, dynamic>>> entry in results.entries) {\n      final String dbFile = entry.key;\n      final List<Map<String, dynamic>> tafseer = entry.value;\n\n      for (final Map<String, dynamic> tafsir in tafseer) {\n        final String tafsirText = tafsir['tafsirText'] as String? ?? '';\n        bool shouldInclude = false;\n\n        if (searchType == SearchTypeEntity.exact) {\n          shouldInclude = tafsirText.toLowerCase().contains(query.toLowerCase());\n        } else if (searchType == SearchTypeEntity.normal) {\n          final words = query.split(' ');\n          final validWords = words.where((word) => word.trim().isNotEmpty).toList();\n          if (validWords.isNotEmpty) {\n            shouldInclude = validWords.every(\n              (word) => tafsirText.toLowerCase().contains(word.toLowerCase()),\n            );\n          } else {\n            shouldInclude = tafsirText.isNotEmpty;\n          }\n        } else if (searchType == SearchTypeEntity.partial) {\n          final words = query.split(' ');\n          final validWords = words.where((word) => word.trim().isNotEmpty).toList();\n          if (validWords.isNotEmpty) {\n            shouldInclude = validWords.any(\n              (word) => tafsirText.toLowerCase().contains(word.toLowerCase()),\n            );\n          } else {\n            shouldInclude = tafsirText.isNotEmpty;\n          }\n        }\n\n        if (shouldInclude) {\n          if (tafsir.containsKey('suraId') && tafsir.containsKey('ayahId')) {\n            _processCommonTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n          } else {\n            _processUniqueTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n          }\n        }\n      }\n    }\n\n    return mergedAyahTexts.entries.map((MapEntry<String, Map<String, String>> entry) {\n      final List<String> parts = entry.key.split('_');\n      return SearchResultEntity(\n        surahId: int.parse(parts[0]),\n        ayahId: int.parse(parts[1]),\n        resultText: entry.value,\n      );\n    }).toList();\n  }\n\n  List<SearchResultEntity> mergeResults(Map<String, List<Verse>> results) {\n    final Map<String, SearchResultEntity> mergedResults = {};\n\n    for (final MapEntry<String, List<Verse>> entry in results.entries) {\n      final String dbFile = entry.key;\n      final List<Verse> verses = entry.value;\n\n      for (final Verse verse in verses) {\n        final String key = '${verse.suraId}_${verse.ayahId}';\n\n        if (mergedResults.containsKey(key)) {\n          mergedResults[key]!.resultText[dbFile] = verse.verseText ?? '';\n        } else {\n          mergedResults[key] = SearchResultEntity(\n            surahId: verse.suraId!,\n            ayahId: verse.ayahId!,\n            resultText: {dbFile: verse.verseText ?? ''},\n          );\n        }\n      }\n    }\n\n    return mergedResults.values.toList();\n  }\n\n  List<SearchResultEntity> mergeTafseerResults(Map<String, dynamic> params) {\n    final Map<String, List<Map<String, dynamic>>> results =\n        params['results'] as Map<String, List<Map<String, dynamic>>>;\n    final String query = params['query'] as String;\n\n    final Map<String, Map<String, String>> mergedAyahTexts = {};\n\n    for (final MapEntry<String, List<Map<String, dynamic>>> entry in results.entries) {\n      final String dbFile = entry.key;\n      final List<Map<String, dynamic>> tafseer = entry.value;\n\n      for (final Map<String, dynamic> tafsir in tafseer) {\n        if (tafsir.containsKey('suraId') && tafsir.containsKey('ayahId')) {\n          _processCommonTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n        } else {\n          _processUniqueTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n        }\n      }\n    }\n\n    return mergedAyahTexts.entries.map((MapEntry<String, Map<String, String>> entry) {\n      final List<String> parts = entry.key.split('_');\n      return SearchResultEntity(\n        surahId: int.parse(parts[0]),\n        ayahId: int.parse(parts[1]),\n        resultText: entry.value,\n      );\n    }).toList();\n  }\n\n  void _processCommonTafseerJson(\n    Map<String, dynamic> tafsir,\n    String dbFile,\n    Map<String, Map<String, String>> mergedAyahTexts,\n    String query,\n  ) {\n    final String key = '${tafsir['suraId']}_${tafsir['ayahId']}';\n    mergedAyahTexts.putIfAbsent(key, () => {});\n\n    final String truncatedText = _getTruncatedTafseerText(\n      text: tafsir['tafsirText'] ?? '',\n      query: query,\n    );\n\n    final String tafseerName = _getTafseerName(dbFile);\n    mergedAyahTexts[key]![tafseerName] = truncatedText;\n  }\n\n  void _processUniqueTafseerJson(\n    Map<String, dynamic> tafsir,\n    String dbFile,\n    Map<String, Map<String, String>> mergedAyahTexts,\n    String query,\n  ) {\n    final int startAyah = tafsir['start'] ?? 1;\n    final int endAyah = tafsir['end'] ?? startAyah;\n    final int suraId = tafsir['suraId'] ?? 1;\n\n    for (int ayahId = startAyah; ayahId <= endAyah; ayahId++) {\n      final String key = '${suraId}_$ayahId';\n      mergedAyahTexts.putIfAbsent(key, () => {});\n\n      final String truncatedText = _getTruncatedTafseerText(\n        text: tafsir['tafsirText'] ?? '',\n        query: query,\n      );\n\n      mergedAyahTexts[key]![dbFile] = truncatedText;\n    }\n  }\n\n  String _getTruncatedTafseerText({\n    required String text,\n    required String query,\n  }) {\n    final int matchIndex = text.toLowerCase().indexOf(query.toLowerCase());\n    if (matchIndex == -1) return text;\n\n    int startIndex = (matchIndex - 100).clamp(0, text.length);\n    int endIndex = (matchIndex + query.length + 100).clamp(0, text.length);\n\n    // Adjust start index to include complete word\n    while (startIndex > 0 && text[startIndex] != ' ') {\n      startIndex--;\n    }\n\n    // Adjust end index to include complete word\n    while (endIndex < text.length && text[endIndex] != ' ') {\n      endIndex++;\n    }\n\n    final String prefix = startIndex > 0 ? '...' : '';\n    final String suffix = endIndex < text.length ? '...' : '';\n\n    return prefix + text.substring(startIndex, endIndex).trim() + suffix;\n  }\n\n  @override\n  Future<List<SearchResultEntity>> searchArabic({\n    required String query,\n    required SearchTypeEntity searchType,\n  }) async {\n    final String normalizedQuery = ArabicTextHighlighter.normalizeArabicString(query);\n    final List<AyahDatabaseTableData> results = await _quranDatabase.searchArabicText(\n      query: normalizedQuery,\n      searchType: searchType,\n    );\n\n    // Process results and get Arabic text for each result\n    final List<SearchResultEntity> searchResults = [];\n    for (final result in results) {\n      final arabicText = await _getArabicTextForSearch(result.surahId as int, result.ayahId as int);\n      searchResults.add(SearchResultEntity(\n        surahId: result.surahId as int,\n        ayahId: result.ayahId as int,\n        resultText: {'arabic': arabicText},\n      ));\n    }\n\n    return searchResults;\n  }\n\n  // Helper method to get Arabic text for search result\n  Future<String> _getArabicTextForSearch(int surahId, int ayahId) async {\n    final wordDbData = await _quranDatabase.getWordsByWordForSpecificAyah(surahId, ayahId);\n\n    // Convert to WordByWordEntity\n    final List<WordByWordEntity> words = wordDbData\n        .map((dbData) => WordByWordEntity(\n              surah: dbData.surah,\n              ayah: dbData.ayah,\n              word: dbData.word,\n              uthmani: dbData.uthmani,\n              indopak: dbData.indopak,\n              en: dbData.en,\n              bn: dbData.bn,\n              clean: dbData.clean,\n              juz: dbData.juz,\n              page: dbData.page,\n              hijb: dbData.hijb,\n              summary: dbData.summary,\n            ))\n        .toList();\n\n    if (words.isEmpty) return '';\n\n    // Get the script from settings (default to uthmani if not available)\n    const isUthmani = true; // Default to uthmani for search\n    return AyahEntity.getArabicTextFromWords(words, isUthmani);\n  }\n\n  // Cache for tafseer name mappings\n  static final Map<String, String> _tafseerNameCache = {};\n\n  String _getTafseerName(String fileName) {\n    // Return cached name if available\n    if (_tafseerNameCache.containsKey(fileName)) {\n      return _tafseerNameCache[fileName]!;\n    }\n\n    // Look up name and cache it\n    final String? name = locate<TafseerPresenter>().getNameOfTafseerFromFileName(fileName: fileName);\n\n    _tafseerNameCache[fileName] = name!;\n    return name;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "info", "file_path": "data/repository/info/info_repository_impl.dart", "file_name": "info_repository_impl.dart", "line": 34, "line_from": 34, "line_to": 51, "snippet": "    required void Function(PromotionalMessageEntity?) onMessage,\n  }) async {\n    await _infoRemoteDataSource.getPromotionalMessage(\n      onMessage: (promotionalMessage) async {\n        final bool shouldPublish = await _infoLocalDataSource.shouldPublishPromotionalMessage(\n          notification: promotionalMessage,\n        );\n\n        if (!shouldPublish) {\n          onMessage(null);\n          return;\n        }\n\n        _notification = promotionalMessage;\n        onMessage(promotionalMessage);\n      },\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "info", "file_path": "data/repository/info/info_repository_impl.dart", "file_name": "info_repository_impl.dart", "line": 143, "line_from": 143, "line_to": 160, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _resourceRemoteDataSource.downloadResourceDatabase(\n        fileName: _infoDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Info database download was cancelled', 'InfoRepositoryImpl');\n        rethrow;\n      }\n      logErrorStatic('Error downloading info database: $e', 'InfoRepositoryImpl');\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "downloadAudioFiles", "docstring": "", "module": "audio", "file_path": "data/repository/audio/audio_repository_impl.dart", "file_name": "audio_repository_impl.dart", "line": 26, "line_from": 26, "line_to": 234, "snippet": "  Future<void> downloadAudioFiles({\n    required int surahID,\n    required Reciter reciter,\n    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    if (cancelToken.isCancelled) return;\n\n    try {\n      final String audioFile = CacheData.audioFiles[surahID]!.audioLink;\n      await _downloadSurahAudio(audioFile, surahID, reciter, onProgress, cancelToken);\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        await _audioLocalDataSource.removeAudioFileFromCache(surahID, ReciterMapper.toDatabase(reciter));\n      }\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> persistSurahAudioPath({\n    required List<int> surahs,\n    required Reciter reciter,\n  }) async {\n    String directoryPath = await getApplicationDirectoryPath();\n\n    for (int surah in surahs) {\n      final String generatedPath = await generateAudioFilePath(surah: surah, reciter: reciter);\n      final String savePath = p.join(directoryPath, generatedPath);\n      await _audioLocalDataSource.persistSurahAudioPath(surah, ReciterMapper.toDatabase(reciter), savePath);\n    }\n  }\n\n  @override\n  Future<AudioFile> getAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  }) async {\n    return await _audioLocalDataSource.getAudioFilesBySurahAndReciter(surahNumber, ReciterMapper.toDatabase(reciter));\n  }\n\n  Future<void> _downloadSurahAudio(\n    String url,\n    int surah,\n    Reciter reciter,\n    void Function(int percentage)? onProgress,\n    CancelToken? cancelToken,\n  ) async {\n    if (cancelToken?.isCancelled ?? false) return;\n\n    try {\n      String filePath = await generateAudioFilePath(surah: surah, reciter: reciter);\n      await _audioRemoteDataSource.fetchAndDownloadAudio(\n        url: url,\n        filePath: filePath,\n        onProgress: onProgress!,\n        cancelToken: cancelToken,\n      );\n      if (!(cancelToken?.isCancelled ?? false)) {\n        await _audioLocalDataSource.persistSurahAudioPath(surah, ReciterMapper.toDatabase(reciter), filePath);\n      }\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        await _audioLocalDataSource.removeAudioFileFromCache(surah, ReciterMapper.toDatabase(reciter));\n      }\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> deleteAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  }) async {\n    final String audioPath = await generateAudioFilePath(surah: surahNumber, reciter: reciter);\n    await _audioLocalDataSource.deleteAudioFilesBySurahAndReciter(\n        surahNumber, ReciterMapper.toDatabase(reciter), audioPath);\n  }\n\n  @override\n  Future<String> generateAudioFilePath({required int surah, required Reciter reciter}) async {\n    String directoryPath = p.join('audio', reciter.name);\n    return p.join(directoryPath, '$surah.mp3');\n  }\n\n  @override\n  Future<String> getAudioPath({required int surah, required Reciter reciter, bool isOnlineStream = false}) async {\n    if (isOnlineStream) {\n      final AudioFile audioFile = CacheData.audioFiles[surah]!;\n      return audioFile.audioLink;\n    }\n    return await _audioLocalDataSource.fetchLocalAudioPath(surah, ReciterMapper.toDatabase(reciter));\n  }\n\n  @override\n  Future<bool> isSurahAudioAvailable({required int surahNumber, required Reciter reciter}) =>\n      _audioLocalDataSource.checkIfSurahAudioDownloaded(surahNumber, ReciterMapper.toDatabase(reciter));\n\n  @override\n  Future<List<VerseTiming>> getVerseTimings({\n    required int surahID,\n    required int reciterID,\n  }) async {\n    try {\n      List<VerseTiming> verseTimings = await _audioLocalDataSource.getVerseTimingsBySurahId(reciterID, surahID);\n      return verseTimings;\n    } catch (e) {\n      logErrorStatic('Error in getVerseTimings: $e', 'AudioRepositoryImpl');\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> playVerseWithDelay(VerseTiming verseTiming, Duration delay) async {\n    try {\n      await AudioPlayerService.playVerseAfterDelay(verseTiming, delay);\n    } catch (e) {\n      logErrorStatic('Error in playVerseWithDelay: $e', 'AudioRepositoryImpl');\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> playSurahPlaylist() async {\n    await AudioPlayerService.startPlaylistPlayback();\n  }\n\n  @override\n  Future<void> seekAudio(Duration position) async {\n    await AudioPlayerService.seekAudioPosition(position);\n  }\n\n  @override\n  Future<void> addToPlayl1ist({\n    required String audioPath,\n    required String title,\n    bool isOnlineStream = false,\n  }) async {\n    await AudioPlayerService.enqueueAudioToPlaylist(\n      audioPath: audioPath,\n      title: title,\n      isOnlineStream: isOnlineStream,\n    );\n  }\n\n  @override\n  Future<void> clearPlaylist() async {\n    await AudioPlayerService.clearPlaylist();\n  }\n\n  @override\n  Future<void> stopAudio() async {\n    await AudioPlayerService.stopPlayback();\n  }\n\n  @override\n  Future<void> pausePlayback() async {\n    await AudioPlayerService.pausePlayback();\n  }\n\n  @override\n  Future<void> resumePlayback() async {\n    await AudioPlayerService.resumePlayback();\n  }\n\n  @override\n  Future<void> playWordAudio({required WordByWordEntity word}) async {\n    try {\n      if (word.surah == null || word.ayah == null || word.word == null) return;\n\n      final String surahFormatted = word.surah.toString().padLeft(3, '0');\n      final String ayahFormatted = word.ayah.toString().padLeft(3, '0');\n      final String wordFormatted = word.word.toString().padLeft(3, '0');\n\n      final String audioUrl = 'https://verses.quran.com/wbw/${surahFormatted}_${ayahFormatted}_$wordFormatted.mp3';\n\n      await AudioPlayerService.stopPlayback();\n\n      final player = AudioPlayer();\n      try {\n        await player.setAudioSource(\n          AudioSource.uri(\n            Uri.parse(audioUrl),\n            tag: MediaItem(\n              id: audioUrl,\n              title: 'Word Audio',\n              album: 'Quran Majeed',\n            ),\n          ),\n        );\n\n        await player.play();\n\n        player.playerStateStream.listen((state) {\n          if (state.processingState == ProcessingState.completed) {\n            player.dispose();\n          }\n        });\n      } catch (e) {\n        await player.dispose();\n        logErrorStatic('Error playing word audio: $e', 'AudioRepositoryImpl');\n        rethrow;\n      }\n    } catch (e) {\n      logErrorStatic('Error in audio playback: $e', 'AudioRepositoryImpl');\n      rethrow;\n    }\n  }\n}"}, {"structure_type": "function", "name": "getSelectedTafseers", "docstring": "", "module": "tafseer", "file_path": "data/repository/tafseer/tafseer_repository_impl.dart", "file_name": "tafseer_repository_impl.dart", "line": 30, "line_from": 30, "line_to": 241, "snippet": "  Future<Set<String>> getSelectedTafseers() async {\n    final selectedTafseersSerialised = localCacheService.getData(key: CacheKeys.selectedTafseer);\n    if (selectedTafseersSerialised == null) return {};\n    final Set<String> selectedTafseers = Set<String>.from(jsonDecode(selectedTafseersSerialised));\n\n    // Check if the default tafseer should be included\n    final bool includeDefault = localCacheService.getData(key: CacheKeys.includeDefaultTafseer) ?? true;\n    if (includeDefault && !selectedTafseers.contains('en_kathir')) {\n      selectedTafseers.add('en_kathir');\n    }\n\n    return selectedTafseers;\n  }\n\n  @override\n  Future<void> saveSelectedTafseers(Set<String> selectedTafseers) async {\n    final serialisedString = jsonEncode(selectedTafseers.toList());\n    await localCacheService.saveData(key: CacheKeys.selectedTafseer, value: serialisedString);\n\n    // Update the flag for including the default tafseer\n    final bool includeDefault = selectedTafseers.contains('en_kathir');\n    await localCacheService.saveData(key: CacheKeys.includeDefaultTafseer, value: includeDefault);\n  }\n\n  @override\n  Future<void> selectTafseer({\n    required TTDbFileModel file,\n    required int surahID,\n    required TafseerType tafseerType,\n  }) async {\n    final String dbPath = await getDatabaseFilePath(file.fileName);\n    final TafseerDatabase database = TafseerDatabase(File(dbPath));\n    try {\n      switch (tafseerType) {\n        case TafseerType.common:\n          final List<CommonTafseerTableData> tafseer =\n              await tafseerLocalDataSource.getCommonTafseerData(surahID: surahID, database: database);\n          CacheData.tafseerCache[file.fileName] = await _convertCommonTafseerToMap(tafseer);\n     \n          break;\n        case TafseerType.unique:\n          final List<UniqueTafseerTableData> tafseer =\n              await tafseerLocalDataSource.getUniqueTafseerData(surahID: surahID, database: database);\n          CacheData.tafseerCache[file.fileName] = await _convertUniqueTafseerToMap(tafseer, surahID);\n        \n          break;\n      }\n    } catch (e) {\n      logErrorStatic(\"Error in selectTafseer: $e\", \"TafseerRepositoryImpl\");\n      rethrow;\n    }\n  }\n\n  Future<Map<int, Map<int, String>>> _convertCommonTafseerToMap(List<CommonTafseerTableData> tafseer) async {\n    List<Map<String, dynamic>> tafseerData = tafseer\n        .map((item) => {\n              'suraId': item.suraId,\n              'ayahId': item.ayahId,\n              'tafsirText': item.tafsirText,\n            })\n        .toList();\n    return compute(convertCommonTafseerToMapIsolate, tafseerData);\n  }\n\n  Future<Map<int, Map<int, String>>> _convertUniqueTafseerToMap(\n      List<UniqueTafseerTableData> tafseer, int surahId) async {\n    List<Map<String, dynamic>> tafseerData = tafseer\n        .map((item) => {\n              'start': item.start,\n              'end': item.end,\n              'tafsirText': item.tafsirText,\n            })\n        .toList();\n    return compute(\n      convertUniqueTafseerToMapIsolate,\n      {'tafseerData': tafseerData, 'surahId': surahId},\n    );\n  }\n\n  @override\n  List<String> getAvailableTafseers() {\n    final availableTafseersSerialised = localCacheService.getData(key: CacheKeys.availableTafseer);\n    Set<String> availableTafseers;\n\n    if (availableTafseersSerialised == null) {\n      // Initialize with empty set since there are no default tafseers\n      availableTafseers = {};\n      final String serializedString = jsonEncode([]);\n      localCacheService.saveData(key: CacheKeys.availableTafseer, value: serializedString);\n    } else {\n      availableTafseers = Set.from(_convertSerialisedStringToAvailableeTafseers(availableTafseersSerialised));\n      // No need to include default tafseers since they don't exist anymore\n    }\n\n    return availableTafseers.toList();\n  }\n\n  @override\n  Future<void> saveAvailableTafseers({required Set<String> availableTafseers, required String newItem}) async {\n    availableTafseers.add(newItem);\n    final String serialisedString = jsonEncode(availableTafseers.toList());\n    await localCacheService.saveData(key: CacheKeys.availableTafseer, value: serialisedString);\n  }\n\n  @override\n  Future<void> deleteAvailableTafseer({required TTDbFileModel file}) async {\n    final availableeTafseersSerialised = localCacheService.getData(key: CacheKeys.availableTafseer);\n    if (availableeTafseersSerialised == null) return;\n    final List<String> availableeTafseers = _convertSerialisedStringToAvailableeTafseers(availableeTafseersSerialised);\n    availableeTafseers.remove(file.fileName);\n    final String serialisedString = jsonEncode(availableeTafseers);\n    await localCacheService.saveData(key: CacheKeys.availableTafseer, value: serialisedString);\n  }\n\n  @override\n  Future<void> deleteTafseerDatabase({required String fileName}) async {\n    final dbFile = File(await getDatabaseFilePath(fileName));\n    if (await dbFile.exists()) {\n      try {\n        await dbFile.delete();\n      } catch (e) {\n        logErrorStatic(\"Error deleting database: $e\", \"TranslationRepositoryImpl\");\n        rethrow;\n      }\n    }\n  }\n\n  @override\n  Future<void> saveAvailableItemsCount(int count) async {\n    await localCacheService.saveData(key: 'available_items_count_tafseer', value: count.toString());\n  }\n\n  @override\n  Future<int> fetchAvailableItemsCount() async {\n    final countString = localCacheService.getData(key: 'available_items_count_tafseer');\n    return countString != null ? int.parse(countString) : 20; // default to 20 if not found\n  }\n\n\n  List<String> _convertSerialisedStringToAvailableeTafseers(String serialisedString) =>\n      jsonDecode(serialisedString).cast<String>();\n\n  @override\n  Future<void> getTafseer({\n    required TTDbFileModel file,\n    void Function(int percentage)? onProgress,\n    required int surahID,\n    required TafseerType tafseerType,\n    required CancelToken cancelToken,\n  }) async {\n    final File dbFile = File(await getDatabaseFilePath(file.fileName));\n    final bool exists = await dbFile.exists();\n\n    // All tafseers need to be downloaded - no more default ones\n    if (!exists && !cancelToken.isCancelled) {\n      await _downloadDatabaseFile(\n        fileName: file.fileName,\n        downloadLink: file.link,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    }\n\n    if (exists || !cancelToken.isCancelled) {\n      await selectTafseer(file: file, surahID: surahID, tafseerType: tafseerType);\n    }\n  }\n\n  Future<void> _downloadDatabaseFile({\n    required String fileName,\n    required String downloadLink,\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await remoteDataSource.downloadDatabase(\n        fileName: fileName,\n        url: downloadLink,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) return;\n      logErrorStatic(\"Error downloading database file: $e\", \"TafseerRepositoryImpl\");\n    }\n  }\n\n  @override\n  Future<void> saveSelectedTabIndex(int index) async {\n    await localCacheService.saveData(key: CacheKeys.selectedTafseerTabIndex, value: index.toString());\n  }\n\n  @override\n  Future<int> getSelectedTabIndex() async {\n    final selectedTabIndex = localCacheService.getData(key: CacheKeys.selectedTafseerTabIndex);\n    return selectedTabIndex == null ? 0 : int.parse(selectedTabIndex);\n  }\n}\n\n// For common tafseer\nMap<int, Map<int, String>> convertCommonTafseerToMapIsolate(List<Map<String, dynamic>> tafseerData) {\n  Map<int, Map<int, String>> result = {};\n  for (var item in tafseerData) {\n    int? suraId = item['suraId'];\n    int? ayahId = item['ayahId'];\n    String? tafsirText = item['tafsirText'];\n    if (suraId != null && ayahId != null) {\n      result.putIfAbsent(suraId, () => {}).putIfAbsent(ayahId, () => tafsirText ?? \"No tafseer is found for this ayah\");\n    }\n  }\n  return result;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "text_mushaf", "file_path": "data/repository/text_mushaf/text_mushaf_repository_impl.dart", "file_name": "text_mushaf_repository_impl.dart", "line": 33, "line_from": 33, "line_to": 56, "snippet": "    void Function(int received, int total)? onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    final bool dbExists = await isDatabaseAvailable();\n\n    if (!dbExists) {\n      final File dbFile = await _localDataSource.getTextMushafDatabaseFile();\n      final Directory parentDir = dbFile.parent;\n      if (!await parentDir.exists()) {\n        await parentDir.create(recursive: true);\n      }\n\n      final token = cancelToken ?? CancelToken();\n\n      await _remoteDataSource.downloadTextMushafDatabase(\n        url: _dbDownloadUrl,\n        dbFile: dbFile,\n        onProgress: onProgress,\n        cancelToken: token,\n      );\n    } else {\n      onProgress?.call(100, 100);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "text_mushaf", "file_path": "data/repository/text_mushaf/text_mushaf_repository_impl.dart", "file_name": "text_mushaf_repository_impl.dart", "line": 130, "line_from": 130, "line_to": 148, "snippet": "    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final String fontDir = await getFontDirectoryPath();\n    final String fontPath = '$fontDir/${FontConstants.getFontFileName(pageNumber)}';\n\n    final File fontFile = File(fontPath);\n    if (await fontFile.exists()) {\n      onProgress?.call(100, 100);\n      return;\n    }\n\n    await _remoteDataSource.downloadFontFile(\n      pageNumber: pageNumber,\n      savePath: fontPath,\n      onProgress: onProgress,\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "text_mushaf", "file_path": "data/repository/text_mushaf/text_mushaf_repository_impl.dart", "file_name": "text_mushaf_repository_impl.dart", "line": 153, "line_from": 153, "line_to": 170, "snippet": "    void Function(int completed, int total)? onBatchProgress,\n    void Function(int pageNumber, double progress)? onFontProgress,\n    required CancelToken cancelToken,\n  }) async {\n    if (pageNumbers.isEmpty) {\n      return;\n    }\n\n    final String fontDir = await getFontDirectoryPath();\n\n    await _remoteDataSource.downloadFontBatch(\n      pageNumbers: pageNumbers,\n      saveDir: fontDir,\n      onBatchProgress: onBatchProgress,\n      onFontProgress: onFontProgress,\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "dua", "file_path": "data/repository/dua/dua_repository_impl.dart", "file_name": "dua_repository_impl.dart", "line": 54, "line_from": 54, "line_to": 71, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _remoteDataSource.downloadResourceDatabase(\n        fileName: _duaDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Dua database download was cancelled', 'DuaRepositoryImpl');\n        rethrow;\n      }\n      logErrorStatic('Error downloading dua database: $e', 'DuaRepositoryImpl');\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "sealed_classes", "file_path": "data/sealed_classes/surah_ayah_presenter.dart", "file_name": "surah_ayah_presenter.dart", "line": 9, "line_from": 9, "line_to": 36, "snippet": "  void Function(String)? get onSurahSearchChanged;\n  TextEditingController get surahNameSearchController;\n\n  void Function(String)? get onAyahSearchChanged;\n  TextEditingController get ayahNumberSearchController;\n\n  factory SurahAyahPresenter.ayah(AyahPresenter presenter) = AyahSurahAyahPresenter;\n  factory SurahAyahPresenter.audio(AudioPresenter presenter) = AudioSurahAyahPresenter;\n  factory SurahAyahPresenter.memorization(MemorizationPresenter presenter) = MemorizationSurahAyahPresenter;\n}\n\nclass AyahSurahAyahPresenter extends SurahAyahPresenter {\n  final AyahPresenter presenter;\n\n  const AyahSurahAyahPresenter(this.presenter);\n\n  @override\n  void Function(String)? get onSurahSearchChanged => presenter.onSurahSearchChanged;\n\n  @override\n  TextEditingController get surahNameSearchController => presenter.surahNameSearchController;\n\n  @override\n  void Function(String)? get onAyahSearchChanged => presenter.onAyahSearchChanged;\n\n  @override\n  TextEditingController get ayahNumberSearchController => presenter.ayahNumberSearchController;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "sealed_classes", "file_path": "data/sealed_classes/surah_ayah_presenter.dart", "file_name": "surah_ayah_presenter.dart", "line": 43, "line_from": 43, "line_to": 70, "snippet": "  void Function(String)? get onSurahSearchChanged => presenter.onSurahSearchChanged;\n\n  @override\n  TextEditingController get surahNameSearchController => presenter.surahNameSearchController;\n\n  @override\n  void Function(String)? get onAyahSearchChanged => presenter.onAyahSearchChanged;\n\n  @override\n  TextEditingController get ayahNumberSearchController => presenter.ayahNumberSearchController;\n}\n\nclass MemorizationSurahAyahPresenter extends SurahAyahPresenter {\n  final MemorizationPresenter presenter;\n  const MemorizationSurahAyahPresenter(this.presenter);\n\n  @override\n  void Function(String)? get onSurahSearchChanged => presenter.onSurahSearchChanged;\n\n  @override\n  TextEditingController get surahNameSearchController => presenter.surahNameSearchController;\n\n  @override\n  void Function(String)? get onAyahSearchChanged => presenter.onAyahSearchChanged;\n\n  @override\n  TextEditingController get ayahNumberSearchController => presenter.ayahNumberSearchController;\n}"}, {"structure_type": "function", "name": "getNuzulBySurahId", "docstring": "", "module": "nuzul", "file_path": "data/data_sources/local_data_source/nuzul/nuzul_local_data_source.dart", "file_name": "nuzul_local_data_source.dart", "line": 7, "line_from": 7, "line_to": 106, "snippet": "  Future<List<NuzulDatabaseTableData>> getNuzulBySurahId(int surahId);\n  Future<List<NuzulDatabaseTableData>> getAllNuzul();\n  Future<List<int>> getUniqueNuzulSurahIds();\n}\n\nclass NuzulLocalDataSourceImpl implements NuzulLocalDataSource {\n  static const String _tag = 'NuzulLocalDataSourceImpl';\n  final QuranDatabase _database;\n  final String _externalDbName = 'nuzul.db'; // Using the same DB file as QuranInfo\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true;\n\n  NuzulLocalDataSourceImpl({QuranDatabase? database}) : _database = database ?? locate<QuranDatabase>();\n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n        // First check if the external database exists\n        final exists = await ExternalDbFactory.doesExternalDbExist(_externalDbName);\n        if (!exists) {\n         \n          _useExternalDb = false;\n          return;\n        }\n\n        // If it exists, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<List<NuzulDatabaseTableData>> getNuzulBySurahId(int surahId) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final dataList = await _externalDbService!.getNuzulBySurahId(surahId);\n          if (dataList.isNotEmpty) {\n            return dataList.map((data) => _externalDbService!.mapToNuzulDatabaseTableData(data)).toList();\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting Nuzul from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    return await _database.getNuzulBySurahId(surahId);\n  }\n\n  @override\n  Future<List<NuzulDatabaseTableData>> getAllNuzul() async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final dataList = await _externalDbService!.getAllNuzul();\n          if (dataList.isNotEmpty) {\n            return dataList.map((data) => _externalDbService!.mapToNuzulDatabaseTableData(data)).toList();\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting all Nuzul from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    return await _database.getAllNuzul();\n  }\n\n  @override\n  Future<List<int>> getUniqueNuzulSurahIds() async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final surahIds = await _externalDbService!.getUniqueNuzulSurahIds();\n          if (surahIds.isNotEmpty) {\n            return surahIds;\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting unique Nuzul surah IDs from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    return await _database.getUniqueNuzulSurahIds();\n  }\n}"}, {"structure_type": "function", "name": "getGrammarSummaryData", "docstring": "Get grammar summary data for a specific ayah and word", "module": "grammar", "file_path": "data/data_sources/local_data_source/grammar/grammar_local_data_source.dart", "file_name": "grammar_local_data_source.dart", "line": 7, "line_from": 7, "line_to": 75, "snippet": "  Future<GrammarSummaryData?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  });\n}\n\nclass GrammarLocalDataSourceImpl implements GrammarLocalDataSource {\n  static const String _tag = 'GrammarLocalDataSourceImpl';\n  final String _externalDbName = 'same_exact_summary.db';\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true;\n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n        // First check if the external database exists\n        final exists = await ExternalDbFactory.doesExternalDbExist(_externalDbName);\n        if (!exists) {\n          _useExternalDb = false;\n          return;\n        }\n\n        // If it exists, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<GrammarSummaryData?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  }) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final data = await _externalDbService!.getGrammarSummaryData(\n            surahId: surahId,\n            ayahId: ayahId,\n            wordIndex: wordIndex,\n          );\n          if (data != null) {\n            return _externalDbService!.mapToGrammarSummaryTableData(data);\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting grammar summary from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    try {\n      // Since we haven't implemented drift tables for this functionality yet,\n      // we'll just return null\n      return null;\n    } catch (e) {\n      Logger.error('Error getting grammar summary from drift tables: $e', _tag);\n      return null;\n    }\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "user", "file_path": "data/data_sources/local_data_source/user/user_data_local_data_source.dart", "file_name": "user_data_local_data_source.dart", "line": 168, "line_from": 168, "line_to": 172, "snippet": "    required void Function() onBookmarkFolderDeleted,\n  }) async {\n    await _userDataStorage.deleteBookmarkFolderByName(folderName: folderName);\n    onBookmarkFolderDeleted();\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "user", "file_path": "data/data_sources/local_data_source/user/user_data_local_data_source.dart", "file_name": "user_data_local_data_source.dart", "line": 272, "line_from": 272, "line_to": 332, "snippet": "    required void Function(List<BookmarkEntity>) onBookmarksSaved,\n  }) async {\n    // Get current bookmarks for this ayah\n    final List<BookmarkData> bookmarkDataList = await _userDataStorage.getBookmarkFolderBySurahAndAyah(\n      surahID: surahID,\n      ayahID: ayahID,\n    );\n\n    // Convert BookmarkData to BookmarkEntity\n    final List<BookmarkEntity> currentBookmarks = await bookmarkDataList.toBookmarkEntities();\n\n    // Create sets of folder names for comparison\n    final Set<String> currentFolderNames = currentBookmarks.map((b) => b.folderName).toSet();\n    final Set<String> newFolderNames = bookmarks.map((b) => b.folderName).toSet();\n\n    // Find folders to remove (in current but not in new)\n    final Set<String> foldersToRemove = currentFolderNames.difference(newFolderNames);\n\n    // For each folder that would be removed, check if it would become empty\n    for (final folderName in foldersToRemove) {\n      // Remove the specific bookmark from this folder\n      await _userDataStorage.deleteAyahFromBookmarkFolder(\n        surahID: surahID,\n        ayahID: ayahID,\n        folderName: folderName,\n      );\n\n      // Check if this folder would become empty\n      final List<BookmarkData> folderBookmarks = await _userDataStorage.getBookmarksByFolderName(\n        folderName: folderName,\n      ) as List<BookmarkData>;\n\n      // If folder would become empty, create a placeholder bookmark to preserve the folder\n      if (folderBookmarks.isEmpty) {\n        // Get the folder color from the original bookmark\n        final String folderColor =\n            getHexFromColor(currentBookmarks.firstWhere((b) => b.folderName == folderName).color);\n\n        // Create a placeholder bookmark with special IDs to mark it as a placeholder\n        // Using surahID=0, ayahID=0 to indicate this is a placeholder\n        await _userDataStorage.addAyahToBookmarkFolder(\n          surahID: 0,\n          ayahID: 0,\n          folderName: folderName,\n          color: folderColor,\n        );\n      }\n    }\n\n    // Add new bookmarks\n    final List<BookmarkEntity> savedBookmarks = List.empty(growable: true);\n    await Future.forEach(\n      bookmarks,\n      (bookmark) async => catchFutureOrVoid(\n        () => addAyahToBookmarkFolder(\n          bookmark: bookmark,\n        ),\n      ),\n    );\n    onBookmarksSaved(savedBookmarks);\n  }"}, {"structure_type": "function", "name": "getQuranInfoBySurahId", "docstring": "", "module": "info", "file_path": "data/data_sources/local_data_source/info/quran_info_local_data_source.dart", "file_name": "quran_info_local_data_source.dart", "line": 8, "line_from": 8, "line_to": 64, "snippet": "  Future<QuranInfoTableData?> getQuranInfoBySurahId(int surahId);\n\n}\n\nclass QuranInfoLocalDataSourceImpl implements QuranInfoLocalDataSource {\n  static const String _tag = 'QuranInfoLocalDataSourceImpl';\n  final QuranDatabase _database;\n  final String _externalDbName = 'info.db';\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true; // Flag to control which data source to use\n\n\n  QuranInfoLocalDataSourceImpl({QuranDatabase? database}) : _database = database ?? locate<QuranDatabase>();\n\n \n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n\n        // If it exists and is valid, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n       \n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<QuranInfoTableData?> getQuranInfoBySurahId(int surahId) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final data = await _externalDbService!.getQuranInfoBySurahId(surahId);\n          if (data != null) {\n            return _externalDbService!.mapToQuranInfoTableData(data);\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting QuranInfo from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables if external DB is not available or has an error\n    try {\n      return await _database.getQuranInfoBySurahId(surahId);\n    } catch (e) {\n      Logger.error('Error getting QuranInfo from drift tables: $e', _tag);\n      return null;\n    }\n  }\n}"}, {"structure_type": "function", "name": "getDuasByCategoryId", "docstring": "Get duas by category ID", "module": "dua", "file_path": "data/data_sources/local_data_source/dua/dua_local_data_source.dart", "file_name": "dua_local_data_source.dart", "line": 9, "line_from": 9, "line_to": 65, "snippet": "  Future<List<DuaEntity>> getDuasByCategoryId(int categoryId);\n}\n\nclass DuaLocalDataSourceImpl implements DuaLocalDataSource {\n  static const String _tag = 'DuaLocalDataSourceImpl';\n  final QuranDatabase _database;\n  final String _externalDbName = 'dua.db';\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true;\n\n  DuaLocalDataSourceImpl({QuranDatabase? database}) : _database = database ?? locate<QuranDatabase>();\n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n        // First check if the external database exists\n        final exists = await ExternalDbFactory.doesExternalDbExist(_externalDbName);\n        if (!exists) {\n          _useExternalDb = false;\n          return;\n        }\n\n        // If it exists, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<List<DuaEntity>> getDuasByCategoryId(int categoryId) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final dataList = await _externalDbService!.getDuasByCategoryId(categoryId);\n          if (dataList.isNotEmpty) {\n            return dataList.map((data) {\n              final duaData = _externalDbService!.mapToDuaDatabaseTableData(data);\n              return DuaEntity.fromDatabaseModel(duaData);\n            }).toList();\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting Duas from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    final databaseDuas = await _database.getDuasByCategoryId(categoryId);\n    return databaseDuas.map((dua) => DuaEntity.fromDatabaseModel(dua)).toList();\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "network", "file_path": "data/data_sources/remote_data_source/network/file_downloader.dart", "file_name": "file_downloader.dart", "line": 13, "line_from": 13, "line_to": 28, "snippet": "    required void Function(int) onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    // Check if savePath is an absolute path\n    if (savePath.startsWith('/')) {\n      // It's already an absolute path, use it directly\n      return await _downloadWithProgress(\n          url: url, filePath: savePath, onProgress: onProgress, cancelToken: cancelToken);\n    } else {\n      // It's a relative path, prepend the application directory path\n      String directoryPath = await getApplicationDirectoryPath();\n      String filePath = \"$directoryPath/$savePath\";\n      return await _downloadWithProgress(\n          url: url, filePath: filePath, onProgress: onProgress, cancelToken: cancelToken);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "network", "file_path": "data/data_sources/remote_data_source/network/file_downloader.dart", "file_name": "file_downloader.dart", "line": 33, "line_from": 33, "line_to": 61, "snippet": "    required void Function(int) onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    try {\n      // Ensure the directory exists\n      final directory = Directory(File(filePath).parent.path);\n      if (!await directory.exists()) {\n        await directory.create(recursive: true);\n      }\n\n      await DioClient.downloadFile(\n        url,\n        filePath,\n        onReceiveProgress: (received, total) {\n          if (total != -1) {\n            int percentage = ((received / total) * 100).floor();\n            onProgress(percentage);\n          }\n        },\n        cancelToken: cancelToken,\n      );\n\n      return filePath;\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) rethrow;\n      Logger.error(\"Error downloading file: $e\", _tag);\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "[];", "docstring": "", "module": "network", "file_path": "data/data_sources/remote_data_source/network/dio_client.dart", "file_name": "dio_client.dart", "line": 76, "line_from": 76, "line_to": 87, "snippet": "      final List<Future<Response>> downloadFutures = [];\n      for (int i = 0; i < urls.length; i++) {\n        downloadFutures.add(_dio.download(urls[i], savePaths[i],\n            cancelToken: cancelToken, onReceiveProgress: onReceiveProgress));\n      }\n      final List<Response> responses = await Future.wait(downloadFutures);\n      return responses;\n    } on DioException catch (e) {\n      // Handle DioException\n      logErrorStatic('Error in downloading multiple files: $e', 'DioClient');\n      rethrow;\n    }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "info", "file_path": "data/data_sources/remote_data_source/info/info_remote_data_source.dart", "file_name": "info_remote_data_source.dart", "line": 14, "line_from": 14, "line_to": 26, "snippet": "    required void Function(PromotionalMessageEntity) onMessage,\n  }) async {\n    await _backendAsAService.getRemoteNotice(\n      onNotification: (map) async {\n        await catchFutureOrVoid(() async {\n          final Map<String, Object?> remoteNoticeMap = map.map(MapEntry.new);\n          final PromotionalMessageEntity promotionalMessage =\n              await convertJsonMapToPromotionalMessage(map: remoteNoticeMap);\n          onMessage(promotionalMessage);\n        });\n      },\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "audio", "file_path": "data/data_sources/remote_data_source/audio/audio_remote_data_source.dart", "file_name": "audio_remote_data_source.dart", "line": 10, "line_from": 10, "line_to": 19, "snippet": "    required void Function(int percentage) onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    return await _fileDownloader.downloadFile(\n      url: url,\n      savePath: filePath,\n      onProgress: (int progress) => onProgress(progress),\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation_and_tafseer", "file_path": "data/data_sources/remote_data_source/translation_and_tafseer/translation_tafseer_remote_data_source.dart", "file_name": "translation_tafseer_remote_data_source.dart", "line": 10, "line_from": 10, "line_to": 20, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    // Call the downloadFile method from the FileDownloader class\n    await _fileDownloader.downloadFile(\n      url: url,\n      savePath: fileName,\n      onProgress: (int percentage) => onProgress?.call(percentage),\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word", "file_path": "data/data_sources/remote_data_source/word_by_word/word_by_word_remote_data_source.dart", "file_name": "word_by_word_remote_data_source.dart", "line": 10, "line_from": 10, "line_to": 19, "snippet": "    required void Function(int percentage) onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    await _fileDownloader.downloadFile(\n      url: url,\n      savePath: fileName,\n      onProgress: onProgress,\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "downloadMushaf", "docstring": "", "module": "mushaf", "file_path": "data/data_sources/remote_data_source/mushaf/mushaf_remote_data_source.dart", "file_name": "mushaf_remote_data_source.dart", "line": 8, "line_from": 8, "line_to": 49, "snippet": "  Future<void> downloadMushaf({\n    required String mushafName,\n    ProgressCallback? onProgress,\n    CancelToken? cancelToken,\n  });\n}\n\nclass MushafRemoteDataSource implements IMushafRemoteDataSource {\n  static const String baseUrl = 'https://download.quranmazid.com/mushaf/';\n\n  @override\n  Future<void> downloadMushaf({\n    required String mushafName,\n    ProgressCallback? onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    final String fileName = '$mushafName.zip';\n    final String downloadUrl = '$baseUrl$fileName';\n\n    final Directory appDir = await getApplicationDocumentsDirectory();\n    final Directory mushafDir = Directory('${appDir.path}/mushaf');\n    final File zipFile = File('${mushafDir.path}/$fileName');\n\n    if (!await mushafDir.exists()) {\n      await mushafDir.create(recursive: true);\n    }\n\n    final response = await DioClient.downloadFile(\n      downloadUrl,\n      zipFile.path,\n      onReceiveProgress: onProgress,\n      cancelToken: cancelToken,\n    );\n\n    if (response.statusCode == 200) {\n      // Download successful\n    } else {\n      final String error = 'Failed to download mushaf: ${response.statusCode}';\n      throw Exception(error);\n    }\n  }\n}"}, {"structure_type": "function", "name": "downloadTextMushafDatabase", "docstring": "Downloads the Text Mushaf database file.", "module": "mushaf", "file_path": "data/data_sources/remote_data_source/mushaf/text_mushaf_remote_data_source.dart", "file_name": "text_mushaf_remote_data_source.dart", "line": 9, "line_from": 9, "line_to": 193, "snippet": "  Future<void> downloadTextMushafDatabase({\n    required File dbFile,\n    required String url, // URL should be configurable or constant\n    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  /// Downloads a single Quran page font file.\n  Future<void> downloadFontFile({\n    required int pageNumber,\n    required String savePath,\n    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  /// Downloads multiple Quran page font files in batch.\n  Future<void> downloadFontBatch({\n    required List<int> pageNumbers,\n    required String saveDir,\n    void Function(int completed, int total)? onBatchProgress,\n    void Function(int pageNumber, double progress)? onFontProgress,\n    required CancelToken cancelToken,\n  });\n}\n\n/// Implementation of [ITextMushafRemoteDataSource] using Dio for network requests.\nclass TextMushafRemoteDataSource implements ITextMushafRemoteDataSource {\n  final Dio _dio;\n  static const String _tag = 'TextMushafRemoteDataSource';\n\n  // Inject Dio instance.\n  TextMushafRemoteDataSource({required Dio dio}) : _dio = dio;\n\n  @override\n  Future<void> downloadTextMushafDatabase({\n    required File dbFile,\n    required String url,\n    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final options = Options(\n      receiveTimeout: const Duration(minutes: 2),\n      sendTimeout: const Duration(minutes: 2),\n      headers: {\n        'Connection': 'keep-alive',\n      },\n    );\n\n    final result = await InternetAddress.lookup('google.com');\n    if (result.isEmpty || result[0].rawAddress.isEmpty) {\n      throw const SocketException('Network connectivity check failed');\n    }\n\n    await _dio.download(\n      url,\n      dbFile.path,\n      onReceiveProgress: onProgress,\n      cancelToken: cancelToken,\n      deleteOnError: true,\n      options: options,\n    );\n\n    if (!cancelToken.isCancelled) {\n      logInfoStatic('Text Mushaf DB downloaded successfully to ${dbFile.path}', _tag);\n\n      if (!await dbFile.exists() || await dbFile.length() == 0) {\n        throw Exception('Download completed but file is missing or empty');\n      }\n    } else {\n      logInfoStatic('Text Mushaf DB download cancelled for ${dbFile.path}', _tag);\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n        logInfoStatic('Deleted cancelled download file', _tag);\n      }\n      throw Exception('Download cancelled by user');\n    }\n  }\n\n  @override\n  Future<void> downloadFontFile({\n    required int pageNumber,\n    required String savePath,\n    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final String url = FontConstants.getFontDownloadUrl(pageNumber);\n    final File fontFile = File(savePath);\n\n    logInfoStatic('Starting download for font file page $pageNumber from $url to $savePath', _tag);\n\n    final options = Options(\n      receiveTimeout: const Duration(minutes: 1),\n      sendTimeout: const Duration(minutes: 1),\n      headers: {\n        'Connection': 'keep-alive',\n      },\n    );\n\n    if (!await fontFile.parent.exists()) {\n      await fontFile.parent.create(recursive: true);\n    }\n\n    await _dio.download(\n      url,\n      savePath,\n      onReceiveProgress: onProgress,\n      cancelToken: cancelToken,\n      deleteOnError: true,\n      options: options,\n    );\n\n    if (!cancelToken.isCancelled) {\n      logInfoStatic('Font file for page $pageNumber downloaded successfully to $savePath', _tag);\n\n      if (!await fontFile.exists() || await fontFile.length() == 0) {\n        throw Exception('Font download completed but file is missing or empty');\n      }\n    } else {\n      logInfoStatic('Font download cancelled for page $pageNumber', _tag);\n      if (await fontFile.exists()) {\n        await fontFile.delete();\n      }\n      throw Exception('Download cancelled by user');\n    }\n  }\n\n  @override\n  Future<void> downloadFontBatch({\n    required List<int> pageNumbers,\n    required String saveDir,\n    void Function(int completed, int total)? onBatchProgress,\n    void Function(int pageNumber, double progress)? onFontProgress,\n    required CancelToken cancelToken,\n  }) async {\n    if (pageNumbers.isEmpty) {\n      return;\n    }\n\n    logInfoStatic('Starting batch download of ${pageNumbers.length} font files to $saveDir', _tag);\n\n    final Directory dir = Directory(saveDir);\n    if (!await dir.exists()) {\n      await dir.create(recursive: true);\n    }\n\n    int completedDownloads = 0;\n    final int totalDownloads = pageNumbers.length;\n    final List<Exception> errors = [];\n\n    for (final int pageNumber in pageNumbers) {\n      if (cancelToken.isCancelled) {\n        logInfoStatic('Font batch download cancelled after $completedDownloads/$totalDownloads files', _tag);\n        throw Exception('Font batch download cancelled by user');\n      }\n\n      final String fontPath = '$saveDir/${FontConstants.getFontFileName(pageNumber)}';\n      final File fontFile = File(fontPath);\n\n      if (await fontFile.exists() && await fontFile.length() > 0) {\n        completedDownloads++;\n        onBatchProgress?.call(completedDownloads, totalDownloads);\n        continue;\n      }\n\n      await downloadFontFile(\n        pageNumber: pageNumber,\n        savePath: fontPath,\n        onProgress: (received, total) {\n          final double progress = total > 0 ? received / total : 0;\n          onFontProgress?.call(pageNumber, progress);\n        },\n        cancelToken: cancelToken,\n      );\n\n      completedDownloads++;\n      onBatchProgress?.call(completedDownloads, totalDownloads);\n    }\n\n    if (errors.isNotEmpty) {\n      throw Exception('Completed with ${errors.length} errors out of $totalDownloads font files.');\n    }\n\n    logInfoStatic('Batch download completed successfully: $completedDownloads fonts', _tag);\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "resource", "file_path": "data/data_sources/remote_data_source/resource/resource_remote_data_source.dart", "file_name": "resource_remote_data_source.dart", "line": 20, "line_from": 20, "line_to": 53, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final String url = '$_baseUrl$fileName';\n\n    try {\n      // Get the correct path for external databases\n      final String dbPath = await ExternalDbFactory.getExternalDbPath(fileName);\n      final File dbFile = File(dbPath);\n\n      // Create directory if it doesn't exist\n      if (!await dbFile.parent.exists()) {\n        await dbFile.parent.create(recursive: true);\n      }\n\n      // Delete existing file if it exists\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n      }\n\n\n      // Call the downloadFile method from the FileDownloader class with the correct path\n      await _fileDownloader.downloadFile(\n        url: url,\n        savePath: dbPath,\n        onProgress: (int percentage) => onProgress?.call(percentage),\n        cancelToken: cancelToken,\n      );\n\n    } catch (e) {\n      Logger.error('Error downloading database $fileName: $e', _tag);\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "toNoteEntities", "docstring": "", "module": "note", "file_path": "data/mappers/note/note_mapper.dart", "file_name": "note_mapper.dart", "line": 31, "line_from": 31, "line_to": 48, "snippet": "  Future<List<NoteEntity>> toNoteEntities() async {\n    return map((note) => NoteEntity(\n          surahId: note.surahId,\n          ayahNumber: note.ayahNumber,\n          title: note.title,\n          content: note.content,\n          color: note.color,\n          createdAt: note.createdAt,\n          updatedAt: note.updatedAt,\n        )).toList();\n  }\n}\n\nextension NoteEntitiesToBeSavedMapper on Pair<List<NoteEntity>, List<NoteEntity>> {\n  Future<List<NoteEntity>> findOutNotesToBeSaved() async {\n    return await compute(_findOutNotesToBeSavedStatic, this);\n  }\n}"}, {"structure_type": "function", "name": "toSerialisedString", "docstring": "", "module": "settings", "file_path": "data/mappers/settings/setting_entity_mapper.dart", "file_name": "setting_entity_mapper.dart", "line": 16, "line_from": 16, "line_to": 23, "snippet": "  Future<String> toSerialisedString() async =>\n      compute(_convertSettingsEntityToSerialisedString, this);\n}\n\nextension SerialisedStringToSettingStateEntity on String {\n  Future<SettingsStateEntity> toSettingStateEntity() async =>\n      compute(_convertSerialisedStringToSettingStateEntity, this);\n}"}, {"structure_type": "function", "name": "toPinEntities", "docstring": "", "module": "pin", "file_path": "data/mappers/pin/pin_mapper.dart", "file_name": "pin_mapper.dart", "line": 23, "line_from": 23, "line_to": 46, "snippet": "  Future<List<PinEntity>> toPinEntities() async {\n    return map((pin) => PinEntity(\n          surahId: pin.surahId,\n          ayahNumber: pin.ayahNumber,\n          name: pin.name,\n          color: pin.color,\n          createdAt: pin.createdAt,\n          updatedAt: pin.updatedAt,\n        )).toList();\n  }\n}\n\nextension PinEntityToDtoMapper on PinData {\n  PinEntity toPinEntity() {\n    return PinEntity(\n      surahId: surahId,\n      ayahNumber: ayahNumber,\n      name: name,\n      color: color,\n      createdAt: createdAt,\n      updatedAt: updatedAt,\n    );\n  }\n}"}, {"structure_type": "function", "name": "findOutPinsToBeSaved", "docstring": "", "module": "pin", "file_path": "data/mappers/pin/pin_mapper.dart", "file_name": "pin_mapper.dart", "line": 49, "line_from": 49, "line_to": 84, "snippet": "  Future<List<PinEntity>> findOutPinsToBeSaved() async {\n    return await compute(_findOutPinsToBeSavedStatic, this);\n  }\n}\n\nList<PinEntity> _findOutPinsToBeSavedStatic(\n  Pair<List<PinEntity>, List<PinEntity>> params,\n) {\n  // Here we define a local variable to hold the pins that need to be saved.\n  final List<PinEntity>? pinsToBeSaved = catchAndReturn(() {\n    // First we create a set of the IDs of the existing pins, so we can easily\n    // check if a new pin already exists or not.\n    final List<PinEntity> existingPins = params.first;\n    final Set<String> existingPinUniqueIdentifiers =\n        existingPins.map((pin) => \"${pin.surahId}-${pin.ayahNumber}-${pin.name}\").toSet();\n\n    // Then we filter out the new pins that already exist by checking if their\n    // ID is present in the set we just created.\n    // Using a Set helps to improve performance by removing duplicates and\n    // enabling faster membership testing.\n    final List<PinEntity> savingPins = params.second;\n    final Set<PinEntity> pinsToBeSaved = savingPins\n        .where(\n          (pin) => !existingPinUniqueIdentifiers.contains(\"${pin.surahId}-${pin.ayahNumber}-${pin.name}\"),\n        )\n        .toSet();\n\n    // Finally, we return the filtered set of new pins.\n    final List<PinEntity> pinsToBeSavedList = pinsToBeSaved.toList(growable: true);\n    return pinsToBeSavedList;\n  });\n\n  // If there was an error during the pin filtering process, return an\n  // empty list instead.\n  return pinsToBeSaved ?? [];\n}"}, {"structure_type": "function", "name": "toBookmarkEntities", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 22, "line_from": 22, "line_to": 32, "snippet": "  Future<List<BookmarkEntity>> toBookmarkEntities() async {\n    final List<BookmarkEntity> bookmarkEntities = await compute(_convertBookmarkDtoToBookmarkEntities, this);\n    return bookmarkEntities;\n  }\n}\n\nextension BookmarkEntitiesToBookmarkFolderEntitiesMapper on Pair<List<BookmarkEntity>, List<BookmarkEntity>> {\n  Future<List<BookmarkEntity>> findOutBookmarksToBeSaved() async {\n    return await compute(_findOutBookmarksToBeSavedStatic, this);\n  }\n}"}, {"structure_type": "function", "name": "groupBookmarksInFolders", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 68, "line_from": 68, "line_to": 125, "snippet": "  Future<List<BookmarkFolderEntity>> groupBookmarksInFolders() async {\n    return await compute(_groupBookmarksInFoldersStatic, this);\n  }\n}\n\nList<BookmarkFolderEntity> _groupBookmarksInFoldersStatic(\n  List<BookmarkData?> params,\n) {\n  final List<BookmarkFolderEntity>? folders = catchAndReturn(() {\n    final List<BookmarkData?> bookmarkDataList = params;\n\n    // Group bookmarks by name\n    final Map<String, List<BookmarkData?>> bookmarkDataMapGroupedByName =\n        bookmarkDataList.groupListsBy((bk) => bk!.foldername);\n\n    final List<BookmarkFolderEntity> allFolders = List.empty(growable: true);\n    int folderId = 1;\n\n    // Iterate over each group (folder)\n    for (final String folderName in bookmarkDataMapGroupedByName.keys) {\n      final List<BookmarkData?>? bookmarks = bookmarkDataMapGroupedByName[folderName];\n\n      if (bookmarks == null) continue;\n\n      // We allow empty folders to exist - removed the check for bookmarks.isEmpty\n      // Get folder color (use a default if no bookmarks)\n      final Color folderColor = bookmarks.isNotEmpty\n          ? getColorFromHex(bookmarks.first!.color)\n          : const Color(0xff66BB6A); // Default color for empty folders\n\n      // count total number of bookmarks in the folder\n      final int totalBookmarks =\n          bookmarks.isNotEmpty ? bookmarks.where((b) => b != null && b.suraId > 0 && b.ayahId > 0).length : 0;\n\n      // Get folder created and updated time\n      final (folderCreatedAt, folderUpdatedAt) = getBookmarkFolderCreatedAndUpdatedTime(bookmarks);\n\n      // Create a new bookmark folder entity\n      allFolders.add(\n        BookmarkFolderEntity(\n          id: folderId++,\n          name: folderName,\n          color: folderColor,\n          count: totalBookmarks,\n          updatedAt: folderUpdatedAt,\n          createdAt: folderCreatedAt,\n        ),\n      );\n    }\n\n    // Sort folders by name\n    allFolders.sort((a, b) => a.name.compareTo(b.name));\n\n    return allFolders;\n  });\n\n  return folders ?? [];\n}"}, {"structure_type": "function", "name": "param.map", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 147, "line_from": 147, "line_to": 163, "snippet": "  final List<Future<BookmarkEntity>> futures = param.map((dto) async => _convertDtoToBookmarkEntity(dto!)).toList();\n  return Future.wait(futures);\n}\n\nBookmarkEntity _convertDtoToBookmarkEntity(BookmarkData dto) => BookmarkEntity(\n      id: dto.id,\n      folderName: dto.foldername,\n      color: getColorFromHex(dto.color),\n      surahID: dto.suraId,\n      ayahID: dto.ayahId,\n      createdAt: dto.createdAt,\n      updatedAt: dto.updatedAt,\n    );\n\nextension BookmarkToDtoMap on BookmarkEntity {\n  Future<Map<String, Object?>> toMap() async => compute(_convertBookmarkToDtoMap, this);\n}"}, {"structure_type": "function", "name": "toMapList", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 180, "line_from": 180, "line_to": 191, "snippet": "  Future<List<Map<String, Object?>>> toMapList() async => compute(convertBookmarkListToDtoMap, this);\n}\n\nFuture<List<Map<String, Object?>>> convertBookmarkListToDtoMap(\n  List<BookmarkEntity> bookmarks,\n) async {\n  final List<Future<Map<String, Object?>>> futures = bookmarks.map((bookmark) async {\n    return _convertBookmarkToDtoMap(bookmark);\n  }).toList();\n  final List<Map<String, Object?>> result = await Future.wait(futures);\n  return result;\n}"}, {"structure_type": "function", "name": "toBookmarks", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 208, "line_from": 208, "line_to": 224, "snippet": "  Future<List<BookmarkEntity>> toBookmarks() async {\n    return compute(_convertMapsToBookmarkList, this);\n  }\n}\n\nFuture<List<BookmarkEntity>> _convertMapsToBookmarkList(\n  List<Map<String, Object?>> bookmarkMaps,\n) async {\n  final List<Future<BookmarkEntity>> futures = bookmarkMaps\n      .map(\n        (bookmarkMap) => Future<BookmarkEntity>.value(\n          _convertMapToBookmarkEntity(bookmarkMap),\n        ),\n      )\n      .toList();\n  return Future.wait(futures);\n}"}, {"structure_type": "function", "name": "toNotificationPayload", "docstring": "", "module": "notification", "file_path": "data/mappers/notification/notification_entity_mapper.dart", "file_name": "notification_entity_mapper.dart", "line": 56, "line_from": 56, "line_to": 62, "snippet": "  Future<NotificationPayLoadEntity> toNotificationPayload() async =>\n      compute(_convertJsonMapToNotificationPayLoadStatic, this);\n}\n\nextension NotificationPayLoadToJsonMap on NotificationPayLoadEntity {\n  Future<Map<String, String>> toJsonMap() async => compute(_convertNotificationPayLoadToJsonMapStatic, this);\n}"}, {"structure_type": "class", "name": "TTJsonModel", "docstring": "", "module": "content", "file_path": "data/mappers/content/tt_json_mapper.dart", "file_name": "tt_json_mapper.dart", "line": 6, "line_from": 6, "line_to": 105, "snippet": "class TTJsonModel {\n  Map<String, List<TTDbFileModel>> trans;\n  Map<String, List<TTDbFileModel>> tafsir;\n\n  TTJsonModel({\n    required this.trans,\n    required this.tafsir,\n  });\n\n  factory TTJsonModel.empty() {\n    return TTJsonModel(tafsir: {}, trans: {});\n  }\n\n  factory TTJsonModel.fromJson(Map<String, dynamic> json) => TTJsonModel(\n        trans: Map.from(json[\"trans\"]).map((k, v) => MapEntry<String, List<TTDbFileModel>>(\n            k, List<TTDbFileModel>.from(v.map((x) => TTDbFileModel.fromJson(x))))),\n        tafsir: Map.from(json[\"tafsir\"]).map((k, v) => MapEntry<String, List<TTDbFileModel>>(\n            k, List<TTDbFileModel>.from(v.map((x) => TTDbFileModel.fromJson(x))))),\n      );\n\n  Map<String, dynamic> toJson() => {\n        \"trans\":\n            Map.from(trans).map((k, v) => MapEntry<String, dynamic>(k, List<dynamic>.from(v.map((x) => x.toJson())))),\n        \"tafsir\":\n            Map.from(tafsir).map((k, v) => MapEntry<String, dynamic>(k, List<dynamic>.from(v.map((x) => x.toJson())))),\n      };\n}\n\nclass TTDbFileModel {\n  String name;\n  String fileName;\n  String size;\n  String language;\n  String languageCode;\n  Type type;\n  String link;\n\n  TTDbFileModel({\n    required this.name,\n    required this.fileName,\n    required this.size,\n    required this.language, // Changed to String\n    required this.type,\n    required this.link,\n    required this.languageCode,\n  });\n\n  factory TTDbFileModel.fromJson(Map<String, dynamic> json) => TTDbFileModel(\n        name: json[\"name\"],\n        fileName: json[\"file_name\"],\n        size: json[\"size\"],\n        language: json[\"language\"], // Changed from \"lang\"\n        type: typeValues.map[json[\"type\"]]!,\n        link: json[\"link\"],\n        languageCode: json[\"language_code\"],\n      );\n\n  Map<String, dynamic> toJson() => {\n        \"name\": name,\n        \"file_name\": fileName,\n        \"size\": size,\n        \"language\": language, // Changed to \"language\"\n        \"type\": typeValues.reverse[type],\n        \"link\": link,\n        \"language_code\": languageCode,\n      };\n\n  Map<String, Object> toMap() {\n    return {\n      'name': name,\n      'file_name': fileName,\n      'size': size,\n      'language': language, // Directly use the language string\n      'type': typeValues.reverse[type]!,\n      'link': link,\n      'language_code': languageCode,\n    };\n  }\n}\n\n// Adjusted Type and Lang enums are not needed anymore if Lang is directly a string.\n// Consider removing or adjusting Lang enum if it's used elsewhere in your code.\n\nenum Type { tafseer, translation }\n\nfinal typeValues = EnumValues({\"tafseer\": Type.tafseer, \"translation\": Type.translation});\n\nclass EnumValues<T> {\n  Map<String, T> map;\n  late Map<T, String> reverseMap;\n\n  EnumValues(this.map);\n\n  Map<T, String> get reverse {\n    reverseMap = map.map((k, v) => MapEntry(v, k));\n    return reverseMap;\n  }\n}\n"}, {"structure_type": "function", "name": "toAyahEntity", "docstring": "", "module": "quran", "file_path": "data/mappers/quran/ayah_mapper.dart", "file_name": "ayah_mapper.dart", "line": 8, "line_from": 8, "line_to": 28, "snippet": "  Future<List<AyahEntity>> toAyahEntity() async {\n    final List<AyahDatabaseTableData> dtoList = this;\n    final List<AyahEntity> ayahEntityList = await compute(_convertAyahFtsToAyahEntity, dtoList);\n    return ayahEntityList;\n  }\n}\n\nList<AyahEntity> _convertAyahFtsToAyahEntity(List<AyahDatabaseTableData> dtoList) =>\n    dtoList.map(_convertDtoToAyahEntity).toList();\n\nAyahEntity _convertDtoToAyahEntity(AyahDatabaseTableData ayahDto) {\n  return AyahEntity(\n    id: ayahDto.id,\n    surahID: ayahDto.surahId!,\n    ayahID: ayahDto.ayahId!,\n    juz: ayahDto.juz,\n    hijb: ayahDto.hijb,\n    page: ayahDto.page,\n    clean: ayahDto.clean,\n  );\n}"}, {"structure_type": "function", "name": "toPageListEntity", "docstring": "", "module": "surah", "file_path": "data/mappers/surah/surah_mapper.dart", "file_name": "surah_mapper.dart", "line": 28, "line_from": 28, "line_to": 48, "snippet": "  Future<List<SurahEntity>> toPageListEntity() async {\n    final List<SurahDatabaseTableData> dtoList = this;\n    final List<SurahEntity> surahList = await compute(_convertSurahDtoToSurahEntity, dtoList);\n    return surahList;\n  }\n}\n\nList<SurahEntity> _convertSurahDtoToSurahEntity(List<SurahDatabaseTableData> dtoList) =>\n    dtoList.map(_convertDtoToSurahEntity).toList();\n\nSurahEntity _convertDtoToSurahEntity(SurahDatabaseTableData surahDto) {\n  return SurahEntity(\n      serial: surahDto.serial!,\n      name: surahDto.name!,\n      nameBn: surahDto.nameBn!,\n      meaning: surahDto.meaning!,\n      totalAyah: surahDto.totalAyah!,\n      nameEn: surahDto.nameEn!,\n      meaningBn: surahDto.meaningBn!,\n      type: surahDto.type!);\n}"}, {"structure_type": "function", "name": "toWordByWordListEntity", "docstring": "", "module": "word_by_word", "file_path": "data/mappers/word_by_word/word_by_word_mapper.dart", "file_name": "word_by_word_mapper.dart", "line": 6, "line_from": 6, "line_to": 18, "snippet": "  Future<List<WordByWordEntity>> toWordByWordListEntity() async {\n    final List<WordByWordDatabaseTableData> dtoList = this;\n    final List<WordByWordEntity> wordByWordList = await compute(_convertWordByWordDtoToWordByWordEntity, dtoList);\n    return wordByWordList;\n  }\n}\n\nextension DtoToWordByWordMapper on WordByWordDatabaseTableData {\n  WordByWordEntity toWordByWordEntity() {\n    final WordByWordDatabaseTableData wordByWordDto = this;\n    return _convertDtoToWordByWordEntity(wordByWordDto);\n  }\n}"}, {"structure_type": "function", "name": "setUp", "docstring": "", "module": "service", "file_path": "data/service/local_cache_service.dart", "file_name": "local_cache_service.dart", "line": 13, "line_from": 13, "line_to": 133, "snippet": "  static Future<void> setUp() async {\n    final Directory document = await getApplicationDocumentsDirectory();\n    final String documentPath = document.path;\n    Hive.init(documentPath);\n    await Hive.openBox<Object>(_storageFileName);\n  }\n\n  static String get _storageFileName => \"${_secretVaultName}_239090\";\n\n  /// Saves the provided `value` to the persistent storage using the specified `key`.\n  ///\n  /// The type parameter `T` represents the type of the `value` being saved,\n  /// and it must be a subtype of `Object`.\n  ///\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  /// await saveData(key: CacheKeys.userId, value: 'sufi_bhai_28283');\n  /// ```\n  Future<void> saveData<T extends Object>({\n    required String key,\n    required T value,\n  }) async {\n    await catchFutureOrVoid(() async {\n      if (key.isEmpty) return;\n      await _hiveBox.put(key, value);\n    });\n  }\n\n  // Future<String?> getOldBookmarkJsonFile() async {\n  //   bool hasPermission = await PermissionService.checkPermission();\n\n  //   if (hasPermission) {\n  //     const String bookmarkFilePath = '/storage/emulated/0/quranAppBookmark/bookmark.json';\n  //     final File bookmarkFile = File(bookmarkFilePath);\n  //     if (await bookmarkFile.exists()) {\n  //       return await bookmarkFile.readAsString();\n  //     }\n  //   }\n  //   return null;\n  // }\n\n  Future<String?> getOldBookmarkJsonFile() async {\n    const MethodChannel platformMethodChannel = MethodChannel(\"com.ihadis.quran/legacy\");\n\n    if (!Platform.isAndroid) {\n      logError(\"Platform is not android, skipping legacy data retrieval\");\n      return null;\n    }\n\n    final bool alreadyRetrieved = getData(key: CacheKeys.retrievedPreviousBookmarks) ?? false;\n\n    if (alreadyRetrieved) {\n      logError(\"Already retrieved legacy data, skipping\");\n      return null;\n    }\n\n    try {\n      final String? legacyBookmarkJson = await platformMethodChannel.invokeMethod<String>(\"fetch_bookmarks\");\n\n      if (legacyBookmarkJson == null || legacyBookmarkJson.isEmpty) {\n        logError(\"Legacy bookmark json is null or empty\");\n        return null;\n      }\n\n      await saveData(key: CacheKeys.retrievedPreviousBookmarks, value: true);\n      return legacyBookmarkJson;\n    } catch (e) {\n      logError(\"Error fetching legacy bookmarks: $e\");\n      return null;\n    }\n  }\n\n  /// Retrieves data from persistent storage using the specified `key`.\n  ///\n  /// The type parameter `T` represents the type of the data being retrieved,\n  /// and it allows writing type-safe and reusable code that can operate on\n  /// different data types.\n  ///\n  ///\n  /// If an error occurs during the retrieval process, an error message is logged,\n  /// and `null` is returned.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  /// String? userId = getData<String>(key: CacheKeys.userId);\n  /// bool? isFirstTime = getData<bool>(key: CacheKeys.firstTime);\n  /// ```\n  ///\n  /// Note: This function assumes that the `_hiveBox` instance is properly initialized\n  /// and accessible within the scope of this function.\n  T? getData<T>({required String key}) {\n    try {\n      final T? result = _hiveBox.get(key) as T?;\n      return result;\n    } catch (e) {\n      logError(\"getData: key: $key\\nerror: $e\");\n      return null;\n    }\n  }\n\n  /// Deletes data from persistent storage for the specified `key`.\n  ///\n  /// If the `key` does not exist, the operation completes without any effect.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  /// await deleteData(key: CacheKeys.userId);\n  /// ```\n  Future<void> deleteData({required String key}) async {\n    await catchFutureOrVoid(() async {\n      if (key.isEmpty) return;\n      await _hiveBox.delete(key);\n    });\n  }\n\n  late final Box<Object> _hiveBox = Hive.box(_storageFileName);\n}"}, {"structure_type": "function", "name": "initialize", "docstring": "Initialize the database connection", "module": "database", "file_path": "data/service/database/external_db_service.dart", "file_name": "external_db_service.dart", "line": 25, "line_from": 25, "line_to": 355, "snippet": "  Future<void> initialize() async {\n    if (_database != null) return;\n\n    try {\n      final dbFile = File(_dbFilePath);\n\n      if (!await dbFile.exists()) {\n        throw Exception('External database file not found at: $_dbFilePath');\n      }\n\n      _database = await openDatabase(\n        _dbFilePath,\n        readOnly: true,\n      );\n    } catch (e) {\n      Logger.error('Error initializing external database: $e', _tag);\n      throw Exception('Failed to initialize external database: $e');\n    }\n  }\n\n  /// Close the database connection\n  Future<void> close() async {\n    if (_database != null) {\n      await _database!.close();\n      _database = null;\n    }\n  }\n\n  /// Helper method to ensure database is initialized\n  Future<Database> get database async {\n    if (_database == null) {\n      await initialize();\n    }\n    return _database!;\n  }\n\n  /// Get QuranInfo data by surah ID\n  Future<Map<String, dynamic>?> getQuranInfoBySurahId(int surahId) async {\n    try {\n      final db = await database;\n      final List<Map<String, dynamic>> result = await db.query(\n        'info',\n        where: 'surah_id = ?',\n        whereArgs: [surahId],\n      );\n\n      return result.isNotEmpty ? result.first : null;\n    } catch (e) {\n      Logger.error('Error getting QuranInfo by surahId: $e', _tag);\n      return null;\n    }\n  }\n\n  /// Get Nuzul data by surah ID\n  Future<List<Map<String, dynamic>>> getNuzulBySurahId(int surahId) async {\n    try {\n      final db = await database;\n      return await db.query(\n        'nuzul',\n        where: 'surah_id = ?',\n        whereArgs: [surahId],\n        orderBy: 'from_ayah ASC',\n      );\n    } catch (e) {\n      Logger.error('Error getting Nuzul by surahId: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Get all Nuzul data\n  Future<List<Map<String, dynamic>>> getAllNuzul() async {\n    try {\n      final db = await database;\n      return await db.query(\n        'nuzul',\n        orderBy: 'surah_id ASC, from_ayah ASC',\n      );\n    } catch (e) {\n      Logger.error('Error getting all Nuzul data: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Get unique Nuzul surah IDs\n  Future<List<int>> getUniqueNuzulSurahIds() async {\n    try {\n      final db = await database;\n      final List<Map<String, dynamic>> result = await db.rawQuery(\n        'SELECT DISTINCT surah_id FROM nuzul ORDER BY surah_id ASC',\n      );\n\n      return result.map((row) => row['surah_id'] as int).toList();\n    } catch (e) {\n      Logger.error('Error getting unique Nuzul surah IDs: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Get Duas by category ID\n  Future<List<Map<String, dynamic>>> getDuasByCategoryId(int categoryId) async {\n    try {\n      final db = await database;\n      return await db.query(\n        'dua',\n        where: 'category_id = ?',\n        whereArgs: [categoryId],\n        orderBy: 'id ASC',\n      );\n    } catch (e) {\n      Logger.error('Error getting Duas by category ID: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Helper method to convert result to QuranInfoTableData\n  QuranInfoTableData? mapToQuranInfoTableData(Map<String, dynamic>? data) {\n    if (data == null) return null;\n\n    return QuranInfoTableData(\n      surahId: data['surah_id'] as int,\n      en: data['en'] as String,\n      bn: data['bn'] as String,\n    );\n  }\n\n  /// Helper method to convert result to NuzulDatabaseTableData\n  NuzulDatabaseTableData mapToNuzulDatabaseTableData(Map<String, dynamic> data) {\n    return NuzulDatabaseTableData(\n      surahId: data['surah_id'] as int,\n      fromAyah: data['from_ayah'] as int,\n      toAyah: data['to_ayah'] as int,\n      bn: data['bn'] as String,\n      en: data['en'] as String,\n    );\n  }\n\n  /// Helper method to convert result to DuaDatabaseTableData\n  DuaDatabaseTableData mapToDuaDatabaseTableData(Map<String, dynamic> data) {\n    return DuaDatabaseTableData(\n      id: data['id'] as int,\n      categoryId: data['category_id'] as int,\n      surahId: data['surah_id'] as int?,\n      ayahId: data['ayah_id'] as String?,\n      lang: data['lang'] as String?,\n      name: data['name'] as String?,\n      uthmani: data['uthmani'] as String?,\n      indopak: data['indopak'] as String?,\n      translation: data['translation'] as String?,\n      note: data['note'] as String?,\n      reference: data['reference'] as String?,\n      audio: data['audio'] as int?,\n    );\n  }\n\n  /// Get grammar summary data\n  Future<Map<String, dynamic>?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  }) async {\n    try {\n      final db = await database;\n      final List<Map<String, dynamic>> result = await db.query(\n        'same_exact_summary_data_table',\n        where: 'surah = ? AND ayah = ? AND word = ?',\n        whereArgs: [surahId, ayahId, wordIndex],\n      );\n\n      return result.isNotEmpty ? result.first : null;\n    } catch (e) {\n      Logger.error('Error getting grammar summary data: $e', _tag);\n      return null;\n    }\n  }\n\n  /// Helper method to convert result to GrammarSummaryTableData\n  GrammarSummaryData mapToGrammarSummaryTableData(Map<String, dynamic> data) {\n    return GrammarSummaryData(\n      surah: data['surah'] as int,\n      ayah: data['ayah'] as int,\n      word: data['word'] as int,\n      sameRoot: data['same_root'] as String?,\n      exactMatch: data['exact_match'] as String?,\n      summary: data['summary'] as String?,\n    );\n  }\n}\n\n/// A factory to create and manage external database services\nclass ExternalDbFactory {\n  static final Map<String, ExternalDbService> _instances = {};\n  static const String _tag = 'ExternalDbFactory';\n\n  /// Get external database path\n  static Future<String> getExternalDbPath(String dbName) async {\n    try {\n      // Use getApplicationDocumentsDirectory for iOS compatibility\n      // For Android, this will map to the app's internal storage\n      final appDir = await getApplicationDocumentsDirectory();\n      final path = p.join(appDir.path, 'external_dbs', dbName);\n\n      return path;\n    } catch (e) {\n      Logger.error('Error getting external DB path: $e', _tag);\n      rethrow;\n    }\n  }\n\n  /// Get an ExternalDbService instance for a specific database\n  static Future<ExternalDbService> getService(String dbName) async {\n    if (_instances.containsKey(dbName)) {\n      return _instances[dbName]!;\n    }\n\n    final dbPath = await getExternalDbPath(dbName);\n    final service = ExternalDbService(dbPath);\n\n    try {\n      await service.initialize();\n      _instances[dbName] = service;\n      return service;\n    } catch (e) {\n      Logger.error('Failed to get external db service for $dbName: $e', _tag);\n      throw Exception('Failed to get external db service for $dbName: $e');\n    }\n  }\n\n  /// Download an external database file from the server\n  static Future<bool> downloadExternalDb({\n    required String dbName,\n    required String url,\n    void Function(int percentage)? onProgress,\n    required bool Function() isCancelled,\n  }) async {\n    try {\n      final dbPath = await getExternalDbPath(dbName);\n      final dbFile = File(dbPath);\n\n      // Create directory if it doesn't exist\n      if (!await dbFile.parent.exists()) {\n        await dbFile.parent.create(recursive: true);\n      }\n\n      // Delete existing file if it exists\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n      }\n\n      // Download the file\n      final dio = Dio();\n      await dio.download(\n        url,\n        dbPath,\n        onReceiveProgress: (received, total) {\n          if (total != -1) {\n            final percentage = (received / total * 100).round();\n            onProgress?.call(percentage);\n          }\n\n          // Check if the download should be cancelled\n          if (isCancelled()) {\n            throw Exception('Download cancelled by user');\n          }\n        },\n      );\n\n      // Validate the downloaded database\n      try {\n        final db = await openDatabase(dbPath, readOnly: true);\n\n        // Check if required tables exist\n        final tables =\n            await db.query('sqlite_master', where: \"type = 'table' AND name IN ('quran_info', 'nuzul', 'dua')\");\n\n        await db.close();\n\n        if (tables.isEmpty) {\n          Logger.error('Downloaded database $dbName is missing required tables', _tag);\n          await dbFile.delete();\n          return false;\n        }\n\n        return true;\n      } catch (e) {\n        Logger.error('Error validating downloaded database $dbName: $e', _tag);\n        await dbFile.delete();\n        return false;\n      }\n    } catch (e) {\n      Logger.error('Error downloading external database $dbName: $e', _tag);\n      return false;\n    }\n  }\n\n  /// Close all database connections\n  static Future<void> closeAll() async {\n    for (final service in _instances.values) {\n      await service.close();\n    }\n    _instances.clear();\n  }\n\n  /// Check if an external database exists\n  static Future<bool> doesExternalDbExist(String dbName) async {\n    try {\n      final dbPath = await getExternalDbPath(dbName);\n      final dbFile = File(dbPath);\n      final exists = await dbFile.exists();\n      return exists;\n    } catch (e) {\n      Logger.error('Error checking if external DB exists: $e', _tag);\n      return false;\n    }\n  }\n\n  /// Ensure the external database directory exists\n  static Future<void> ensureExternalDbDirectoryExists() async {\n    try {\n      final appDir = await getApplicationDocumentsDirectory();\n      final dirPath = p.join(appDir.path, 'external_dbs');\n      final dir = Directory(dirPath);\n\n      if (!await dir.exists()) {\n        await dir.create(recursive: true);\n      }\n    } catch (e) {\n      Logger.error('Error ensuring external DB directory exists: $e', _tag);\n      rethrow;\n    }\n  }\n}"}, {"structure_type": "function", "name": "getLayoutForPage", "docstring": "", "module": "text_mushaf", "file_path": "data/service/database/text_mushaf/text_mushaf_database.dart", "file_name": "text_mushaf_database.dart", "line": 36, "line_from": 36, "line_to": 101, "snippet": "  Future<List<dynamic>> getLayoutForPage({\n    required int pageNumber,\n    required String layoutTableName,\n  }) async {\n\n    List<dynamic> result;\n    switch (layoutTableName) {\n      case 'indopak13_lines_layout':\n        final query = select(indopak13LinesLayout)..where((tbl) => tbl.page.equals(pageNumber));\n        result = await query.get();\n        break;\n      case 'indopak15_lines_layout':\n        final query = select(indopak15LinesLayout)..where((tbl) => tbl.page.equals(pageNumber));\n        result = await query.get();\n        break;\n      case 'qpc_v1_layout':\n        final query = select(qpcV1Layout)..where((tbl) => tbl.page.equals(pageNumber));\n        result = await query.get();\n        break;\n      case 'qpc_v2_layout':\n        final query = select(qpcV2Layout)..where((tbl) => tbl.page.equals(pageNumber));\n        result = await query.get();\n            break;\n      default:\n        result = [];\n    }\n\n\n    return result;\n  }\n\n  Future<List<TextWordEntry>> getWordsForRange({\n    required int rangeStart,\n    required int rangeEnd,\n  }) async {\n    final query = select(words)\n      ..where((tbl) =>\n          tbl.wordNumberAll.isNotNull() & tbl.wordNumberAll.isBetween(Constant(rangeStart), Constant(rangeEnd)))\n      ..orderBy([(t) => OrderingTerm(expression: t.wordNumberAll)]);\n    return await query.get();\n  }\n\n  Future<List<TextWordEntry>> getWordsForAyah({\n    required int surahNumber,\n    required int ayahNumber,\n  }) async {\n    final query = select(words)\n      ..where((tbl) => tbl.surahNumber.equals(surahNumber) & tbl.ayahNumber.equals(ayahNumber))\n      ..orderBy([(t) => OrderingTerm(expression: t.wordNumber)]);\n    return await query.get();\n  }\n}\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    final Directory dbFolder = await getApplicationDocumentsDirectory();\n    final File file = File(p.join(dbFolder.path, 'databases', TextMushafDatabase.dbFileName));\n\n    final Directory parentDir = file.parent;\n    if (!await parentDir.exists()) {\n      await parentDir.create(recursive: true);\n    }\n\n    return NativeDatabase.createInBackground(file);\n  });\n}"}, {"structure_type": "function", "name": "initSettings", "docstring": "", "module": "settings", "file_path": "domain/repositories/settings/setting_repository.dart", "file_name": "setting_repository.dart", "line": 5, "line_from": 5, "line_to": 21, "snippet": "  Future<void> initSettings();\n\n  Stream<SettingsStateEntity> get settingsStream;\n\n  Future<void> updateSettings({required SettingsStateEntity settingsState});\n\n    Future<void> scheduleNotification({\n    required TimeOfDay time,\n    required bool turnOn,\n  });\n\n  Future<SettingsStateEntity> getSettingsState();\n\n  Future<void> dispose();\n\n\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "grammar", "file_path": "domain/repositories/grammar/grammar_repository.dart", "file_name": "grammar_repository.dart", "line": 10, "line_from": 10, "line_to": 19, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  /// Get grammar summary data for a specific ayah and word\n  Future<GrammarSummaryData?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  });"}, {"structure_type": "function", "name": "getAllMemorizationPlans", "docstring": "", "module": "memorization", "file_path": "domain/repositories/memorization/memorization_plan_repository.dart", "file_name": "memorization_plan_repository.dart", "line": 5, "line_from": 5, "line_to": 54, "snippet": "  Future<List<MemorizationPlanEntity>> getAllMemorizationPlans();\n\n  Future<MemorizationPlanEntity?> getMemorizationPlanByName(String planName);\n\n  Future<void> addMemorizationPlan({\n    required MemorizationPlanEntity plan,\n    bool saveToRemote = true,\n  });\n\n  Future<void> updateMemorizationPlan({\n    required String planName,\n    String? newPlanName,\n    int? startSurahId,\n    int? startAyahId,\n    int? endSurahId,\n    int? endAyahId,\n    int? estimatedDays,\n    bool? hasNotification,\n    DateTime? notificationTime,\n  });\n\n  Future<void> deleteMemorizationPlan({required String planName});\n\n  Future<List<MemorizationPlanEntity>> syncMemorizationPlansWithRemote();\n\n  Future<void> memorizeAyah({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  });\n\n  Future<void> unmemorizeAyah({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  });\n\n  Future<bool> isAyahMemorized({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  });\n\n  Future<int> getMemorizedAyahsCount({\n    required String planName,\n    required int surahId,\n  });\n\n  Future<MemorizedAyahEntity?> getLastMemorizedAyah(String planName);\n}"}, {"structure_type": "function", "name": "getNonDefaultTranslation", "docstring": "", "module": "translation", "file_path": "domain/repositories/translation/translation_repository.dart", "file_name": "translation_repository.dart", "line": 5, "line_from": 5, "line_to": 16, "snippet": "  Future<void> getNonDefaultTranslation({required TTDbFileModel file,  void Function(int percentage)? onProgress, required CancelToken cancelToken,});\n  Future<void> getDefaultTranslation(TTDbFileModel file);\n  Future<void> deleteTranslationDatabase({required String fileName});\n  Future<List<String>> getAvailableTranslations();\n  Future<void> saveAvailableTranslations({required Set<String> availableTranslations, required String newItem});\n  Future<void> selectTranslation({required TTDbFileModel file});\n  Future<void> deleteAvailableTranslation({required TTDbFileModel file});\n  Future<Set<String>> getSelectedTranslations();\n  Future<void> saveSelectedTranslations(Set<String> selectedTranslations);\n   Future<void> saveAvailableItemsCount(int count);\n   Future<int> fetchAvailableItemsCount(); \n}"}, {"structure_type": "function", "name": "getAllSurahs", "docstring": "", "module": "quran_structure", "file_path": "domain/repositories/quran_structure/surah_repository.dart", "file_name": "surah_repository.dart", "line": 5, "line_from": 5, "line_to": 12, "snippet": "  Future<List<SurahEntity>> getAllSurahs();\n  Future<List<AyahEntity>> getIDsBySurahID({required int surahId});\n\n  Future<List<AyahEntity>> getAyahsBySurahAndAyahList({\n    required int surahId,\n    required String ayahList,\n  });\n}"}, {"structure_type": "function", "name": "recordUsage", "docstring": "Records the duration the app was used for a specific date.", "module": "usage_tracking", "file_path": "domain/repositories/usage_tracking/usage_tracking_repository.dart", "file_name": "usage_tracking_repository.dart", "line": 11, "line_from": 11, "line_to": 46, "snippet": "  Future<Either<Failure, void>> recordUsage({\n    required Duration duration,\n    required DateTime date,\n    String usageType = 'reading',\n  });\n\n  /// Retrieves the aggregated usage data (minutes per day) for the last N days\n  Future<Either<Failure, List<(DateTime, double)>>> getUsageForLastNDays(int days);\n  \n  /// Retrieves the aggregated usage data (minutes per day) for a specific month\n  Future<Either<Failure, List<(DateTime, double)>>> getUsageForMonth({\n    required int year,\n    required int month,\n  });\n  \n  /// Retrieves the aggregated usage data (minutes per day) for a specific year\n  Future<Either<Failure, List<(int, int, double)>>> getUsageForYear({\n    required int year,\n  });\n  \n  /// Retrieves stats for time range (total time, average per day, etc.)\n  Future<Either<Failure, UsageStats>> getUsageStats({\n    required TimeRange timeRange,\n  });\n}\n\n/// Used to represent different time ranges for queries\nenum TimeRange {\n  last7Days,\n  last30Days,\n  currentMonth,\n  previousMonth,\n  currentYear,\n  previousYear,\n  custom,\n}"}, {"structure_type": "function", "name": "getPromotionalMessage", "docstring": "", "module": "info", "file_path": "domain/repositories/info/info_repository.dart", "file_name": "info_repository.dart", "line": 6, "line_from": 6, "line_to": 30, "snippet": "  Future<void> getPromotionalMessage({\n    required void Function(PromotionalMessageEntity?) onMessage,\n  });\n\n  Future<void> closePromotionalMessage({required bool userSeen});\n\n  Future<String> getSadaqahJariah();\n  Future<String> getPrivacyPolicy();\n  Future<String> getAboutUs();\n  Future<String> getThanksAndCredit();\n  Future<String> getContactUs();\n  Future<String> getAboutTafsir();\n  Future<String> getHelpUs();\n  Future<String> getAboutApp();\n  Future<List<OurProjectEntity>> getOurProjects();\n\n  /// Check if the info database is available\n  Future<bool> isInfoDatabaseAvailable();\n\n  /// Download the info database from the server\n  Future<void> downloadInfoDatabase({\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n}"}, {"structure_type": "function", "name": "downloadAudioFiles", "docstring": "", "module": "audio", "file_path": "domain/repositories/audio/audio_repository.dart", "file_name": "audio_repository.dart", "line": 8, "line_from": 8, "line_to": 61, "snippet": "  Future<void> downloadAudioFiles({\n    required int surahID,\n    required Reciter reciter,\n    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  Future<String> generateAudioFilePath({required int surah, required Reciter reciter});\n\n  Future<void> deleteAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  });\n\n  Future<void> persistSurahAudioPath({\n    required List<int> surahs,\n    required Reciter reciter,\n  });\n  Future<bool> isSurahAudioAvailable({\n    required int surahNumber,\n    required Reciter reciter,\n  });\n  Future<List<VerseTiming>> getVerseTimings({\n    required int surahID,\n    required int reciterID,\n  });\n  Future<void> playSurahPlaylist();\n\n  Future<void> playVerseWithDelay(\n    VerseTiming verseTiming,\n    Duration delay,\n  );\n  Future<String> getAudioPath({\n    required int surah,\n    required Reciter reciter,\n    bool isOnlineStream = false,\n  });\n  Future<void> addToPlayl1ist({\n    required String audioPath,\n    required String title,\n    bool isOnlineStream = false,\n  });\n\n  Future<AudioFile> getAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  });\n  Future<void> seekAudio(Duration position);\n  Future<void> clearPlaylist();\n  Future<void> stopAudio();\n  Future<void> pausePlayback();\n  Future<void> resumePlayback();\n  Future<void> playWordAudio({required WordByWordEntity word});\n}"}, {"structure_type": "function", "name": "getAllDailyAyahList", "docstring": "", "module": "dailyAyah", "file_path": "domain/repositories/dailyAyah/daily_ayah_repository.dart", "file_name": "daily_ayah_repository.dart", "line": 4, "line_from": 4, "line_to": 5, "snippet": "  Future<List<AyahDatabaseTableData>> getAllDailyAyahList({required String languageCode});\n}"}, {"structure_type": "function", "name": "getTafseer", "docstring": "", "module": "tafseer", "file_path": "domain/repositories/tafseer/tafseer_repository.dart", "file_name": "tafseer_repository.dart", "line": 6, "line_from": 6, "line_to": 24, "snippet": "  Future<void> getTafseer({\n    required TTDbFileModel file,\n    void Function(int percentage)? onProgress,\n    required int surahID,\n    required TafseerType tafseerType,\n    required CancelToken cancelToken,\n  });\n  Future<void> deleteTafseerDatabase({required String fileName});\n  List<String> getAvailableTafseers();\n  Future<void> saveAvailableTafseers({required Set<String> availableTafseers, required String newItem});\n  Future<void> selectTafseer({required TTDbFileModel file, required int surahID, required TafseerType tafseerType});\n  Future<void> deleteAvailableTafseer({required TTDbFileModel file});\n  Future<Set<String>> getSelectedTafseers();\n  Future<void> saveSelectedTafseers(Set<String> selectedTafseers);\n  Future<void> saveSelectedTabIndex(int index);\n  Future<int> getSelectedTabIndex();\n  Future<void> saveAvailableItemsCount(int count);\n  Future<int> fetchAvailableItemsCount();\n}"}, {"structure_type": "function", "name": "getSubjects", "docstring": "", "module": "subjects", "file_path": "domain/repositories/subjects/subject_repository.dart", "file_name": "subject_repository.dart", "line": 4, "line_from": 4, "line_to": 6, "snippet": "  Future<List<SubjectEntity>> getSubjects({required String language});\n  Future<SubjectEntity?> getSubjectById({required int id, required String language});\n}"}, {"structure_type": "function", "name": "doneFirstTime", "docstring": "", "module": "user_data", "file_path": "domain/repositories/user_data/user_data_repository.dart", "file_name": "user_data_repository.dart", "line": 13, "line_from": 13, "line_to": 129, "snippet": "  Future<void> doneFirstTime();\n\n  Future<bool> determineFirstRun();\n\n  Future<bool> needsMigration();\n\n  Future<List<BookmarkEntity>> getAllBookmarks();\n\n  Future<UpdateInfoEntity> fetchUpdateInfo();\n\n  Future<List<BookmarkFolderEntity>> syncBookmarksWithRemote(); \n  Future<List<PinEntity>> syncPinsWithRemote();\n  Future<List<NoteEntity>> syncNotesWithRemote();\n\n  Future<void> logAnalyticsEvent({\n    required String name,\n    required Map<String, Object>? parameters,\n  });\n\n  Future<void> migrateOldBookmarks();\n\n  Future<void> saveSortOption({required SortOptionEntity option});\n\n  Future<SortOptionEntity?> getSavedSortOption();\n\n  Future<void> addAyahToBookmarkFolder({\n    required BookmarkEntity bookmark,\n    bool saveToRemote = true,\n  });\n\n  Future<void> saveCollections({\n    required List<BookmarkEntity> bookmarks,\n    List<MemorizationPlanEntity>? memorizationPlans,\n    List<PinEntity>? pins,\n    List<NoteEntity>? notes,\n  });\n\n  Future<bool> askForReviewIfAllowed({\n    required VoidCallback askForReview,\n  });\n\n  Future<void> saveNeedsMigration();\n\n  Future<void> updateBookmark({\n    required String folderName,\n    required String newFolderName,\n    required Color color,\n  });\n\n  Future<void> deleteAyahFromBookmarks({\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n  });\n\n  Future<void> deleteBookmarkFolder({\n    required BookmarkFolderEntity folder,\n  });\n\n  Future<List<BookmarkFolderEntity>> getAllBookmarkFolders();\n\n  Future<List<BookmarkEntity>> getAyahListByBookmarkFolder({required String folderName});\n\n  Future<BookmarkFolderEntity?> getBookmarkFolder({\n    required String folderName,\n  });\n\n  Future<List<BookmarkFolderEntity>> getBookmarkFolderBySurahAndAyah({\n    required int surahID,\n    required int ayahID,\n  });\n\n  Future<void> syncCollectionsWithRemote();\n\n  Future<void> saveBookmarksToAyah({\n    required int surahID,\n    required int ayahID,\n    required List<BookmarkEntity> bookmarks,\n  });\n\n  Future<void> deleteAyahFromBookmarkFolder({\n    required int surahID,\n    required int ayahID,\n    required BookmarkFolderEntity folder,\n  });\n\n  Future<void> saveLastRead({required LastReadEntity lastRead});\n\n  Future<List<LastReadEntity>> getLastReads();\n\n  Future<List<LastReadEntity>> deleteLastReads({\n    required List<int> deletedItem,\n  });\n\n  Future<void> savePinSortOption({required SortOptionEntity option});\n\n  Future<SortOptionEntity?> getPinSortOption();\n\n  Future<void> saveNoteSortOption({required SortOptionEntity option});\n\n  Future<SortOptionEntity?> getNoteSortOption();\n\n  Future<List<MemorizationPlanEntity>> getAllMemorizationPlans();\n\n  Future<List<PinEntity>> getAllPins();\n  Future<List<NoteEntity>> getAllNotes();\n\n  Future<void> addPin({\n    required PinEntity pin,\n    bool saveToRemote = true,\n  });\n\n  Future<void> addNote({\n    required NoteEntity note,\n    bool saveToRemote = true,\n  });\n}"}, {"structure_type": "function", "name": "getReciters", "docstring": "", "module": "reciter", "file_path": "domain/repositories/reciter/reciter_repository.dart", "file_name": "reciter_repository.dart", "line": 4, "line_from": 4, "line_to": 11, "snippet": "  Future<List<Reciter>> getReciters();\n  Future<List<Reciter>> loadRecitersList();\n  Future<void> saveSelectedReciter(Reciter reciter);\n  Future<Reciter> getSelectedReciter();\n  Future<void> saveReciterWithSurahId(int surahId, Reciter reciter, {bool isDelete = false});\n  Future<List<int>> getSurahIdsForReciter(Reciter reciter);\n  Future<void> saveDownloadCount(int reciterId, int count);\n}"}, {"structure_type": "function", "name": "isExternalDbAvailable", "docstring": "Check if a specific external database is available", "module": "external_db", "file_path": "domain/repositories/external_db/external_db_repository.dart", "file_name": "external_db_repository.dart", "line": 9, "line_from": 9, "line_to": 64, "snippet": "  Future<bool> isExternalDbAvailable(String dbName);\n\n  /// Download an external database\n  Future<Either<String, bool>> downloadExternalDb({\n    required String dbName,\n    required String url,\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n}\n\n/// Implementation of ExternalDbRepository\nclass ExternalDbRepositoryImpl implements ExternalDbRepository {\n  static const String _tag = 'ExternalDbRepositoryImpl';\n  final Map<String, CancelToken> _cancelTokens = {};\n\n  @override\n  Future<bool> isExternalDbAvailable(String dbName) async {\n    try {\n      return await ExternalDbFactory.doesExternalDbExist(dbName);\n    } catch (e) {\n      Logger.error('Error checking if external DB is available: $e', _tag);\n      return false;\n    }\n  }\n\n  @override\n  Future<Either<String, bool>> downloadExternalDb({\n    required String dbName,\n    required String url,\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      _cancelTokens[dbName] = cancelToken;\n\n      final result = await ExternalDbFactory.downloadExternalDb(\n        dbName: dbName,\n        url: url,\n        onProgress: onProgress,\n        isCancelled: () => cancelToken.isCancelled,\n      );\n\n      if (result) {\n        return right(true);\n      } else {\n        return left('Failed to download or validate the database');\n      }\n    } catch (e) {\n      Logger.error('Error downloading external DB: $e', _tag);\n      return left('Error downloading database: $e');\n    } finally {\n      _cancelTokens.remove(dbName);\n    }\n  }\n}"}, {"structure_type": "function", "name": "getTextMushafDatabaseFile", "docstring": "Retrieves the File object representing the database file location.", "module": "mushaf", "file_path": "domain/repositories/mushaf/i_text_mushaf_local_data_source.dart", "file_name": "i_text_mushaf_local_data_source.dart", "line": 8, "line_from": 8, "line_to": 24, "snippet": "  Future<File> getTextMushafDatabaseFile();\n\n  /// Checks if the Text Mushaf database file exists on the device.\n  Future<bool> isTextMushafDatabaseAvailable();\n\n  /// Gets layout information for a specific page from a specified layout table.\n  Future<List<dynamic>> getLayoutForPage({required int pageNumber, required String layoutTableName});\n\n  /// Gets words within a specific range (based on word_number_all).\n  Future<List<TextWordEntry>> getWordsForRange({required int rangeStart, required int rangeEnd});\n\n  /// Gets words for a specific Ayah.\n  Future<List<TextWordEntry>> getWordsForAyah({required int surahNumber, required int ayahNumber});\n\n  /// Debug method to query a layout table for a specific page\n  Future<List<dynamic>> debugQueryLayoutTable({required String tableName, required int pageNumber});\n}"}, {"structure_type": "function", "name": "downloadMushaf", "docstring": "", "module": "mushaf", "file_path": "domain/repositories/mushaf/mushaf_repository.dart", "file_name": "mushaf_repository.dart", "line": 5, "line_from": 5, "line_to": 11, "snippet": "  Future<void> downloadMushaf(String mushafName, {ProgressCallback? onProgress, CancelToken? cancelToken});\n  Future<String> extractMushaf(String mushafName);\n  Future<bool> isMushafDownloaded(String mushafName);\n  Future<String> getMushafDirectory(String mushafName);\n  Future<void> saveLastReadPage(String mushafName, int pageNumber);\n  Future<int?> getLastReadPage(String mushafName);\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "mushaf", "file_path": "domain/repositories/mushaf/text_mushaf_repository.dart", "file_name": "text_mushaf_repository.dart", "line": 9, "line_from": 9, "line_to": 16, "snippet": "    void Function(int received, int total)? onProgress,\n    CancelToken? cancelToken,\n  });\n\n  Future<List<TextLayoutEntity>> getTextLayoutForPage({\n    required int pageNumber,\n    required String layoutType, // e.g., 'indopak_13', 'qpc_v2'\n  });"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "mushaf", "file_path": "domain/repositories/mushaf/text_mushaf_repository.dart", "file_name": "text_mushaf_repository.dart", "line": 37, "line_from": 37, "line_to": 47, "snippet": "    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  /// Download a batch of fonts for multiple pages\n  Future<void> downloadPageFontBatch({\n    required List<int> pageNumbers,\n    void Function(int completed, int total)? onBatchProgress,\n    void Function(int pageNumber, double progress)? onFontProgress,\n    required CancelToken cancelToken,\n  });"}, {"structure_type": "function", "name": "getAllPins", "docstring": "", "module": "collections", "file_path": "domain/repositories/collections/pin_repository.dart", "file_name": "pin_repository.dart", "line": 4, "line_from": 4, "line_to": 27, "snippet": "  Future<List<PinEntity>> getAllPins();\n\n  Future<PinEntity?> getPinBySurah({required int surahId});\n\n  Future<PinEntity?> getPinByName({required String name});\n\n  Future<void> addPin({\n    required PinEntity pin,\n    bool saveToRemote = true,\n  });\n\n  Future<void> deletePin({\n    required String name,\n  });\n\n  Future<void> updatePin({\n    required int surahId,\n    required int ayahNumber,\n    required String name,\n    required String color,\n  });\n\n  Future<List<PinEntity>> syncPinsWithRemote();\n}"}, {"structure_type": "function", "name": "getAllNotes", "docstring": "", "module": "collections", "file_path": "domain/repositories/collections/note_repository.dart", "file_name": "note_repository.dart", "line": 4, "line_from": 4, "line_to": 29, "snippet": "  Future<List<NoteEntity>> getAllNotes();\n\n  Future<List<NoteEntity>> getNotesBySurah({required int surahId});\n\n  Future<NoteEntity?> getNoteByAyah({required int surahId, required int ayahNumber});\n\n  Future<NoteEntity?> getNoteBySurah({required int surahId});\n\n  Future<void> addNote({\n    required NoteEntity note,\n    bool saveToRemote = true,\n  });\n\n  Future<void> deleteNote({required int surahId, required int ayahNumber});\n\n  Future<void> updateNote({\n    required String title,\n    required int surahId,\n    required int ayahNumber,\n    required String content,\n    required String color,\n  });\n\n  Future<void> syncNotesWithRemote();\n\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "grammar", "file_path": "domain/use_cases/grammar/download_grammar_database_use_case.dart", "file_name": "download_grammar_database_use_case.dart", "line": 18, "line_from": 18, "line_to": 25, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    return mapResultToEither(() => _repository.downloadGrammarDatabase(\n          onProgress: onProgress,\n          cancelToken: cancelToken,\n        ));\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "collection", "file_path": "domain/use_cases/collection/import_collections.dart", "file_name": "import_collections.dart", "line": 24, "line_from": 24, "line_to": 110, "snippet": "  Future<Either<String, String>> execute(String collectionJsonString) async {\n    return mapResultToEither(() async {\n      try {\n        _validateFile(collectionJsonString);\n\n        final Map<String, dynamic> jsonData = jsonDecode(collectionJsonString);\n        if (!jsonData.containsKey('data')) {\n          throw Exception('Invalid file format: Missing \"data\" field');\n        }\n\n        final (bookmarks, plans, pins, notes) = await compute(_parseCollections, collectionJsonString);\n\n        await _userDataRepository.saveCollections(\n          bookmarks: bookmarks,\n          memorizationPlans: plans,\n          pins: pins,\n          notes: notes,\n        );\n\n        return \"Your collections have been imported successfully.\";\n      } catch (e) {\n        showMessage(message: \"Import failed: ${e.toString()}\\nPlease make sure you're using a valid backup file.\");\n        throw Exception(\"Import failed: ${e.toString()}\");\n      }\n    });\n  }\n\n  void _validateFile(String collectionJsonString) {\n    if (collectionJsonString.isEmpty) throw Exception(\"The file is empty.\");\n\n    try {\n      final decoded = jsonDecode(collectionJsonString);\n      if (decoded is! Map<String, dynamic>) {\n        throw Exception(\"Invalid JSON format: Root must be an object\");\n      }\n    } catch (e) {\n      throw Exception(\"Invalid JSON format: ${e.toString()}\");\n    }\n  }\n}\n\nFuture<(List<BookmarkEntity>, List<MemorizationPlanEntity>, List<PinEntity>, List<NoteEntity>)> _parseCollections(\n    String collectionJsonString) async {\n  final Map<String, dynamic> collectionMap = jsonDecode(collectionJsonString) as Map<String, dynamic>;\n\n  if (!collectionMap.containsKey(\"data\")) {\n    throw Exception(\"Invalid file format: Missing 'data' field\");\n  }\n\n  final Map<String, dynamic> data = collectionMap['data'] as Map<String, dynamic>;\n\n  // Create separate JSON strings for bookmarks, plans and pins\n  final String bookmarksJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'bookmarks': data['bookmarks'] ?? [],\n  });\n\n  final String plansJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'memorization_plans': data['memorization_plans'] ?? [],\n  });\n\n  final String pinsJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'pins': data['pins'] ?? [],\n  });\n\n  final String notesJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'notes': data['notes'] ?? [],\n  });\n\n  try {\n    final List<BookmarkEntity> bookmarks = await convertJsonToBookmarks(bookmarksJson);\n    final List<MemorizationPlanEntity> plans = await convertJsonToMemorizationPlans(plansJson);\n    final List<PinEntity> pins = await convertJsonToPins(pinsJson);\n    final List<NoteEntity> notes = await convertJsonToNotes(notesJson);\n\n    return (bookmarks, plans, pins, notes);\n  } catch (e) {\n    throw Exception(\"Error parsing collections: $e\");\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "collection", "file_path": "domain/use_cases/collection/export_collections.dart", "file_name": "export_collections.dart", "line": 20, "line_from": 20, "line_to": 59, "snippet": "  Future<Either<String, String>> execute() async {\n    return mapResultToEither(() async {\n      try {\n        final List<BookmarkEntity> bookmarks = await _userDataRepository.getAllBookmarks();\n        final List<MemorizationPlanEntity> plans = await _userDataRepository.getAllMemorizationPlans();\n        final List<PinEntity> pins = await _userDataRepository.getAllPins();\n        final List<NoteEntity> notes = await _userDataRepository.getAllNotes();\n\n        final String exportData = await compute(\n          _generateExportData,\n          (bookmarks, plans, pins, notes),\n        );\n\n        return exportData;\n      } catch (e) {\n     showMessage(message: e.toString());\n        throw Exception(\"Failed to export collections.\");\n      }\n    });\n  }\n}\n\nFuture<String> _generateExportData(\n  (List<BookmarkEntity>, List<MemorizationPlanEntity>, List<PinEntity>, List<NoteEntity>) collections,\n) async {\n  final (bookmarks, plans, pins, notes) = collections;\n\n  final Map<String, dynamic> exportData = {\n    'version': 1,\n    'last_updated': DateTime.now().toIso8601String(),\n    'data': {\n      'bookmarks': bookmarks.map((b) => b.toJson()).toList(),\n      'memorization_plans': plans.map((p) => p.toJson()).toList(),\n      'pins': pins.map((p) => p.toJson()).toList(),\n      'notes': notes.map((n) => n.toJson()).toList(),\n    },\n  };\n\n  return jsonEncode(exportData);\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "pins", "file_path": "domain/use_cases/collection/pins/sort_pin_use_case.dart", "file_name": "sort_pin_use_case.dart", "line": 19, "line_from": 19, "line_to": 42, "snippet": "  Future<Either<String, List<PinEntity>>> execute({\n    required SortOptionEntity option,\n    required List<PinEntity> pins,\n  }) async {\n    return mapResultToEither(() async {\n      final List<PinEntity> sortedPins = await compute(_sortPins, SortParams(option, pins));\n      return sortedPins;\n    });\n  }\n}\n\nList<PinEntity> _sortPins(SortParams params) {\n  final option = params.option;\n  final pins = params.pins;\n\n  switch (option.type) {\n    case SortOptionType.name:\n      return _sortByName(pins);\n    case SortOptionType.createdDate:\n      return _sortByCreatedAt(pins);\n    case SortOptionType.updatedDate:\n      return _sortByUpdatedAt(pins);\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "notes", "file_path": "domain/use_cases/collection/notes/sort_note_use_case.dart", "file_name": "sort_note_use_case.dart", "line": 19, "line_from": 19, "line_to": 42, "snippet": "  Future<Either<String, List<NoteEntity>>> execute({\n    required SortOptionEntity option,\n    required List<NoteEntity> notes,\n  }) async {\n    return mapResultToEither(() async {\n      final List<NoteEntity> sortedNotes = await compute(_sortNotes, SortParams(option, notes));\n      return sortedNotes;\n    });\n  }\n}\n\nList<NoteEntity> _sortNotes(SortParams params) {\n  final option = params.option;\n  final notes = params.notes;\n\n  switch (option.type) {\n    case SortOptionType.name:\n      return _sortByName(notes);\n    case SortOptionType.createdDate:\n      return _sortByCreatedAt(notes);\n    case SortOptionType.updatedDate:\n      return _sortByUpdatedAt(notes);\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "bookmarks", "file_path": "domain/use_cases/collection/bookmarks/search_bookmark.dart", "file_name": "search_bookmark.dart", "line": 12, "line_from": 12, "line_to": 36, "snippet": "  Future<Either<String, List<BookmarkFolderEntity>>> execute({\n    required String query,\n    required List<BookmarkFolderEntity> allFolders,\n  }) async {\n    return mapResultToEither(() async {\n      return _searchLock.synchronized(() async {\n        if (query.isEmpty) return allFolders;\n        final List<BookmarkFolderEntity> filteredFolders =\n            await compute(_filterFolderByQuery, (allFolders, query));\n        return filteredFolders;\n      });\n    });\n  }\n}\n\nFuture<List<BookmarkFolderEntity>> _filterFolderByQuery(\n  (List<BookmarkFolderEntity>, String) param,\n) async {\n  final (allFolders, query) = param;\n  final String normalizedQuery = query.trim().toLowerCase();\n\n  return allFolders.where((folder) => \n    folder.name.toLowerCase().contains(normalizedQuery)\n  ).toList();\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "bookmarks", "file_path": "domain/use_cases/collection/bookmarks/sort_bookmark.dart", "file_name": "sort_bookmark.dart", "line": 19, "line_from": 19, "line_to": 45, "snippet": "  Future<Either<String, List<BookmarkFolderEntity>>> execute({\n    required SortOptionEntity option,\n    required List<BookmarkFolderEntity> folders,\n  }) async {\n    return mapResultToEither(() async {\n      // Use compute with SortParams\n      final List<BookmarkFolderEntity> sortedBookmarks =\n          await compute(_sortBookmarks, SortParams(option, folders));\n      return sortedBookmarks;\n    });\n  }\n}\n\n// Update the sorting function to accept SortParams\nList<BookmarkFolderEntity> _sortBookmarks(SortParams params) {\n  final option = params.option;\n  final folders = params.folders;\n\n  switch (option.type) {\n    case SortOptionType.name:\n      return _sortByName(folders);\n    case SortOptionType.createdDate:\n      return _sortByCreatedAt(folders);\n    case SortOptionType.updatedDate:\n      return _sortByUpdatedAt(folders);\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "bookmarks", "file_path": "domain/use_cases/collection/bookmarks/save_bookmarks_to_ayah.dart", "file_name": "save_bookmarks_to_ayah.dart", "line": 16, "line_from": 16, "line_to": 56, "snippet": "  Future<Either<String, String>> execute({\n    required int surahID,\n    required int ayahID,\n    required List<BookmarkFolderEntity> savingFolders,\n  }) async {\n    return mapResultToEither(() async {\n      final List<BookmarkEntity> generatedBookmarks =\n          await _mapBookmarkFoldersIntoBookmarks(savingFolders, surahID, ayahID);\n      await _userDataRepository.saveBookmarksToAyah(\n        surahID: surahID,\n        ayahID: ayahID,\n        bookmarks: generatedBookmarks,\n      );\n      return savingFolders.isNotEmpty ? \"Collection saved\" : \"\";\n    });\n  }\n\n  Future<List<BookmarkEntity>> _mapBookmarkFoldersIntoBookmarks(\n    List<BookmarkFolderEntity> folders,\n    int surahID,\n    int ayahID,\n  ) async {\n    final List<BookmarkEntity> bookmarks = await compute(\n      _mapBookmarkFoldersIntoBookmarksPure,\n      (folders, surahID, ayahID),\n    );\n    return bookmarks;\n  }\n}\n\nList<BookmarkEntity> _mapBookmarkFoldersIntoBookmarksPure(\n  (List<BookmarkFolderEntity>, int, int) param,\n) {\n  final (folders, surahID, ayahID) = param;\n  final List<BookmarkEntity> generatedBookmarks = folders\n      .map(\n        (folder) => _mapBookmarkFolderToBookmark(folder: folder, surahID: surahID, ayahID: ayahID),\n      )\n      .toList();\n  return generatedBookmarks;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation", "file_path": "domain/use_cases/translation/get_non_default_use_case.dart", "file_name": "get_non_default_use_case.dart", "line": 15, "line_from": 15, "line_to": 23, "snippet": "    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) {\n    return mapResultToEither(() => _translationRepository.getNonDefaultTranslation(\n          file: file,\n          onProgress: onProgress,\n          cancelToken: cancelToken,\n        ));\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "corpus", "file_path": "domain/use_cases/corpus/get_corpus_data_use_case.dart", "file_name": "get_corpus_data_use_case.dart", "line": 16, "line_from": 16, "line_to": 34, "snippet": "  Future<List<CorpusTableData>> execute(GetCorpusDataParams params) async {\n    return getRight(\n      () => repository.getCorpusData(\n        suraId: params.suraId,\n        ayahId: params.ayahId,\n      ),\n    );\n  }\n}\n\nclass GetCorpusDataParams {\n  final int suraId;\n  final int ayahId;\n\n  GetCorpusDataParams({\n    required this.suraId,\n    required this.ayahId,\n  });\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "subjectwise", "file_path": "domain/use_cases/subjectwise/get_subject_by_id_usecase.dart", "file_name": "get_subject_by_id_usecase.dart", "line": 16, "line_from": 16, "line_to": 32, "snippet": "  Future<Either<String, SubjectEntity?>> execute({required GetSubjectByIdParams params}) async {\n    return mapResultToEither(() => _repository.getSubjectById(\n          id: params.id,\n          language: params.language,\n        ));\n  }\n}\n\nclass GetSubjectByIdParams {\n  final int id;\n  final String language;\n\n  const GetSubjectByIdParams({\n    required this.id,\n    required this.language,\n  });\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "info", "file_path": "domain/use_cases/info/get_drawer_information.dart", "file_name": "get_drawer_information.dart", "line": 14, "line_from": 14, "line_to": 50, "snippet": "  Future<Either<String, String>> execute({\n    required DrawerInfo info,\n  }) async =>\n      mapResultToEither(() async => _getText(info));\n\n  Future<String> _getText(DrawerInfo info) async {\n    switch (info) {\n      case DrawerInfo.sadaqahJariah:\n        return _infoRepository.getSadaqahJariah();\n      case DrawerInfo.privacyPolicy:\n        return _infoRepository.getPrivacyPolicy();\n      case DrawerInfo.aboutUs:\n        return _infoRepository.getAboutUs();\n      case DrawerInfo.thanksAndCredit:\n        return _infoRepository.getThanksAndCredit();        \n      case DrawerInfo.contactUs:\n        return _infoRepository.getContactUs();      \n      case DrawerInfo.aboutTafsir:\n        return _infoRepository.getAboutTafsir();      \n      case DrawerInfo.helpUs:\n        return _infoRepository.getHelpUs();\n      case DrawerInfo.aboutApp:\n        return _infoRepository.getAboutApp();   \n    }\n  }\n}\n\nenum DrawerInfo {\n  sadaqahJariah,\n  privacyPolicy,\n  aboutUs,\n  thanksAndCredit,\n  contactUs,\n  aboutTafsir,\n  helpUs,\n  aboutApp,\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "audio", "file_path": "domain/use_cases/audio/download_and_save_audio_location_use_case.dart", "file_name": "download_and_save_audio_location_use_case.dart", "line": 15, "line_from": 15, "line_to": 26, "snippet": "    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) {\n    return mapResultToEither(() async {\n      await _audioRepository.downloadAudioFiles(\n        surahID: surahID,\n        reciter: reciter,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    });\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "tafseer", "file_path": "domain/use_cases/tafseer/get_tafseer_use_case.dart", "file_name": "get_tafseer_use_case.dart", "line": 19, "line_from": 19, "line_to": 33, "snippet": "    void Function(int percentage)? onProgress,\n    required int surahID,\n    required TafseerType tafseerType,\n    required CancelToken cancelToken,\n  }) async {\n    return mapResultToEither(\n      () async => _tafseerRepository.getTafseer(\n        file: file,\n        onProgress: onProgress,\n        surahID: surahID,\n        tafseerType: tafseerType,\n        cancelToken: cancelToken,\n      ),\n    );\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "word_by_word", "file_path": "domain/use_cases/word_by_word/get_words_for_multiple_ayahs_use_case.dart", "file_name": "get_words_for_multiple_ayahs_use_case.dart", "line": 15, "line_from": 15, "line_to": 36, "snippet": "  Future<Either<String, List<WordByWordEntity>>> execute({\n    required List<int> surahNumbers,\n    required List<int> ayahNumbers,\n  }) async {\n    return mapResultToEither(() async {\n      return await _repository.getWordsForMultipleAyahs(\n        surahNumbers: surahNumbers,\n        ayahNumbers: ayahNumbers,\n      );\n    });\n  }\n}\n\nclass GetWordsForMultipleAyahsParams {\n  final List<int> surahNumbers;\n  final List<int> ayahNumbers;\n\n  GetWordsForMultipleAyahsParams({\n    required this.surahNumbers,\n    required this.ayahNumbers,\n  });\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word", "file_path": "domain/use_cases/word_by_word/download_wbw_language_use_case.dart", "file_name": "download_wbw_language_use_case.dart", "line": 15, "line_from": 15, "line_to": 23, "snippet": "    required void Function(int) onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    return mapResultToEither(() => _repository.downloadWbwLanguage(\n          wbwFile,\n          onProgress,\n          cancelToken,\n        ));\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "text_mushaf", "file_path": "domain/use_cases/text_mushaf/get_words_for_range_text_mushaf_use_case.dart", "file_name": "get_words_for_range_text_mushaf_use_case.dart", "line": 14, "line_from": 14, "line_to": 33, "snippet": "  Future<Either<String, List<TextWordEntity>>> execute({required GetWordsForRangeParams params}) async {\n\n      final List<TextWordEntity> words = await _repository.getWordsForRange(\n        rangeStart: params.rangeStart,\n        rangeEnd: params.rangeEnd,\n      );\n      return Right(words);\n    \n  }\n}\n\nclass GetWordsForRangeParams {\n  final int rangeStart;\n  final int rangeEnd;\n\n  const GetWordsForRangeParams({\n    required this.rangeStart,\n    required this.rangeEnd,\n  });\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "text_mushaf", "file_path": "domain/use_cases/text_mushaf/initialize_text_mushaf_database_use_case.dart", "file_name": "initialize_text_mushaf_database_use_case.dart", "line": 17, "line_from": 17, "line_to": 24, "snippet": "    void Function(int received, int total)? onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    return mapResultToEither(() => _repository.initializeDatabase(\n          onProgress: onProgress,\n          cancelToken: cancelToken,\n        ));\n  }"}, {"structure_type": "class", "name": "CopyEntity", "docstring": "", "module": "ui", "file_path": "domain/entities/ui/copy_entity.dart", "file_name": "copy_entity.dart", "line": 1, "line_from": 1, "line_to": 32, "snippet": "class CopyEntity {\n  final String arabicText;\n  final String translationText;\n  final CopyType copyType;\n  final int startAyah;\n  final int endAyah;\n  final String surahName;\n\n  const CopyEntity({\n    required this.arabicText,\n    required this.translationText,\n    required this.copyType,\n    required this.startAyah,\n    required this.endAyah,\n    required this.surahName,\n  });\n\n  String get formattedText {\n    switch (copyType) {\n      case CopyType.normalCopy:\n        return arabicText;\n      case CopyType.translationCopy:\n        return translationText;\n      case CopyType.arabicCopy:\n        return arabicText;\n    }\n  }\n}\n\nenum CopyType { normalCopy, translationCopy, arabicCopy }\n"}, {"structure_type": "class", "name": "SettingsStateEntity extends Equatable", "docstring": "", "module": "settings", "file_path": "domain/entities/settings/setting_state_entity.dart", "file_name": "setting_state_entity.dart", "line": 5, "line_from": 5, "line_to": 168, "snippet": "class SettingsStateEntity extends Equatable {\n  const SettingsStateEntity({\n    required this.showArabic,\n    required this.showTranslation,\n    required this.arabicFontSize,\n    required this.localFontSize,\n    required this.arabicFontScript,\n    required this.arabicFont,\n    required this.keepScreenOn,\n    required this.showWordByWord,\n    required this.tafseerFontSize,\n    required this.showDailyNotification,\n    required this.dailyNotificationTime,\n    required this.currentThemeName,\n    required this.currentLanguage,\n    required this.fontFamily,\n    required this.fontSize,\n    required this.showTajweed,\n  });\n\n  factory SettingsStateEntity.empty() {\n    return const SettingsStateEntity(\n      showArabic: true,\n      showTranslation: true,\n      arabicFontSize: 27,\n      localFontSize: 15,\n      arabicFontScript: ArabicFontScript.uthmani,\n      arabicFont: ArabicFonts.kfgq,\n      keepScreenOn: false,\n      showWordByWord: false,\n      tafseerFontSize: 15,\n      showDailyNotification: true,\n      dailyNotificationTime: TimeOfDay(hour: 9, minute: 0),\n      currentThemeName: 'Light',\n      currentLanguage: 'English',\n      fontFamily: FontFamily.inter,\n      fontSize: 14,\n      showTajweed: false,\n    );\n  }\n\n  final bool showArabic;\n  final bool showTranslation;\n  final double arabicFontSize;\n  final double localFontSize;\n  final ArabicFontScript arabicFontScript;\n  final ArabicFonts arabicFont;\n  final bool keepScreenOn;\n  final bool showWordByWord;\n  final double tafseerFontSize;\n  final bool showDailyNotification;\n  final TimeOfDay dailyNotificationTime;\n  final String currentThemeName;\n  final String currentLanguage;\n  final String fontFamily;\n  final double fontSize;\n  final bool showTajweed;\n\n  @override\n  List<Object?> get props => [\n        showArabic,\n        showTranslation,\n        arabicFontSize,\n        localFontSize,\n        arabicFontScript,\n        arabicFont,\n        keepScreenOn,\n        showWordByWord,\n        tafseerFontSize,\n        showDailyNotification,\n        dailyNotificationTime,\n        currentThemeName,\n        currentLanguage,\n        fontFamily,\n        fontSize,\n        showTajweed,\n      ];\n\n  SettingsStateEntity copyWith({\n    bool? showArabic,\n    bool? showTranslation,\n    double? arabicFontSize,\n    double? localFontSize,\n    ArabicFontScript? arabicFontScript,\n    ArabicFonts? arabicFont,\n    bool? keepScreenOn,\n    bool? showWordByWord,\n    double? tafseerFontSize,\n    bool? showDailyNotification,\n    TimeOfDay? dailyNotificationTime,\n    String? currentThemeName,\n    String? currentLanguage,\n    String? fontFamily,\n    double? fontSize,\n    bool? showTajweed,\n  }) {\n    return SettingsStateEntity(\n      showArabic: showArabic ?? this.showArabic,\n      showTranslation: showTranslation ?? this.showTranslation,\n      arabicFontSize: arabicFontSize ?? this.arabicFontSize,\n      localFontSize: localFontSize ?? this.localFontSize,\n      arabicFontScript: arabicFontScript ?? this.arabicFontScript,\n      arabicFont: arabicFont ?? this.arabicFont,\n      keepScreenOn: keepScreenOn ?? this.keepScreenOn,\n      showWordByWord: showWordByWord ?? this.showWordByWord,\n      tafseerFontSize: tafseerFontSize ?? this.tafseerFontSize,\n      showDailyNotification:\n          showDailyNotification ?? this.showDailyNotification,\n      dailyNotificationTime:\n          dailyNotificationTime ?? this.dailyNotificationTime,\n      currentThemeName: currentThemeName ?? this.currentThemeName,\n      currentLanguage: currentLanguage ?? this.currentLanguage,\n      fontFamily: fontFamily ?? this.fontFamily,\n      fontSize: fontSize ?? this.fontSize,\n      showTajweed: showTajweed ?? this.showTajweed,\n    );\n  }\n}\n\nenum ArabicFontScript { uthmani, indoPak }\n\nenum ArabicFonts {\n  kfgq,\n  meQuran,\n  kitab,\n  alQalamQuranMajeed,\n  amiriQuran,\n  lateef,\n  nooreHira,\n  nooreHuda,\n  indoPakNastaleeq,\n  uthmani,\n  husrevHatti,\n}\n\nMap<ArabicFonts, String> arabicFontToFontFamilyMap = {\n  ArabicFonts.kfgq: FontFamily.kfgq,\n  ArabicFonts.meQuran: FontFamily.meQuran,\n  ArabicFonts.kitab: FontFamily.kitab,\n  ArabicFonts.alQalamQuranMajeed: FontFamily.alQalamQuranMajeed,\n  ArabicFonts.amiriQuran: FontFamily.amiriQuran,\n  ArabicFonts.lateef: FontFamily.lateef,\n  ArabicFonts.nooreHira: FontFamily.nooreHira,\n  ArabicFonts.nooreHuda: FontFamily.nooreHuda,\n  ArabicFonts.indoPakNastaleeq: FontFamily.indoPakNastaleeq,\n  ArabicFonts.uthmani: FontFamily.uthmani,\n  ArabicFonts.husrevHatti: FontFamily.husrevHatti,\n};\n\nMap<ArabicFonts, String> arabicFontToNameMap = {\n  ArabicFonts.kfgq: \"KFGQ\",\n  ArabicFonts.meQuran: \"MeQuran\",\n  ArabicFonts.kitab: \"Kitab\",\n  ArabicFonts.alQalamQuranMajeed: \"Al Qalam Quran Majeed\",\n  ArabicFonts.amiriQuran: \"Amiri Quran\",\n  ArabicFonts.lateef: \"Lateef\",\n  ArabicFonts.nooreHira: \"Noore Hira\",\n  ArabicFonts.nooreHuda: \"Noore Huda\",\n  ArabicFonts.indoPakNastaleeq: \"IndoPak Nastaleeq\",\n  ArabicFonts.uthmani: \"Uthmani\",\n  ArabicFonts.husrevHatti: \"Husrev Hatti\",\n};\n"}, {"structure_type": "class", "name": "AnnouncementEntity extends Equatable", "docstring": "", "module": "notification", "file_path": "domain/entities/notification/announcement_entity.dart", "file_name": "announcement_entity.dart", "line": 5, "line_from": 5, "line_to": 35, "snippet": "class AnnouncementEntity extends Equatable {\n  const AnnouncementEntity({\n    required this.ayahList,\n    required this.promotionalMessage,\n    required this.announcementType,\n  });\n\n  factory AnnouncementEntity.empty() => AnnouncementEntity(\n        ayahList: const [\n        ],\n        promotionalMessage: PromotionalMessageEntity.empty(),\n        announcementType: AnnouncementType.ayah,\n      );\n\n  final List<DailyAyah> ayahList;\n  final PromotionalMessageEntity? promotionalMessage;\n  final AnnouncementType announcementType;\n\n  @override\n  List<Object?> get props => [ayahList, promotionalMessage, announcementType];\n\n  AnnouncementEntity close() => AnnouncementEntity(\n        ayahList: ayahList,\n        promotionalMessage: null,\n        announcementType: AnnouncementType.ayah,\n      );\n}\n\nenum AnnouncementType { ayah, promotionalMessage }\n"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "widgets", "file_path": "presentation/settings/widgets/custom_slider.dart", "file_name": "custom_slider.dart", "line": 35, "line_from": 35, "line_to": 202, "snippet": "  void initState() {\n    super.initState();\n    _currentSliderValue = widget.defaultValue;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final Color activeColor = widget.activeColor ?? context.color.primaryColor;\n    final Color inactiveColor =\n        widget.inactiveColor ?? activeColor.withOpacityInt(0.35);\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(\n          widget.title,\n          style: theme.textTheme.bodyMedium!.copyWith(\n            fontWeight: FontWeight.w600,\n            color: isDarkMode(context)\n                ? context.color.subtitleColor\n                : context.color.blackColor,\n          ),\n        ),\n        gapH10,\n        Row(\n          children: [\n            Expanded(\n              child: SliderTheme(\n                data: SliderTheme.of(context).copyWith(\n                  // valueIndicatorTextStyle: TextStyle(\n                  //   color: context.color.primaryColor,\n                  //   fontSize: bodyMediumFontSize,\n                  //   fontWeight: FontWeight.w600,\n                  // ),\n                  // valueIndicatorShape: AbovePointerSliderValueIndicatorShape(\n                  //   valueStyle: TextStyle(\n                  //     color: context.color.primaryColor,\n                  //     fontSize: bodyMediumFontSize,\n                  //     fontWeight: FontWeight.w600,\n                  //   ),\n                  //   context: context,\n                  // ),\n                  // showValueIndicator: ShowValueIndicator.always,\n                  trackHeight: _trackHeight,\n                  activeTrackColor: activeColor,\n                  inactiveTrackColor: inactiveColor,\n                  thumbColor: activeColor,\n                  thumbShape:\n                      const RoundSliderThumbShape(enabledThumbRadius: 5),\n                  overlayShape:\n                      const RoundSliderOverlayShape(overlayRadius: 12),\n                  tickMarkShape: SliderTickMarkShape.noTickMark,\n                  trackShape: CustomTrackShape(trackHeight: _trackHeight),\n                ),\n                child: Slider(\n                  value: _currentSliderValue,\n                  min: widget.min,\n                  max: widget.max,\n                  label: _currentSliderValue\n                      .round()\n                      .toString()\n                      .toLocalizedNumber(context),\n                  onChanged: (double value) {\n                    setState(() {\n                      _currentSliderValue = value;\n                    });\n                    widget.onChanged(value);\n                  },\n                ),\n              ),\n            ),\n            gapW5,\n            Container(\n              alignment: Alignment.centerRight,\n              width: 20,\n              child: Text(\n                _currentSliderValue\n                    .round()\n                    .toString()\n                    .toLocalizedNumber(context),\n                style: TextStyle(\n                  fontSize: 13,\n                  fontWeight: FontWeight.w600,\n                  color: theme.primaryColor,\n                ),\n              ),\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n\n// CustomTrackShape to customize track height\nclass CustomTrackShape extends SliderTrackShape {\n  final double trackHeight;\n\n  const CustomTrackShape({required this.trackHeight});\n\n  @override\n  Rect getPreferredRect({\n    required RenderBox parentBox,\n    Offset offset = Offset.zero,\n    required SliderThemeData sliderTheme,\n    bool isEnabled = false,\n    bool isDiscrete = false,\n  }) {\n    final double trackHeight = sliderTheme.trackHeight ?? this.trackHeight;\n\n    final double trackLength = parentBox.size.width;\n\n    final Rect trackRect = Rect.fromLTWH(\n      offset.dx,\n      offset.dy + (parentBox.size.height - trackHeight) / 2,\n      trackLength,\n      trackHeight,\n    );\n\n    return trackRect;\n  }\n\n  @override\n  void paint(\n    PaintingContext context,\n    Offset offset, {\n    required RenderBox parentBox,\n    required SliderThemeData sliderTheme,\n    required Animation<double> enableAnimation,\n    required Offset thumbCenter,\n    bool isEnabled = false,\n    bool isDiscrete = false,\n    TextDirection? textDirection,\n    Offset? secondaryOffset,\n  }) {\n    final Paint activePaint = Paint()..color = sliderTheme.activeTrackColor!;\n    final Paint inactivePaint = Paint()\n      ..color = sliderTheme.inactiveTrackColor!;\n\n    final double trackHeight = sliderTheme.trackHeight ?? this.trackHeight;\n    final double trackRadius = trackHeight / 2;\n    final double trackLength = parentBox.size.width;\n\n    final RRect activeTrackRRect = RRect.fromRectAndRadius(\n      Rect.fromLTWH(\n        offset.dx,\n        thumbCenter.dy - trackRadius,\n        thumbCenter.dx - offset.dx,\n        trackHeight,\n      ),\n      Radius.circular(trackRadius),\n    );\n\n    final RRect inactiveTrackRRect = RRect.fromRectAndRadius(\n      Rect.fromLTWH(\n        thumbCenter.dx,\n        thumbCenter.dy - (trackHeight / 2),\n        trackLength - thumbCenter.dx,\n        trackHeight,\n      ),\n      Radius.circular(trackHeight / 2),\n    );\n\n    context.canvas.drawRRect(activeTrackRRect, activePaint);\n    context.canvas.drawRRect(inactiveTrackRRect, inactivePaint);\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "mini_settings", "file_path": "presentation/settings/widgets/mini_settings/mini_settings_drawer.dart", "file_name": "mini_settings_drawer.dart", "line": 31, "line_from": 31, "line_to": 176, "snippet": "  Widget build(BuildContext context) {\n    final SettingsPresenter settingPresenter = locate();\n    final ThemeData themeData = Theme.of(context);\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      PageType pageType = PageType.settings;\n      if (isAyahPage) {\n        pageType = PageType.ayah;\n      } else if (isTafseerPage || showOnlyFontSettings) {\n        pageType = PageType.tafseer;\n      }\n      settingPresenter.initializeMiniSettings(pageType: pageType);\n    });\n\n    return Container(\n      margin: EdgeInsets.only(\n        top: MediaQuery.of(context).padding.top,\n      ),\n      height: double.infinity,\n      width: QuranScreen.width * 0.75,\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: ClipRRect(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.start,\n          children: [\n            const MiniSettingsTopBar(),\n            gapH5,\n            Expanded(\n              child: SingleChildScrollView(\n                child: Column(\n                  children: showOnlyFontSettings\n                      ? [\n                          FontSettingsCard(\n                            settingPresenter: settingPresenter,\n                            showTextReview: false,\n                            showTafseerFontSlider: showTafseerFontSlider,\n                          ),\n                        ]\n                      : [\n                          ContentSettingsCard(\n                            settingPresenter: settingPresenter,\n                            isFromSettingsPage: false,\n                          ),\n                          Padding(\n                            padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                            child: BuildDivider(\n                              theme: themeData,\n                            ),\n                          ),\n                          WordByWordSwitch(\n                            settingPresenter: settingPresenter,\n                            theme: themeData,\n                          ),\n                          Padding(\n                            padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                            child: BuildDivider(\n                              theme: themeData,\n                            ),\n                          ),\n                          FontSettingsCard(\n                            settingPresenter: settingPresenter,\n                            showTextReview: false,\n                          ),\n                        ],\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass MiniSettingsTopBar extends StatelessWidget {\n  const MiniSettingsTopBar({\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData themeData = Theme.of(context);\n    return Container(\n      padding: EdgeInsets.only(\n        left: twelvePx,\n        right: twelvePx,\n        top: twentyOnePx,\n      ),\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n          GestureDetector(\n            onTap: () => context.navigatorPop(),\n            child: Padding(\n              padding: paddingH6,\n              child: Icon(\n                Icons.arrow_forward_ios_rounded,\n                size: sixteenPx,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          gapW8,\n          Align(\n            alignment: Alignment.centerLeft,\n            child: Text(\n              context.l10n.quickTools,\n              style: themeData.textTheme.headlineSmall?.copyWith(\n                fontWeight: FontWeight.bold,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          const Spacer(),\n          GestureDetector(\n            onTap: () async {\n              await context.navigatorPush<void>(const SettingsPage());\n            },\n            child: SvgPicture.asset(\n              SvgPath.icSettings,\n              height: twentyOnePx,\n              colorFilter: buildColorFilter(isDarkMode(context)\n                  ? context.color.subtitleColor\n                  : context.color.primaryColor),\n            ),\n          ),\n          gapW10,\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word_language_selection_bottom_sheet", "file_path": "presentation/settings/widgets/word_by_word_language_selection_bottom_sheet/word_by_word_downloaded_items.dart", "file_name": "word_by_word_downloaded_items.dart", "line": 12, "line_from": 12, "line_to": 58, "snippet": "  final void Function({required String name})? onLanguageSelected;\n  final void Function({required String name})? onLanguageDelete;\n  final ThemeData theme;\n  const WordByWordDownloadedItems({\n    super.key,\n    required this.title,\n    required this.theme,\n    this.selectedLanguage,\n    this.downloadedLanguages,\n    this.onLanguageSelected,\n    this.onLanguageDelete,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Padding(\n          padding: EdgeInsets.symmetric(horizontal: sixteenPx),\n          child: SectionHeader(\n            theme: theme,\n            title:\n                '$title (${downloadedLanguages!.length.toLocalizedString(context)})',\n          ),\n        ),\n        ListView.builder(\n          shrinkWrap: true,\n          physics: const NeverScrollableScrollPhysics(),\n          itemCount: downloadedLanguages!.length,\n          padding: EdgeInsets.zero,\n          itemBuilder: (context, index) {\n            final String name = downloadedLanguages![index];\n\n            return WordByWordDownloadedSingleItem(\n              name: name,\n              isSelected: name == selectedLanguage,\n              onSelect: (String name) => onLanguageSelected?.call(name: name),\n              onDelete: (String name) => onLanguageDelete?.call(name: name),\n              theme: theme,\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word_language_selection_bottom_sheet", "file_path": "presentation/settings/widgets/word_by_word_language_selection_bottom_sheet/word_by_word_available_items.dart", "file_name": "word_by_word_available_items.dart", "line": 12, "line_from": 12, "line_to": 68, "snippet": "  final void Function({required String name})? onLanguageDownload;\n  final void Function({required String name})? onLanguageDelete;\n  final ThemeData theme;\n  final bool? isDownloading;\n  final String? activeDownloadId;\n  final int? downloadProgress;\n\n  const WordByWordAvailableItems({\n    super.key,\n    required this.title,\n    required this.items,\n    required this.theme,\n    this.selectedLanguage,\n    this.onLanguageDownload,\n    this.onLanguageDelete,\n    this.isDownloading,\n    this.activeDownloadId,\n    this.downloadProgress,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Padding(\n          padding: EdgeInsets.symmetric(horizontal: sixteenPx),\n          child: SectionHeader(\n            theme: theme,\n            title: '$title (${items.length.toLocalizedString(context)})',\n          ),\n        ),\n        ListView.builder(\n          shrinkWrap: true,\n          physics: const NeverScrollableScrollPhysics(),\n          itemCount: items.length,\n          padding: EdgeInsets.zero,\n          itemBuilder: (context, index) {\n            final WbwDbFileModel file = items[index];\n            final String name = file.name;\n            final String size = file.size;\n\n            return WordByWordAvailableSingleItem(\n              name: name,\n              onDownload: (String name) => onLanguageDownload?.call(name: name),\n              theme: theme,\n              isDownloading: isDownloading!,\n              size: size,\n              activeDownloadId: activeDownloadId,\n              downloadProgress: downloadProgress!,\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "notice", "file_path": "presentation/home/ui/notice/notice_dialog.dart", "file_name": "notice_dialog.dart", "line": 421, "line_from": 421, "line_to": 433, "snippet": "    required void Function(PromotionalMessageEntity) onClose,\n  }) async {\n    final bool? isClosed = await showAnimatedDialog<bool>(\n      context: context,\n      barrierDismissible: true,\n      builder: (context) => NoticeDialog(\n        payload: notice,\n      ),\n      animationType: DialogTransitionType.fadeScale,\n      curve: Curves.fastOutSlowIn,\n    );\n    if (isClosed ?? false) onClose(notice);\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "announcement", "file_path": "presentation/home/ui/announcement/carousel_item.dart", "file_name": "carousel_item.dart", "line": 24, "line_from": 24, "line_to": 69, "snippet": "  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: GestureDetector(\n        onTap: onTap,\n        child: _CarouselContent(\n          ayah: ayah,\n          surahName: surahName,\n          theme: theme,\n          context: context,\n        ),\n      ),\n    );\n  }\n}\n\nclass _CarouselContent extends StatelessWidget {\n  const _CarouselContent({\n    required this.ayah,\n    required this.surahName,\n    required this.theme,\n    required this.context,\n  });\n\n  final DailyAyah ayah;\n  final String surahName;\n  final ThemeData theme;\n  final BuildContext context;\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: QuranScreen.width - 70,\n      child: Text(\n        \"${ayah.text} \\n\\n [$surahName ${ayah.surahId.toLocalizedString(context)}:${ayah.ayahId.toLocalizedString(context)}]\",\n        overflow: TextOverflow.ellipsis,\n        maxLines: 7,\n        textAlign: TextAlign.center,\n        style: context.quranText.aText!.copyWith(\n          // color: context.color.whiteColor.withAlpha((0.7 * 255).toInt()),\n\n          height: 1.7,\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/home/presenter/home_presenter.dart", "file_name": "home_presenter.dart", "line": 125, "line_from": 125, "line_to": 135, "snippet": "    required void Function(UpdateInfoEntity) onForceUpdate,\n  }) async {\n    await Future<void>.delayed(4.inSeconds);\n    await parseDataFromEitherWithUserMessage(\n      task: () async => _determineIfNeedForceUpdate.execute(),\n      onDataLoaded: (updateInfo) {\n        final bool needForceUpdate = updateInfo.askToUpdate;\n        if (needForceUpdate) onForceUpdate(updateInfo);\n      },\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/home/presenter/home_presenter.dart", "file_name": "home_presenter.dart", "line": 320, "line_from": 320, "line_to": 334, "snippet": "    required void Function(String promotionUrl) onInternet,\n    required VoidCallback onNoInternet,\n  }) async {\n    final bool isNetworkAvailable = await checkInternetConnection();\n    if (!isNetworkAvailable) {\n      onNoInternet();\n      return;\n    }\n    const String appStoreUrl =\n        \"https://apps.apple.com/us/developer/md-saiful-islam-saif/id1238182913\";\n    const String playStoreUrl =\n        \"https://play.google.com/store/apps/dev?id=5689317609893757784\";\n    final String promotionUrl = Platform.isIOS ? appStoreUrl : playStoreUrl;\n    onInternet(promotionUrl);\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/home/presenter/home_presenter.dart", "file_name": "home_presenter.dart", "line": 367, "line_from": 367, "line_to": 375, "snippet": "    await Future<void>.delayed(5.inSeconds);\n    await _askReviewIfNecessary.execute(askForReview: askForReview);\n  }\n\n  @override\n  void onClose() {\n    _fetchAnnouncementsSub?.cancel();\n    super.onClose();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/home/widgets/home_page_fancy_background.dart", "file_name": "home_page_fancy_background.dart", "line": 12, "line_from": 12, "line_to": 48, "snippet": "  Widget build(BuildContext context) {\n    // used vector for improved rendering performance\n    return SvgPicture.asset(\n      SvgPath.imgBgHome,\n      height: 55.percentHeight,\n      width: 100.percentWidth,\n      colorFilter: buildColorFilterToChangeColor(\n          context.theme.bannerTheme.backgroundColor!.withOpacityInt(0.8)),\n    );\n  }\n}\n\nclass StartPageFancyBackgroundColor extends StatelessWidget {\n  const StartPageFancyBackgroundColor({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ClipPath(\n      clipper: OvalBottomBorderClipper(),\n      child: Container(\n        height: 55.percentHeight,\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            stops: const [0.0, 0.42, 1.0],\n            colors: [\n              context.color.gdTop,\n              context.color.gdMiddle,\n              context.color.gdBottom,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/home/widgets/page_list_widget.dart", "file_name": "page_list_widget.dart", "line": 24, "line_from": 24, "line_to": 119, "snippet": "  Widget build(BuildContext context) {\n    return ListView.builder(\n      padding: EdgeInsets.zero,\n      physics: const NeverScrollableScrollPhysics(),\n      shrinkWrap: true,\n      itemCount: pages.length,\n      itemBuilder: (context, index) {\n        final PageEntity page = pages[index];\n\n        return _buildPageListItem(\n          theme: theme,\n          pageNumber: page.id,\n          context: context,\n          surahName: getTranslatedSurahName(\n              surahNumber: page.startSurahNo, context: context),\n          pageInitialText: page.arabicInitial,\n          onTapPageItem: () async =>\n              await homePresenter.goToSurahDetailsPageWithSpecificAyah(\n            context: context,\n            surahIndex: page.startSurahNo - 1,\n            ayahIndex: page.startAyatNo - 1,\n            isNeedToJump: false,\n            showPageIndicator: true,\n          ),\n        );\n      },\n    );\n  }\n}\n\nOnTapWidget _buildPageListItem({\n  required ThemeData theme,\n  required int pageNumber,\n  required BuildContext context,\n  required String surahName,\n  required String pageInitialText,\n  required VoidCallback onTapPageItem,\n}) {\n  return OnTapWidget(\n    theme: theme,\n    onTap: onTapPageItem,\n    child: Container(\n      margin: EdgeInsets.symmetric(horizontal: twentyPx, vertical: sixteenPx),\n      child: Row(\n        children: [\n          ShowSurahNumberWidget(\n            formatSurahNumber: pageNumber.toLocalizedString(context),\n            theme: theme,\n          ),\n          gapW18,\n          SizedBox(\n            width: 35.percentWidth,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.start,\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(\n                  '${context.l10n.page} ${pageNumber.toLocalizedString(context)}',\n                  overflow: TextOverflow.ellipsis,\n                  style: theme.textTheme.titleLarge?.copyWith(\n                    fontWeight: FontWeight.w600,\n                  ),\n                ),\n                gapH4,\n                Text(\n                  surahName,\n                  overflow: TextOverflow.ellipsis,\n                  style: theme.textTheme.bodySmall!.copyWith(\n                    color: context.color.subtitleColor,\n                  ),\n                ),\n              ],\n            ),\n          ),\n          gapW15,\n          Flexible(\n            child: Align(\n              alignment: Alignment.centerRight,\n              child: Text(\n                pageInitialText,\n                overflow: TextOverflow.clip,\n                maxLines: 1,\n                textDirection: TextDirection.rtl,\n                style: context.quranText.arabicAyah!.copyWith(\n                  fontFamily: FontFamily.alQalamQuranMajeed,\n                  fontSize: nineteenPx,\n                  letterSpacing: 0,\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n    ),\n  );\n}"}, {"structure_type": "function", "name": "show", "docstring": "", "module": "ui", "file_path": "presentation/grammar/ui/grammar_bottom_sheet.dart", "file_name": "grammar_bottom_sheet.dart", "line": 31, "line_from": 31, "line_to": 220, "snippet": "  static Future<void> show({\n    required BuildContext context,\n    required List<WordByWordEntity> wordList,\n    required int selectedWordIndex,\n  }) async {\n    final GrammarPresenter grammarPresenter = locate<GrammarPresenter>();\n    final bool success = await grammarPresenter.loadCorpusDataAndPrepare(\n      suraId: wordList[selectedWordIndex].surah!,\n      ayahId: wordList[selectedWordIndex].ayah!,\n    );\n\n    if (!success || !context.mounted) return;\n\n    final GrammarBottomSheet grammarBottomSheet = GrammarBottomSheet(\n      key: const Key(\"GrammarBottomSheet\"),\n      wordList: wordList,\n      selectedWordIndex: selectedWordIndex,\n    );\n    await grammarPresenter.jumpToPage(selectedWordIndex);\n    if (context.mounted) {\n      await context.showBottomSheet<void>(grammarBottomSheet, context);\n    }\n  }\n\n  @override\n  State<GrammarBottomSheet> createState() => _GrammarBottomSheetState();\n}\n\nclass _GrammarBottomSheetState extends State<GrammarBottomSheet> {\n  late int currentWordIndex;\n\n  String _getTranslation(\n      WordByWordEntity word, GrammarPresenter grammarPresenter, int wordIndex) {\n    final WordByWordPresenter wordByWordPresenter =\n        locate<WordByWordPresenter>();\n    final String selectedLanguage =\n        wordByWordPresenter.currentUiState.selectedLanguage;\n\n    switch (selectedLanguage) {\n      case 'English':\n        return word.en ?? '';\n      case 'Bangla':\n        return word.bn ?? '';\n      default:\n        return CacheData\n                .wordByWordCache[selectedLanguage]?[word.surah ?? 0]\n                    ?[word.ayah ?? 0]?[wordIndex]\n                .translation ??\n            word.en ??\n            '';\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    currentWordIndex = widget.selectedWordIndex;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final GrammarPresenter grammarPresenter = locate<GrammarPresenter>();\n\n    return PresentableWidgetBuilder(\n      presenter: grammarPresenter,\n      builder: () {\n        final List<CorpusTableData> corpusData =\n            grammarPresenter.currentUiState.corpusData;\n\n        return Container(\n          decoration: decorateBottomSheet(context),\n          alignment: Alignment.topCenter,\n          height: QuranScreen.width * 1.1,\n          child: Column(\n            key: const Key('grammar_bottom_sheet'),\n            mainAxisSize: MainAxisSize.min,\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n              gapH20,\n              TitleSectionWidget(\n                pageController: grammarPresenter.pageController,\n                wordList: widget.wordList,\n                selectedWordIndex: currentWordIndex,\n              ),\n              gapH15,\n              Flexible(\n                child: PageView.builder(\n                  itemCount: corpusData.length,\n                  reverse: true,\n                  controller: grammarPresenter.pageController,\n                  onPageChanged: (int index) {\n                    setState(() {\n                      currentWordIndex = index;\n                    });\n                  },\n                  itemBuilder: (context, index) {\n                    final CorpusTableData word = corpusData[index];\n                    return Wrap(\n                      alignment: WrapAlignment.center,\n                      children: [\n                        Padding(\n                          padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                          child: Column(\n                            crossAxisAlignment: CrossAxisAlignment.center,\n                            children: [\n                              ArabicWordWidget(\n                                key: const Key(\"ArabicWordWidget\"),\n                                theme: theme,\n                                word: word,\n                              ),\n                              gapH20,\n                              WordPartsOfSpeechWidget(\n                                key: const Key(\"WordPartsOfSpeechWidget\"),\n                                theme: theme,\n                                pos1: word.pos1,\n                                pos2: word.pos2,\n                                pos3: word.pos3,\n                                pos4: word.pos4,\n                                pos5: word.pos5,\n                              ),\n                              gapH10,\n                              Text(\n                                key: const Key(\"TranslationText\"),\n                                _getTranslation(widget.wordList[index],\n                                    grammarPresenter, index),\n                                style: theme.textTheme.titleMedium!.copyWith(\n                                  fontWeight: FontWeight.w400,\n                                ),\n                              ),\n                              gapH20,\n                              if (word.rootAr != null) ...[\n                                ShowRootWordWidget(\n                                  key: const Key(\"ShowRootWordWidget\"),\n                                  title: context.l10n.rootWord,\n                                  subtitle: word.rootAr,\n                                  theme: theme,\n                                ),\n                                gapH6,\n                              ],\n                              if (word.lemma != null) ...[\n                                ShowRootWordWidget(\n                                  key: const Key(\"ShowLemmaDerivativeWidget\"),\n                                  title: context.l10n.lemmaDerivative,\n                                  subtitle: word.lemma!,\n                                  theme: theme,\n                                ),\n                                gapH10,\n                              ],\n                            ],\n                          ),\n                        ),\n                      ],\n                    );\n                  },\n                ),\n              ),\n              Padding(\n                padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                child: TwoWayActionButton(\n                  theme: theme,\n                  svgPictureForCancelButton: SvgImage(\n                    SvgPath.icMaximize,\n                    width: twentyPx,\n                    height: twentyPx,\n                    color: context.color.primaryColor,\n                  ),\n                  svgPictureForOkButton: SvgImage(\n                    SvgPath.icPlayCircle,\n                    width: twentyPx,\n                    height: twentyPx,\n                    color: context.color.primaryColor,\n                  ),\n                  submitButtonBgColor: context.color.secondaryButtonColor,\n                  submitButtonTextColor: context.color.primaryColor,\n                  cancelButtonTextColor: context.color.primaryColor,\n                  submitButtonTitle: context.l10n.playAudio,\n                  cancelButtonTitle: 'Click for More',\n                  onSubmitButtonTap: () async => await grammarPresenter.handleSubmitButtonTap(context, widget.wordList),\n                  onCancelButtonTap: () async => await grammarPresenter.handleClickForMore(context),\n                ),\n              ),\n              gapH30,\n            ],\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/grammar/widgets/verse_navigation.dart", "file_name": "verse_navigation.dart", "line": 32, "line_from": 32, "line_to": 134, "snippet": "  Widget build(BuildContext context) {\n    return Row(\n      mainAxisSize: MainAxisSize.min,\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        _NavigationButton(\n          onPressed: isFirstAyah ? null : onPreviousPressed,\n          text: 'Previous $previousVerse',\n          iconPath: SvgPath.icLeftArrow,\n          isNext: false,\n          theme: theme,\n          isDisabled: isFirstAyah,\n        ),\n        gapW12,\n        _NavigationButton(\n          onPressed: isLastAyah ? null : onNextPressed,\n          text: 'Next $nextVerse',\n          iconPath: SvgPath.icRightArrow,\n          isNext: true,\n          theme: theme,\n          isDisabled: isLastAyah,\n        ),\n      ],\n    );\n  }\n}\n\nclass _NavigationButton extends StatelessWidget {\n  const _NavigationButton({\n    required this.onPressed,\n    required this.text,\n    required this.iconPath,\n    required this.isNext,\n    required this.theme,\n    required this.isDisabled,\n  });\n\n  final VoidCallback? onPressed;\n  final String text;\n  final String iconPath;\n  final bool isNext;\n  final ThemeData theme;\n  final bool isDisabled;\n\n  @override\n  Widget build(BuildContext context) {\n    return OnTapWidget(\n      onTap: isDisabled ? null : onPressed,\n      theme: theme,\n      borderRadius: BorderRadius.circular(thirtySevenPx),\n      child: Container(\n        alignment: Alignment.center,\n        constraints: BoxConstraints(\n          minWidth: 41.percentWidth,\n        ),\n        decoration: BoxDecoration(\n          color: isDisabled\n              ? context.color.secondaryButtonColor.withOpacityInt(0.5)\n              : context.color.secondaryButtonColor,\n          borderRadius: BorderRadius.circular(thirtySevenPx),\n        ),\n        padding: EdgeInsets.symmetric(horizontal: fourteenPx, vertical: tenPx),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            if (!isNext)\n              SvgImage(\n                iconPath,\n                width: twentyPx,\n                height: twentyPx,\n                color: isDisabled\n                    ? context.color.subtitleColor\n                    : context.color.blackColor,\n              ),\n            if (!isNext) gapW8,\n            Flexible(\n              child: Text(\n                text,\n                maxLines: 1,\n                style: theme.textTheme.bodyMedium!.copyWith(\n                  fontWeight: FontWeight.normal,\n                  overflow: TextOverflow.ellipsis,\n                  color: isDisabled ? context.color.subtitleColor : null,\n                ),\n              ),\n            ),\n            if (isNext) gapW8,\n            if (isNext)\n              SvgImage(\n                iconPath,\n                width: twentyPx,\n                height: twentyPx,\n                color: isDisabled\n                    ? context.color.subtitleColor\n                    : context.color.blackColor,\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "conflicts", "docstring": "", "module": "presenter", "file_path": "presentation/memorization/presenter/memorization_presenter.dart", "file_name": "memorization_presenter.dart", "line": 425, "line_from": 425, "line_to": 459, "snippet": "    // Create a unique notification ID based on plan name to avoid conflicts\n    final int notificationId = currentState.planName.hashCode.abs() % 100000;\n\n    final NotificationContent content = NotificationContent(\n      id: notificationId,\n      channelKey: memorizationNotificationChannelKey,\n      title: 'Memorization Reminder',\n      body:\n          'Time to practice your Quran memorization: ${currentState.planName}',\n      category: NotificationCategory.Reminder,\n      backgroundColor: QuranColor.primaryColorLight,\n      color: QuranColor.primaryColorLight,\n      notificationLayout: NotificationLayout.Default,\n      payload: {\n        'type': 'memorization_plan',\n        'plan_name': currentState.planName\n      },\n    );\n\n    final NotificationCalendar schedule = NotificationCalendar(\n      hour: time.hour,\n      minute: time.minute,\n      second: 0,\n      millisecond: 0,\n      timeZone: timeZone,\n      repeats: true,\n      allowWhileIdle: true,\n      preciseAlarm: true,\n    );\n\n    await _awesomeNotifications.createNotification(\n      content: content,\n      schedule: schedule,\n    );\n  }"}, {"structure_type": "function", "name": "progress;", "docstring": "", "module": "widgets", "file_path": "presentation/memorization/widgets/memorization_plan_card.dart", "file_name": "memorization_plan_card.dart", "line": 29, "line_from": 29, "line_to": 164, "snippet": "  final Future<double> progress;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: EdgeInsets.symmetric(horizontal: twentyPx, vertical: sixPx),\n      child: OnTapWidget(\n        onTap: onTap,\n        theme: theme,\n        child: Container(\n          decoration: BoxDecoration(\n            borderRadius: radius15,\n            border: Border.all(color: context.color.borderColor, width: 1),\n          ),\n          child: Padding(\n            padding: padding15,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                MemorizationPlanTopRow(\n                  planName: plan.planName,\n                  theme: theme,\n                  memorizationPresenter: memorizationPresenter,\n                  plan: plan,\n                ),\n                gapH20,\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    Expanded(\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          DaysLeftText(\n                            daysLeft: plan.estimatedDays,\n                            theme: theme,\n                          ),\n                          gapH20,\n                          PlanInfoRow(\n                            iconPath: SvgPath.icStar,\n                            text: getCurrentLanguage(context) ==\n                                    LanguageType.bangla.code\n                                ? '${plan.startSurahId.toLocalizedString(context)}:${plan.startAyahId.toLocalizedString(context)} ${context.l10n.from} ${plan.endSurahId.toLocalizedString(context)}:${plan.endAyahId.toLocalizedString(context)}'\n                                : '${context.l10n.from} ${plan.startSurahId.toLocalizedString(context)}:${plan.startAyahId.toLocalizedString(context)} - ${plan.endSurahId.toLocalizedString(context)}:${plan.endAyahId.toLocalizedString(context)}',\n                            theme: theme,\n                          ),\n                          gapH8,\n                          FutureBuilder<String>(\n                              future: memorizationPresenter.getCurrentProgress(\n                                  plan.planName, context),\n                              builder: (context, snapshot) {\n                                return PlanInfoRow(\n                                  iconPath: SvgPath.icGraduate,\n                                  text: snapshot.data ?? context.l10n.loading,\n                                  theme: theme,\n                                );\n                              }),\n                          gapH8,\n                          PlanInfoRow(\n                            iconPath: plan.hasNotification\n                                ? SvgPath.icVolumeHigh\n                                : SvgPath.icVolumeSlash,\n                            text: plan.hasNotification &&\n                                    plan.notificationTime != null\n                                ? '${DateFormat('h:mm a').format(plan.notificationTime!)} ${context.l10n.daily}'\n                                : context.l10n.turnedOff,\n                            theme: theme,\n                          ),\n                          gapH8,\n                          PlanInfoRow(\n                            iconPath: SvgPath.icClock,\n                            text:\n                                '${context.l10n.endsIn} ${DateFormat('MMM dd, yyyy').format(plan.createdAt.add(Duration(days: plan.estimatedDays)))}',\n                            theme: theme,\n                          ),\n                        ],\n                      ),\n                    ),\n                    SizedBox(\n                      width: 26.percentWidth,\n                      child: FutureBuilder<double>(\n                        key: Key(plan.planName),\n                        future: progress,\n                        builder: (context, snapshot) {\n                          return ProgressCircle(\n                            theme: theme,\n                            progress: snapshot.data ?? 0.0,\n                            text: context.l10n.completed,\n                          );\n                        },\n                      ),\n                    )\n                  ],\n                )\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass DaysLeftText extends StatelessWidget {\n  const DaysLeftText({\n    super.key,\n    required this.daysLeft,\n    required this.theme,\n  });\n\n  final int daysLeft;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    return RichText(\n      text: TextSpan(\n        children: [\n          TextSpan(\n            text: '${daysLeft.toLocalizedString(context)} ',\n            style: theme.textTheme.headlineLarge!.copyWith(\n              fontWeight: FontWeight.bold,\n            ),\n          ),\n          TextSpan(\n            text: context.l10n.daysLeft,\n            style: theme.textTheme.labelSmall!.copyWith(\n              color: context.color.subtitleColor,\n              fontWeight: FontWeight.w400,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/memorization/widgets/memorzation_search_widget.dart", "file_name": "memorzation_search_widget.dart", "line": 15, "line_from": 15, "line_to": 66, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return Container(\n      height: isMobile ? 40.px : 25.px,\n      margin: EdgeInsets.symmetric(horizontal: isMobile ? twentyPx : tenPx),\n      padding: EdgeInsets.symmetric(vertical: 0.px),\n      alignment: Alignment.centerLeft,\n      child: TextFormField(\n        //contextMenuBuilder: fixedLightContextMenu,\n\n        textAlignVertical: TextAlignVertical.center,\n        onTapOutside: (event) => FocusScope.of(context).unfocus(),\n        textAlign: TextAlign.left,\n        controller: textEditingController,\n\n        decoration: InputDecoration(\n          contentPadding: padding4,\n          filled: true,\n          hintText: hintText,\n          fillColor: context.color.primaryColor.withOpacityInt(0.12),\n          hintStyle: theme.textTheme.bodySmall!.copyWith(\n            color: context.color.primaryColor,\n          ),\n          enabledBorder: _determineFormFieldRadius(),\n          border: _determineFormFieldRadius(),\n          disabledBorder: _determineFormFieldRadius(),\n          focusedBorder: _determineFormFieldRadius(),\n          prefixIcon: Padding(\n            padding: isMobile ? padding12 : padding8,\n            child: SvgPicture.asset(\n              SvgPath.icSearch,\n              // height: twentyPx,\n              // width: twentyPx,\n              colorFilter: buildColorFilterToChangeColor(\n                context.color.primaryColor,\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nOutlineInputBorder _determineFormFieldRadius() => _borderRadius();\n\nOutlineInputBorder _borderRadius() {\n  return OutlineInputBorder(\n    borderRadius: isMobile ? radius8 : radius4,\n    borderSide: BorderSide.none,\n  );\n}"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "services", "file_path": "presentation/notification/services/notification_service_utilities.dart", "file_name": "notification_service_utilities.dart", "line": 20, "line_from": 20, "line_to": 50, "snippet": "      await Future<void>.delayed(manualDelayDuration, run);\n    });\n  }\n\n  static Duration _determineManualDelayDuration(int addedDayCount) =>\n      addedDayCount == 0 ? 3.inSeconds : Duration(seconds: Random().nextInt(3) + addedDayCount);\n\n  static int get notificationScheduleDayCount => Random(DateTime.now().millisecondsSinceEpoch).nextInt(65) + 31;\n\n  static NotificationContent buildNotificationContent({\n    required int notificationId,\n    required String channelKey,\n    required Map<String, String?> payload,\n  }) {\n    final String notificationTitle = payload[\"title\"] ?? \"\";\n    final String notificationBody = payload[\"body\"] ?? \"\";\n    final bool invalidNotification = notificationTitle.isEmpty || notificationBody.isEmpty;\n    if (invalidNotification) throw InvalidNotificationException();\n\n    return NotificationContent(\n      id: notificationId,\n      channelKey: channelKey,\n      title: notificationTitle,\n      body: notificationBody,\n      category: NotificationCategory.Recommendation,\n      backgroundColor: QuranColor.primaryColorLight,\n      notificationLayout: NotificationLayout.BigText,\n      payload: payload,\n      \n    );\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/daily_ayah/presenter/daily_ayah_presenter.dart", "file_name": "daily_ayah_presenter.dart", "line": 91, "line_from": 91, "line_to": 99, "snippet": "    return Future<void>.delayed(const Duration(milliseconds: 120), () {\n      uiState.value = currentUiState.copyWith(errorMessage: \"\");\n    });\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/last_read/presenter/last_read_presenter.dart", "file_name": "last_read_presenter.dart", "line": 87, "line_from": 87, "line_to": 115, "snippet": "    await Future<void>.delayed(1.inSeconds);\n    await getLastReadList();\n  }\n\n  Future<void> deleteSelectedLastReads(BuildContext context) async {\n    if (currentUiState.isSelected.isEmpty) {\n      addUserMessage(context.l10n.selectAnItem);\n      return;\n    }\n    await RemoveDialog.show(\n      onRemove: () async {\n        final List<int> selectedItem =\n            Set<int>.from(currentUiState.isSelected).toList();\n        final List<LastReadEntity> result =\n            await _deleteLastReadUseCase.execute(deletedItem: selectedItem);\n\n        uiState.value = uiState.value.copyWith(\n          isSelected: {},\n          lastReadList: result,\n          checkBox: result.isNotEmpty,\n        );\n        if (context.mounted && result.isEmpty) {\n          context.navigatorPop();\n        }\n      },\n      context: context,\n      title: context.l10n.lastRead,\n    );\n  }"}, {"structure_type": "function", "name": "Future.microtask", "docstring": "", "module": "presenter", "file_path": "presentation/search/presenter/search_presenter.dart", "file_name": "search_presenter.dart", "line": 576, "line_from": 576, "line_to": 592, "snippet": "    final Widget resultPage = await Future.microtask(\n      () => SearchResultPage(\n        query: currentUiState.searchQuery,\n        searchPresenter: this,\n      ),\n    );\n    Get.to(() => resultPage);\n  }\n\n  void clearSearchAndError() {\n    uiState.value = currentUiState.copyWith(\n      userMessage: null,\n      showSearchFieldError: false,\n      showDatabaseError: false,\n    );\n    queryController.clear();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "common", "file_path": "presentation/common/custom_bottom_sheet_container.dart", "file_name": "custom_bottom_sheet_container.dart", "line": 29, "line_from": 29, "line_to": 114, "snippet": "  Widget build(BuildContext context) {\n    return CustomStatusBarColor(\n      statusBarColor: statusBarColor ?? Colors.transparent,\n      navigationBarColor: context.color.backgroundColor,\n      statusBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      navigationBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      child: Container(\n        width: double.infinity,\n        constraints: constraints,\n        decoration: decorateBottomSheet(context),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            if (bottomSheetTitle != null) ...[\n              BottomSheetHeader(\n                title: bottomSheetTitle!,\n                theme: theme,\n              ),\n              gapH5,\n            ],\n            Padding(\n              padding: showPadding\n                  ? EdgeInsets.only(\n                      bottom: twentyPx,\n                      left: twentyPx,\n                      right: twentyPx,\n                    )\n                  : EdgeInsets.zero,\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  showPadding ? const SizedBox.shrink() : gapH10,\n                  ...children,\n                  gapH10,\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass BottomSheetHeader extends StatelessWidget {\n  BottomSheetHeader({\n    super.key,\n    required this.title,\n    required this.theme,\n  });\n\n  final String title;\n  final ThemeData theme;\n  late final SettingsPresenter settingsPresenter = locate<SettingsPresenter>();\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      width: double.infinity,\n      decoration: BoxDecoration(\n        color: context.color.inputColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n      child: Padding(\n        padding: EdgeInsets.symmetric(\n          vertical: seventeenPx,\n          horizontal: twentyPx,\n        ),\n        child: Text(\n          title,\n          overflow: TextOverflow.ellipsis,\n          maxLines: 1,\n          style: theme.textTheme.headlineSmall?.copyWith(\n              color: context.color.primaryColor,\n              fontFamily: settingsPresenter.getAppFontFamily()),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "widgets", "file_path": "presentation/common/widgets/custom_fade_scrollbar.dart", "file_name": "custom_fade_scrollbar.dart", "line": 6, "line_from": 6, "line_to": 136, "snippet": "  final Widget child;\n  final Color? scrollbarColor;\n  final double scrollbarWidth;\n  final double scrollbarRadius;\n  final Duration fadeOutDuration;\n  final Duration fadeInDuration;\n  final Duration idleDuration;\n\n  const CustomFadeScrollbar({\n    super.key,\n    required this.child,\n    this.scrollbarColor,\n    this.scrollbarWidth = 8.0,\n    this.scrollbarRadius = 4.0,\n    this.fadeOutDuration = const Duration(milliseconds: 300),\n    this.fadeInDuration = const Duration(milliseconds: 150),\n    this.idleDuration = const Duration(milliseconds: 600),\n  });\n\n  @override\n  State<CustomFadeScrollbar> createState() => _CustomFadeScrollbarState();\n}\n\nclass _CustomFadeScrollbarState extends State<CustomFadeScrollbar> with SingleTickerProviderStateMixin {\n  late AnimationController _fadeController;\n  late Animation<double> _fadeAnimation;\n  Timer? _fadeoutTimer;\n  ScrollController? _scrollController;\n  bool _isDragging = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _fadeController = AnimationController(\n      vsync: this,\n      duration: widget.fadeOutDuration,\n    );\n    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(\n        parent: _fadeController,\n        curve: Curves.easeInOut,\n      ),\n    );\n\n    // Start with scrollbar hidden\n    _fadeController.reverse();\n  }\n\n  @override\n  void dispose() {\n    _fadeoutTimer?.cancel();\n    _fadeController.dispose();\n    _scrollController?.dispose();\n    super.dispose();\n  }\n\n  bool _handleScrollNotification(ScrollNotification notification) {\n    final ScrollMetrics metrics = notification.metrics;\n    if (metrics.maxScrollExtent <= metrics.minScrollExtent) {\n      return false;\n    }\n\n    if (notification is ScrollStartNotification || notification is ScrollUpdateNotification) {\n      _showScrollbar();\n    } else if (notification is ScrollEndNotification) {\n      _hideScrollbarAfterIdle();\n    }\n    return false;\n  }\n\n  void _showScrollbar() {\n    _fadeoutTimer?.cancel();\n    _fadeController.duration = widget.fadeInDuration;\n    _fadeController.forward();\n  }\n\n  void _hideScrollbarAfterIdle() {\n    _fadeoutTimer?.cancel();\n    _fadeoutTimer = Timer(widget.idleDuration, () {\n      if (mounted && !_isDragging) {\n        _fadeController.duration = widget.fadeOutDuration;\n        _fadeController.reverse();\n      }\n    });\n  }\n\n  void _onPointerDown(PointerDownEvent event) {\n    _isDragging = true;\n    _showScrollbar();\n  }\n\n  void _onPointerUp(PointerUpEvent event) {\n    _isDragging = false;\n    _hideScrollbarAfterIdle();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return NotificationListener<ScrollNotification>(\n      onNotification: _handleScrollNotification,\n      child: Stack(\n        children: [\n          widget.child,\n          Positioned.fill(\n            child: IgnorePointer(\n              ignoring: false,\n              child: Listener(\n                onPointerDown: _onPointerDown,\n                onPointerUp: _onPointerUp,\n                child: FadeTransition(\n                  opacity: _fadeAnimation,\n                  child: Container(\n                    alignment: Alignment.centerRight,\n                    child: Container(\n                      width: widget.scrollbarWidth,\n                      margin: const EdgeInsets.only(right: 2.0),\n                      decoration: BoxDecoration(\n                        color: widget.scrollbarColor ?? Theme.of(context).colorScheme.onSurface.withOpacityInt(0.4),\n                        borderRadius: BorderRadius.circular(widget.scrollbarRadius),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "_onSearchQueryChanged", "docstring": "", "module": "presenter", "file_path": "presentation/audio/reciter/presenter/reciter_presenter.dart", "file_name": "reciter_presenter.dart", "line": 57, "line_from": 57, "line_to": 511, "snippet": "  void _onSearchQueryChanged() {\n    Debounce.debounce(\"surahSearching\", 300.inMilliseconds, () async {\n      final query = surahNameSearchController.text.trim().toLowerCase();\n      uiState.value = uiState.value.copyWith(searchQuery: query);\n    });\n  }\n\n  void _onReciterSearchQueryChanged() {\n    final query = reciterSearchController.text.trim().toLowerCase();\n    Debounce.debounce(\"reciterSearching\", 300.inMilliseconds, () async {\n      try {\n        final List<Reciter> allReciters =\n            await _getRecitersFromDatabaseUseCase.call();\n\n        List<Reciter> filteredReciters = List.from(allReciters);\n\n        if (query.isNotEmpty) {\n          filteredReciters = allReciters\n              .where((reciter) => reciter.name.toLowerCase().contains(query))\n              .toList();\n        }\n\n        // Remove the currently selected reciter from the filtered list\n        filteredReciters\n            .removeWhere((r) => r.id == currentUiState.selectedReciter.id);\n        filteredReciters.sort((a, b) => a.name.compareTo(b.name));\n\n        // Force UI update by creating a new state\n        if (!uiState.value.isLoading) {\n          uiState.value = currentUiState.copyWith(\n            availableRecitersForDownload: filteredReciters,\n            searchQuery: query,\n          );\n        }\n      } catch (e) {\n        addUserMessage(\"Error filtering reciters: $e\");\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    surahNameSearchController.removeListener(_onSearchQueryChanged);\n    reciterSearchController.removeListener(_onReciterSearchQueryChanged);\n    surahNameSearchController.dispose();\n    reciterSearchController.dispose();\n    super.dispose();\n  }\n\n  List<int> get filteredSurahIndices {\n    if (currentUiState.searchQuery.isEmpty) {\n      return List.generate(CacheData.surahsCache.length, (i) => i);\n    } else {\n      return CacheData.surahsCache\n          .asMap()\n          .entries\n          .where((entry) =>\n              entry.value.nameEn\n                  .toLowerCase()\n                  .contains(currentUiState.searchQuery) ||\n              entry.value.nameBn\n                  .toLowerCase()\n                  .contains(currentUiState.searchQuery) ||\n              entry.value.serial\n                  .toString()\n                  .toLowerCase()\n                  .contains(currentUiState.searchQuery))\n          .map((entry) => entry.key)\n          .toList();\n    }\n  }\n\n  ReciterUiState get currentUiState => uiState.value;\n  final Map<int, bool> _isProcessingSurah = {}; // Map to track Surah processing\n  Future<void> downloadSurahAudio(\n      {required int surahIndex,\n      required Reciter reciter,\n      required BuildContext context}) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet && context.mounted) {\n      await showMessage(message: context.l10n.noInternetConnection);\n      return;\n    }\n\n    if (_isProcessingSurah[surahIndex] ?? false) {\n      cancelDownload();\n      _isProcessingSurah[surahIndex] = false;\n      if (context.mounted) addUserMessage(context.l10n.downloadCancelled);\n\n      updateUiState(\n          isDownloading: false,\n          currentDownloadingSurahIndex: null,\n          downloadProgress: 0,\n          downloadCancelToken: null,\n          activeDownloadId: null);\n      _cancelTokens.remove(currentUiState.activeDownloadId);\n      return;\n    }\n\n    if (_isProcessingSurah.containsValue(true) && context.mounted) {\n      addUserMessage(context.l10n.downloadInProgress);\n      return;\n    }\n\n    _isProcessingSurah[surahIndex] = true;\n\n    try {\n      _initializeDownloadProcess();\n      await fetchAudioFilesAndVerseTimings([surahIndex], reciter);\n      updateUiState(\n          isDownloading: true,\n          currentDownloadingSurahIndex: surahIndex,\n          currentDownloadingReciterId: reciter.id,\n          downloadCancelToken: CancelToken(),\n          downloadProgress: 0);\n\n      final connectivitySubscription = await monitorNetworkConnectivity(\n        context,\n        onConnectionLost: () {\n          addUserMessage(context.l10n.noInternetConnection);\n        },\n        onConnectionRestored: () {\n          addUserMessage(context.l10n.internetConnectionRestored);\n        },\n      );\n\n      final result = await _downloadAndSaveAudioLocationUseCase.execute(\n        surahID: surahIndex,\n        reciter: reciter,\n        onProgress: updateDownloadProgress,\n        cancelToken: currentUiState.downloadCancelToken!,\n      );\n\n      // Cancel connectivity subscription\n      await connectivitySubscription.cancel();\n\n      await result.fold(\n        (failure) => processDownloadFailure(),\n        (_) async {\n          if (!currentUiState.downloadCancelToken!.isCancelled) {\n            await processDownloadSuccess(reciter, context);\n            await loadDownloadCounts();\n          }\n        },\n      );\n    } catch (e) {\n      addUserMessage(\"Failed to download surah: $e\");\n    } finally {\n      _isProcessingSurah[surahIndex] = false;\n      _cancelTokens.remove(currentUiState.activeDownloadId);\n      updateUiState(\n          isDownloading: false,\n          currentDownloadingSurahIndex: null,\n          downloadProgress: 0,\n          currentDownloadingReciterId: null,\n          downloadCancelToken: null,\n          activeDownloadId: null);\n    }\n  }\n\n  Future<void> deleteAudioFilesBySurahAndReciter(\n      {required int surahNumber, required Reciter reciter}) async {\n    final result = await _deleteAudioBySurahAndReciter.execute(\n      surahNumber: surahNumber,\n      reciter: reciter,\n    );\n    await result.fold(\n      (failure) async => await addUserMessage(failure),\n      (_) async {\n        await addUserMessage('Audio deleted successfully');\n        await updateDownloadCountsAndReciters(reciter, surahNumber,\n            isDelete: true);\n      },\n    );\n  }\n\n  void updateDownloadProgress(int percentage) {\n    updateUiState(downloadProgress: percentage);\n  }\n\n  Future<void> processDownloadFailure() async {\n    addUserMessage('Failed to download surah');\n    updateUiState(isDownloading: false);\n  }\n\n  Future<void> processDownloadSuccess(\n      Reciter reciter, BuildContext context) async {\n    if (context.mounted) addUserMessage(context.l10n.surahDownloaded);\n    await updateDownloadCountsAndReciters(\n        reciter, currentUiState.currentDownloadingSurahIndex!);\n    updateUiState(isDownloading: false, downloadProgress: 0);\n  }\n\n  void _initializeDownloadProcess() {\n    final String downloadId = DateTime.now().millisecondsSinceEpoch.toString();\n    final CancelToken cancelToken = CancelToken();\n    _cancelTokens[downloadId] = cancelToken;\n    uiState.value = currentUiState.copyWith(\n      downloadCancelToken: cancelToken,\n      activeDownloadId: downloadId,\n    );\n  }\n\n  void cancelDownload() {\n    if (currentUiState.isDownloading! &&\n        currentUiState.downloadCancelToken != null) {\n      currentUiState.downloadCancelToken!.cancel();\n      if (currentUiState.activeDownloadId != null) {\n        _cancelTokens.remove(currentUiState.activeDownloadId);\n      }\n      uiState.value = uiState.value.copyWith(\n        isDownloading: false,\n        downloadProgress: 0,\n        currentDownloadingSurahIndex: null,\n        currentDownloadingReciterId: null,\n        downloadCancelToken: null,\n        activeDownloadId: null,\n      );\n    }\n  }\n\n  Future<void> fetchAudioFilesAndVerseTimings(\n      List<int> totalSurahs, Reciter reciter) async {\n    await _fetchAudioFilesAndVerseTimingsUseCase.execute(totalSurahs, reciter);\n  }\n\n  Future<void> updateDownloadCountsAndReciters(Reciter reciter, int surahId,\n      {bool isDelete = false}) async {\n    Map<int, int> currentCounts =\n        Map<int, int>.from(currentUiState.downloadedSurahCounts ?? {});\n    List<int> surahIds = await _getSurahIdsForReciterUseCase.call(reciter);\n\n    if (isDelete) {\n      surahIds.remove(surahId);\n    } else if (!surahIds.contains(surahId)) {\n      surahIds.add(surahId);\n    }\n\n    int newCount = surahIds.length;\n    currentCounts[reciter.id] = newCount;\n    await _saveDownloadCountUseCase.saveDownloadCount(reciter.id, newCount);\n    await _saveReciterWithSurahIdUseCase.call(surahId, reciter,\n        isDelete: isDelete);\n\n    await loadReciterSurahIds();\n\n    updateUiState(downloadedSurahCounts: currentCounts);\n  }\n\n  String getImagePath(String reciterName) {\n    return 'assets/images/non_svg/img_qari/$reciterName.png';\n  }\n\n  void updateUiState({\n    bool? isDownloading,\n    int? currentDownloadingSurahIndex,\n    int? downloadProgress,\n    Map<int, int>? downloadedSurahCounts,\n    int? currentDownloadingReciterId,\n    CancelToken? downloadCancelToken,\n    String? activeDownloadId,\n  }) {\n    uiState.value = uiState.value.copyWith(\n      isDownloading: isDownloading,\n      currentDownloadingSurahIndex: currentDownloadingSurahIndex,\n      downloadProgress: downloadProgress,\n      downloadedSurahCounts: downloadedSurahCounts,\n      currentDownloadingReciterId: currentDownloadingReciterId,\n      downloadCancelToken: downloadCancelToken,\n      activeDownloadId: activeDownloadId,\n    );\n  }\n\n  int getCurrentDownloadCount(Reciter reciter) =>\n      uiState.value.downloadedSurahCounts?[reciter.id] ?? 0;\n\n  Future<void> downloadAllSurahs(\n      {required Reciter reciter, required BuildContext context}) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet) {\n      if (context.mounted) addUserMessage(context.l10n.noInternetConnection);\n      return;\n    }\n\n    updateUiState(isDownloading: true);\n    int totalSurahs = 114;\n    List<String> errors = [];\n    _initializeDownloadProcess();\n\n    for (int surahIndex = 1; surahIndex <= totalSurahs; surahIndex++) {\n      if (currentUiState.downloadCancelToken!.isCancelled) break;\n      await fetchAudioFilesAndVerseTimings([surahIndex], reciter);\n      updateUiState(currentDownloadingSurahIndex: surahIndex);\n\n      final result = await _downloadAndSaveAudioLocationUseCase.execute(\n        surahID: surahIndex,\n        reciter: reciter,\n        onProgress: (percentage) =>\n            updateOverallProgress(surahIndex, percentage, totalSurahs),\n        cancelToken: currentUiState.downloadCancelToken!,\n      );\n\n      result.fold(\n        (failure) => errors.add(\"Surah $surahIndex: $failure\"),\n        (_) async => await updateDownloadCountsAndReciters(\n            reciter, currentUiState.currentDownloadingSurahIndex!),\n      );\n    }\n\n    if (errors.isNotEmpty) {\n      addUserMessage(\"Errors occurred during download: ${errors.join(', ')}\");\n    } else if (context.mounted) {\n      addUserMessage(context.l10n.surahDownloaded);\n    }\n\n    updateUiState(\n        isDownloading: false,\n        downloadProgress: 0,\n        currentDownloadingSurahIndex: 0);\n  }\n\n  void updateOverallProgress(int surahIndex, int percentage, int totalSurahs) {\n    int progress = ((surahIndex / totalSurahs) * 100).toInt() +\n        (percentage ~/ totalSurahs);\n    updateUiState(downloadProgress: progress);\n  }\n\n  void toggleCheckBoxVisibility() {\n    final bool newState = !currentUiState.checkBoxVisible!;\n    uiState.value = currentUiState.copyWith(\n      checkBoxVisible: newState,\n      isSelected: newState ? currentUiState.isSelected : {},\n    );\n  }\n\n  void selectSurah(int index) {\n    if (currentUiState.checkBoxVisible!) {\n      final isSelectedSet =\n          Set<int>.from(currentUiState.isSelected as Set<int>);\n      isSelectedSet.contains(index)\n          ? isSelectedSet.remove(index)\n          : isSelectedSet.add(index);\n      uiState.value = currentUiState.copyWith(isSelected: isSelectedSet);\n      // isSelectedSet.isEmpty ? showDownlaod.value = false : showDownlaod.value = true;\n    }\n  }\n\n  Future<void> loadDownloadCounts() async {\n    try {\n      Map<int, int> downloadCounts = {};\n      List<Reciter> allReciters =\n          await _getRecitersFromDatabaseUseCase.call(); // Get all reciters\n      for (Reciter reciter in allReciters) {\n        List<int> surahIds = await _getSurahIdsForReciterUseCase.call(reciter);\n        downloadCounts[reciter.id] = surahIds.length;\n      }\n      uiState.value =\n          currentUiState.copyWith(downloadedSurahCounts: downloadCounts);\n    } catch (e) {\n      addUserMessage(\"Failed to load download counts: $e\");\n    }\n  }\n\n  Future<void> selectReciter(\n      {required Reciter reciter, required BuildContext context}) async {\n    List<Reciter> availableReciters =\n        List.from(currentUiState.availableRecitersForDownload ?? []);\n\n    availableReciters.removeWhere((r) => r.id == reciter.id);\n    availableReciters.insert(0, currentUiState.selectedReciter);\n    availableReciters.sort((a, b) => a.name.compareTo(b.name));\n\n    uiState.value = currentUiState.copyWith(\n      availableRecitersForDownload: availableReciters,\n      selectedReciterId: reciter.id,\n      selectedReciter: reciter,\n    );\n\n    await saveSelectedReciter(reciter);\n    await audioPresenter.onReciterChanged(reciter);\n\n    // Show toast message after reciter selection\n    await addUserMessage(context.l10n.selectedSuccessfully);\n  }\n\n  @override\n  Future<void> addUserMessage(String message) {\n    return showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }\n\n  @override\n  Future<void> onInit() async {\n    await toggleLoading(loading: true);\n    await getSelectedReciter();\n    await getReciters();\n    await loadDownloadCounts();\n    await loadReciterSurahIds();\n    await toggleLoading(loading: false);\n\n    super.onInit();\n  }\n\n  Future<void> loadReciterSurahIds() async {\n    try {\n      final reciters =\n          await _getRecitersFromDatabaseUseCase.call(); // Get all reciters\n      final Map<int, List<int>> reciterSurahIds = {\n        for (var reciter in reciters)\n          reciter.id: await _getSurahIdsForReciterUseCase.call(reciter)\n      };\n      uiState.value = uiState.value.copyWith(reciterSurahIds: reciterSurahIds);\n    } catch (e) {\n      addUserMessage(\"Failed to load Reciter Surah IDs: $e\");\n    }\n  }\n\n  Future<void> getReciters() async {\n    final List<Reciter> reciters = await _getRecitersFromDatabaseUseCase.call();\n\n    final List<Reciter> availableReciters = List.from(reciters);\n    availableReciters\n        .removeWhere((r) => r.id == currentUiState.selectedReciter.id);\n    availableReciters.sort((a, b) => a.name.compareTo(b.name));\n    uiState.value = currentUiState.copyWith(\n        availableRecitersForDownload: availableReciters);\n  }\n\n  Future<void> saveSelectedReciter(Reciter reciter) async {\n    await _manageSelectedReciterUseCase.saveSelectedReciter(reciter);\n  }\n\n  Future<void> getSelectedReciter() async {\n    final Reciter reciter =\n        await _manageSelectedReciterUseCase.getSelectedReciter();\n    uiState.value = currentUiState.copyWith(\n      defaultReciter: reciter,\n      selectedReciter: reciter,\n      selectedReciterId: reciter.id,\n    );\n    await audioPresenter.onReciterChanged(reciter);\n  }\n\n  Future<void> saveReciterWithSurahId(int surahId, Reciter reciter) async {\n    await _saveReciterWithSurahIdUseCase.call(surahId, reciter);\n    uiState.value = currentUiState.copyWith(reciterSurahIds: {\n      ...?currentUiState.reciterSurahIds,\n      reciter.id: [surahId]\n    });\n  }\n}"}, {"structure_type": "function", "name": "_updateState", "docstring": "", "module": "presenter", "file_path": "presentation/profile/presenter/profile_presenter.dart", "file_name": "profile_presenter.dart", "line": 53, "line_from": 53, "line_to": 414, "snippet": "  void _updateState(ProfileUiState newState) => uiState.value = newState;\n  // --- End State Management ---\n\n  // Flags to prevent concurrent refreshes\n  bool _isRefreshingActivity = false;\n\n  // Animation controllers for charts\n  final Map<ActivityTimeRange, AnimationController> _animationControllers = {};\n\n  ProfilePresenter({\n    required GetWeeklyActivityUseCase getWeeklyActivityUseCase,\n    required GetMonthlyActivityUseCase getMonthlyActivityUseCase,\n    required GetYearlyActivityUseCase getYearlyActivityUseCase,\n    required GetActivityStatsUseCase getActivityStatsUseCase,\n    required CheckAuthenticationStatusUseCase checkAuthenticationStatus,\n    required SignInUserUseCase signInUser,\n    required SignOutUserUseCase signOutUser,\n  })  : _getWeeklyActivityUseCase = getWeeklyActivityUseCase,\n        _getMonthlyActivityUseCase = getMonthlyActivityUseCase,\n        _getYearlyActivityUseCase = getYearlyActivityUseCase,\n        _getActivityStatsUseCase = getActivityStatsUseCase,\n        _checkAuthenticationStatus = checkAuthenticationStatus,\n        _signInUser = signInUser;\n\n  @override\n  void onInit() {\n    super.onInit();\n    loadProfileData(); // Load initial data\n    _listenForUsageDataChanges(); // Start listening for updates\n  }\n\n  @override\n  void onReady() {\n    super.onReady();\n    _checkAuthenticationAndFetchUserData();\n  }\n\n  /// Handles the sign-in button tap\n  Future<void> onSignInTap() async {\n    if (currentUiState.isAuthenticated) {\n      return;\n    }\n\n    Throttle.throttle(\"signIn_throttle_tag\", const Duration(seconds: 1), () async {\n      final bool hasInternet = await checkInternetConnection();\n      if (!hasInternet) {\n        await showMessage(message: \"No internet connection\");\n        return;\n      }\n\n      await toggleLoading(loading: true);\n\n      try {\n        await executeMessageOnlyUseCase(() => _signInUser.execute());\n        // Fetch authentication status and user data after sign-in attempt\n        await _checkAuthenticationAndFetchUserData();\n      } catch (e) {\n        logErrorStatic('ProfilePresenter', 'Error during sign in: $e');\n        await addUserMessage(\"Error signing in. Please try again.\");\n      } finally {\n        await toggleLoading(loading: false);\n      }\n    });\n  }\n\n  /// Checks authentication status and fetches user data if authenticated\n  Future<void> _checkAuthenticationAndFetchUserData() async {\n    final bool isAuthenticated = await _checkAuthenticationStatus.execute();\n\n    if (isAuthenticated) {\n      // Get user data when authenticated\n      try {\n        // Use the auth instance directly from Firebase\n        final firebaseAuth = FirebaseAuth.instance;\n        final userCredential = firebaseAuth.currentUser;\n\n        _updateState(currentUiState.copyWith(\n          isAuthenticated: true,\n          userName: userCredential?.displayName ?? '',\n          userEmail: userCredential?.email ?? '',\n          avatarUrl: userCredential?.photoURL ?? '',\n        ));\n      } catch (e) {\n        logErrorStatic('ProfilePresenter', 'Error fetching user data: $e');\n        _updateState(currentUiState.copyWith(\n          isAuthenticated: true,\n          // Use empty values or defaults if we couldn't fetch the details\n        ));\n      }\n    } else {\n      _updateState(currentUiState.copyWith(\n        isAuthenticated: false,\n        userName: '',\n        userEmail: '',\n        avatarUrl: '',\n      ));\n    }\n  }\n\n  void _listenForUsageDataChanges() {\n    _usageDataChangeSubscription = _appLifecycleTracker.onUsageDataChanged\n        .debounceTime(const Duration(milliseconds: 1000)) // Debounce for 1 second\n        .listen((_) {\n      if (!_isRefreshingActivity) {\n        // Prevent concurrent refreshes\n        refreshActivityData(); // Call refresh method\n      }\n    }, onError: (Object e, StackTrace stackTrace) {\n      logErrorStatic('ProfilePresenter', 'Error in usage data change stream: $e');\n    });\n  }\n\n  /// Loads all necessary data for the profile page, including user details,\n  /// stats, and the initial activity data.\n  Future<void> loadProfileData() async {\n    await toggleLoading(loading: true);\n\n    // Set initial time range to weekly (default view)\n    final activeTimeRange = currentUiState.activeTimeRange;\n\n    // Fetch Initial Activity Data based on active time range\n    await _loadActivityDataForTimeRange(activeTimeRange);\n\n    // Fetch usage stats for active time range\n    final Either<String, UsageStatsEntity> statsResult = await _getActivityStatsUseCase.execute(\n      timeRange: _mapActivityTimeRangeToTimeRange(activeTimeRange),\n    );\n\n    UsageStatsEntity? usageStats;\n\n    statsResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading usage stats: $error');\n      },\n      (UsageStatsEntity stats) {\n        usageStats = stats;\n      },\n    );\n\n    // Update UI state with all fetched data\n    _updateState(currentUiState.copyWith(\n      usageStats: usageStats,\n      isLoading: false,\n    ));\n  }\n\n  /// Convert our UI-specific time range to the domain layer's time range\n  /// Maps the [ActivityTimeRange] to the domain layer's TimeRange.\n  TimeRange _mapActivityTimeRangeToTimeRange(ActivityTimeRange timeRange) {\n    switch (timeRange) {\n      case ActivityTimeRange.weekly:\n        return TimeRange.last7Days;\n      case ActivityTimeRange.monthly:\n        return TimeRange.currentMonth;\n      case ActivityTimeRange.yearly:\n        return TimeRange.currentYear;\n    }\n  }\n\n  /// Initializes the animation controller for the activity charts based on time range\n  void initAnimationController(\n    ActivityTimeRange timeRange,\n    TickerProvider vsync,\n  ) {\n    if (_animationControllers.containsKey(timeRange)) {\n      _animationControllers[timeRange]?.dispose();\n    }\n\n    _animationControllers[timeRange] = AnimationController(\n      duration: const Duration(milliseconds: 1000),\n      vsync: vsync,\n    )..forward();\n  }\n\n  /// Navigates to the Activity Details page\n  void navigateToActivityDetails(BuildContext context) {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => DetailedActivityPage(\n          weeklyActivity: currentUiState.weeklyActivity,\n          monthlyActivity: currentUiState.monthlyActivity,\n          yearlyActivity: currentUiState.yearlyActivity,\n          onAnimationInit: initAnimationController,\n        ),\n      ),\n    );\n  }\n\n  /// Navigates to the Set Reminder page\n  void navigateToSetReminder(BuildContext context) {\n    // Implementation for navigating to reminder setup\n    // e.g., Navigator.push(context, MaterialPageRoute(...))\n  }\n\n  /// Refreshes all activity data - called when the app lifecycle changes or\n  /// when explicitly requested by the UI (pull-to-refresh)\n  Future<void> refreshActivityData() async {\n    if (_isRefreshingActivity) return;\n    _isRefreshingActivity = true;\n\n    try {\n      _updateState(currentUiState.copyWith(isActivityLoading: true));\n      await _loadActivityDataForTimeRange(currentUiState.activeTimeRange);\n      _updateState(currentUiState.copyWith(isActivityLoading: false));\n    } catch (e) {\n      logErrorStatic('ProfilePresenter', 'Error refreshing activity data: $e');\n    } finally {\n      _isRefreshingActivity = false;\n    }\n  }\n\n  /// Loads activity data for the specified time range\n  Future<void> _loadActivityDataForTimeRange(ActivityTimeRange timeRange) async {\n    switch (timeRange) {\n      case ActivityTimeRange.weekly:\n        await _loadWeeklyActivityData();\n        break;\n      case ActivityTimeRange.monthly:\n        await _loadMonthlyActivityData();\n        break;\n      case ActivityTimeRange.yearly:\n        await _loadYearlyActivityData();\n        break;\n    }\n  }\n\n  /// Loads weekly activity data\n  Future<void> _loadWeeklyActivityData() async {\n    final Either<String, List<WeeklyActivityEntity>> activityResult = await _getWeeklyActivityUseCase.execute();\n\n    List<ActivityData> activityData = [];\n\n    activityResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading weekly activity: $error');\n        activityData = []; // Keep activity data empty on failure\n      },\n      (List<WeeklyActivityEntity> entities) {\n        activityData = _mapWeeklyActivityToPresentationModel(entities: entities);\n      },\n    );\n\n    // Update just the weekly activity part of the state\n    _updateState(currentUiState.copyWith(\n      weeklyActivity: activityData,\n    ));\n  }\n\n  /// Loads monthly activity data\n  Future<void> _loadMonthlyActivityData() async {\n    final Either<String, List<MonthlyActivityEntity>> activityResult = await _getMonthlyActivityUseCase.execute();\n\n    List<MonthlyActivityData> activityData = [];\n\n    activityResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading monthly activity: $error');\n        activityData = []; // Keep activity data empty on failure\n      },\n      (List<MonthlyActivityEntity> entities) {\n        activityData = _mapMonthlyActivityToPresentationModel(entities: entities);\n      },\n    );\n\n    // Update just the monthly activity part of the state\n    _updateState(currentUiState.copyWith(\n      monthlyActivity: activityData,\n    ));\n  }\n\n  /// Loads yearly activity data\n  Future<void> _loadYearlyActivityData() async {\n    final Either<String, List<YearlyActivityEntity>> activityResult = await _getYearlyActivityUseCase.execute();\n\n    List<YearlyActivityData> activityData = [];\n\n    activityResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading yearly activity: $error');\n        activityData = []; // Keep activity data empty on failure\n      },\n      (List<YearlyActivityEntity> entities) {\n        activityData = _mapYearlyActivityToPresentationModel(entities: entities);\n      },\n    );\n\n    // Update just the yearly activity part of the state\n    _updateState(currentUiState.copyWith(\n      yearlyActivity: activityData,\n    ));\n  }\n\n  /// Maps a list of [WeeklyActivityEntity] (domain) to a list of [ActivityData] (presentation).\n  List<ActivityData> _mapWeeklyActivityToPresentationModel({required List<WeeklyActivityEntity> entities}) {\n    // Assumes 'entities' is the sorted list of 7 days from the use case.\n    final DateTime todayDateOnly = DateUtils.dateOnly(DateTime.now());\n\n    return entities.map((entity) {\n      final bool isTodayFlag = DateUtils.dateOnly(entity.date) == todayDateOnly;\n      return ActivityData(\n        day: entity.date.day, // Day of month for display\n        date: entity.date, // Full date object\n        minutes: entity.minutes,\n        isToday: isTodayFlag,\n        // 'isActive' is derived in ActivityData constructor\n      );\n    }).toList();\n  }\n\n  /// Maps a list of [MonthlyActivityEntity] (domain) to a list of [MonthlyActivityData] (presentation).\n  List<MonthlyActivityData> _mapMonthlyActivityToPresentationModel({required List<MonthlyActivityEntity> entities}) {\n    final DateTime todayDateOnly = DateUtils.dateOnly(DateTime.now());\n\n    return entities.map((entity) {\n      final bool isTodayFlag = DateUtils.dateOnly(entity.date) == todayDateOnly;\n      return MonthlyActivityData(\n        day: entity.date.day,\n        date: entity.date,\n        minutes: entity.minutes,\n        isToday: isTodayFlag,\n      );\n    }).toList();\n  }\n\n  /// Maps a list of [YearlyActivityEntity] (domain) to a list of [YearlyActivityData] (presentation).\n  List<YearlyActivityData> _mapYearlyActivityToPresentationModel({required List<YearlyActivityEntity> entities}) {\n    return entities.map((entity) {\n      return YearlyActivityData(\n        date: entity.date,\n        minutes: entity.minutes,\n      );\n    }).toList();\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    _updateState(currentUiState.copyWith(isLoading: loading));\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async {\n    _updateState(currentUiState.copyWith(\n      userMessage: () => message,\n    ));\n    await showMessage(message: message);\n  }\n\n  @override\n  void onClose() {\n    _usageDataChangeSubscription?.cancel();\n    for (final controller in _animationControllers.values) {\n      controller.dispose();\n    }\n    _animationControllers.clear();\n    super.onClose();\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/profile/widgets/lifetime_activity_card.dart", "file_name": "lifetime_activity_card.dart", "line": 22, "line_from": 22, "line_to": 112, "snippet": "  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(\n          'Lifetime Activity',\n          style: theme.textTheme.titleLarge?.copyWith(\n            fontWeight: FontWeight.bold,\n            color: context.color.primaryColor,\n          ),\n        ),\n        gapH10,\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          spacing: tenPx,\n          children: [\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icQuran,\n              value: totalReads,\n              label: 'Readings',\n            ),\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icBookmark,\n              value: totalBookmarks,\n              label: context.l10n.bookmark,\n            ),\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icSettings,\n              value: totalNotes,\n              label: context.l10n.pin,\n            ),\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icSettings,\n              value: totalNotes,\n              label: context.l10n.note,\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n\nclass _StatItem extends StatelessWidget {\n  const _StatItem({\n    required this.theme,\n    required this.icon,\n    required this.value,\n    required this.label,\n  });\n\n  final ThemeData theme;\n  final String icon;\n  final int value;\n  final String label;\n\n  @override\n  Widget build(BuildContext context) {\n    return Expanded(\n      child: Container(\n        height: 75.px,\n        decoration: BoxDecoration(\n          color: context.color.tabBarShade,\n          borderRadius: radius12,\n        ),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(\n              '${value.toLocalizedString(context)}+',\n              style: theme.textTheme.titleMedium?.copyWith(\n                fontWeight: FontWeight.w600,\n              ),\n            ),\n            gapH4,\n            Text(\n              label,\n              style: theme.textTheme.bodySmall?.copyWith(\n                color: context.color.subtitleColor,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "paint", "docstring": "", "module": "widgets", "file_path": "presentation/profile/widgets/chart_animations.dart", "file_name": "chart_animations.dart", "line": 27, "line_from": 27, "line_to": 124, "snippet": "  void paint(Canvas canvas, Size size) {\n    final width = size.width;\n    final height = size.height;\n\n    if (values.isEmpty) return;\n\n    // Calculate spacing between bars\n    final totalBarsWidth = barWidth * values.length;\n    final spacing = (width - totalBarsWidth) / (values.length + 1);\n\n    // Draw each bar with ripple animation\n    for (int i = 0; i < values.length; i++) {\n      final normalizedValue = values[i] / maxValue;\n      final barHeight = normalizedValue * height * animationValue;\n\n      // Calculate bar position\n      final left = spacing + (spacing + barWidth) * i;\n      final top = height - barHeight;\n      final rect = RRect.fromRectAndRadius(\n        Rect.fromLTWH(left, top, barWidth, barHeight),\n        Radius.circular(cornerRadius),\n      );\n\n      // Create gradient for each bar\n      final gradient = LinearGradient(\n        begin: Alignment.topCenter,\n        end: Alignment.bottomCenter,\n        colors: [\n          colors[i % colors.length].withOpacityInt(0.8),\n          colors[i % colors.length],\n        ],\n      );\n\n      // Paint bar with gradient\n      final paint = Paint()\n        ..shader = gradient.createShader(rect.outerRect)\n        ..style = PaintingStyle.fill;\n\n      canvas.drawRRect(rect, paint);\n\n      // Add glow effect (optional)\n      if (animationValue > 0.7) {\n        final glowPaint = Paint()\n          ..color = colors[i % colors.length].withOpacityInt(0.2)\n          ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8);\n\n        canvas.drawRRect(rect, glowPaint);\n      }\n\n      // Add ripple effect on top of bar (wave animation)\n      if (animationValue > 0.9 && values[i] > 0) {\n        const double waveHeight = 3.0;\n        const double waveFrequency = 10.0;\n        final double wavePhase = animationValue * 10.0;\n\n        final wavePaint = Paint()\n          ..color = Colors.white.withOpacityInt(0.3)\n          ..style = PaintingStyle.stroke\n          ..strokeWidth = 1.5;\n\n        final wavePath = Path();\n        double startX = left;\n        wavePath.moveTo(startX, top + waveHeight * sin(startX / waveFrequency + wavePhase));\n\n        for (double x = startX; x <= left + barWidth; x += 2) {\n          final y = top + waveHeight * sin(x / waveFrequency + wavePhase);\n          wavePath.lineTo(x, y);\n        }\n\n        canvas.drawPath(wavePath, wavePaint);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant AnimatedBarChartPainter oldDelegate) {\n    return oldDelegate.animationValue != animationValue;\n  }\n}\n\n/// Custom line chart with animation effects\nclass AnimatedLineChart extends StatefulWidget {\n  final List<FlSpot> spots;\n  final Color lineColor;\n  final Color gradientColor;\n  final bool animate;\n\n  const AnimatedLineChart({\n    super.key,\n    required this.spots,\n    required this.lineColor,\n    required this.gradientColor,\n    this.animate = true,\n  });\n\n  @override\n  State<AnimatedLineChart> createState() => _AnimatedLineChartState();\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "widgets", "file_path": "presentation/profile/widgets/chart_animations.dart", "file_name": "chart_animations.dart", "line": 131, "line_from": 131, "line_to": 326, "snippet": "  void initState() {\n    super.initState();\n    _animationController = AnimationController(\n      vsync: this,\n      duration: const Duration(milliseconds: 1500),\n    );\n\n    _animation = CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.elasticOut,\n    );\n\n    if (widget.animate) {\n      _animationController.forward();\n    } else {\n      _animationController.value = 1.0;\n    }\n  }\n\n  @override\n  void dispose() {\n    _animationController.dispose();\n    super.dispose();\n  }\n\n  void reset() {\n    _animationController.reset();\n    _animationController.forward();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _animation,\n      builder: (context, child) {\n        final animatedSpots = _getAnimatedSpots();\n\n        return LineChart(\n          LineChartData(\n            gridData: const FlGridData(show: false),\n            titlesData: FlTitlesData(\n              topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),\n              rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),\n              bottomTitles: AxisTitles(\n                sideTitles: SideTitles(\n                  showTitles: true,\n                  getTitlesWidget: (value, meta) {\n                    // Show every 5th point or important x values\n                    if (value % 5 != 0 && value != 1) {\n                      return const SizedBox();\n                    }\n                    return Padding(\n                      padding: const EdgeInsets.only(top: 8.0),\n                      child: Text(\n                        value.toInt().toString(),\n                        style: Theme.of(context).textTheme.bodySmall,\n                      ),\n                    );\n                  },\n                ),\n              ),\n              leftTitles: AxisTitles(\n                sideTitles: SideTitles(\n                  showTitles: true,\n                  reservedSize: 30,\n                  getTitlesWidget: (value, meta) {\n                    if (value == 0) return const SizedBox();\n                    return Padding(\n                      padding: const EdgeInsets.only(right: 8.0),\n                      child: Text(\n                        value.toInt().toString(),\n                        style: Theme.of(context).textTheme.bodySmall,\n                      ),\n                    );\n                  },\n                ),\n              ),\n            ),\n            borderData: FlBorderData(show: false),\n            lineBarsData: [\n              LineChartBarData(\n                spots: animatedSpots,\n                isCurved: true,\n                curveSmoothness: 0.3,\n                color: widget.lineColor,\n                barWidth: 3,\n                isStrokeCapRound: true,\n                dotData: FlDotData(\n                  show: true,\n                  getDotPainter: (spot, percent, barData, index) {\n                    // Determine if this is today's spot based on index\n                    final bool isToday = index == (animatedSpots.length - 1);\n                    return FlDotCirclePainter(\n                      radius: isToday ? 5 * _animation.value : 3 * _animation.value, // Larger radius for today\n                      color: widget.lineColor, // Primary color for dots\n                      strokeWidth: 1,\n                      strokeColor: Theme.of(context).cardColor, // Use card background for stroke\n                    );\n                  },\n                ),\n                belowBarData: BarAreaData(\n                  show: true,\n                  color: widget.gradientColor,\n                  gradient: LinearGradient(\n                    colors: [\n                      widget.gradientColor.withOpacityInt(0.3), // Start a bit stronger\n                      widget.gradientColor.withOpacityInt(0.05), // End very transparent\n                    ],\n                    begin: Alignment.topCenter,\n                    end: Alignment.bottomCenter,\n                  ),\n                ),\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n\n  List<FlSpot> _getAnimatedSpots() {\n    if (widget.spots.isEmpty) return [];\n\n    // Animate the growth of the line\n    final animationValue = _animation.value;\n\n    // Animate both y values and line progress\n    return widget.spots.asMap().entries.map((entry) {\n      final index = entry.key;\n      final spot = entry.value;\n\n      // Determine if this spot should be shown based on animation progress\n      if (index / widget.spots.length > animationValue) {\n        return FlSpot(spot.x, 0); // Not yet visible\n      }\n\n      // Animate the y value\n      return FlSpot(spot.x, spot.y * animationValue);\n    }).toList();\n  }\n}\n\n/// Heat map cell for yearly activity visualization\nclass HeatMapCell extends StatelessWidget {\n  final double value;\n  final double maxValue;\n  final Color baseColor;\n  final bool isAnimated;\n  final bool isHighlighted;\n\n  const HeatMapCell({\n    super.key,\n    required this.value,\n    required this.maxValue,\n    required this.baseColor,\n    this.isAnimated = true,\n    this.isHighlighted = false,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final intensity = value > 0 ? (value / maxValue).clamp(0.1, 1.0) : 0.0;\n\n    return TweenAnimationBuilder<double>(\n      tween: Tween<double>(begin: 0, end: intensity),\n      duration: Duration(milliseconds: isAnimated ? 800 : 0),\n      curve: Curves.easeInOut,\n      builder: (context, value, child) {\n        // Calculate color based on intensity\n        final color = intensity > 0 ? Color.lerp(baseColor.withOpacityInt(0.2), baseColor, value)! : Colors.transparent;\n\n        return Container(\n          margin: const EdgeInsets.all(1),\n          decoration: BoxDecoration(\n            color: color,\n            borderRadius: BorderRadius.circular(2),\n            boxShadow: isHighlighted\n                ? [\n                    BoxShadow(\n                      color: baseColor.withOpacityInt(0.4),\n                      blurRadius: 4,\n                      spreadRadius: 1,\n                    ),\n                  ]\n                : null,\n          ),\n          child: AnimatedScale(\n            scale: isHighlighted ? 1.1 : 1.0,\n            duration: const Duration(milliseconds: 200),\n            child: const SizedBox.square(dimension: 10),\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "duplicates", "docstring": "", "module": "activity_details", "file_path": "presentation/profile/widgets/activity_details/monthly_activity_chart_view.dart", "file_name": "monthly_activity_chart_view.dart", "line": 53, "line_from": 53, "line_to": 241, "snippet": "    // Create fixed y-axis labels to avoid duplicates\n    final List<double> yLabels = [0]; // Always show 0\n    if (maxYValue <= 60) {\n      // If max is less than an hour, show minutes\n      final double interval = (maxYValue / 3).ceil().toDouble();\n      yLabels.addAll([interval, 2 * interval, 3 * interval]);\n    } else {\n      // If max includes hours, ensure proper hour spacing\n      final int maxHours = (maxYValue / 60).ceil();\n      final double hourInterval = (maxHours / 3).ceil().toDouble();\n      yLabels.addAll(\n          [hourInterval * 60, 2 * hourInterval * 60, 3 * hourInterval * 60]);\n    }\n\n    return CustomContainer(\n      theme: widget.theme,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          // Title section\n          Text(\n            'Monthly Activity (${DateFormat('MMMM yyyy').format(now)})',\n            style: widget.theme.textTheme.titleMedium?.copyWith(\n              fontWeight: FontWeight.bold,\n              color: widget.theme.textTheme.bodyLarge?.color,\n            ),\n          ),\n          gapH16,\n          SizedBox(\n            height: 180,\n            child: BarChart(\n              BarChartData(\n                alignment: BarChartAlignment.spaceAround,\n                maxY: maxYValue,\n                gridData: const FlGridData(show: false),\n                titlesData: FlTitlesData(\n                  topTitles: const AxisTitles(\n                      sideTitles: SideTitles(showTitles: false)),\n                  rightTitles: const AxisTitles(\n                      sideTitles: SideTitles(showTitles: false)),\n                  bottomTitles: AxisTitles(\n                    sideTitles: SideTitles(\n                      showTitles: true,\n                      getTitlesWidget: (value, meta) {\n                        final day = value.toInt();\n                        // Only show every 5th day or 1st day to avoid crowding\n                        if (day % 5 != 0 && day != 1 && day != data.length) {\n                          return const SizedBox.shrink();\n                        }\n                        return Padding(\n                          padding: EdgeInsets.only(top: eightPx),\n                          child: Text(\n                            day.toLocalizedString(context),\n                            style: widget.theme.textTheme.bodySmall?.copyWith(\n                              color: context.color.subtitleColor,\n                            ),\n                          ),\n                        );\n                      },\n                      reservedSize: 28,\n                    ),\n                  ),\n                  leftTitles: AxisTitles(\n                    sideTitles: SideTitles(\n                      showTitles: true,\n                      reservedSize: 40,\n                      // Use our explicit label values\n                      interval: 1,\n                      getTitlesWidget: (value, meta) {\n                        // Check if this value is in our yLabels (with small tolerance)\n                        bool isLabelValue = false;\n                        double labelToUse = 0;\n\n                        for (final labelValue in yLabels) {\n                          if ((value - labelValue).abs() < 1.0) {\n                            isLabelValue = true;\n                            labelToUse = labelValue;\n                            break;\n                          }\n                        }\n\n                        if (!isLabelValue) {\n                          return const SizedBox.shrink();\n                        }\n\n                        // Format the label based on its value\n                        final String label;\n                        if (labelToUse >= 60) {\n                          final int hours = (labelToUse / 60).floor();\n                          label = '${hours.toLocalizedString(context)}h';\n                        } else {\n                          label =\n                              '${labelToUse.toInt().toLocalizedString(context)}m';\n                        }\n\n                        return Padding(\n                          padding: EdgeInsets.only(right: eightPx),\n                          child: Text(\n                            label,\n                            style: widget.theme.textTheme.bodySmall?.copyWith(\n                              color: context.color.subtitleColor,\n                            ),\n                          ),\n                        );\n                      },\n                    ),\n                  ),\n                ),\n                borderData: FlBorderData(show: false),\n                barGroups: List.generate(data.length, (i) {\n                  final dayData = data[i];\n                  final bool isToday = dayData.isToday;\n\n                  return BarChartGroupData(\n                    x: dayData.day,\n                    barRods: [\n                      BarChartRodData(\n                        toY: dayData.minutes,\n                        color: isToday\n                            ? primaryColor\n                            : context.color.primaryColor30,\n                        width: sixPx, // Thinner bars due to more data points\n                        borderRadius: BorderRadius.only(\n                          topLeft: Radius.circular(fourPx),\n                          topRight: Radius.circular(fourPx),\n                        ),\n                        backDrawRodData: BackgroundBarChartRodData(\n                          show: true,\n                          toY: maxYValue,\n                          color: context.color.chartShade.withOpacityInt(0.6),\n                        ),\n                      ),\n                    ],\n                    groupVertically: false,\n                    barsSpace: 4,\n                  );\n                }),\n                barTouchData: BarTouchData(\n                  touchTooltipData: BarTouchTooltipData(\n                    tooltipRoundedRadius: 8,\n                    tooltipBorder: BorderSide(\n                      color: context.color.borderColor,\n                      width: 1,\n                    ),\n                    getTooltipItem: (group, groupIndex, rod, rodIndex) {\n                      final day = group.x;\n                      final minutesTotal = rod.toY.round();\n                      final hours = minutesTotal ~/ 60;\n                      final minutes = minutesTotal % 60;\n\n                      // Format the day to show the date (e.g., Aug 15)\n                      final DateTime date = DateTime(now.year, now.month, day);\n                      final String dayText = DateFormat('MMM d').format(date);\n\n                      String timeText = '';\n                      if (hours > 0) {\n                        timeText += '${hours.toLocalizedString(context)} h ';\n                      }\n                      timeText += '${minutes.toLocalizedString(context)} min';\n\n                      return BarTooltipItem(\n                        '$dayText\\n',\n                        widget.theme.textTheme.bodySmall!.copyWith(\n                          fontWeight: FontWeight.bold,\n                          color: widget.theme.textTheme.bodyLarge?.color,\n                        ),\n                        children: [\n                          TextSpan(\n                            text: timeText,\n                            style: TextStyle(\n                              color: primaryColor,\n                              fontWeight: FontWeight.bold,\n                            ),\n                          ),\n                        ],\n                      );\n                    },\n                    getTooltipColor: (group) {\n                      return widget.theme.cardColor;\n                    },\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "activity_dashboard", "file_path": "presentation/profile/widgets/activity_dashboard/weekly_activity_chart.dart", "file_name": "weekly_activity_chart.dart", "line": 19, "line_from": 19, "line_to": 152, "snippet": "  Widget build(BuildContext context) {\n    assert(activityData.length <= 7,\n        \"Weekly ActivityChart requires at most 7 days of data.\");\n\n    final List<ActivityData> data = activityData.isEmpty\n        ? List.generate(\n            7,\n            (index) => ActivityData(\n              day: DateTime.now().subtract(Duration(days: 6 - index)).day,\n              date: DateTime.now().subtract(Duration(days: 6 - index)),\n              minutes: 0,\n              isToday: index == 6,\n            ),\n          )\n        : activityData;\n\n    final double maxMinutesInWeek = data.isNotEmpty\n        ? data\n            .map((d) => d.minutes)\n            .fold(0.0, (prev, current) => max(prev, current))\n        : 0.0;\n\n    final double effectiveMaxMinutes =\n        (maxMinutesInWeek <= 0) ? 30.0 : maxMinutesInWeek;\n\n    final Color primaryChartColor = context.color.primaryColor;\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        SizedBox(\n          height: 160,\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            crossAxisAlignment: CrossAxisAlignment.end,\n            children: List.generate(\n              data.length,\n              (index) => _ActivityBar(\n                theme: theme,\n                data: data[index],\n                maxMinutesInWeek: effectiveMaxMinutes,\n                barColor: primaryChartColor,\n                inactiveBarColor: primaryChartColor.withOpacityInt(0.2),\n              ),\n            ),\n          ),\n        ),\n        gapH12,\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceAround,\n          children: List.generate(\n            data.length,\n            (index) => _DayLabel(\n              day: data[index].day,\n              isToday: data[index].isToday,\n              isActive: data[index].isActive,\n              theme: theme,\n              activeColor: primaryChartColor,\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass _ActivityBar extends StatelessWidget {\n  const _ActivityBar({\n    required this.theme,\n    required this.data,\n    required this.maxMinutesInWeek,\n    required this.barColor,\n    required this.inactiveBarColor,\n  });\n\n  final ThemeData theme;\n  final ActivityData data;\n  final double maxMinutesInWeek;\n  final Color barColor;\n  final Color inactiveBarColor;\n\n  @override\n  Widget build(BuildContext context) {\n    const double maxBarHeight = 125.0;\n    const double minBarHeight = 5.0;\n    const double barWidth = 30.0;\n\n    final double ratio =\n        maxMinutesInWeek > 0 ? data.minutes / maxMinutesInWeek : 0.0;\n\n    final double barHeight = data.isActive\n        ? (ratio * maxBarHeight).clamp(minBarHeight, maxBarHeight)\n        : minBarHeight;\n\n    final Color inactiveColor = context.color.primaryColor20;\n\n    final Color currentBarColor = data.isActive ? barColor : inactiveColor;\n\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.end,\n      children: [\n        SizedBox(\n          height: sixteenPx,\n          child: (data.isActive && data.minutes >= 1)\n              ? Text(\n                  \"${data.minutes.toInt().toLocalizedString(context)}m\",\n                  style: theme.textTheme.bodySmall?.copyWith(\n                    color: barColor,\n                    fontWeight: FontWeight.w500,\n                    fontSize: tenPx,\n                  ),\n                )\n              : null,\n        ),\n        gapH4,\n        TweenAnimationBuilder<double>(\n          tween: Tween<double>(begin: 0, end: barHeight),\n          duration: const Duration(milliseconds: 800),\n          curve: Curves.elasticOut,\n          builder: (context, height, child) {\n            return Container(\n              width: barWidth,\n              height: height.clamp(minBarHeight, maxBarHeight),\n              decoration: BoxDecoration(\n                color: currentBarColor,\n                borderRadius: radius8,\n              ),\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"}, {"structure_type": "function", "name": "[];", "docstring": "", "module": "presenter", "file_path": "presentation/tafseer/presenter/tafseer_presenter.dart", "file_name": "tafseer_presenter.dart", "line": 911, "line_from": 911, "line_to": 939, "snippet": "    List<Future<void>> futures = [];\n    for (TTDbFileModel model in modelsToDownload) {\n      if (!isAlreadyDownloaded(model) && context.mounted) {\n        futures.add(_loadTafseer(model, context));\n      }\n    }\n    await Future.wait(futures);\n    uiState.value = uiState.value.copyWith(isAllFilesDownloading: false);\n  }\n\n  List<MapEntry<String, List<TTDbFileModel>>> _getDownloadableTafseers(\n      Map<String, List<TTDbFileModel>> allTafseers,\n      List<TTDbFileModel> downloadedModels) {\n    final List<TTDbFileModel> allItems =\n        allTafseers.values.expand((models) => models).toList();\n    final Set<String> downloadedFileNames =\n        downloadedModels.map((model) => model.fileName).toSet();\n    final List<TTDbFileModel> downloadableItems = allItems\n        .where((model) => !downloadedFileNames.contains(model.fileName))\n        .toList();\n\n    return allTafseers.entries\n        .map((entry) => MapEntry(\n            entry.key,\n            entry.value\n                .where((model) => downloadableItems.contains(model))\n                .toList()))\n        .toList();\n  }"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "widgets", "file_path": "presentation/tafseer/widgets/custom_speed_dial.dart", "file_name": "custom_speed_dial.dart", "line": 41, "line_from": 41, "line_to": 224, "snippet": "  void initState() {\n    super.initState();\n    presenter = CustomSpeedDialPresenter(vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _isDisposed = true;\n    presenter.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isDisposed) return const SizedBox();\n\n    final TafseerPresenter tafseerPresenter = locate<TafseerPresenter>();\n    final NotePresenter notePresenter = locate<NotePresenter>();\n\n    return PresentableWidgetBuilder<CustomSpeedDialPresenter>(\n      presenter: presenter,\n      builder: () {\n        final isOpened = presenter.state.isOpened;\n        final slideAnimations = presenter.slideAnimations;\n\n        return StreamBuilder<void>(\n          stream: notePresenter.noteUpdateStream,\n          builder: (context, _) {\n            return FutureBuilder<bool>(\n              future: tafseerPresenter.hasExistingNote(\n                  widget.surahID, widget.ayahID),\n              builder: (context, snapshot) {\n                final bool hasNote = snapshot.data ?? false;\n\n                return Column(\n                  mainAxisAlignment: MainAxisAlignment.end,\n                  crossAxisAlignment: CrossAxisAlignment.end,\n                  children: [\n                    SpeedDialItem(\n                      isOpened: isOpened,\n                      theme: Theme.of(context),\n                      svgIconPath:\n                          hasNote ? SvgPath.icEdit : SvgPath.icNoteFavorite,\n                      backgroundColor: QuranColor.axolotlColor,\n                      label: hasNote\n                          ? context.l10n.editNote\n                          : context.l10n.createNote,\n                      onTap: () {\n                        widget.onTapCreateNote();\n                        presenter.closeSpeedDial();\n                      },\n                      slideAnimation: slideAnimations[0],\n                    ),\n                    SpeedDialItem(\n                      isOpened: isOpened,\n                      theme: Theme.of(context),\n                      svgIconPath: SvgPath.icCopyFill,\n                      backgroundColor: QuranColor.tigerEyeColor,\n                      label: context.l10n.copyTafseer,\n                      onTap: () {\n                        widget.onTapCopy();\n                        presenter.closeSpeedDial();\n                      },\n                      slideAnimation: slideAnimations[1],\n                    ),\n                    SpeedDialItem(\n                      isOpened: isOpened,\n                      theme: Theme.of(context),\n                      svgIconPath: SvgPath.icShare2,\n                      backgroundColor: QuranColor.cornflowerBlueColor,\n                      label: context.l10n.share,\n                      onTap: () {\n                        widget.onTapShare();\n                        presenter.closeSpeedDial();\n                      },\n                      slideAnimation: slideAnimations[2],\n                    ),\n                    FloatingActionButton(\n                      elevation: 2,\n                      shape: RoundedRectangleBorder(borderRadius: radius20),\n                      backgroundColor: context.color.primaryButtonColor,\n                      onPressed: presenter.toggleSpeedDial,\n                      child: AnimatedRotation(\n                        turns: isOpened ? 0.5 : 0,\n                        duration: const Duration(milliseconds: 300),\n                        child: SvgImage(\n                          isOpened ? SvgPath.icClose : SvgPath.icDashboard,\n                          width: twentyFourPx,\n                          height: twentyFourPx,\n                          color: context.color.primaryButtonTextColor,\n                        ),\n                      ),\n                    ),\n                  ],\n                );\n              },\n            );\n          },\n        );\n      },\n    );\n  }\n}\n\nclass SpeedDialItem extends StatelessWidget {\n  const SpeedDialItem({\n    super.key,\n    required this.isOpened,\n    required this.theme,\n    required this.svgIconPath,\n    required this.backgroundColor,\n    required this.label,\n    required this.onTap,\n    required this.slideAnimation,\n  });\n\n  final bool isOpened;\n  final ThemeData theme;\n  final String svgIconPath;\n  final Color backgroundColor;\n  final String label;\n  final VoidCallback onTap;\n  final Animation<Offset> slideAnimation;\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedOpacity(\n      opacity: isOpened ? 1.0 : 0.0,\n      duration: const Duration(milliseconds: 300),\n      child: isOpened\n          ? SlideTransition(\n              position: slideAnimation,\n              child: OnTapWidget(\n                onTap: onTap,\n                theme: theme,\n                child: Transform.translate(\n                  offset: Offset(0, isOpened ? 0 : 20),\n                  child: Container(\n                    margin: EdgeInsets.only(bottom: tenPx),\n                    child: Row(\n                      mainAxisAlignment: MainAxisAlignment.end,\n                      mainAxisSize: MainAxisSize.min,\n                      children: [\n                        Material(\n                          color: context.color.primaryColor10,\n                          elevation: 2,\n                          borderRadius: radius20,\n                          child: Padding(\n                            padding: EdgeInsets.symmetric(\n                                horizontal: sixteenPx, vertical: eightPx),\n                            child: Text(\n                              label,\n                              style: context.quranText.buttonText!.copyWith(\n                                color: context.color.primaryColor,\n                                fontWeight: FontWeight.normal,\n                              ),\n                            ),\n                          ),\n                        ),\n                        gapW8,\n                        FloatingActionButton(\n                          heroTag: label,\n                          elevation: 2,\n                          mini: true,\n                          splashColor: Colors.transparent,\n                          backgroundColor: backgroundColor,\n                          onPressed: onTap,\n                          child: SvgImage(\n                            svgIconPath,\n                            width: twentyPx,\n                            height: twentyPx,\n                            color: context.color.primaryButtonTextColor,\n                          ),\n                        ),\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            )\n          : const SizedBox(),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/tafseer/widgets/view_tafseer_details.dart", "file_name": "view_tafseer_details.dart", "line": 32, "line_from": 32, "line_to": 137, "snippet": "  Widget build(BuildContext context) {\n    return FutureBuilder<String>(\n      future: tafseerPresenter.getTafsirTextFuture(surahID, ayahID, index),\n      builder: (context, snapshot) {\n        return SingleChildScrollView(\n          physics: const ClampingScrollPhysics(),\n          key: Key('tafseer_details_$index'),\n          child: Container(\n            padding: EdgeInsets.only(\n                left: twentyPx,\n                right: twentyPx,\n                top: thirtyPx,\n                bottom: 30.percentWidth),\n            width: double.infinity,\n            child: Column(\n              key: const Key('tafseer_details_column'),\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                if (snapshot.hasData) ...[\n                  HtmlFormattedText(\n                    tafsirText: snapshot.data!,\n                    theme: theme,\n                    ayahPresenter: ayahPresenter,\n                  ),\n                ] else if (snapshot.hasError) ...[\n                  Text('Error: ${snapshot.error}'),\n                ] else ...[\n                  const Center(child: Text('Loading...')),\n                ],\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass OptimizedHtmlContent extends StatelessWidget {\n  const OptimizedHtmlContent({\n    super.key,\n    required this.tafsirText,\n    required this.theme,\n    required this.tafseerFontSize,\n    required this.arabicFontSize,\n    required this.tafseerArabicFontFamily,\n  });\n\n  final String tafsirText;\n  final ThemeData theme;\n  final double tafseerFontSize;\n  final double arabicFontSize;\n  final ArabicFonts tafseerArabicFontFamily;\n\n  @override\n  Widget build(BuildContext context) {\n    return Html(\n      key: ValueKey(\n          'html_content_${tafseerFontSize}_${arabicFontSize}_${tafseerArabicFontFamily.name}'),\n      data: tafsirText.replaceAll(RegExp(r'\\r?\\n'), '<br/>'),\n      shrinkWrap: true,\n      extensions: [\n        TagExtension(\n          tagsToExtend: {\"longer\"},\n          builder: (ExtensionContext extensionContext) {\n            return Padding(\n              padding: EdgeInsets.only(top: sixteenPx, bottom: sixteenPx),\n              child: SizedBox(\n                width: double.infinity,\n                child: Text(\n                  extensionContext.element!.innerHtml.replaceAll('<br>', \"\\n\"),\n                  textDirection: TextDirection.rtl,\n                  style: TextStyle(\n                    fontSize: arabicFontSize,\n                    fontFamily: tafseerArabicFontFamily.name,\n                    letterSpacing: 0,\n                  ),\n                ),\n              ),\n            );\n          },\n        ),\n      ],\n      style: {\n        \"body\": Style(\n          margin: Margins.zero,\n          textAlign: TextAlign.left,\n          padding: HtmlPaddings.zero,\n          fontFamily: FontFamily.kalpurush,\n          fontSize: FontSize(tafseerFontSize),\n          letterSpacing: 0,\n          lineHeight: const LineHeight(1.5),\n          color: theme.textTheme.bodyMedium!.color,\n        ),\n        \"span\": Style(\n          direction: TextDirection.rtl,\n          lineHeight: const LineHeight(2),\n          letterSpacing: 0,\n          wordSpacing: 2,\n          fontFamily: tafseerArabicFontFamily.name,\n          fontSize: FontSize(arabicFontSize),\n        ),\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/main_page/ui/main_page.dart", "file_name": "main_page.dart", "line": 32, "line_from": 32, "line_to": 181, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    QuranScreen.setUp(context);\n    _mainPagePresenter.updateContext(context);\n    // _tafseerPresenter.updateContext(context);\n    return PopScope(\n      onPopInvokedWithResult: (bool isInvoked, dynamic result) async {\n        final bool isDrawerOpen =\n            _mainPagePresenter.mainScaffoldKey.currentState?.isDrawerOpen ??\n                false;\n        final int currentIndex = _mainPagePresenter.currentUiState.currentIndex;\n\n        if (isDrawerOpen) {\n          _mainPagePresenter.closeDrawer();\n          return;\n        }\n        if (currentIndex != 0) {\n          await _mainPagePresenter.setNavBarIndex(0);\n          return;\n        }\n\n        _mainPagePresenter.showExitDialog(context);\n      },\n      canPop: false,\n      child: PresentableWidgetBuilder(\n        presenter: _mainPagePresenter,\n        builder: () {\n          final MainPageUiState uiState = _mainPagePresenter.currentUiState;\n          return CustomStatusBarColor(\n            statusBarColor: isDarkMode(context)\n                ? theme.colorScheme.secondary\n                : (uiState.currentIndex == 0\n                    ? theme.primaryColor\n                    : context.color.gradientTop),\n            statusBarIconColor: isDarkMode(context)\n                ? Brightness.light\n                : (uiState.currentIndex == 0\n                    ? Brightness.light\n                    : Brightness.dark),\n            navigationBarIconColor:\n                isDarkMode(context) ? Brightness.light : Brightness.dark,\n            navigationBarColor: context.color.bottomNavBgColor,\n            child: Scaffold(\n              key: _mainPagePresenter.mainScaffoldKey,\n              resizeToAvoidBottomInset: false,\n              body: _pages[uiState.currentIndex],\n              drawer: const MainPageDrawer(),\n              bottomNavigationBar: MainNavigationBar(\n                selectedIndex: uiState.currentIndex,\n                onDestinationSelected: (index) {\n                  _mainPagePresenter.changeTabIndex(index);\n                },\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass MainNavigationBar extends StatelessWidget {\n  const MainNavigationBar({\n    super.key,\n    required this.selectedIndex,\n    required this.onDestinationSelected,\n  });\n\n  final int selectedIndex;\n  final ValueChanged<int> onDestinationSelected;\n\n  @override\n  Widget build(BuildContext context) {\n    return Theme(\n      key: const Key('main_navigation_bar_theme'),\n      data: Theme.of(context).copyWith(\n        navigationBarTheme: NavigationBarThemeData(\n          elevation: 0,\n          backgroundColor: context.color.backgroundColor,\n          labelTextStyle: WidgetStateProperty.resolveWith((states) {\n            if (states.contains(WidgetState.selected)) {\n              return TextStyle(\n                fontSize: twelvePx,\n                fontWeight: FontWeight.w600,\n                color: context.color.primaryColor,\n              );\n            }\n            return TextStyle(\n              fontSize: twelvePx,\n              fontWeight: FontWeight.normal,\n              color: context.color.navInactive,\n            );\n          }),\n          indicatorColor: context.color.navBgAc,\n        ),\n      ),\n      child: Container(\n        key: const Key('main_navigation_bar_container'),\n        padding: EdgeInsets.symmetric(horizontal: tenPx),\n        decoration: BoxDecoration(\n          color: context.color.backgroundColor,\n          border: Border(\n            top: BorderSide(\n              color: context.color.borderColor,\n            ),\n          ),\n        ),\n        child: NavigationBar(\n          key: const Key('main_navigation_bar'),\n          backgroundColor: context.color.backgroundColor,\n          selectedIndex: selectedIndex,\n          onDestinationSelected: onDestinationSelected,\n          overlayColor: WidgetStateProperty.all(Colors.transparent),\n          destinations: const [\n            NavDestinationItem(\n              key: Key('home_nav_destination_item'),\n              outlineIcon: SvgPath.icHomeActive,\n              fillIcon: SvgPath.icHomeInactive,\n              label: 'Home',\n            ),\n            NavDestinationItem(\n              key: Key('subject_wise_nav_destination_item'),\n              outlineIcon: SvgPath.icSubjectWiseActive,\n              fillIcon: SvgPath.icSubjectWiseInactive,\n              label: 'Topics',\n            ),\n            NavDestinationItem(\n              key: Key('collection_nav_destination_item'),\n              outlineIcon: SvgPath.icCollectionActive,\n              fillIcon: SvgPath.icCollectionInactive,\n              label: 'Collection',\n            ),\n            NavDestinationItem(\n              key: Key('memorize_nav_destination_item'),\n              outlineIcon: SvgPath.icMemorizeActive,\n              fillIcon: SvgPath.icMemorizeInactive,\n              label: 'Memorize',\n            ),\n            NavDestinationItem(\n              key: Key('profile_nav_destination_item'),\n              outlineIcon: SvgPath.icSettingsFill,\n              fillIcon: SvgPath.icSettingsDeactive,\n              label: 'Profile',\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "class", "name": "NoticeDialogButton extends StatelessWidget", "docstring": "", "module": "drawer", "file_path": "presentation/main_page/widgets/drawer/notice_dialog_button.dart", "file_name": "notice_dialog_button.dart", "line": 11, "line_from": 11, "line_to": 99, "snippet": "class NoticeDialogButton extends StatelessWidget {\n  const NoticeDialogButton({\n    super.key,\n    required this.title,\n    required this.icon,\n    required this.color,\n    this.opacity,\n    this.trailing = true,\n    required this.onPressed,\n    required this.actionType,\n    required this.theme,\n  });\n\n  final String title;\n  final String icon;\n  final Color color;\n  final double? opacity;\n  final VoidCallback onPressed;\n  final ButtonActionType actionType;\n  final bool trailing;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: EdgeInsets.only(bottom: twelvePx),\n      child: OnTapWidget(\n        theme: theme,\n        onTap: onPressed,\n        child: Container(\n          width: QuranScreen.width,\n          padding: EdgeInsets.only(\n              left: eightPx, right: twelvePx, top: twelvePx, bottom: twelvePx),\n          decoration: BoxDecoration(\n            color: theme.primaryColor.withOpacityInt(0.07),\n            borderRadius: radius6,\n          ),\n          child: Row(\n            mainAxisAlignment: trailing\n                ? MainAxisAlignment.spaceBetween\n                : MainAxisAlignment.center,\n            children: [\n              Row(\n                children: [\n                  gapW5,\n                  SizedBox(\n                    width: thirtyPx,\n                    height: thirtyPx,\n                    child: SvgPicture.asset(icon),\n                  ),\n                  gapW15,\n                  SizedBox(\n                    width: trailing ? 55.percentWidth : null,\n                    child: Text(\n                      title,\n                      overflow: TextOverflow.ellipsis,\n                      style: theme.textTheme.titleMedium!.copyWith(\n                        fontWeight: FontWeight.w500,\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n              if (trailing)\n                if (actionType == ButtonActionType.copy)\n                  SvgPicture.asset(\n                    SvgPath.icCopy,\n                    width: eighteenPx,\n                    height: eighteenPx,\n                    colorFilter: buildColorFilter(context.color.subtitleColor),\n                  )\n                else\n                  SvgPicture.asset(\n                    SvgPath.icSend,\n                    width: sixteenPx,\n                    height: sixteenPx,\n                    colorFilter: buildColorFilter(context.color.subtitleColor),\n                  ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum ButtonActionType { copy, send }\n"}, {"structure_type": "function", "name": "_handlePopScope", "docstring": "", "module": "ui", "file_path": "presentation/ayah_detail/ui/ayah_details_page.dart", "file_name": "ayah_details_page.dart", "line": 40, "line_from": 40, "line_to": 278, "snippet": "  Future<void> _handlePopScope() async {\n    await _ayahPresenter.stopAudio();\n    _ayahPresenter.stopAutoScroll();\n    await _ayahPresenter.fetchAndSaveLastAyah();\n  }\n\n  Future<void> _initializePage() async {\n    await _ayahPresenter.initializeAyahDetailsPage(\n      initialPageIndex: initialPageIndex,\n      initialAyahIndex: initialAyahIndex,\n      showPageIndicator: showPageIndicator,\n    );\n    _audioPresenter.setPageChangeSubscription(\n      _ayahPresenter.uiState.stream.map((state) => state.currentPageIndex),\n    );\n\n    // Add preloading logic here after initialization\n    _preloadAyahData();\n  }\n\n  // New method to preload ayah data safely\n  void _preloadAyahData() {\n    // Start a microtask to ensure this runs after initialization\n    Future.microtask(() {\n      final int surahId = initialPageIndex + 1; // Convert to 1-indexed\n      final int currentAyah = initialAyahIndex + 1;\n      final int totalAyahs = CacheData.surahsCache[initialPageIndex].totalAyah;\n\n      // Determine range to preload\n      final int pageSize = _ayahPresenter.pageSize;\n      final int endAyah = (currentAyah + pageSize - 1) > totalAyahs\n          ? totalAyahs\n          : (currentAyah + pageSize - 1);\n\n      // Preload the range\n      _ayahPresenter.getWordsForAyahRange(surahId, currentAyah, endAyah);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n\n    SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(\n      statusBarColor: context.color.gradientTop,\n      statusBarIconBrightness:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      systemNavigationBarIconBrightness:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n    ));\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(\n      value: SystemUiOverlayStyle(\n        statusBarColor: context.color.gradientTop,\n        statusBarIconBrightness:\n            isDarkMode(context) ? Brightness.light : Brightness.dark,\n      ),\n      child: Stack(\n        children: [\n          PopScope(\n            onPopInvokedWithResult: (bool isPopInvoked, dynamic result) =>\n                _handlePopScope(),\n            child: PresentableWidgetBuilder(\n              presenter: _ayahPresenter,\n              onInit: () {\n                // Use post-frame callback to ensure initialization happens after the first build\n                WidgetsBinding.instance.addPostFrameCallback((_) {\n                  _initializePage();\n                });\n              },\n              builder: () {\n                final AyahViewUiState uiState = _ayahPresenter.uiState.value;\n                final AudioUIState audioUIState = _audioPresenter.uiState.value;\n\n                return Scaffold(\n                  backgroundColor: context.color.gradientTop,\n                  key: scaffoldKey,\n                  endDrawer: const MiniSettingsDrawer(isAyahPage: true),\n                  extendBody: true,\n                  endDrawerEnableOpenDragGesture: false,\n                  body: SafeArea(\n                    child: FancyScaffold(\n                      floatingWidgetController:\n                          _ayahPresenter.floatingWidgetController,\n                      isAudioPlaying: audioUIState.showPlayerControls ||\n                          _ayahPresenter\n                              .currentUiState.autoScrollOptionTurnedOn,\n                      appBar: AyahDetailsPageAppBar(\n                        key: const Key(_ayahDetailsPageAppBarKey),\n                        ayahPresenter: _ayahPresenter,\n                        scaffoldKey: scaffoldKey,\n                        theme: theme,\n                      ),\n                      body: Column(\n                        children: [\n                          Expanded(\n                            child: AyahPageScrollView(\n                              key: const Key(_ayahPageScrollViewKey),\n                              ayahPresenter: _ayahPresenter,\n                              uiState: uiState,\n                              showPageIndicator: showPageIndicator,\n                            ),\n                          ),\n                        ],\n                      ),\n                      bottomNavigationBarHeight:\n                          uiState.bottomNavigationBarHeight,\n                      bottomNavigationBar: _BottomNavigationWidget(\n                        audioUIState: audioUIState,\n                        uiState: uiState,\n                        audioPresenter: _audioPresenter,\n                        ayahPresenter: _ayahPresenter,\n                        theme: theme,\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n          StreamBuilder<AudioAction>(\n            stream: _audioPresenter.actionStream,\n            builder: (context, snapshot) {\n              if (snapshot.hasData) {\n                final AudioAction action = snapshot.data!;\n                switch (action.type) {\n                  case AudioActionType.scrollToAyah:\n                    final scrollController = ScrollControllerManager()\n                        .getScrollController(action.pageIndex!);\n                    if (scrollController.isAttached) {\n                      WidgetsBinding.instance.addPostFrameCallback((_) {\n                        scrollController.scrollTo(\n                          index: action.ayahIndex!,\n                          duration: const Duration(milliseconds: 100),\n                          curve: Curves.easeInOut,\n                        );\n                      });\n                    }\n                    break;\n                  case AudioActionType.jumpToPage:\n                    WidgetsBinding.instance.addPostFrameCallback((_) {\n                      _ayahPresenter.pageController\n                          .jumpToPage(action.pageIndex!);\n                    });\n                    break;\n                  case AudioActionType.jumpToAyah:\n                    final scrollController = ScrollControllerManager()\n                        .getScrollController(action.pageIndex!);\n                    if (scrollController.isAttached) {\n                      WidgetsBinding.instance.addPostFrameCallback((_) {\n                        scrollController.jumpTo(index: action.ayahIndex!);\n                      });\n                    }\n                    break;\n                  case AudioActionType.setBottomBarHeight:\n                    WidgetsBinding.instance.addPostFrameCallback((_) {\n                      _ayahPresenter\n                          .setBottomNavigationBarHeight(action.height!);\n                    });\n                    break;\n                }\n              }\n              return const SizedBox.shrink();\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass _BottomNavigationWidget extends StatelessWidget {\n  const _BottomNavigationWidget({\n    required this.audioUIState,\n    required this.uiState,\n    required this.audioPresenter,\n    required this.ayahPresenter,\n    required this.theme,\n  });\n\n  final AudioUIState audioUIState;\n  final AyahViewUiState uiState;\n  final AudioPresenter audioPresenter;\n  final AyahPresenter ayahPresenter;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    if (audioUIState.isDownloading) {\n      // return AudioDownloadState(\n      //   qariName: audioPresenter.getSelectedReciterName(),\n      //   downloadRange:\n      //       '${audioUIState.selectedStartSurahName} - ${audioUIState.selectedEndSurahName}',\n      //   downloadProgress: audioUIState.downloadProgress,\n      //   onCancelPressed: () async => await audioPresenter.cancelDownload(),\n      //   bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n      //   theme: theme,\n      // );\n      return AudioDownloadStatusBar(\n        qariName: audioPresenter.getSelectedReciterName(),\n        downloadRange:\n            '${audioUIState.selectedStartSurahName} - ${audioUIState.selectedEndSurahName}',\n        downloadProgress: audioUIState.downloadProgress,\n        onCancelPressed: () async => await audioPresenter.cancelDownload(),\n        bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n        theme: theme,\n      );\n    }\n\n    if (audioUIState.showPlayerControls) {\n      return AudioPlayerWidget(\n        theme: theme,\n        progress: audioUIState.currentPlayTime != null &&\n                audioUIState.totalDuration != null\n            ? audioUIState.currentPlayTime!.inMilliseconds /\n                audioUIState.totalDuration!.inMilliseconds\n            : 0.0,\n        audioPresenter: audioPresenter,\n        isFromAyahDetail: true,\n        bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n      );\n    }\n\n    if (uiState.autoScrollOptionTurnedOn) {\n      return AutoScrollControlWidget(\n        theme: theme,\n        ayahPresenter: ayahPresenter,\n        bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n      );\n    }\n\n    return SimpleNavigationButtons(\n      ayahPresenter: ayahPresenter,\n      audioPresenter: audioPresenter,\n      theme: theme,\n      bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "collection", "file_path": "presentation/ayah_detail/widgets/collection/collection_bottomsheet_persistent_footer.dart", "file_name": "collection_bottomsheet_persistent_footer.dart", "line": 26, "line_from": 26, "line_to": 129, "snippet": "  final void Function(int, {required bool isBookmarked}) onBookmarkToggled;\n  final CollectionType collectionType;\n  final VoidCallback onNewCreateBottomSheetClosed;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    final pinPresenter = locate<PinPresenter>();\n\n    return Container(\n      // height: 14.percentWidth,\n      padding: padding20,\n      color: theme.scaffoldBackgroundColor,\n      child: TwoWayActionButton(\n        key: const Key(\"TwoWayActionButton\"),\n        theme: theme,\n        cancelButtonBgColor: isDarkMode(context)\n            ? context.color.primaryButtonColor\n            : context.color.secondaryButtonColor,\n        cancelButtonTextColor: isDarkMode(context)\n            ? context.color.primaryButtonTextColor\n            : context.color.secondaryButtonTextColor,\n        onCancelButtonTap: () {\n          presenter.onClickNewCreate(\n            context: context,\n            surahID: surahID,\n            ayahID: ayahID,\n            collectionType: collectionType,\n          );\n          onNewCreateBottomSheetClosed();\n        },\n        onSubmitButtonTap: () async {\n          if (collectionType == CollectionType.pin) {\n            // Handle pin update\n            final selectedPinName = pinPresenter.currentUiState.selectedPinName;\n            if (selectedPinName.isEmpty) {\n              context.navigatorPop<void>();\n              return;\n            }\n\n            // Find the selected pin\n            final selectedPin = pinPresenter.currentUiState.pins.firstWhere(\n              (pin) => pin.name == selectedPinName,\n            );\n\n            // Only show toast if the pin's ayah or surah has actually changed\n            final bool hasChanges = selectedPin.surahId != surahID ||\n                selectedPin.ayahNumber != ayahID;\n\n            // Update the existing pin with new ayah\n            await pinPresenter.updatePin(\n              oldPin: selectedPin,\n              newName: selectedPin.name,\n              newColor: selectedPin.color,\n              newSurahId: surahID,\n              newAyahNumber: ayahID,\n              context: context,\n              onUpdated: () async {\n                // Update the UI state to show the pin icon for the new ayah\n                final ayahPresenter = locate<AyahPresenter>();\n\n                // Only update the old position if it changed\n                if (hasChanges) {\n                  // Mark the old position as no longer pinned\n                  await ayahPresenter.updateAyahDataWithPin(\n                    surahID: selectedPin.surahId,\n                    ayahID: selectedPin.ayahNumber,\n                    isPinned: false,\n                  );\n                }\n\n                // Mark the new position as pinned\n                await ayahPresenter.updateAyahDataWithPin(\n                  surahID: surahID,\n                  ayahID: ayahID,\n                  isPinned: true,\n                );\n\n                ayahPresenter.uiState.refresh();\n\n                context.navigatorPop<void>();\n                // Only show toast if there were actual changes\n                if (hasChanges) {\n                  pinPresenter.addUserMessage(context.l10n.pinUpdSuccess);\n                }\n              },\n            );\n          } else {\n            // Handle bookmark update\n            await presenter.doneButtonHandlerWithToast(\n              context: context,\n              surahID: surahID,\n              ayahID: ayahID,\n              onBookmarkToggled: onBookmarkToggled,\n              showToastAlways: true,\n            );\n          }\n        },\n        cancelButtonTitle: context.l10n.createNew,\n        submitButtonTitle: context.l10n.done,\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "collection", "file_path": "presentation/ayah_detail/widgets/collection/collection_bottom_sheet.dart", "file_name": "collection_bottom_sheet.dart", "line": 29, "line_from": 29, "line_to": 66, "snippet": "  final void Function(int, {required bool isBookmarked}) onBookmarkAdded;\n  final String? title;\n  final CollectionType collectionType;\n  @override\n  State<CollectionBottomSheet> createState() => _CollectionBottomSheetState();\n\n  static Future<void> show({\n    required int surahID,\n    required int ayahID,\n    required String? title,\n    required Future<void> Function(int, {required bool isBookmarked})\n        onBookmarkToggled,\n    required CollectionType collectionType,\n    required BuildContext context,\n  }) async {\n    try {\n      if (!context.mounted) return;\n\n      await showModalBottomSheet<void>(\n        context: context,\n        isScrollControlled: true,\n        enableDrag: false,\n        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.zero),\n        backgroundColor: Colors.transparent,\n        builder: (_) => CollectionBottomSheet(\n          surahID: surahID,\n          ayahID: ayahID,\n          title: title,\n          onBookmarkAdded: onBookmarkToggled,\n          collectionType: collectionType,\n        ),\n      );\n    } catch (e, stack) {\n      log(\"BottomSheet Error: $e\", error: e, stackTrace: stack);\n    }\n    // dislocate<MoreMenuPresenter>();\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/surah_list_column.dart", "file_name": "surah_list_column.dart", "line": 25, "line_from": 25, "line_to": 89, "snippet": "  final void Function(int surahId)? onSurahSelected;\n  final ThemeData theme;\n  final int selectedSurahIndex;\n  final List<SurahEntity> filteredSurahs;\n  final Function(String) onSearchChanged;\n  final TextEditingController surahSearchController;\n  final int? initialSurahIndex;\n  @override\n  State<SurahListColumn> createState() => _SurahListColumnState();\n}\n\nclass _SurahListColumnState extends State<SurahListColumn> {\n  final ItemScrollController _scrollController = ItemScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    UiHelper.doOnPageLoaded(() {\n      // Prioritize scrollToSurahIndex if provided, otherwise use initialSurahIndex\n      if (widget.initialSurahIndex != null && _scrollController.isAttached) {\n        _scrollController.jumpTo(index: widget.initialSurahIndex!);\n      } else if (widget.initialSurahIndex != null &&\n          _scrollController.isAttached) {\n        _scrollController.jumpTo(index: widget.initialSurahIndex!);\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return BuildExpandedColumn(\n      flex: 2,\n      searchTextField: UserInputField(\n        borderRadius: BorderRadius.circular(fiftyPx),\n        textEditingController: widget.surahSearchController,\n        hintText: context.l10n.searchSurah,\n        onChanged: widget.onSearchChanged,\n      ),\n      listViewBuilder: () {\n        if (widget.filteredSurahs.isEmpty) {\n          return CustomizableFeedbackWidget(\n            theme: widget.theme,\n            svgPath: SvgPath.icSearchBox,\n            message: context.l10n.noResultFound,\n          );\n        }\n\n        return ScrollablePositionedList.builder(\n          itemScrollController: _scrollController,\n          itemCount: widget.filteredSurahs.length,\n          itemBuilder: (context, index) {\n            final surah = widget.filteredSurahs[index];\n            return SurahListItem(\n              surah: surah,\n              theme: widget.theme,\n              index: surah.serial - 1,\n              onSelect: () => widget.onSurahSelected?.call(surah.serial - 1),\n              selectedSurahIndex: widget.selectedSurahIndex,\n            );\n          },\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "onFontChanged", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/arabic_ayah_text_widget.dart", "file_name": "arabic_ayah_text_widget.dart", "line": 19, "line_from": 19, "line_to": 326, "snippet": "  static void onFontChanged(String fontFamily, double fontSize) {\n    // If the font has changed, clear the entire cache\n    if (_lastFontFamily != fontFamily || _lastFontSize != fontSize) {\n      _cache.clear();\n      _processedAyahs.clear();\n      _lastFontFamily = fontFamily;\n      _lastFontSize = fontSize;\n\n      // Also clear the TajweedEntity cache to ensure consistency\n      TajweedEntity.clearCache();\n    }\n  }\n\n  static TextSpan getProcessedText({\n    required String text,\n    required TextStyle baseStyle,\n    required int surahNumber,\n    required int ayahNumber,\n    required bool showTajweed,\n  }) {\n    if (text.isEmpty) {\n      // Return a simple text span if the text is empty to avoid processing issues\n      return TextSpan(text: '', style: baseStyle);\n    }\n\n    // Check if font has changed and update tracking\n    final fontFamily = baseStyle.fontFamily ?? '';\n    final fontSize = baseStyle.fontSize ?? 0.0;\n\n    if (_lastFontFamily != fontFamily || _lastFontSize != fontSize) {\n      onFontChanged(fontFamily, fontSize);\n    }\n\n    final String ayahKey = '${surahNumber}_$ayahNumber';\n    // Enhanced cache key including more font properties and theme color\n    final String key =\n        '${surahNumber}_${ayahNumber}_${text.length}_${fontSize}_${fontFamily}_${baseStyle.fontWeight?.index}_${baseStyle.fontStyle?.index}_${baseStyle.color?.toARGB32()}_$showTajweed';\n\n    // Skip cache for previously problematic ayahs\n    if (_processedAyahs.containsKey(ayahKey) && _processedAyahs[ayahKey] == false) {\n      _cache.remove(key);\n    }\n\n    if (!_cache.containsKey(key)) {\n      try {\n        final result = TajweedEntity.processTajweedText(\n          text: text,\n          baseStyle: baseStyle,\n          surahNumber: surahNumber,\n          ayahNumber: ayahNumber,\n          showTajweed: showTajweed,\n        );\n\n        // Extract the original text without tajweed markup for comparison\n        final String strippedOriginal = text.replaceAllMapped(\n            RegExp(r'\\[(.*?)\\]\\((.*?)\\)|\\((.*?)\\)\\[(.*?)\\]', dotAll: true, multiLine: true), (Match match) {\n          if (match.group(1) != null) return match.group(1)!;\n          return match.group(4)!;\n        });\n\n        // Verify the processed text has expected content\n        if (_isProcessedTextValid(result, strippedOriginal)) {\n          _cache[key] = result;\n          _processedAyahs[ayahKey] = true; // Mark as successfully processed\n        } else {\n          // If verification fails, mark as problematic\n          _processedAyahs[ayahKey] = false;\n\n          // Process without cache and return the result\n          return TajweedEntity.processTajweedText(\n            text: text,\n            baseStyle: baseStyle,\n            surahNumber: surahNumber,\n            ayahNumber: ayahNumber,\n            showTajweed: showTajweed,\n          );\n        }\n\n        // Manage cache size\n        if (_cache.length > 200) {\n          final keysToRemove = _cache.keys.take(50).toList();\n          for (final cacheKey in keysToRemove) {\n            _cache.remove(cacheKey);\n          }\n        }\n      } catch (e) {\n        // Fallback to simple text span if processing fails\n        _processedAyahs[ayahKey] = false; // Mark as problematic\n        return TextSpan(text: text, style: baseStyle);\n      }\n    }\n\n    // Double-check the cached result for completeness\n    final cachedResult = _cache[key]!;\n\n    // Extract the original text without tajweed markup for verification\n    final String strippedOriginal = text.replaceAllMapped(\n        RegExp(r'\\[(.*?)\\]\\((.*?)\\)|\\((.*?)\\)\\[(.*?)\\]', dotAll: true, multiLine: true), (Match match) {\n      if (match.group(1) != null) return match.group(1)!;\n      return match.group(4)!;\n    });\n\n    if (!_isProcessedTextValid(cachedResult, strippedOriginal)) {\n      _processedAyahs[ayahKey] = false; // Mark as problematic\n      _cache.remove(key);\n\n      // Regenerate without caching\n      return TajweedEntity.processTajweedText(\n        text: text,\n        baseStyle: baseStyle,\n        surahNumber: surahNumber,\n        ayahNumber: ayahNumber,\n        showTajweed: showTajweed,\n      );\n    }\n\n    return cachedResult;\n  }\n\n  // Helper method to extract all text from a TextSpan tree\n  static String _extractTextFromSpan(TextSpan span) {\n    String result = span.text ?? '';\n\n    if (span.children != null) {\n      for (var child in span.children!) {\n        if (child is TextSpan) {\n          result += _extractTextFromSpan(child);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // Helper method to verify processed text contains all expected content\n  static bool _isProcessedTextValid(TextSpan processedSpan, String originalText) {\n    if (processedSpan.children == null || processedSpan.children!.isEmpty) {\n      return processedSpan.text == originalText;\n    }\n\n    // Extract all text from the TextSpan tree\n    final String extractedText = _extractTextFromSpan(processedSpan);\n\n    // Remove whitespace for comparison\n    final String normalizedOriginal = originalText.replaceAll(RegExp(r'\\s+'), '');\n    final String normalizedProcessed = extractedText.replaceAll(RegExp(r'\\s+'), '');\n\n    // Check for length equality and some content matching at the beginning and end\n    if (normalizedOriginal.length != normalizedProcessed.length) {\n      return false;\n    }\n\n    // Add extra checks for the start and end of the text\n    // This ensures the processed text maintains the same structure\n    final int checkLength = normalizedOriginal.length > 10 ? 5 : normalizedOriginal.length ~/ 2;\n\n    if (checkLength > 0) {\n      if (!normalizedProcessed.startsWith(normalizedOriginal.substring(0, checkLength))) {\n        return false;\n      }\n\n      if (!normalizedProcessed.endsWith(normalizedOriginal.substring(normalizedOriginal.length - checkLength))) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Clear the cache\n  static void clearCache() {\n    _cache.clear();\n    _processedAyahs.clear();\n    _lastFontFamily = '';\n    _lastFontSize = 0;\n    // Also clear the TajweedEntity cache\n    TajweedEntity.clearCache();\n  }\n}\n\nclass ArabicAyahTextWidget extends StatelessWidget {\n  const ArabicAyahTextWidget({\n    super.key,\n    required this.ayahNumber,\n    this.wordData,\n    required this.arabicFontScript,\n    required this.arabicFontName,\n    required this.arabicFontSize,\n    required this.theme,\n    this.singleAyah,\n    this.highlightedAyah,\n    this.isArabicSearch = false,\n    this.surahID,\n    required this.showTajweed,\n    this.selectedWordIndex,\n  });\n\n  final int ayahNumber;\n  final List<WordByWordEntity>? wordData;\n  final ArabicFontScript arabicFontScript;\n  final String arabicFontName;\n  final double arabicFontSize;\n  final AyahEntity? singleAyah;\n  final ThemeData theme;\n  final TextSpan? highlightedAyah;\n  final bool isArabicSearch;\n  final int? surahID;\n  final bool showTajweed;\n  final int? selectedWordIndex;\n\n  // Static method to clear all caches when font settings change\n  static void onFontSettingsChanged(String fontFamily, double fontSize) {\n    _TajweedTextCache.clearCache();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: double.infinity,\n      child: _buildWordByWordText(context),\n    );\n  }\n\n  Widget _buildWordByWordText(BuildContext context) {\n    // In search results, if we have a highlighted span, use that directly\n    if (isArabicSearch && highlightedAyah != null) {\n      // For search results, we need to use the highlightedAyah directly\n      // but still apply the proper font and styling\n      final TextStyle baseStyle = context.quranText.arabicAyah!.copyWith(\n        fontFamily: arabicFontName,\n        fontSize: arabicFontSize,\n      );\n\n      // The highlighted ayah already has tajweed tags stripped\n      // in the SearchPresenter.getHighlightedAyah method\n      return RichText(\n        textDirection: TextDirection.rtl,\n        text: TextSpan(\n          children: highlightedAyah!.children,\n          style: baseStyle.merge(highlightedAyah!.style),\n          text: highlightedAyah!.text,\n        ),\n      );\n    }\n\n    if (wordData == null) return const SizedBox.shrink();\n\n    return Wrap(\n      key: Key(\"ayah_$ayahNumber\"),\n      direction: Axis.horizontal,\n      alignment: WrapAlignment.start,\n      textDirection: TextDirection.rtl,\n      children: List.generate(wordData!.length, (index) {\n        final word = wordData![index];\n        final String arabicText = arabicFontScript == ArabicFontScript.uthmani ? word.uthmani! : word.indopak!;\n        final TextStyle baseStyle = context.quranText.arabicAyah!.copyWith(\n          fontFamily: arabicFontName,\n          fontSize: arabicFontSize,\n          letterSpacing: 0,\n          height: 1.3,\n        );\n        final bool isSelected = index == selectedWordIndex;\n        final TextStyle wordStyle = isSelected ? baseStyle.copyWith(color: theme.colorScheme.primary) : baseStyle;\n\n        return Padding(\n          padding: const EdgeInsets.only(left: 2.0, bottom: 8.0),\n          child: OnTapWidget(\n            theme: theme,\n            onTap: () => _showGrammarBottomSheet(context, word),\n            child: Container(\n              padding: EdgeInsets.symmetric(horizontal: twoPx),\n              decoration: BoxDecoration(\n                color: isSelected ? theme.colorScheme.primary.withOpacityInt(0.2) : null,\n                borderRadius: BorderRadius.circular(fourPx),\n              ),\n              child: showTajweed\n                  ? RichText(\n                      textDirection: TextDirection.rtl,\n                      text: _TajweedTextCache.getProcessedText(\n                        text: arabicText,\n                        baseStyle: wordStyle,\n                        surahNumber: surahID ?? 1,\n                        ayahNumber: ayahNumber,\n                        showTajweed: showTajweed,\n                      ),\n                    )\n                  : Text(\n                      TajweedEntity.stripTajweedTags(arabicText),\n                      textDirection: TextDirection.rtl,\n                      style: wordStyle,\n                    ),\n            ),\n          ),\n        );\n      }),\n    );\n  }\n\n  void _showGrammarBottomSheet(BuildContext context, WordByWordEntity selectedWord) {\n    if (wordData != null) {\n      GrammarBottomSheet.show(\n        context: context,\n        wordList: wordData!,\n        selectedWordIndex: wordData!.indexOf(selectedWord),\n      );\n    }\n  }\n}"}, {"structure_type": "function", "name": "issues", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/ayah_content_widget.dart", "file_name": "ayah_content_widget.dart", "line": 95, "line_from": 95, "line_to": 166, "snippet": "        // We use Future.microtask to avoid blocking the UI thread and prevent initialization issues\n        Future.microtask(() {\n          ayahPresenter.preloadNextAyahPage(\n              pageIndex + 1, currentAyahIndex + 1);\n        });\n      }\n    }\n  }\n\n  Widget _buildAyahItem(BuildContext context, SurahEntity surah,\n      ThemeData theme, List<WordByWordEntity> wordData, int ayahIndex) {\n    final int ayahNumber = ayahIndex + 1;\n    final List<WordByWordEntity> ayahWords =\n        wordData.where((word) => word.ayah == ayahNumber).toList();\n\n    final bool isFirstAyah = ayahIndex == 0;\n    final bool isNewPage = CacheData.uniquePageIDwithSurahAndAyahID\n        .containsKey('${surah.serial}:$ayahNumber');\n    final WordByWordEntity? firstWordOfPageAyah =\n        ayahWords.isNotEmpty ? ayahWords.first : null;\n    final bool shouldShowBismillah =\n        isFirstAyah && surah.serial != 1 && surah.serial != 9;\n\n    return Column(\n      children: [\n        if (isFirstAyah) ...[\n          SurahHeader(surah: surah, theme: theme),\n          gapH16,\n        ],\n        if (shouldShowBismillah) ...[\n          ShowBismillahWidget(theme: theme),\n          gapH12,\n        ],\n        if (showPageIndicator && isNewPage) ...[\n          CenteredPageIndicator(\n            theme: theme,\n            pageNumber: firstWordOfPageAyah?.page ?? 0,\n            juzNumber: firstWordOfPageAyah?.juz ?? 0,\n            hijbNumber: firstWordOfPageAyah?.hijb != null\n                ? ayahPresenter.formatHijbNumber(firstWordOfPageAyah!.hijb!)\n                : '',\n          ),\n          gapH8,\n        ],\n        AyahContainer(\n          theme: theme,\n          isFromSpecificPage: true,\n          onTapAyahCard: () async {\n            await ayahPresenter.onTapAyahCard(\n              context: context,\n              surahID: surah.serial,\n              ayahNumber: ayahNumber,\n            );\n          },\n          ayahPresenter: ayahPresenter,\n          index: ayahIndex,\n          surahID: pageIndex + 1,\n          ayahNumber: ayahNumber,\n          ayahTopRowTitle: ayahNumber.toLocalizedString(context),\n          wordData: ayahWords,\n          onClickMore: () {\n            ayahPresenter.onAyahMoreClicked(\n              context: context,\n              surah: surah,\n              ayahNumber: ayahNumber,\n            );\n          },\n        ),\n        if (ayahIndex == surah.totalAyah - 1) SizedBox(height: 22.percentWidth),\n      ],\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/build_ayah_list_column.dart", "file_name": "build_ayah_list_column.dart", "line": 22, "line_from": 22, "line_to": 80, "snippet": "  final void Function(int ayahID)? onAyahSelected;\n  final ThemeData theme;\n  final int selectedAyahIndex;\n  final List<int> filteredAyahs;\n  final Function(String) onSearchChanged;\n  final TextEditingController ayahSearchController;\n  final int ayahNumbers;\n  final int? initialAyahIndex;\n\n  @override\n  State<BuildAyahListColumn> createState() => _BuildAyahListColumnState();\n}\n\nclass _BuildAyahListColumnState extends State<BuildAyahListColumn> {\n  final ItemScrollController _scrollController = ItemScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.initialAyahIndex != null) {\n      UiHelper.doOnPageLoaded(() {\n        if (_scrollController.isAttached) {\n          _scrollController.jumpTo(index: widget.initialAyahIndex!);\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return BuildExpandedColumn(\n        flex: 1,\n        searchTextField: UserInputField(\n          textEditingController: widget.ayahSearchController,\n          borderRadius: BorderRadius.circular(50),\n          hintText: context.l10n.ayah,\n          onChanged: widget.onSearchChanged,\n          inputFormatters: [\n            FilteringTextInputFormatter.digitsOnly,\n            LengthLimitingTextInputFormatter(3),\n          ],\n        ),\n        listViewBuilder: () {\n          return ScrollablePositionedList.builder(\n            itemScrollController: _scrollController,\n            itemCount: widget.filteredAyahs.length,\n            itemBuilder: (context, index) {\n              final ayahID = widget.filteredAyahs[index];\n              return AyahNumberListItem(\n                index: ayahID - 1,\n                theme: widget.theme,\n                selectedAyahIndex: widget.selectedAyahIndex,\n                onSelect: () => widget.onAyahSelected!(ayahID - 1),\n              );\n            },\n          );\n        });\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "bottom_sheet", "file_path": "presentation/ayah_detail/widgets/bottom_sheet/more_option_bottom_sheet.dart", "file_name": "more_option_bottom_sheet.dart", "line": 60, "line_from": 60, "line_to": 95, "snippet": "    void Function(BookmarkEntity)? onBookmarkRemoved,\n    bool isDirectButtonVisible = false,\n    bool idAddCollectionButtonVisible = true,\n    bool isPlayButtonVisible = true,\n    bool isCopyAyahButtonVisible = true,\n    bool isFromMemorization = false,\n    bool isFromDailyAyah = false,\n    bool isFromSearch = false,\n    bool isFromSubjectWise = false,\n    bool isTafseerButtonVisible = false,\n    bool isFromAyahPage = false,\n    bool isFromDua = false,\n  }) async {\n    final MoreOptionBottomSheet moreOptionBottomSheet = MoreOptionBottomSheet(\n      surahID: surahID,\n      ayahID: ayahID,\n      bookmark: bookmark,\n      dua: dua,\n      onBookmarkRemoved: onBookmarkRemoved,\n      isDirectButtonVisible: isDirectButtonVisible,\n      idAddCollectionButtonVisible: idAddCollectionButtonVisible,\n      isPlayButtonVisible: isPlayButtonVisible,\n      isCopyAyahButtonVisible: isCopyAyahButtonVisible,\n      isFromMemorization: isFromMemorization,\n      isFromDailyAyah: isFromDailyAyah,\n      isFromSearch: isFromSearch,\n      isFromSubjectWise: isFromSubjectWise,\n      isTafseerButtonVisible: isTafseerButtonVisible,\n      isFromAyahPage: isFromAyahPage,\n      isFromDua: isFromDua,\n      key: const Key(\"MoreOptionBottomSheet\"),\n    );\n\n    if (!context.mounted) return;\n    await context.showBottomSheet(moreOptionBottomSheet, context);\n  }"}, {"structure_type": "function", "name": "onInit", "docstring": "", "module": "presenter", "file_path": "presentation/word_by_word/presenter/word_by_word_presenter.dart", "file_name": "word_by_word_presenter.dart", "line": 47, "line_from": 47, "line_to": 322, "snippet": "  Future<void> onInit() async {\n    super.onInit();\n    await _loadInitialData();\n  }\n\n  Future<void> _loadInitialData() async {\n    await toggleLoading(loading: true);\n    await _loadDownloadedLanguages();\n    await _loadAvailableLanguages();\n    await _loadSelectedLanguage();\n    await toggleLoading(loading: false);\n  }\n\n  Future<void> _loadAvailableLanguages() async {\n    final result = await _getAvailableWbwLanguagesUseCase.execute();\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (wbwJsonModel) async {\n        final input = _LanguageProcessInput(\n          allLanguages: wbwJsonModel.wordbyword,\n          downloadedLanguages: currentUiState.downloadedLanguages,\n        );\n\n        final List<WbwDbFileModel> availableLanguages = await compute(\n          _processAvailableLanguages,\n          input,\n        );\n\n        uiState.value = currentUiState.copyWith(\n          availableLanguages: availableLanguages,\n          allLanguages: wbwJsonModel.wordbyword,\n        );\n      },\n    );\n  }\n\n  static List<WbwDbFileModel> _processAvailableLanguages(_LanguageProcessInput input) {\n    return input.allLanguages.where((language) => !input.downloadedLanguages.contains(language.name)).toList();\n  }\n\n  Future<void> _loadDownloadedLanguages() async {\n    final result = await _getDownloadedWbwLanguagesUseCase.execute();\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (downloadedLanguages) {\n        uiState.value = currentUiState.copyWith(\n          downloadedLanguages: downloadedLanguages,\n        );\n      },\n    );\n  }\n\n  String getFileSize(String fileName, BuildContext context) {\n    if (fileName == 'Bangla' || fileName == 'English') {\n      return context.l10n.defaultLang;\n    }\n    final WbwDbFileModel file = currentUiState.allLanguages.firstWhere((element) => element.name == fileName);\n    return '${context.l10n.fileSize}: ${file.size.toLocalizedNumber(context)} ${context.l10n.mb}';\n  }\n\n  Future<void> _loadSelectedLanguage() async {\n    final result = await _getSelectedWbwLanguageUseCase.execute();\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (selectedLanguage) {\n        uiState.value = currentUiState.copyWith(\n          selectedLanguage: selectedLanguage,\n        );\n      },\n    );\n  }\n\n  Future<void> downloadLanguage({required WbwDbFileModel wbwFile, required BuildContext context}) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet && context.mounted) {\n      showMessage(message: context.l10n.noInternetConnection);\n      return;\n    }\n\n    if (currentUiState.isDownloading) {\n      if (currentUiState.activeDownloadId == wbwFile.name && context.mounted) {\n        cancelDownload(context);\n        return addUserMessage(context.l10n.downloadCancelled);\n      } else {\n        if (context.mounted) {\n          return addUserMessage(context.l10n.downloadInProgress);\n        }\n      }\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isDownloading: true,\n      activeDownloadId: wbwFile.name,\n      downloadProgress: 0,\n    );\n\n    final Either<String, void> result = await _downloadWbwLanguageUseCase.execute(\n      wbwFile: wbwFile,\n      onProgress: (progress) {\n        uiState.value = currentUiState.copyWith(downloadProgress: progress);\n      },\n      cancelToken: _addCancelToken(wbwFile),\n    );\n\n    result.fold(\n      (failure) {\n        if (failure == \"Download cancelled\") {\n          if (context.mounted) addUserMessage(context.l10n.downloadCancelled);\n        } else {\n          if (context.mounted) addUserMessage(context.l10n.downloadFailed);\n        }\n        uiState.value = currentUiState.copyWith(\n          isDownloading: false,\n          activeDownloadId: null,\n          downloadProgress: 0,\n        );\n      },\n      (_) async {\n        await _loadDownloadedLanguages();\n        await _loadAvailableLanguages();\n        if (context.mounted) {\n          addUserMessage(context.l10n.downloadedSuccessfully);\n        }\n        uiState.value = currentUiState.copyWith(\n          isDownloading: false,\n          activeDownloadId: null,\n          downloadProgress: 0,\n        );\n      },\n    );\n  }\n\n  Future<void> loadWordByWordByFileModel(WbwDbFileModel fileModel, BuildContext context) async {\n    if (['Bangla', 'English'].contains(fileModel.name)) {\n      // Handle default language\n      await setSelectedLanguage(fileName: fileModel.name);\n    } else {\n      // Handle non-default language\n      final bool hasInternet = await checkInternetConnection();\n      if (!hasInternet) {\n        if (context.mounted) {\n          showMessage(message: context.l10n.noInternetConnection);\n        }\n        return;\n      }\n\n      uiState.value = currentUiState.copyWith(\n        isDownloading: true,\n        activeDownloadId: fileModel.name,\n        downloadProgress: 0,\n      );\n\n      final result = await _downloadWbwLanguageUseCase.execute(\n        wbwFile: fileModel,\n        cancelToken: _addCancelToken(fileModel),\n        onProgress: (progress) {\n          uiState.value = currentUiState.copyWith(downloadProgress: progress);\n        },\n      );\n\n      result.fold(\n        (error) => addUserMessage(error),\n        (_) async {\n          await _loadDownloadedLanguages();\n          await setSelectedLanguage(fileName: fileModel.name);\n        },\n      );\n    }\n\n    await _loadAvailableLanguages();\n    uiState.value = currentUiState.copyWith(\n      isDownloading: false,\n      activeDownloadId: null,\n      downloadProgress: 0,\n    );\n  }\n\n  CancelToken _addCancelToken(WbwDbFileModel file) {\n    final CancelToken cancelToken = CancelToken();\n    _cancelTokens[file.name] = cancelToken;\n    return cancelToken;\n  }\n\n  void cancelDownload(BuildContext context) {\n    if (currentUiState.isDownloading) {\n      _cancelTokens[currentUiState.activeDownloadId]?.cancel();\n\n      uiState.value = currentUiState.copyWith(\n        isDownloading: false,\n        activeDownloadId: null,\n        downloadProgress: 0,\n      );\n      addUserMessage(context.l10n.downloadCancelled);\n    }\n  }\n\n  Future<void> deleteLanguage({required String fileName, required BuildContext context}) async {\n    if (['Bangla', 'English'].contains(fileName)) {\n      addUserMessage(context.l10n.cannotDeleteDefaultLanguages);\n      return;\n    }\n\n    await RemoveDialog.show(\n      title: context.l10n.language,\n      context: context,\n      onRemove: () async {\n        final bool isCurrentlySelected = currentUiState.selectedLanguage == fileName;\n        final Either<String, WbwJsonModel> availableLanguagesResult = await _getAvailableWbwLanguagesUseCase.execute();\n        final WbwDbFileModel? wbwFile = availableLanguagesResult.fold(\n          (failure) {\n            addUserMessage(failure);\n            return null;\n          },\n          (wbwJsonModel) {\n            return wbwJsonModel.wordbyword.firstWhere((element) => element.name == fileName);\n          },\n        );\n        final deletedFile = await _deleteWbwLanguageUseCase.execute(file: wbwFile!);\n        deletedFile.fold(\n          (failure) => addUserMessage(failure),\n          (_) async {\n            await _loadDownloadedLanguages();\n            await _loadAvailableLanguages();\n            if (isCurrentlySelected) {\n              await setSelectedLanguage(fileName: currentUiState.downloadedLanguages.first);\n            }\n            if (context.mounted) {\n              addUserMessage(context.l10n.deletedSuccessfully);\n            }\n          },\n        );\n      },\n    );\n  }\n\n  Future<void> setSelectedLanguage({required String fileName}) async {\n    final WbwDbFileModel file = currentUiState.allLanguages.firstWhere((element) => element.fileName == fileName);\n    final result = await _setSelectedWbwLanguageUseCase.execute(file: file);\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (_) async {\n        await _loadSelectedLanguage();\n      },\n    );\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async {\n    uiState.value = currentUiState.copyWith(userMessage: message);\n    showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async =>\n      uiState.value = currentUiState.copyWith(isLoading: loading);\n\n  bool isLanguageDownloaded(String fileName) {\n    // Convert fileName to language name if needed\n    String languageName = fileName;\n\n    // Map filename to language name\n    final Map<String, String> fileToName = {\n      'wbw_bn': 'Bangla',\n      'wbw_en': 'English',\n      'wbw_de': 'German',\n      'wbw_hi': 'Hindi',\n      'wbw_indo': 'Indonesian',\n      'wbw_ru': 'Russian',\n      'wbw_tr': 'Turkish',\n      'wbw_ur': 'Urdu',\n    };\n    languageName = fileToName[fileName] ?? fileName;\n\n    return currentUiState.downloadedLanguages.contains(languageName);\n  }\n}"}, {"structure_type": "function", "name": "conflicts", "docstring": "", "module": "ui", "file_path": "presentation/mushaf/ui/mushaf_page.dart", "file_name": "mushaf_page.dart", "line": 40, "line_from": 40, "line_to": 58, "snippet": "    // Set the mushaf type in the next frame to avoid build conflicts\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      presenter.setSelectedMushafType(type: widget.mushafType);\n      // Update appbar title after initialization\n      presenter.updateAppbarTitle(context);\n\n      // Start preloading pages in the background\n      presenter.preloadMushafPages();\n    });\n\n    // Register for app lifecycle events to manage memory\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "ui", "file_path": "presentation/mushaf/ui/text_mushaf_page.dart", "file_name": "text_mushaf_page.dart", "line": 27, "line_from": 27, "line_to": 132, "snippet": "  void initState() {\n    super.initState();\n\n    // Defer initialization to after the build is complete\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      presenter.initializePreloadCache();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    super.build(context);\n    final ThemeData theme = Theme.of(context);\n\n    return Scaffold(\n      body: PresentableWidgetBuilder(\n        presenter: presenter,\n        builder: () {\n          final TextMushafUiState state = presenter.currentUiState;\n\n          return Column(\n            children: [\n              Expanded(\n                child: PageView.builder(\n                  controller: presenter.pageController,\n                  onPageChanged: (index) => presenter.onPageChanged(newPage: index + 1),\n                  itemCount: state.totalPages,\n                  itemBuilder: (BuildContext context, int pageIndex) {\n                    final int pageNumber = pageIndex + 1;\n\n                    final pageData = presenter.getPageCache(pageNumber);\n\n                    String fontFamily;\n                    if (state.selectedTextFormat == TextFormat.qpcV1) {\n                      fontFamily = state.pageFonts[pageNumber] ?? FontConstants.defaultFontFamily;\n                    } else {\n                      fontFamily = state.selectedTextFormat.fontFamily;\n                    }\n\n                    final bool hasPageFont = state.pageFonts.containsKey(pageNumber);\n\n                    return _TextMushafPageContent(\n                      key: ValueKey('text_page_$pageNumber'),\n                      pageNumber: pageNumber,\n                      layoutData: pageData?.layout ?? [],\n                      wordsByLine: pageData?.words ?? {},\n                      theme: theme,\n                      fontFamily: fontFamily,\n                      textFormat: state.selectedTextFormat,\n                      hasPageFont: hasPageFont,\n                    );\n                  },\n                ),\n              ),\n              Text(\n                'Page ${state.currentPage} of ${state.totalPages}',\n                style: theme.textTheme.bodySmall,\n              ),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _TextMushafPageContent extends StatelessWidget {\n  final int pageNumber;\n  final List<TextLayoutEntity> layoutData;\n  final Map<int, List<TextWordEntity>> wordsByLine;\n  final ThemeData theme;\n  final String fontFamily;\n  final bool hasPageFont;\n  final TextFormat textFormat;\n\n  const _TextMushafPageContent({\n    super.key,\n    required this.pageNumber,\n    required this.layoutData,\n    required this.wordsByLine,\n    required this.theme,\n    required this.fontFamily,\n    required this.textFormat,\n    this.hasPageFont = false,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: layoutData.length,\n      itemBuilder: (context, lineIndex) {\n        final TextLayoutEntity lineLayout = layoutData[lineIndex];\n        final List<TextWordEntity>? words = wordsByLine[lineLayout.line];\n        return _TextLineWidget(\n          key: ValueKey('line_${pageNumber}_${lineLayout.line}'),\n          lineLayout: lineLayout,\n          words: words,\n          theme: theme,\n          fontFamily: fontFamily,\n          textFormat: textFormat,\n          hasPageFont: hasPageFont,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "conflicts", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 135, "line_from": 135, "line_to": 146, "snippet": "    // Update state in a microtask to avoid build conflicts\n    await Future.microtask(() {\n      uiState.value = currentUiState.copyWith(pageFonts: updatedFonts);\n    });\n\n    return fontFamily;\n  }\n\n  Future<void> _preloadFonts(int currentPage) async {\n    _fontDirPath ??= await _textMushafRepository.getFontDirectoryPath();\n    await _fontManager.preloadFonts(currentPage, currentUiState.totalPages, _fontDirPath!);\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 150, "line_from": 150, "line_to": 178, "snippet": "    void Function(double progress)? onProgressUpdate,\n  }) async {\n    _fontDirPath ??= await _textMushafRepository.getFontDirectoryPath();\n\n    final List<int> pagesToDownload = List.generate(_initialFontBatchSize, (index) => index + 1);\n\n    uiState.value = currentUiState.copyWith(\n      isFontDownloading: true,\n      fontDownloadProgress: 0.0,\n    );\n\n    await _textMushafRepository.downloadPageFontBatch(\n      pageNumbers: pagesToDownload,\n      onBatchProgress: (completed, total) {\n        final double progress = completed / total;\n        uiState.value = currentUiState.copyWith(fontDownloadProgress: progress);\n        onProgressUpdate?.call(progress);\n      },\n      onFontProgress: (pageNumber, progress) {},\n      cancelToken: cancelToken,\n    );\n\n    uiState.value = currentUiState.copyWith(\n      isFontDownloading: false,\n      fontDownloadProgress: 1.0,\n    );\n\n    await _loadFontForPage(currentUiState.currentPage);\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 219, "line_from": 219, "line_to": 263, "snippet": "    void Function(double progress)? onProgressUpdate,\n  }) async {\n    final bool isAvailable = await isDatabaseAvailable();\n\n    _initCancelToken = CancelToken();\n\n    if (isAvailable) {\n      await loadTextDataForPage(pageNumber: currentUiState.currentPage);\n\n      _fontDirPath ??= await _textMushafRepository.getFontDirectoryPath();\n\n      final bool fontAvailable = await _isPageFontAvailable(currentUiState.currentPage);\n      if (fontAvailable) {\n        await _loadFontForPage(currentUiState.currentPage);\n      }\n\n      _initCancelToken = null;\n      return;\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isDownloading: true,\n      downloadProgress: 0.0,\n    );\n\n    await _initializeTextMushafDatabaseUseCase.execute(\n      onProgress: (received, total) {\n        if (total > 0) {\n          final progress = received / total;\n          uiState.value = currentUiState.copyWith(downloadProgress: progress);\n          onProgressUpdate?.call(progress);\n        }\n      },\n      cancelToken: _initCancelToken!,\n    );\n\n    await loadTextDataForPage(pageNumber: currentUiState.currentPage);\n\n    uiState.value = currentUiState.copyWith(\n      isDownloading: false,\n      downloadProgress: 1.0,\n    );\n\n    _initCancelToken = null;\n  }"}, {"structure_type": "function", "name": "conflicts", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 322, "line_from": 322, "line_to": 339, "snippet": "        // Update state in a microtask to avoid build conflicts\n        await Future.microtask(() {\n          uiState.value = currentUiState.copyWith(\n            textLayout: layoutData,\n            textWordsByLine: wordsByLine,\n            isLoading: false,\n          );\n        });\n\n        _preloadFonts(pageNumber);\n      }\n    } catch (e) {\n      if (!background) {\n        await addUserMessage('An unexpected error occurred.');\n      }\n    } finally {\n      _loadingPages.remove(pageNumber);\n    }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 361, "line_from": 361, "line_to": 421, "snippet": "    // Use microtask to avoid updating state during build\n    Future.microtask(() {\n      uiState.value = currentUiState.copyWith(\n        currentSurahNameOrNull: () => surahName ?? currentUiState.currentSurahName,\n        currentJuzNumberOrNull: () => juzNumber ?? currentUiState.currentJuzNumber,\n        currentHizbNumberOrNull: () => hizbNumber ?? currentUiState.currentHizbNumber,\n        appbarTitleKeyOrNull: () => surahName != null ? null : 'textMushafTitle',\n        appbarTitleOrNull: () => surahName,\n      );\n    });\n  }\n\n  Future<void> loadTextDataForPage({required int pageNumber}) async {\n    if (pageNumber < 1 || pageNumber > currentUiState.totalPages) return;\n\n    if (currentUiState.isLoading && currentUiState.currentPage == pageNumber) return;\n\n    // Update state in a microtask to avoid build conflicts\n    await Future.microtask(() {\n      uiState.value = currentUiState.copyWith(\n        isLoading: true,\n        currentPage: pageNumber,\n        userMessage: null,\n      );\n    });\n\n    // Make sure the glyph database is initialized\n    try {\n      await _glyphRepository.initializeGlyphDatabase();\n    } catch (e) {\n      log('Error initializing glyph database: $e');\n    }\n\n    if (_pageCache.containsKey(pageNumber)) {\n      final PageCacheData cachedData = _pageCache[pageNumber]!;\n\n      await _updatePageHeaderInfo(pageNumber);\n\n      if (await _isPageFontAvailable(pageNumber)) {\n        await _loadFontForPage(pageNumber);\n      }\n\n      // Update state in a microtask to avoid build conflicts\n      await Future.microtask(() {\n        uiState.value = currentUiState.copyWith(\n          textLayout: cachedData.layout,\n          textWordsByLine: cachedData.words,\n          isLoading: false,\n        );\n      });\n\n      _preloadAdjacentPages(pageNumber);\n\n      _preloadFonts(pageNumber);\n      return;\n    }\n\n    await _loadPageDataToCache(pageNumber: pageNumber);\n\n    _preloadAdjacentPages(pageNumber);\n  }"}, {"structure_type": "function", "name": "[];", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 473, "line_from": 473, "line_to": 513, "snippet": "    final List<Future<void>> wordFutures = [];\n\n    for (final TextLayoutEntity lineLayout in layoutData) {\n      if (lineLayout.type == 'ayah' && lineLayout.rangeStart > 0 && lineLayout.rangeEnd >= lineLayout.rangeStart) {\n        wordFutures.add(_getWordsForRangeUseCase\n            .execute(\n          params: GetWordsForRangeParams(\n            rangeStart: lineLayout.rangeStart,\n            rangeEnd: lineLayout.rangeEnd,\n          ),\n        )\n            .then((wordsResult) {\n          wordsResult.fold(\n            (wordsError) {\n              wordFetchError = true;\n              wordsByLine[lineLayout.line] = [];\n            },\n            (wordData) {\n              wordsByLine[lineLayout.line] = wordData;\n            },\n          );\n        }));\n      } else {\n        wordsByLine[lineLayout.line] = [];\n      }\n    }\n\n    await Future.wait(wordFutures);\n\n    if (wordFetchError) {\n      await addUserMessage('Some word data could not be loaded.');\n    }\n\n    return wordsByLine;\n  }\n\n  void onPageChanged({required int newPage}) {\n    if (newPage < 1 || newPage > currentUiState.totalPages || newPage == currentUiState.currentPage) return;\n\n    loadTextDataForPage(pageNumber: newPage);\n  }"}, {"structure_type": "function", "name": "rebuilds", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 215, "line_from": 215, "line_to": 243, "snippet": "    // Batch all state updates together to avoid multiple rebuilds\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      uiState.value = currentUiState.copyWith(\n        currentMushafType: newType,\n        currentPage: pageToOpen,\n        mushafDirectory: extractedPath,\n      );\n    });\n\n    await updatePageInfo(pageToOpen);\n  }\n\n  Future<int?> getFirstNonEmptyPage(MushafType type) async {\n    for (int page = 1; page <= _getTotalPages(type); page++) {\n      // Check without cache\n      try {\n        final result = await _getPageInfoUseCase.execute(\n          pageNumber: page,\n          mushafType: type,\n        );\n        if (result.isRight()) {\n          return page;\n        }\n      } catch (_) {\n        // Skip this page if there's an error\n      }\n    }\n    return null;\n  }"}, {"structure_type": "function", "name": "exists", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 426, "line_from": 426, "line_to": 466, "snippet": "            // Use exists() instead of existsSync() to avoid blocking the UI thread\n            if (await file1.exists()) {\n              nuraniFileFormat = 'nurani_quran_%d.png';\n            } else if (await file2.exists()) {\n              nuraniFileFormat = 'page%03d.png';\n            } else {\n              // Default if neither exists\n              nuraniFileFormat = 'nurani_quran_%d.png';\n            }\n          }\n\n          // Use last read page if available or default to page 1\n          final int initialPage = lastReadPage ?? 1;\n\n          uiState.value = currentUiState.copyWith(\n            isLoading: false,\n            isExtracting: false,\n            userMessage: null,\n            totalPages: totalPages,\n            currentMushafType: mushafType,\n            mushafDirectory: extractedPath,\n            nuraniFileFormat: nuraniFileFormat,\n            currentPage: initialPage,\n            appbarTitle: appbarTitle, // Set the appbar title directly here\n          );\n        },\n      );\n\n      // Fix the state update during build issue by handling navigation and state updates separately\n      if (isOnMushafPage) {\n        await updateCurrentMushafType(mushafType);\n      } else {\n        context.navigatorPop();\n        // Navigate first, then update state in the next frame to avoid build conflicts\n        Get.to(() => MushafPage(mushafType: mushafType));\n\n        // Use a post-frame callback to update state after navigation is complete\n        WidgetsBinding.instance.addPostFrameCallback((_) async {\n          await updateCurrentMushafType(mushafType);\n        });\n      }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 543, "line_from": 543, "line_to": 568, "snippet": "    // Use a post-frame callback to avoid updating state during build\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      // Make sure we're using the most up-to-date mushaf type\n      final MushafType currentType = currentUiState.currentMushafType;\n      final String title = getMushafTitle(type: currentType, context: context);\n\n      // Update the UI state with the new title\n      uiState.value = currentUiState.copyWith(appbarTitle: title);\n\n      // Force UI to refresh by calling update\n      update();\n    });\n  }\n\n  String getMushafFileSize({required MushafType type}) {\n    const Map<MushafType, double> fileSizes = {\n      MushafType.hafezi: 120.3,\n      MushafType.newmadani: 123.4,\n      MushafType.nurani: 50.0,\n      MushafType.qaloon: 104.9,\n      MushafType.shemerly: 115.9,\n      MushafType.warsh: 234.1,\n      MushafType.text: 5.2, // Smaller file size for the database\n    };\n    return '${fileSizes[type] ?? 0.0}';\n  }"}, {"structure_type": "function", "name": "system", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 1066, "line_from": 1066, "line_to": 1095, "snippet": "    // Preload images in batches to avoid overwhelming the system\n    const int batchSize = 3;\n    for (int i = 0; i < paths.length; i += batchSize) {\n      final end = (i + batchSize < paths.length) ? i + batchSize : paths.length;\n      final batch = paths.sublist(i, end);\n\n      await Future.wait(batch.map((path) => _preloadSingleImage(path)));\n\n      // Update preloading progress\n      final progress = end / paths.length;\n      uiState.value = currentUiState.copyWith(\n        preloadProgress: progress,\n      );\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isPreloading: false,\n      preloadProgress: 1.0,\n    );\n  }\n\n  Future<bool> _preloadSingleImage(String path) async {\n    try {\n      final params = PreloadImageParams(path);\n      return await compute(_preloadImageIsolate, params);\n    } catch (e) {\n      logError('Error preloading image: $e');\n      return false;\n    }\n  }"}, {"structure_type": "function", "name": "rebuilds", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 1114, "line_from": 1114, "line_to": 1188, "snippet": "    // Set flag in UI state but don't update preload paths to avoid widget rebuilds\n    uiState.value = currentUiState.copyWith(\n      isPreloading: true,\n      preloadProgress: 0.0,\n    );\n\n    int completed = 0;\n    final int total = paths.length;\n\n    // Preload in batches of 3 to avoid overwhelming the system\n    const int batchSize = 3;\n    for (int i = 0; i < paths.length; i += batchSize) {\n      final end = (i + batchSize < paths.length) ? i + batchSize : paths.length;\n      final batch = paths.sublist(i, end);\n\n      await Future.wait(batch.map((path) => _preloadSingleImage(path)));\n\n      completed += batch.length;\n      final progress = completed / total;\n\n      uiState.value = currentUiState.copyWith(\n        preloadProgress: progress,\n      );\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isPreloading: false,\n      preloadProgress: 1.0,\n    );\n  }\n\n  // Get button title for the bottom sheet based on current state\n  String getButtonTitleForSelectedMushaf(BuildContext context) {\n    final MushafType selectedType = tempSelectedMushafType;\n    final uiState = currentUiState;\n\n    // Handle Text Mushaf download progress separately as a priority\n    if (selectedType == MushafType.text) {\n      // Get TextMushafPresenter to check its download state\n      final textUiState = textPresenter.currentUiState;\n\n      // Calculate combined progress\n      double combinedProgress = 0.0;\n\n      if (textUiState.isDownloading) {\n        // If database is downloading, it's 1% of total progress\n        combinedProgress = textUiState.downloadProgress * 0.01;\n        final int progressPercent = (combinedProgress * 100).round();\n        return '${context.l10n.downloading} DB ${progressPercent.toLocalizedString(context)}%';\n      } else if (textUiState.isFontDownloading) {\n        // If fonts are downloading, database is complete (1%) and fonts are 99%\n        combinedProgress = 0.01 + (textUiState.fontDownloadProgress * 0.99);\n        final int progressPercent = (combinedProgress * 100).round();\n        return '${context.l10n.downloading} Fonts ${progressPercent.toLocalizedString(context)}%';\n      }\n\n      // If not downloading, check if it's available\n      return textUiState.downloadProgress >= 1.0 ? context.l10n.apply : context.l10n.downloadNow;\n    }\n\n    // For regular mushafs:\n    // First priority: Show extraction status\n    if (uiState.isExtracting && uiState.downloadingMushafName == selectedType.name) {\n      return context.l10n.extracting;\n    }\n\n    // Second priority: Show download progress\n    if (uiState.isDownloading && uiState.downloadingMushafName == selectedType.name) {\n      final int progressPercent = (uiState.downloadProgress * 100).round();\n      return '${context.l10n.downloading} ${progressPercent.toLocalizedString(context)}%';\n    }\n\n    // Default based on downloaded status\n    return uiState.isSelectedMushafDownloaded ? context.l10n.apply : context.l10n.downloadNow;\n  }"}, {"structure_type": "function", "name": "rebuilds", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 1208, "line_from": 1208, "line_to": 1235, "snippet": "    // Only update if the value has changed to avoid unnecessary rebuilds\n    if (currentUiState.isSelectedMushafDownloaded != isDownloaded) {\n      uiState.value = currentUiState.copyWith(\n        isSelectedMushafDownloaded: isDownloaded,\n      );\n    }\n  }\n\n  void onPageChanged(int index) {\n    // This is called by the PageView in MushafPage (for image mushafs)\n    final int newPage = index + 1;\n    if (newPage == currentUiState.currentPage) {\n      return; // Ignore if same page\n    }\n\n    // Save last read page for the *previous* image mushaf page\n    saveLastReadPage();\n\n    // Update state for the new page\n    uiState.value = currentUiState.copyWith(\n      currentPage: newPage,\n      currentSurahName: null, // Clear old info, updatePageInfo will fetch new\n      currentJuzNumber: null,\n    );\n\n    // Update header info (Surah/Juz) for the new page\n    updatePageInfo(newPage);\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/mushaf/widgets/mushaf_juz_list_widget.dart", "file_name": "mushaf_juz_list_widget.dart", "line": 20, "line_from": 20, "line_to": 96, "snippet": "  Widget build(BuildContext context) {\n    final MushafPresenter mushafPresenter = locate();\n\n    return ListView.builder(\n      itemCount: 30,\n      shrinkWrap: true,\n      padding: EdgeInsets.only(top: tenPx),\n      itemBuilder: (context, index) {\n        final int juzNumber = index + 1;\n        return JuzSection(\n          juzNumber: juzNumber,\n          theme: theme,\n          mushafPresenter: mushafPresenter,\n        );\n      },\n    );\n  }\n}\n\nclass JuzSection extends StatelessWidget {\n  const JuzSection({\n    super.key,\n    required this.juzNumber,\n    required this.theme,\n    required this.mushafPresenter,\n  });\n\n  final int juzNumber;\n  final ThemeData theme;\n  final MushafPresenter mushafPresenter;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: double.infinity,\n      decoration: BoxDecoration(\n        borderRadius: radius10,\n      ),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          gapH10,\n          InkWell(\n            onTap: () {\n              mushafPresenter.navigateToJuz(juzNumber: juzNumber);\n              context.navigatorPop();\n            },\n            child: Container(\n              width: double.infinity,\n              padding: EdgeInsets.symmetric(\n                horizontal: fifteenPx,\n                vertical: sixPx,\n              ),\n              decoration: BoxDecoration(\n                color: context.color.dropDownColor,\n                borderRadius: radius4,\n              ),\n              child: Text(\n                '${context.l10n.juz} ${juzNumber.toLocalizedString(context)}',\n                style: theme.textTheme.titleMedium!.copyWith(\n                  fontWeight: FontWeight.w600,\n                  color: theme.primaryColor,\n                ),\n              ),\n            ),\n          ),\n          gapH8,\n          JuzSurahList(\n            juzNumber: juzNumber,\n            theme: theme,\n            mushafPresenter: mushafPresenter,\n          ),\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "imageFuture;", "docstring": "", "module": "widgets", "file_path": "presentation/mushaf/widgets/mushaf_image_loader.dart", "file_name": "mushaf_image_loader.dart", "line": 62, "line_from": 62, "line_to": 235, "snippet": "  final Future<Uint8List?>? imageFuture;\n  final bool hasError;\n  final bool isInitialized;\n\n  MushafImageUiState({\n    this.imageFuture,\n    this.hasError = false,\n    this.isInitialized = false,\n  });\n\n  static MushafImageUiState empty() => MushafImageUiState();\n\n  MushafImageUiState copyWith({\n    Future<Uint8List?>? imageFuture,\n    bool? hasError,\n    bool? isInitialized,\n  }) {\n    return MushafImageUiState(\n      imageFuture: imageFuture ?? this.imageFuture,\n      hasError: hasError ?? this.hasError,\n      isInitialized: isInitialized ?? this.isInitialized,\n    );\n  }\n}\n\n// Presenter class for MushafImageLoader\nclass MushafImagePresenter extends GetxController {\n  final String filePath;\n  final double viewportWidth;\n  final List<String>? preloadPaths;\n\n  // Static image cache\n  static final Map<String, Uint8List> _imageCache =\n      LinkedHashMap<String, Uint8List>(equals: (a, b) => a == b, hashCode: (k) => k.hashCode);\n  static const int _maxCacheSize = 20;\n\n  // Reactive state\n  final Rx<MushafImageUiState> uiState = Rx<MushafImageUiState>(MushafImageUiState.empty());\n  MushafImageUiState get currentUiState => uiState.value;\n\n  final List<Future<void>> _pendingPreloads = [];\n\n  MushafImagePresenter({\n    required this.filePath,\n    required this.viewportWidth,\n    this.preloadPaths,\n  });\n\n  @override\n  void onClose() {\n    _pendingPreloads.clear();\n    super.onClose();\n  }\n\n  // Add to image cache\n  void _addToCache(String key, Uint8List value) {\n    // Remove oldest entries if cache is getting too large\n    if (_imageCache.length >= _maxCacheSize) {\n      final oldestKey = _imageCache.keys.first;\n      _imageCache.remove(oldestKey);\n    }\n    _imageCache[key] = value;\n  }\n\n  // Initialize image loading\n  void initializeImageLoading(BuildContext context) {\n    if (currentUiState.isInitialized) return;\n\n    _loadImage(context);\n    _preloadImages(context);\n\n    uiState.value = currentUiState.copyWith(isInitialized: true);\n  }\n\n  // Load image\n  void _loadImage(BuildContext context) {\n    // Get device pixel ratio safely\n    final double devicePixelRatio = MediaQuery.of(context).devicePixelRatio;\n    final double targetWidth = viewportWidth * devicePixelRatio;\n\n    // Check if the image is already in cache\n    if (_imageCache.containsKey(filePath)) {\n      uiState.value = currentUiState.copyWith(imageFuture: Future.value(_imageCache[filePath]), hasError: false);\n    } else {\n      uiState.value = currentUiState.copyWith(imageFuture: _loadImageData(filePath, targetWidth), hasError: false);\n    }\n  }\n\n  // Retry loading the image\n  void retryLoadImage(BuildContext context) {\n    _loadImage(context);\n  }\n\n  // Process image data in an isolate\n  Future<Uint8List?> _processImageData(Uint8List bytes, double targetWidth) async {\n    try {\n      return await compute(_processImageInIsolate, ProcessImageParams(bytes, targetWidth.round()));\n    } catch (e) {\n      return bytes; // If processing fails, return the original bytes\n    }\n  }\n\n  // Preload images for faster access\n  void _preloadImages(BuildContext context) {\n    if (preloadPaths == null || preloadPaths!.isEmpty) return;\n\n    // Get device pixel ratio safely\n    final double devicePixelRatio = MediaQuery.of(context).devicePixelRatio;\n    final double targetWidth = viewportWidth * devicePixelRatio;\n\n    // Prioritize loading - load closest pages first\n    final preloadPriority = [...preloadPaths!];\n\n    // Load images in a staggered manner to avoid overwhelming the system\n    for (int i = 0; i < preloadPriority.length; i++) {\n      final path = preloadPriority[i];\n\n      // Skip if already cached\n      if (_imageCache.containsKey(path)) continue;\n\n      // Add a small delay between preloads to avoid UI freezes\n      final preloadFuture = Future.delayed(Duration(milliseconds: i * 50), () async {\n        try {\n          final bytes = await _loadImageData(path, targetWidth);\n          if (bytes != null) {\n            _addToCache(path, bytes);\n          }\n        } catch (e) {\n          // Silently handle preload errors\n          logErrorStatic('Error preloading image $path:', e.toString());\n        }\n      });\n\n      _pendingPreloads.add(preloadFuture);\n    }\n  }\n\n  // Load image data from file\n  Future<Uint8List?> _loadImageData(String path, double targetWidth) async {\n    try {\n      // Check cache first\n      if (_imageCache.containsKey(path)) {\n        return _imageCache[path];\n      }\n\n      // Load file bytes in isolate\n      final params = FileReadParams(path);\n      final rawBytes = await compute(_readFileBytes, params);\n\n      if (rawBytes == null || rawBytes.isEmpty) {\n        return null;\n      }\n\n      // Process image in isolate\n      final processedData = await _processImageData(rawBytes, targetWidth);\n\n      if (processedData != null && processedData.isNotEmpty) {\n        // Cache the processed image\n        _addToCache(path, processedData);\n        return processedData;\n      }\n\n      return rawBytes;\n    } catch (e) {\n      logErrorStatic('Error loading image $path:', e.toString());\n      return null;\n    }\n  }\n\n  // Set error state\n  void setErrorState() {\n    uiState.value = currentUiState.copyWith(hasError: true);\n  }\n}"}, {"structure_type": "function", "name": "changes", "docstring": "", "module": "widgets", "file_path": "presentation/mushaf/widgets/mushaf_page_view.dart", "file_name": "mushaf_page_view.dart", "line": 49, "line_from": 49, "line_to": 99, "snippet": "        // Move page controller logic to post-frame callback to avoid build-time state changes\n        WidgetsBinding.instance.addPostFrameCallback((_) {\n          _syncPageControllerWithState(state);\n        });\n\n        return PageView.builder(\n          controller: pageController,\n          itemCount: totalPages,\n          reverse: true,\n          physics: const PageScrollPhysics(\n            parent: ClampingScrollPhysics(),\n          ),\n          scrollDirection: Axis.horizontal,\n          pageSnapping: true,\n          allowImplicitScrolling:\n              true, // This helps preload adjacent pages in memory\n          padEnds: false,\n          itemBuilder: (context, index) {\n            return _buildPage(context, index, state);\n          },\n          onPageChanged: (index) {\n            onPageChanged?.call(index);\n\n            // Defer state updates to after build phase\n            WidgetsBinding.instance.addPostFrameCallback((_) {\n              if (pageController.positions.isNotEmpty) {\n                mushafPresenter.updatePageInfo(index + 1);\n\n                // Preload surrounding pages when page changes\n                _preloadSurroundingPages(index);\n              }\n            });\n          },\n        );\n      },\n    );\n  }\n\n  // New helper method to handle page controller synchronization\n  void _syncPageControllerWithState(MushafPageUiState state) {\n    if (pageController.hasClients) {\n      final currentPageIndex = pageController.page?.round() ?? 0;\n      if ((currentPageIndex + 1) != state.currentPage) {\n        pageController.jumpToPage(\n          state.currentPage - 1,\n        );\n      }\n      // Always update page info for the current page\n      mushafPresenter.updatePageInfo(state.currentPage);\n    }\n  }"}, {"structure_type": "function", "name": "show", "docstring": "", "module": "pins", "file_path": "presentation/collections/ui/pins/edit_pin_bottomsheet.dart", "file_name": "edit_pin_bottomsheet.dart", "line": 28, "line_from": 28, "line_to": 137, "snippet": "  static Future<void> show({\n    required PinEntity pin,\n    required BuildContext context,\n  }) async {\n    await showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      backgroundColor: Colors.transparent,\n      builder: (context) => EditPinBottomSheet(pin: pin),\n    );\n  }\n\n  @override\n  State<EditPinBottomSheet> createState() => _EditPinBottomSheetState();\n}\n\nclass _EditPinBottomSheetState extends State<EditPinBottomSheet> {\n  late final TextEditingController _pinNameEditingController;\n  late final PinPresenter _pinPresenter = locate<PinPresenter>();\n  late final BookmarkPresenter _bookmarkPresenter = locate<BookmarkPresenter>();\n\n  @override\n  @override\n  void initState() {\n    super.initState();\n    _pinNameEditingController = TextEditingController(text: widget.pin.name);\n  }\n\n  @override\n  void dispose() {\n    _pinNameEditingController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return PresentableWidgetBuilder(\n      presenter: _pinPresenter,\n      onInit: () async {\n        _bookmarkPresenter.toggleColor(\n            color: getColorFromHex(widget.pin.color));\n      },\n      builder: () {\n        return Padding(\n          padding: EdgeInsets.only(\n            bottom: MediaQuery.of(context).viewInsets.bottom,\n          ),\n          child: CustomBottomSheetContainer(\n            key: const Key('EditPinBottomSheet'),\n            theme: theme,\n            bottomSheetTitle: context.l10n.editPin,\n            children: [\n              gapH10,\n              HeaderTitle(\n                key: const Key('EditPinBottomSheetHeader'),\n                title: context.l10n.changeName,\n                theme: theme,\n              ),\n              gapH10,\n              SizedBox(\n                height: fortyFivePx,\n                child: UserInputField(\n                  key: const Key('EditPinBottomSheetUserInputField'),\n                  textEditingController: _pinNameEditingController,\n                  contentPadding: EdgeInsets.only(right: tenPx),\n                  hintText: context.l10n.example,\n                  prefixIconPath: SvgPath.icPin,\n                  prefixIconColor:\n                      _bookmarkPresenter.currentUiState.selectedColor,\n                  inputFormatters: [\n                    FilteringTextInputFormatter.deny(RegexPatterns.denySpace),\n                  ],\n                  borderRadius: radius10,\n                ),\n              ),\n              gapH22,\n              HeaderTitle(\n                  key: const Key('EditPinBottomSheetHeaderTitle'),\n                  title: context.l10n.changeFolderColor,\n                  theme: theme),\n              gapH10,\n              SelectableColorList(),\n              gapH22,\n              TwoWayActionButton(\n                theme: theme,\n                submitButtonTitle: context.l10n.done,\n                cancelButtonTitle: context.l10n.cancel,\n                onCancelButtonTap: () => context.navigatorPop<void>(),\n                onSubmitButtonTap: () async {\n                  await _pinPresenter.updatePin(\n                    oldPin: widget.pin,\n                    newName: _pinNameEditingController.text,\n                    newColor: getHexFromColor(\n                        _bookmarkPresenter.currentUiState.selectedColor),\n                    context: context,\n                    onUpdated: () {\n                      context.navigatorPop<void>();\n                      _pinPresenter.addUserMessage(context.l10n.pinUpdSuccess);\n                    },\n                  );\n                },\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "components", "file_path": "presentation/collections/ui/components/remove_dialog.dart", "file_name": "remove_dialog.dart", "line": 23, "line_from": 23, "line_to": 35, "snippet": "    required Future<void> Function() onRemove,\n  }) async {\n    await showAnimatedDialog<void>(\n      context: context,\n      builder: (_) => RemoveDialog(\n        onRemove: onRemove,\n        title: title,\n      ),\n      animationType: DialogTransitionType.scale,\n      curve: Curves.fastOutSlowIn,\n      barrierDismissible: true,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "components", "file_path": "presentation/collections/ui/components/import_export_bottom_sheet.dart", "file_name": "import_export_bottom_sheet.dart", "line": 68, "line_from": 68, "line_to": 83, "snippet": "    required Future<void> Function() onImportSelected,\n    required Future<void> Function() onExportSelected,\n  }) async {\n    final ImportExportBottomSheet importExportBottomSheet =\n        await Future.microtask(\n      () => ImportExportBottomSheet(\n        key: const Key('ImportExportBottomSheet'),\n        onImportSelected: onImportSelected,\n        onExportSelected: onExportSelected,\n      ),\n    );\n\n    if (context.mounted) {\n      await context.showBottomSheet<void>(importExportBottomSheet, context);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "components", "file_path": "presentation/collections/ui/components/log_out_dialog.dart", "file_name": "log_out_dialog.dart", "line": 24, "line_from": 24, "line_to": 36, "snippet": "    required Future<void> Function() onRemove,\n  }) async {\n    await showAnimatedDialog<void>(\n      context: context,\n      builder: (_) => LogOutDialog(\n        onRemove: onRemove,\n        title: title,\n      ),\n      animationType: DialogTransitionType.scale,\n      curve: Curves.fastOutSlowIn,\n      barrierDismissible: true,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "bookmarks", "file_path": "presentation/collections/ui/bookmarks/edit_bookmark_bottomsheet.dart", "file_name": "edit_bookmark_bottomsheet.dart", "line": 33, "line_from": 33, "line_to": 45, "snippet": "    required Future<bool> Function(String, Color) onEditBookmarkFolder,\n  }) async {\n    final EditBookmarkBottomSheet editBookmarkCollection = await Future.microtask(\n      () => EditBookmarkBottomSheet(\n        key: const Key(\"EditBookmarkBottomSheet\"),\n        folder: bookmarkFolder,\n        onEditBookmarkFolder: onEditBookmarkFolder,\n      ),\n    );\n    if (context.mounted) {\n      await context.showBottomSheet<void>(editBookmarkCollection, context);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "bookmarks", "file_path": "presentation/collections/ui/bookmarks/more_bookmark_option_bottom_sheet.dart", "file_name": "more_bookmark_option_bottom_sheet.dart", "line": 75, "line_from": 75, "line_to": 92, "snippet": "    required void Function(BookmarkFolderEntity) onRemoveBookmarkFolder,\n    required Future<bool> Function(BookmarkFolderEntity, String, Color) onEditBookmarkFolder,\n    required BookmarkFolderEntity folder,\n    required ThemeData theme,\n  }) async {\n    final MoreBookmarkOptionBottomSheet moreBookmarkOption = await Future.microtask(\n      () => MoreBookmarkOptionBottomSheet(\n        onRemoveBookmarkFolder: (folder) => onRemoveBookmarkFolder(folder),\n        onEditBookmarkFolder: (newName, color) async => onEditBookmarkFolder(folder, newName, color),\n        theme: theme,\n        folder: folder,\n      ),\n    );\n\n    if (context.mounted) {\n      await context.showBottomSheet<void>(moreBookmarkOption, context);\n    }\n  }"}, {"structure_type": "class", "name": "CollectionUiState extends BaseUiState", "docstring": "", "module": "presenter", "file_path": "presentation/collections/presenter/collection_ui_state.dart", "file_name": "collection_ui_state.dart", "line": 4, "line_from": 4, "line_to": 52, "snippet": "class CollectionUiState extends BaseUiState {\n  final bool isAuthenticated;\n  final bool isSyncing;\n  final Color selectedColor;\n\n  const CollectionUiState({\n    required super.isLoading,\n    required super.userMessage,\n    this.isAuthenticated = false,\n    this.isSyncing = false,\n    this.selectedColor = const Color(0xff66BB6A),\n  });\n\n  factory CollectionUiState.empty() => const CollectionUiState(\n        isLoading: false,\n        userMessage: null,\n      );\n\n  @override\n  List<Object?> get props => [\n        isAuthenticated,\n        userMessage,\n        isLoading,\n        isSyncing,\n        selectedColor,\n      ];\n\n  bool get askToSync => !isAuthenticated;\n\n  CollectionUiState copyWith({\n    bool? isAuthenticated,\n    bool? isSyncing,\n    String? userMessage,\n    bool? isLoading,\n    Color? selectedColor,\n  }) {\n    return CollectionUiState(\n      isAuthenticated: isAuthenticated ?? this.isAuthenticated,\n      isSyncing: isSyncing ?? this.isSyncing,\n      isLoading: isLoading ?? this.isLoading,\n      userMessage: userMessage ?? this.userMessage,\n      selectedColor: selectedColor ?? this.selectedColor,\n    );\n  }\n}\n\n\nenum CollectionType { bookmark, pin }"}, {"structure_type": "function", "name": "=", "docstring": "", "module": "presenter", "file_path": "presentation/collections/presenter/collection_presenter.dart", "file_name": "collection_presenter.dart", "line": 84, "line_from": 84, "line_to": 101, "snippet": "      final Future<Either<String, String>> authenticationTask =\n          isAuthenticated ? _signOutUser.execute() : _signInUser.execute();\n\n      await executeMessageOnlyUseCase(() => authenticationTask);\n      await Future<void>.delayed(const Duration(milliseconds: 560));\n\n      await onCheckAuthentication(onAuthenticated: _syncCollections);\n    });\n  }\n\n  Future<void> onCheckAuthentication({\n    required VoidCallback onAuthenticated,\n    VoidCallback? onUnauthenticated,\n  }) async {\n    final bool isAuthenticated = await _checkAuthenticationStatus.execute();\n    uiState.value = currentUiState.copyWith(isAuthenticated: isAuthenticated);\n    isAuthenticated ? onAuthenticated() : onUnauthenticated?.call();\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/collections/presenter/collection_presenter.dart", "file_name": "collection_presenter.dart", "line": 198, "line_from": 198, "line_to": 208, "snippet": "    required void Function(String) onFetched,\n  }) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    await parseDataFromEitherWithUserMessage(\n      task: () async => await _exportCollectionsUseCase.execute(),\n      onDataLoaded: (data) async {\n        onFetched(data);\n        await showMessage(message: context.l10n.urCollsExptdSuccessfully);\n      },\n    );\n  }"}, {"structure_type": "function", "name": "", "docstring": "", "module": "note", "file_path": "presentation/collections/presenter/note/note_presenter.dart", "file_name": "note_presenter.dart", "line": 154, "line_from": 154, "line_to": 184, "snippet": "      (void _) async {\n        // Trigger immediate sync with Firebase after adding\n        await syncCollectionsWithRemote();\n\n        await _loadNotes();\n        _noteUpdateController.add(null);\n        addUserMessage('Note added successfully');\n      },\n    );\n\n    await toggleLoading(loading: false);\n  }\n\n  Future<void> deleteNote({required NoteEntity note}) async {\n    await toggleLoading(loading: true);\n\n    final result = await deleteNoteUseCase(surahId: note.surahId, ayahNumber: note.ayahNumber);\n    result.fold(\n      (String error) => addUserMessage(error),\n      (void _) async {\n        // Trigger immediate sync with Firebase after deletion\n        await syncCollectionsWithRemote();\n\n        await _loadNotes();\n        _noteUpdateController.add(null);\n        addUserMessage('Note deleted successfully');\n      },\n    );\n\n    await toggleLoading(loading: false);\n  }"}, {"structure_type": "function", "name": "", "docstring": "", "module": "note", "file_path": "presentation/collections/presenter/note/note_presenter.dart", "file_name": "note_presenter.dart", "line": 215, "line_from": 215, "line_to": 235, "snippet": "      (void _) async {\n        // Trigger immediate sync with Firebase after update\n        await syncCollectionsWithRemote();\n\n        await _loadNotes();\n        _noteUpdateController.add(null);\n        addUserMessage('Note updated successfully');\n      },\n    );\n\n    await toggleLoading(loading: false);\n  }\n\n  Future<void> updateSortOption(SortOptionEntity option) async {\n    // First save the option\n    await saveNoteSortOptionUseCase.execute(option: option);\n    // Then update UI state\n    uiState.value = currentUiState.copyWith(selectedSort: option);\n    // Refresh the UI to show sorted notes\n    uiState.refresh();\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/on_boarding/presenter/on_boarding_presenter.dart", "file_name": "on_boarding_presenter.dart", "line": 271, "line_from": 271, "line_to": 279, "snippet": "    await Future<void>.delayed(112.inMilliseconds);\n    uiState.value = uiState.value.copyWith(userMessage: \"\", isLoading: false);\n  }\n\n  @override\n  Future<void> onReady() async {\n    super.onReady();\n    await syncSelectedLanguageWithSettings();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/dua/ui/dua_details_page.dart", "file_name": "dua_details_page.dart", "line": 45, "line_from": 45, "line_to": 211, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n\n    // Sync language with app settings when page is built\n    Future.microtask(() => _duaPresenter.syncLanguageWithAppSettings());\n\n    // Load duas for the selected category if not already loaded\n    if (_duaPresenter.currentUiState.categoryId != category.categoryId) {\n      Future.microtask(\n          () => _duaPresenter.loadDuasByCategory(category.categoryId));\n    }\n\n    return Scaffold(\n      key: scaffoldKey,\n      endDrawer: const DuaMiniSettingsDrawer(),\n      appBar: CustomAppBar(\n        theme: theme,\n        title: context.l10n.duas,\n        actions: [\n          AppbarActionIcon(\n            theme: theme,\n            svgPath: SvgPath.icSettings,\n            onIconTap: () => scaffoldKey.currentState!.openEndDrawer(),\n          ),\n          gapW8\n        ],\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: paddingH16,\n            child: CustomHeaderSectionWidget(\n              title: category.categoryTitle,\n              theme: theme,\n              isDuaPage: true,\n            ),\n          ),\n          Expanded(\n            child: PresentableWidgetBuilder(\n              presenter: _duaPresenter,\n              builder: () {\n                final duas = _duaPresenter.currentUiState.currentDuas;\n\n                // Scroll to the initial dua index if specified\n                if (initialDuaIndex != null) {\n                  // Using post-frame callback to ensure the list is built before scrolling\n                  WidgetsBinding.instance.addPostFrameCallback((_) {\n                    if (_scrollController.isAttached) {\n                      _scrollController.jumpTo(\n                        index: initialDuaIndex!,\n                      );\n                    }\n                  });\n                }\n\n                return ScrollablePositionedList.builder(\n                  itemCount: duas.length,\n                  initialScrollIndex: initialDuaIndex ?? 0,\n                  itemScrollController: _scrollController,\n                  itemPositionsListener: _itemPositionsListener,\n                  itemBuilder: (context, index) {\n                    final dua = duas[index];\n                    final int surahId = dua.surahId ?? 1;\n                    final int ayahId = dua.ayahId?.contains('-') == true\n                        ? int.parse(dua.ayahId!.split('-')[0])\n                        : int.tryParse(dua.ayahId ?? '1') ?? 1;\n                    return DuaDetailsPageAyahContainer(\n                      index: index,\n                      surahID: surahId,\n                      ayahNumber: ayahId,\n                      ayahTopRowTitle: dua.name ?? '',\n                      sectionIcon: SvgPicture.asset(\n                        SvgPath.icAllah,\n                        height: twentyFourPx,\n                        colorFilter: buildColorFilter(theme.primaryColor),\n                      ),\n                      wordData: const [],\n                      onClickMore: () async => await MoreOptionBottomSheet.show(\n                        context: context,\n                        surahID: surahId,\n                        ayahID: ayahId,\n                        dua: dua,\n                        isDirectButtonVisible: true,\n                        isPlayButtonVisible: true,\n                        isCopyAyahButtonVisible: true,\n                        isFromDua: true,\n                      ),\n                      ayahPresenter: _ayahPresenter,\n                      duaReference: dua.reference ?? '',\n                      theme: theme,\n                      dua: dua,\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n/// Custom Mini Settings Drawer specifically for the Dua Details page\n/// Excludes word-by-word and tajweed settings\nclass DuaMiniSettingsDrawer extends StatelessWidget {\n  const DuaMiniSettingsDrawer({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final SettingsPresenter settingPresenter = locate();\n    final ThemeData themeData = Theme.of(context);\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      settingPresenter.initializeMiniSettings(pageType: PageType.dua);\n    });\n\n    return Container(\n      margin: EdgeInsets.only(\n        top: MediaQuery.of(context).padding.top,\n      ),\n      height: double.infinity,\n      width: QuranScreen.width * 0.75,\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: ClipRRect(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.start,\n          children: [\n            _MiniSettingsTopBar(),\n            gapH5,\n            Expanded(\n              child: SingleChildScrollView(\n                child: Column(\n                  children: [\n                    // Custom content settings without tajweed\n                    _DuaContentSettingsCard(\n                      settingPresenter: settingPresenter,\n                    ),\n                    Padding(\n                      padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                      child: BuildDivider(\n                        theme: themeData,\n                      ),\n                    ),\n                    // Include font settings\n                    FontSettingsCard(\n                      settingPresenter: settingPresenter,\n                      showTextReview: false,\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/dua/ui/dua_details_page.dart", "file_name": "dua_details_page.dart", "line": 216, "line_from": 216, "line_to": 340, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData themeData = Theme.of(context);\n    return Container(\n      padding: EdgeInsets.only(\n        left: twelvePx,\n        right: twelvePx,\n        top: twentyOnePx,\n      ),\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n          GestureDetector(\n            onTap: () => context.navigatorPop(),\n            child: Padding(\n              padding: paddingH6,\n              child: Icon(\n                Icons.arrow_forward_ios_rounded,\n                size: sixteenPx,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          gapW8,\n          Align(\n            alignment: Alignment.centerLeft,\n            child: Text(\n              context.l10n.quickTools,\n              style: themeData.textTheme.headlineSmall?.copyWith(\n                fontWeight: FontWeight.bold,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          const Spacer(),\n          GestureDetector(\n            onTap: () async {\n              await context.navigatorPush<void>(const SettingsPage());\n            },\n            child: SvgPicture.asset(\n              SvgPath.icSettings,\n              height: twentyOnePx,\n              colorFilter: buildColorFilter(isDarkMode(context)\n                  ? context.color.subtitleColor\n                  : context.color.primaryColor),\n            ),\n          ),\n          gapW10,\n        ],\n      ),\n    );\n  }\n}\n\n/// Custom Content Settings Card for Dua page\n/// Excludes tajweed settings\nclass _DuaContentSettingsCard extends StatelessWidget {\n  const _DuaContentSettingsCard({\n    required this.settingPresenter,\n  });\n\n  final SettingsPresenter settingPresenter;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return PresentableWidgetBuilder(\n      presenter: settingPresenter,\n      builder: () {\n        final bool isExpanded = settingPresenter.isSectionExpanded(1);\n\n        return SettingsContainer(\n          child: Column(\n            children: [\n              SettingsCardHeader(\n                title: context.l10n.viewSettings,\n                svgPath: SvgPath.icViews,\n                isExpanded: isExpanded,\n                onTap: () => settingPresenter.toggleSection(1),\n              ),\n              SettingsAnimatedContent(\n                isExpanded: isExpanded,\n                child: Column(\n                  children: [\n                    gapH18,\n                    SwitchSettingItem(\n                      theme: theme,\n                      title: context.l10n.showArabic,\n                      value: settingPresenter\n                              .uiState.value.settingsState?.showArabic ??\n                          true,\n                      onChanged: (value) => settingPresenter.toggleShowArabic(\n                        showArabic: value,\n                        context: context,\n                      ),\n                    ),\n                    gapH8,\n                    SwitchSettingItem(\n                      theme: theme,\n                      title: context.l10n.showTranslation,\n                      value: settingPresenter\n                              .uiState.value.settingsState?.showTranslation ??\n                          true,\n                      onChanged: (bool value) {\n                        settingPresenter.toggleShowTranslation(\n                          showTranslation: value,\n                          context: context,\n                        );\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "addUserMessage", "docstring": "", "module": "presenter", "file_path": "presentation/tajweed/presenter/tajweed_presenter.dart", "file_name": "tajweed_presenter.dart", "line": 12, "line_from": 12, "line_to": 39, "snippet": "  Future<void> addUserMessage(String message) async {\n    uiState.value = currentUiState.copyWith(userMessage: message);\n    showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }\n}\n\n// Model class for Tajweed stop symbols\nclass TajweedStopSymbol {\n  final String symbolSvgPath; // The Arabic symbol shown in the colored circle\n  final String name; // Name of the stop type (e.g., \"Must Stop\")\n  final String meaning; // The meaning or instruction (optional)\n\n  final int occurrences; // Number of times found in the text\n  final int priority; // Priority level (optional, for sorting)\n\n  TajweedStopSymbol({\n    required this.symbolSvgPath,\n    required this.name,\n    this.meaning = '',\n    required this.occurrences,\n    this.priority = 0,\n  });\n}"}]