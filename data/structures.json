[{"structure_type": "function", "name": "setUp", "docstring": "", "module": "config", "file_path": "core/config/quran_screen.dart", "file_name": "quran_screen.dart", "line": 45, "line_from": 45, "line_to": 283, "snippet": "  static void setUp(BuildContext context) {\n    final Size size = MediaQuery.sizeOf(context);\n    _height = size.height;\n    _width = size.width;\n    _resetIfInvalid();\n  }\n\n  static double? _width;\n  static double? _height;\n\n  static Size get _size => MediaQuery.sizeOf(QuranMajeed.globalContext);\n\n  static double get width {\n    _width ??= _size.width;\n    return _width!;\n  }\n\n  static double get height {\n    _height ??= _size.height;\n    return _height!;\n  }\n\n  static void _resetIfInvalid() {\n    if (_width! < 10 || _height! < 10) {\n      logErrorStatic(\n        'QuranScreen size not initialized. Please initialize QuranScreen and try again.',\n        \"quran_screen\",\n      );\n      _width = null;\n      _height = null;\n    }\n  }\n}\n\nextension QuranScreenWidth on Widget {\n  static double? _onePercentWidth;\n\n  double get onePercentWidth {\n    const double onePercent = 0.01;\n    _onePercentWidth ??= QuranScreen.width * onePercent;\n    return _onePercentWidth!;\n  }\n\n  static double? _twoPercentWidth;\n\n  double get twoPercentWidth {\n    const double twoPercent = 0.02;\n    _twoPercentWidth ??= QuranScreen.width * twoPercent;\n    return _twoPercentWidth!;\n  }\n\n  static double? _fiftyPercentHeight;\n\n  double get fiftyPercentHeight {\n    const double fiftyPercent = 0.50;\n    _fiftyPercentHeight ??= QuranScreen.height * fiftyPercent;\n    return _fiftyPercentHeight!;\n  }\n\n  static double? _threePercentWidth;\n\n  double get threePercentWidth {\n    const double threePercent = 0.03;\n    _threePercentWidth ??= QuranScreen.width * threePercent;\n    return _threePercentWidth!;\n  }\n\n  static double? _fourPercentWidth;\n\n  double get fourPercentWidth {\n    _fourPercentWidth ??= 4.percentWidth;\n    return _fourPercentWidth!;\n  }\n\n  static double? _fivePercentWidth;\n\n  double get fivePercentWidth {\n    _fivePercentWidth ??= 5.percentWidth;\n    return _fivePercentWidth!;\n  }\n\n  static double? _sixPercentWidth;\n\n  double get sixPercentWidth {\n    const double sixPercent = 0.06;\n    _sixPercentWidth ??= QuranScreen.width * sixPercent;\n    return _sixPercentWidth!;\n  }\n\n  static double? _sevenPercentWidth;\n\n  double get sevenPercentWidth {\n    const double sevenPercent = 0.07;\n    _sevenPercentWidth ??= QuranScreen.width * sevenPercent;\n    return _sevenPercentWidth!;\n  }\n\n  static double? _eightPercentWidth;\n\n  double get eightPercentWidth {\n    const double eightPercent = 0.08;\n    _eightPercentWidth ??= QuranScreen.width * eightPercent;\n    return _eightPercentWidth!;\n  }\n\n  static double? _tenPercentWidth;\n\n  double get tenPercentWidth {\n    const double tenPercentWidth = 0.10;\n    _tenPercentWidth ??= QuranScreen.width * tenPercentWidth;\n    return _tenPercentWidth!;\n  }\n\n  static double? _fortyPercentWidth;\n\n  double get fortyPercentWidth {\n    const double fortyPercent = 0.40;\n    _fortyPercentWidth ??= QuranScreen.width * fortyPercent;\n    return _fortyPercentWidth!;\n  }\n\n  static double? _thirtyPercentWidth;\n\n  double get thirtyPercentWidth {\n    const double thirtyPercentWidth = 0.32;\n    _thirtyPercentWidth ??= QuranScreen.width * thirtyPercentWidth;\n    return _thirtyPercentWidth!;\n  }\n\n  static double? _sixtySixPercentWidth;\n\n  double get sixtySixPercentWidth {\n    _sixtySixPercentWidth ??= 66.percentWidth;\n    return _sixtySixPercentWidth!;\n  }\n\n  static double? _fiftyFivePercentWidth;\n\n  double get fiftyFivePercentWidth {\n    _fiftyFivePercentWidth ??= 55.percentWidth;\n    return _fiftyFivePercentWidth!;\n  }\n\n  static double? _seventyPercentWidth;\n\n  double get seventyPercentWidth {\n    const double seventyPercent = 0.70;\n    _seventyPercentWidth ??= QuranScreen.width * seventyPercent;\n    return _seventyPercentWidth!;\n  }\n\n  static double? _tweentyEightPercentWidth;\n\n  double get tweentyEightPercentWidth {\n    const double tweentyEightPercentWidth = 0.28;\n    _tweentyEightPercentWidth ??= QuranScreen.width * tweentyEightPercentWidth;\n    return _tweentyEightPercentWidth!;\n  }\n\n  static double? _twentyPercentWidth;\n\n  double get twentyPercentWidth {\n    const double twentyPercentWidth = 0.20;\n    _twentyPercentWidth ??= QuranScreen.width * twentyPercentWidth;\n    return _twentyPercentWidth!;\n  }\n\n  static double? _twentyFivePercentWidth;\n\n  double get twentyFivePercentWidth {\n    const double twentyFivePercentWidth = 0.25;\n    _twentyFivePercentWidth ??= QuranScreen.width * twentyFivePercentWidth;\n    return _twentyFivePercentWidth!;\n  }\n\n  static double? _twentySixPercentWidth;\n\n  double get twentySixPercentWidth {\n    const double twentySixPercentWidth = 0.26;\n    _twentySixPercentWidth ??= QuranScreen.width * twentySixPercentWidth;\n    return _twentySixPercentWidth!;\n  }\n\n  static double? _twentyThreePercentWidth;\n\n  double get twentyThreePercentWidth {\n    const double twentyThreePercentWidth = 0.23;\n    _twentyThreePercentWidth ??= QuranScreen.width * twentyThreePercentWidth;\n    return _twentyThreePercentWidth!;\n  }\n\n  static double? _fourtyPercentWidth;\n\n  double get fourtyPercentWidth {\n    const double fourtyPercentWidth = 0.40;\n    _fourtyPercentWidth ??= QuranScreen.width * fourtyPercentWidth;\n    return _fourtyPercentWidth!;\n  }\n\n  static double? _twentyPercentHeight;\n\n  double get twentyPercentHeight {\n    const double twentyPercent = 0.20;\n    _twentyPercentHeight ??= QuranScreen.height * twentyPercent;\n    return _twentyPercentHeight!;\n  }\n\n  static double? _tenPercentHeight;\n\n  double get tenPercentHeight {\n    const double tenPercentHeight = 0.10;\n    _tenPercentHeight ??= QuranScreen.height * tenPercentHeight;\n    return _tenPercentHeight!;\n  }\n\n  static double? _twelvePercentHeight;\n\n  double get twelvePercentHeight {\n    const double twentyPercent = 0.12;\n    _twelvePercentHeight ??= QuranScreen.height * twentyPercent;\n    return _twelvePercentHeight!;\n  }\n\n  static double? _fourteenPercentHeight;\n\n  double get fourteenPercentHeight {\n    const double fourteenPercentHeight = 0.14;\n    _fourteenPercentHeight ??= QuranScreen.height * fourteenPercentHeight;\n    return _fourteenPercentHeight!;\n  }\n\n  static double? _tweentyPercentHeight;\n\n  double get tweentyPercentHeight {\n    const double tweentyPercentHeight = 0.20;\n    _tweentyPercentHeight ??= QuranScreen.height * tweentyPercentHeight;\n    return _tweentyPercentHeight!;\n  }\n}"}, {"structure_type": "class", "name": "to implement this in whatever way makes sense", "docstring": "The progress indicator's background color.\n", "module": "external_libs", "file_path": "core/external_libs/capped_progress_indicator.dart", "file_name": "capped_progress_indicator.dart", "line": 76, "line_from": 76, "line_to": 247, "snippet": "  /// It is up to the subclass to implement this in whatever way makes sense\n  /// for the given use case. See the subclass documentation for details.\n  final Color? backgroundColor;\n\n  /// The progress indicator's color.\n  ///\n  /// This is only used if [CappedProgressIndicator.valueColor] is null.\n  /// If [CappedProgressIndicator.color] is also null, then the ambient\n  /// [ProgressIndicatorThemeData.color] will be used. If that\n  /// is null then the current theme's [ColorScheme.primary] will\n  /// be used by default.\n  final Color? color;\n\n  /// The progress indicator's color as an animated value.\n  ///\n  /// If null, the progress indicator is rendered with [color]. If that is null,\n  /// then it will use the ambient [ProgressIndicatorThemeData.color]. If that\n  /// is also null then it defaults to the current theme's [ColorScheme.primary].\n  final Animation<Color?>? valueColor;\n\n  /// The [SemanticsProperties.label] for this progress indicator.\n  ///\n  /// This value indicates the purpose of the progress bar, and will be\n  /// read out by screen readers to indicate the purpose of this progress\n  /// indicator.\n  final String? semanticsLabel;\n\n  /// The [SemanticsProperties.value] for this progress indicator.\n  ///\n  /// This will be used in conjunction with the [semanticsLabel] by\n  /// screen reading software to identify the widget, and is primarily\n  /// intended for use with determinate progress indicators to announce\n  /// how far along they are.\n  ///\n  /// For determinate progress indicators, this will be defaulted to\n  /// [CappedProgressIndicator.value] expressed as a percentage, i.e. `0.1` will\n  /// become '10%'.\n  final String? semanticsValue;\n\n  Color _getValueColor(BuildContext context) {\n    return valueColor?.value ??\n        color ??\n        ProgressIndicatorTheme.of(context).color ??\n        Theme.of(context).colorScheme.primary;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(PercentProperty('value', value,\n        showName: false, ifNull: '<indeterminate>'));\n  }\n\n  Widget _buildSemanticsWrapper({\n    required BuildContext context,\n    required Widget child,\n  }) {\n    String? expandedSemanticsValue = semanticsValue;\n    if (value != null) {\n      expandedSemanticsValue ??= '${(value! * 100).round()}%';\n    }\n    return Semantics(\n      label: semanticsLabel,\n      value: expandedSemanticsValue,\n      child: child,\n    );\n  }\n}\n\nclass _LinearCappedProgressIndicatorPainter extends CustomPainter {\n  const _LinearCappedProgressIndicatorPainter({\n    required this.backgroundColor,\n    required this.valueColor,\n    this.value,\n    this.cornerRadius,\n    required this.animationValue,\n    required this.textDirection,\n  });\n\n  final Color backgroundColor;\n  final Color valueColor;\n  final double? value;\n  final double? cornerRadius;\n  final double animationValue;\n  final TextDirection textDirection;\n\n  // The indeterminate progress animation displays two lines whose leading (head)\n  // and trailing (tail) endpoints are defined by the following four curves.\n  static const Curve line1Head = Interval(\n    0.0,\n    750.0 / _kIndeterminateLinearDuration,\n    curve: Cubic(0.2, 0.0, 0.8, 1.0),\n  );\n  static const Curve line1Tail = Interval(\n    333.0 / _kIndeterminateLinearDuration,\n    (333.0 + 750.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.4, 0.0, 1.0, 1.0),\n  );\n  static const Curve line2Head = Interval(\n    1000.0 / _kIndeterminateLinearDuration,\n    (1000.0 + 567.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.0, 0.0, 0.65, 1.0),\n  );\n  static const Curve line2Tail = Interval(\n    1267.0 / _kIndeterminateLinearDuration,\n    (1267.0 + 533.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.10, 0.0, 0.45, 1.0),\n  );\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Paint paint = Paint()\n      ..color = backgroundColor\n      ..style = PaintingStyle.fill;\n    canvas.drawRRect(\n      RRect.fromRectAndRadius(\n        Offset.zero & size,\n        Radius.circular(cornerRadius ?? size.height / 2),\n      ),\n      paint,\n    );\n\n    paint.color = valueColor;\n\n    void drawBar(double x, double width) {\n      if (width <= 0.0) {\n        return;\n      }\n\n      final double left;\n      switch (textDirection) {\n        case TextDirection.rtl:\n          left = size.width - width - x;\n          break;\n        case TextDirection.ltr:\n          left = x;\n          break;\n      }\n      canvas.drawRRect(\n        RRect.fromRectAndRadius(\n          Offset(left, 0.0) & Size(width, size.height),\n          Radius.circular(cornerRadius ?? size.height / 2),\n        ),\n        paint,\n      );\n    }\n\n    if (value != null) {\n      drawBar(0.0, clampDouble(value!, 0.0, 1.0) * size.width);\n    } else {\n      final double x1 = size.width * line1Tail.transform(animationValue);\n      final double width1 =\n          size.width * line1Head.transform(animationValue) - x1;\n\n      final double x2 = size.width * line2Tail.transform(animationValue);\n      final double width2 =\n          size.width * line2Head.transform(animationValue) - x2;\n\n      drawBar(x1, width1);\n      drawBar(x2, width2);\n    }\n  }\n\n  @override\n  bool shouldRepaint(_LinearCappedProgressIndicatorPainter oldPainter) {\n    return oldPainter.backgroundColor != backgroundColor ||\n        oldPainter.valueColor != valueColor ||\n        oldPainter.value != value ||\n        oldPainter.animationValue != animationValue ||\n        oldPainter.textDirection != textDirection;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/fancy_scaffold.dart", "file_name": "fancy_scaffold.dart", "line": 9, "line_from": 9, "line_to": 63, "snippet": "  final void Function(double position)? onSlide;\n  final VoidCallback? onOpened;\n  final VoidCallback? onClosed;\n  final FloatingWidgetState defaultState;\n  final Color backdropColor;\n  final double backdropOpacity;\n  final double? maxHeight;\n  final double minHeight;\n  final bool isPanelVisible;\n  final EdgeInsetsGeometry margin;\n  final EdgeInsetsGeometry padding;\n\n  const FloatingWidgetConfig({\n    this.backdropEnabled = true,\n    this.onSlide,\n    this.onOpened,\n    this.onClosed,\n    this.defaultState = FloatingWidgetState.closed,\n    this.backdropColor = Colors.black,\n    this.backdropOpacity = 0.5,\n    this.maxHeight,\n    this.minHeight = kToolbarHeight * 1.6,\n    this.isPanelVisible = true,\n    this.margin = EdgeInsets.zero,\n    this.padding = const EdgeInsets.all(4),\n  });\n}\n\nclass FancyScaffold extends StatefulWidget {\n  final Widget body;\n  final Widget? appBar;\n  final Widget? bottomNavigationBar;\n  final bool? resizeToAvoidBottomInset;\n  final Color? backgroundColor;\n  final FloatingWidgetController? floatingWidgetController;\n  final FloatingWidgetConfig floatingWidgetConfig;\n  final double? bottomNavigationBarHeight;\n  final bool isAudioPlaying;\n\n  const FancyScaffold({\n    required this.body,\n    this.appBar,\n    this.bottomNavigationBar,\n    this.resizeToAvoidBottomInset,\n    this.backgroundColor,\n    this.floatingWidgetConfig = const FloatingWidgetConfig(),\n    this.floatingWidgetController,\n    this.bottomNavigationBarHeight,\n    this.isAudioPlaying = false,\n    super.key,\n  });\n\n  @override\n  FancyScaffoldState createState() => FancyScaffoldState();\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/fancy_scaffold.dart", "file_name": "fancy_scaffold.dart", "line": 90, "line_from": 90, "line_to": 373, "snippet": "  void initState() {\n    super.initState();\n    floatingWidgetAnimationController.addListener(_floatingWidgetListener);\n    _floatingWidgetScrollController.addListener(_scrollListener);\n  }\n\n  void hideAppBar() {\n    if (navigationBarAnimationController.value != 0) {\n      navigationBarAnimationController.animateTo(0);\n    }\n  }\n\n  void showAppBar() {\n    if (navigationBarAnimationController.value != 1) {\n      navigationBarAnimationController.animateTo(1);\n    }\n  }\n\n  void _floatingWidgetListener() {\n    if (widget.floatingWidgetConfig.onSlide != null) {\n      widget.floatingWidgetConfig\n          .onSlide!(floatingWidgetAnimationController.value);\n    }\n\n    if (widget.floatingWidgetConfig.onOpened != null &&\n        floatingWidgetAnimationController.value == 1.0) {\n      widget.floatingWidgetConfig.onOpened!();\n    }\n\n    if (widget.floatingWidgetConfig.onClosed != null &&\n        floatingWidgetAnimationController.value == 0.0) {\n      widget.floatingWidgetConfig.onClosed!();\n    }\n\n    if (!navigationBarScrolledDown) {\n      navigationBarAnimationController.value =\n          1 - floatingWidgetAnimationController.value;\n    }\n  }\n\n  void _scrollListener() {\n    if (!_scrollingEnabled) {\n      _floatingWidgetScrollController.jumpTo(0);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    widget.floatingWidgetController?._addState(this);\n    final double systemTopPadding = MediaQuery.of(context).padding.top;\n    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;\n    final double appBarHeight = widget.appBar != null ? kToolbarHeight : 0;\n\n    return CustomStatusBarColor(\n      statusBarColor: context.color.gradientTop,\n      statusBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      navigationBarColor: Theme.of(context).cardColor,\n      navigationBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      child: AnimatedBuilder(\n        animation: floatingWidgetAnimationController,\n        builder: (context, mainChild) {\n          return AnimatedBuilder(\n            animation: navigationBarAnimationController,\n            builder: (context, child) {\n              return Stack(\n                children: [\n                  Positioned.fill(\n                    child: Column(\n                      children: [\n                        Container(\n                            color: context.color.gradientTop,\n                            height: systemTopPadding +\n                                appBarHeight *\n                                    navigationBarAnimationController.value +\n                                2),\n                        Expanded(\n                          child: child!,\n                        ),\n                      ],\n                    ),\n                  ),\n                  if (widget.appBar != null)\n                    Positioned(\n                      top: -kToolbarHeight *\n                              (1 - navigationBarAnimationController.value) +\n                          systemTopPadding +\n                          2,\n                      left: 0,\n                      right: 0,\n                      child: widget.appBar!,\n                    ),\n                  if (widget.bottomNavigationBar != null)\n                    Positioned(\n                      bottom: -(widget.bottomNavigationBarHeight ?? 80) *\n                          (1 - navigationBarAnimationController.value),\n                      left: 0,\n                      right: 0,\n                      child: Container(\n                        width: double.infinity,\n                        color: Colors.transparent,\n                        height: (widget.bottomNavigationBarHeight ?? 73) +\n                            systemBottomPadding,\n                        child: Column(\n                          children: [\n                            Expanded(\n                              child: SingleChildScrollView(\n                                physics: const NeverScrollableScrollPhysics(),\n                                child: widget.bottomNavigationBar,\n                              ),\n                            ),\n                            Container(\n                              color: Theme.of(context).cardColor,\n                            ),\n                          ],\n                        ),\n                      ),\n                    ),\n                ],\n              );\n            },\n            child: Listener(\n              onPointerUp: _handlePointerUp,\n              child: NotificationListener<ScrollUpdateNotification>(\n                onNotification: _handleScrollNotification,\n                child: mainChild!,\n              ),\n            ),\n          );\n        },\n        child: widget.body,\n      ),\n    );\n  }\n\n  void _handlePointerUp(_) {\n    pixelsScrolled = 0;\n    if (navigationBarAnimationController.value > 0.5) {\n      navigationBarAnimationController.animateTo(1);\n      navigationBarScrolledDown = false;\n    } else {\n      navigationBarAnimationController.animateTo(0);\n      navigationBarScrolledDown = false;\n    }\n  }\n\n  bool _handleScrollNotification(ScrollUpdateNotification details) {\n    if (widget.floatingWidgetController?.lockNotificationListener ?? false) {\n      return false;\n    }\n    if (details.metrics.axis == Axis.horizontal) {\n      return false;\n    }\n\n    // Check if audio is playing\n    if (widget.isAudioPlaying) {\n      return false;\n    }\n\n    pixelsScrolled =\n        (pixelsScrolled + (details.scrollDelta ?? 0).abs()).clamp(0, 100) / 100;\n    if ((details.scrollDelta ?? 0) > 0.0 &&\n        details.metrics.axis == Axis.vertical) {\n      navigationBarAnimationController.value -= pixelsScrolled;\n    } else {\n      navigationBarAnimationController.value += pixelsScrolled;\n    }\n    return false;\n  }\n\n  Future<void> _close() {\n    return floatingWidgetAnimationController.fling(velocity: -1.0);\n  }\n\n  Future<void> _open() {\n    return floatingWidgetAnimationController.fling(velocity: 1.0);\n  }\n\n  Future<void> _animatePanelToPosition(\n    double value, {\n    Duration duration = const Duration(milliseconds: 200),\n    Curve curve = Curves.linear,\n  }) {\n    assert(0.0 <= value && value <= 1.0);\n    return floatingWidgetAnimationController.animateTo(value,\n        duration: duration, curve: curve);\n  }\n\n  set _panelPosition(double value) {\n    assert(0.0 <= value && value <= 1.0);\n    floatingWidgetAnimationController.value = value;\n  }\n\n  double get _panelPosition => floatingWidgetAnimationController.value;\n\n  bool get _isPanelAnimating => floatingWidgetAnimationController.isAnimating;\n\n  bool get _isPanelOpen => floatingWidgetAnimationController.value == 1.0;\n\n  bool get _isPanelClosed => floatingWidgetAnimationController.value == 0.0;\n}\n\nclass FloatingWidgetController {\n  FancyScaffoldState? _scaffoldState;\n\n  void _addState(FancyScaffoldState panelState) {\n    _scaffoldState = panelState;\n  }\n\n  GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  bool lockNotificationListener = false;\n\n  bool get isAttached => _scaffoldState != null;\n\n  AnimationController get animationController =>\n      _scaffoldState!.floatingWidgetAnimationController;\n  AnimationController get navbarAnimationController =>\n      _scaffoldState!.navigationBarAnimationController;\n  bool get navbarScrolledDown => _scaffoldState!.navigationBarScrolledDown;\n  set navbarScrolledDown(bool value) {\n    _scaffoldState!.navigationBarScrolledDown = value;\n  }\n\n  void hideAppBar() {\n    assert(isAttached,\n        \"FloatingWidgetController must be attached to a FancyScaffold\");\n    _scaffoldState!.hideAppBar();\n  }\n\n  void showAppBar() {\n    assert(isAttached,\n        \"FloatingWidgetController must be attached to a FancyScaffold\");\n    _scaffoldState!.showAppBar();\n  }\n\n  Future<void> close() {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._close();\n  }\n\n  Future<void> open() {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._open();\n  }\n\n  Future<void> animatePanelToPosition(\n    double value, {\n    Duration duration = const Duration(milliseconds: 200),\n    Curve curve = Curves.linear,\n  }) {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    assert(0.0 <= value && value <= 1.0);\n    return _scaffoldState!\n        ._animatePanelToPosition(value, duration: duration, curve: curve);\n  }\n\n  set panelPosition(double value) {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    assert(0.0 <= value && value <= 1.0);\n    _scaffoldState!._panelPosition = value;\n  }\n\n  double get panelPosition {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._panelPosition;\n  }\n\n  bool get isPanelAnimating {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelAnimating;\n  }\n\n  bool get isPanelOpen {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelOpen;\n  }\n\n  bool get isPanelClosed {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelClosed;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/positioned_scroll_bar.dart", "file_name": "positioned_scroll_bar.dart", "line": 18, "line_from": 18, "line_to": 35, "snippet": "  final void Function({required bool dragging})? onDragging;\n\n  @override\n  Widget build(BuildContext context) {\n    if (!showScrollBar) return listView;\n\n    return DraggableScrollbarPositionedList.arrows(\n      key: const Key('PositionedScrollBar'),\n      backgroundColor: isDarkMode(context)\n          ? context.color.bottomSheetHeader\n          : Theme.of(context).primaryColor,\n      padding: const EdgeInsets.only(right: 2),\n      onDragging: onDragging,\n      controller: controller,\n      child: listView,\n    );\n  }\n}"}, {"structure_type": "class", "name": "AdvancedRangeSlider extends StatefulWidget", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/advanced_range_slider.dart", "file_name": "advanced_range_slider.dart", "line": 7, "line_from": 7, "line_to": 2647, "snippet": "class AdvancedRangeSlider extends StatefulWidget {\n  AdvancedRangeSlider({\n    super.key,\n    this.min,\n    this.max,\n    required this.values,\n    this.fixedValues,\n    this.axis = Axis.horizontal,\n    this.handler,\n    this.rightHandler,\n    this.handlerHeight,\n    this.handlerWidth,\n    this.onDragStarted,\n    this.onDragCompleted,\n    this.onDragging,\n    this.rangeSlider = false,\n    this.rtl = false,\n    this.jump = false,\n    this.ignoreSteps = const [],\n    this.disabled = false,\n    this.touchSize,\n    this.visibleTouchArea = false,\n    this.minimumDistance = 0,\n    this.maximumDistance = 0,\n    this.tooltip,\n    this.trackBar = const FlutterSliderTrackBar(),\n    this.handlerAnimation = const FlutterSliderHandlerAnimation(),\n    this.selectByTap = true,\n    this.step = const FlutterSliderStep(),\n    this.hatchMark,\n    this.centeredOrigin = false,\n    this.lockHandlers = false,\n    this.lockDistance,\n    this.decoration,\n    this.foregroundDecoration,\n  })  : assert(touchSize == null || (touchSize >= 5 && touchSize <= 50)),\n        assert(\n          (ignoreSteps.isNotEmpty && step.rangeList == null) || (ignoreSteps.isEmpty),\n        ),\n        assert(\n          (step.rangeList != null && minimumDistance == 0 && maximumDistance == 0) ||\n              (minimumDistance > 0 && step.rangeList == null) ||\n              (maximumDistance > 0 && step.rangeList == null) ||\n              (step.rangeList == null),\n        ),\n        assert(\n          centeredOrigin == false ||\n              (centeredOrigin == true &&\n                  rangeSlider == false &&\n                  lockHandlers == false &&\n                  minimumDistance == 0 &&\n                  maximumDistance == 0),\n        ),\n        assert(\n          lockHandlers == false ||\n              (centeredOrigin == false &&\n                  (ignoreSteps.isEmpty) &&\n                  (fixedValues == null || fixedValues.isEmpty) &&\n                  rangeSlider == true &&\n                  values.length > 1 &&\n                  lockHandlers == true &&\n                  lockDistance != null &&\n                  step.rangeList == null &&\n                  lockDistance >= step.step /* && values[1] - values[0] == lockDistance*/),\n        ),\n        assert(\n          fixedValues != null || (min != null && max != null && min <= max),\n          \"Min and Max are required if fixedValues is null\",\n        ),\n        assert(\n          rangeSlider == false || (rangeSlider == true && values.length > 1),\n          \"Range slider needs two values\",\n        );\n  final Axis axis;\n  final double? handlerWidth;\n  final double? handlerHeight;\n  final FlutterSliderHandler? handler;\n  final FlutterSliderHandler? rightHandler;\n  final void Function(int handlerIndex, double lowerValue, double upperValue)? onDragStarted;\n  final void Function(int handlerIndex, double lowerValue, double upperValue)? onDragCompleted;\n  final void Function(int handlerIndex, double lowerValue, double upperValue)? onDragging;\n  final double? min;\n  final double? max;\n  final List<double> values;\n  final List<FlutterSliderFixedValue>? fixedValues;\n  final bool rangeSlider;\n  final bool rtl;\n  final bool jump;\n  final bool selectByTap;\n  final List<FlutterSliderIgnoreSteps> ignoreSteps;\n  final bool disabled;\n  final double? touchSize;\n  final bool visibleTouchArea;\n  final double minimumDistance;\n  final double maximumDistance;\n  final FlutterSliderHandlerAnimation handlerAnimation;\n  final FlutterSliderTooltip? tooltip;\n  final FlutterSliderTrackBar trackBar;\n  final FlutterSliderStep step;\n  final FlutterSliderHatchMark? hatchMark;\n  final bool centeredOrigin;\n  final bool lockHandlers;\n  final double? lockDistance;\n  final BoxDecoration? decoration;\n  final BoxDecoration? foregroundDecoration;\n\n  @override\n  AdvancedRangeSliderState createState() => AdvancedRangeSliderState();\n}\n\nclass AdvancedRangeSliderState extends State<AdvancedRangeSlider> with TickerProviderStateMixin {\n  bool __isInitCall = true;\n\n  late double _touchSize;\n\n  late Widget leftHandler;\n  late Widget rightHandler;\n\n  double? _leftHandlerXPosition = 0;\n  double? _rightHandlerXPosition = 0;\n  double? _leftHandlerYPosition = 0;\n  double? _rightHandlerYPosition = 0;\n\n  double? _lowerValue = 0;\n  double? _upperValue = 0;\n  dynamic _outputLowerValue = 0;\n  dynamic _outputUpperValue = 0;\n\n  double? _realMin;\n  late double _realMax;\n\n  late double _divisions;\n  double _handlersPadding = 0;\n\n  GlobalKey leftHandlerKey = GlobalKey();\n  GlobalKey rightHandlerKey = GlobalKey();\n  GlobalKey containerKey = GlobalKey();\n  GlobalKey leftTooltipKey = GlobalKey();\n  GlobalKey rightTooltipKey = GlobalKey();\n\n  double? _handlersWidth;\n  double? _handlersHeight;\n\n  late double _constraintMaxWidth;\n  late double _constraintMaxHeight;\n\n  double? _containerWidthWithoutPadding;\n  double? _containerHeightWithoutPadding;\n\n  double _containerLeft = 0;\n  double _containerTop = 0;\n\n  late FlutterSliderTooltip _tooltipData;\n\n  late List<Function> _positionedItems;\n\n  double _rightTooltipOpacity = 0;\n  double _leftTooltipOpacity = 0;\n\n  AnimationController? _rightTooltipAnimationController;\n  late Animation<Offset> _rightTooltipAnimation;\n  AnimationController? _leftTooltipAnimationController;\n  late Animation<Offset> _leftTooltipAnimation;\n\n  late AnimationController _leftHandlerScaleAnimationController;\n  late Animation<double> _leftHandlerScaleAnimation;\n  late AnimationController _rightHandlerScaleAnimationController;\n  late Animation<double> _rightHandlerScaleAnimation;\n\n  double? _containerHeight;\n  double? _containerWidth;\n\n  int _decimalScale = 0;\n\n  double xDragTmp = 0;\n  double yDragTmp = 0;\n\n  double? xDragStart;\n  double? yDragStart;\n\n  double? _widgetStep;\n  double? _widgetMin;\n  double? _widgetMax;\n  List<FlutterSliderIgnoreSteps> _ignoreSteps = [];\n  final List<FlutterSliderFixedValue> _fixedValues = [];\n\n  List<Positioned> _points = [];\n\n  bool __dragging = false;\n\n  late double? __dAxis;\n  late double? __rAxis;\n  late double? __axisDragTmp;\n  late double __axisPosTmp;\n  late double? __containerSizeWithoutPadding;\n  late double? __rightHandlerPosition;\n  late double? __leftHandlerPosition;\n  late double? __containerSizeWithoutHalfPadding;\n\n  Orientation? oldOrientation;\n\n  double __lockedHandlersDragOffset = 0;\n  double? _distanceFromRightHandler;\n  double? _distanceFromLeftHandler;\n  double _handlersDistance = 0;\n\n  bool _slidingByActiveTrackBar = false;\n  bool _leftTapAndSlide = false;\n  bool _rightTapAndSlide = false;\n  bool _trackBarSlideOnDragStartedCalled = false;\n\n  @override\n  void initState() {\n    initMethod();\n\n    super.initState();\n  }\n\n  @override\n  void didUpdateWidget(AdvancedRangeSlider oldWidget) {\n    __isInitCall = false;\n\n    initMethod();\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void dispose() {\n    _rightTooltipAnimationController?.dispose();\n    _leftTooltipAnimationController?.dispose();\n    _leftHandlerScaleAnimationController.dispose();\n    _rightHandlerScaleAnimationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return OrientationBuilder(\n      builder: (context, orientation) {\n        oldOrientation ??= MediaQuery.of(context).orientation;\n\n        return LayoutBuilder(\n          builder: (BuildContext context, BoxConstraints constraints) {\n            _constraintMaxWidth = constraints.maxWidth;\n            _constraintMaxHeight = constraints.maxHeight;\n\n            _containerWidthWithoutPadding = _constraintMaxWidth - (_handlersWidth ?? 0);\n            _containerHeightWithoutPadding = _constraintMaxHeight - (_handlersHeight ?? 0);\n\n            final double? sliderProperSize = _findProperSliderSize();\n            if (widget.axis == Axis.vertical) {\n              double layoutWidth = constraints.maxWidth;\n              if (layoutWidth == double.infinity) {\n                layoutWidth = 0;\n              }\n              __containerSizeWithoutPadding = _containerHeightWithoutPadding;\n              _containerWidth = [((sliderProperSize ?? 0.001) * 2), layoutWidth].reduce(max);\n              _containerHeight = constraints.maxHeight;\n            } else {\n              double layoutHeight = constraints.maxHeight;\n              if (layoutHeight == double.infinity) {\n                layoutHeight = 0;\n              }\n              _containerWidth = constraints.maxWidth;\n              _containerHeight = [\n                ((sliderProperSize ?? 0.0001) * 2),\n                layoutHeight,\n              ].reduce(max);\n              __containerSizeWithoutPadding = _containerWidthWithoutPadding;\n            }\n\n            if (MediaQuery.of(context).orientation != oldOrientation) {\n              _leftHandlerXPosition = 0;\n              _rightHandlerXPosition = 0;\n              _leftHandlerYPosition = 0;\n              _rightHandlerYPosition = 0;\n\n              _renderBoxInitialization();\n\n              _arrangeHandlersPosition();\n\n              _drawHatchMark();\n\n              oldOrientation = MediaQuery.of(context).orientation;\n            }\n\n            return Stack(\n              clipBehavior: Clip.none,\n              children: <Widget>[\n                Container(\n                  key: containerKey,\n                  height: _containerHeight,\n                  width: _containerWidth,\n                  foregroundDecoration: widget.foregroundDecoration,\n                  decoration: widget.decoration,\n                  child: Stack(\n                    clipBehavior: Clip.none,\n                    children: drawHandlers(),\n                  ),\n                ),\n              ],\n            );\n          },\n        );\n      },\n    );\n  }\n\n  double? _findProperSliderSize() {\n    final List<double?> sizes = [\n      widget.trackBar.activeTrackBarHeight,\n      widget.trackBar.inactiveTrackBarHeight,\n    ];\n    if (widget.axis == Axis.horizontal) {\n      sizes.add(_handlersHeight);\n    } else {\n      sizes.add(_handlersWidth);\n    }\n\n    return sizes.reduce((value, element) => max(value ?? 0.0001, element ?? 0.0001));\n  }\n\n  void initMethod() {\n    _widgetMax = widget.max;\n    _widgetMin = widget.min;\n\n    _touchSize = widget.touchSize ?? 15;\n\n    _validations();\n\n    if (__isInitCall) {\n      _leftHandlerScaleAnimationController = AnimationController(\n        duration: widget.handlerAnimation.duration,\n        vsync: this,\n      );\n      _rightHandlerScaleAnimationController = AnimationController(\n        duration: widget.handlerAnimation.duration,\n        vsync: this,\n      );\n    }\n\n    _leftHandlerScaleAnimation = Tween(begin: 0.999, end: widget.handlerAnimation.scale).animate(\n      CurvedAnimation(\n        parent: _leftHandlerScaleAnimationController,\n        reverseCurve: widget.handlerAnimation.reverseCurve,\n        curve: widget.handlerAnimation.curve,\n      ),\n    );\n    _rightHandlerScaleAnimation = Tween(begin: 0.999, end: widget.handlerAnimation.scale).animate(\n      CurvedAnimation(\n        parent: _rightHandlerScaleAnimationController,\n        reverseCurve: widget.handlerAnimation.reverseCurve,\n        curve: widget.handlerAnimation.curve,\n      ),\n    );\n\n    _setParameters();\n    _setValues();\n\n    _upperValue ??= 0.0001;\n    _lowerValue ??= 0.0001;\n\n    if (widget.rangeSlider == true &&\n        widget.maximumDistance > 0 &&\n        (_upperValue! - _lowerValue!) > widget.maximumDistance) {\n      throw Exception('lower and upper distance is more than maximum distance');\n    }\n    if (widget.rangeSlider == true &&\n        widget.minimumDistance > 0 &&\n        (_upperValue! - _lowerValue!) < widget.minimumDistance) {\n      throw Exception('lower and upper distance is less than minimum distance');\n    }\n\n    Offset animationStart = Offset.zero;\n    if (widget.tooltip?.disableAnimation ?? false) {\n      animationStart = const Offset(0, -1);\n    }\n\n    Offset? animationFinish;\n    switch (_tooltipData.direction) {\n      case FlutterSliderTooltipDirection.top:\n        animationFinish = const Offset(0, -1);\n      case FlutterSliderTooltipDirection.left:\n        animationFinish = const Offset(-1, 0);\n      case FlutterSliderTooltipDirection.right:\n        animationFinish = const Offset(1, 0);\n      // default case is removed because it is unreachable\n    }\n\n    if (__isInitCall) {\n      _rightTooltipOpacity = (_tooltipData.alwaysShowTooltip == true) ? 1 : 0;\n      _leftTooltipOpacity = (_tooltipData.alwaysShowTooltip == true) ? 1 : 0;\n\n      _leftTooltipAnimationController = AnimationController(\n        duration: const Duration(milliseconds: 200),\n        vsync: this,\n      );\n      _rightTooltipAnimationController = AnimationController(\n        duration: const Duration(milliseconds: 200),\n        vsync: this,\n      );\n    } else {\n      if (_tooltipData.alwaysShowTooltip) {\n        _rightTooltipOpacity = _leftTooltipOpacity = 1;\n      }\n    }\n\n    _leftTooltipAnimation = Tween<Offset>(begin: animationStart, end: animationFinish).animate(\n      CurvedAnimation(\n        parent: _leftTooltipAnimationController ?? AnimationController(vsync: this),\n        curve: Curves.fastOutSlowIn,\n      ),\n    );\n\n    _rightTooltipAnimation = Tween<Offset>(begin: animationStart, end: animationFinish).animate(\n      CurvedAnimation(\n        parent: _rightTooltipAnimationController ?? AnimationController(vsync: this),\n        curve: Curves.fastOutSlowIn,\n      ),\n    );\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      if (!mounted) return;\n\n      _renderBoxInitialization();\n\n      _arrangeHandlersPosition();\n\n      _drawHatchMark();\n\n      setState(() {});\n    });\n  }\n\n  void _drawHatchMark() {\n    if (widget.hatchMark == null || (widget.hatchMark?.disabled ?? false)) {\n      return;\n    }\n    _points = [];\n\n    final double maxTrackBarHeight = [\n      widget.trackBar.inactiveTrackBarHeight,\n      widget.trackBar.activeTrackBarHeight,\n    ].reduce(max);\n\n    final FlutterSliderHatchMark hatchMark = FlutterSliderHatchMark()\n      ..disabled = widget.hatchMark?.disabled ?? false\n      ..density = widget.hatchMark?.density ?? 0.001\n      ..smallDensity = widget.hatchMark?.smallDensity ?? 0\n      ..linesDistanceFromTrackBar = widget.hatchMark?.linesDistanceFromTrackBar ?? 0\n      ..labelsDistanceFromTrackBar = widget.hatchMark?.labelsDistanceFromTrackBar ?? 0\n      ..smallLine = widget.hatchMark?.smallLine ??\n          const FlutterSliderSizedBox(\n            height: 5,\n            width: 1,\n            decoration: BoxDecoration(color: Colors.black45),\n          )\n      ..bigLine = widget.hatchMark?.bigLine ??\n          const FlutterSliderSizedBox(\n            height: 9,\n            width: 2,\n            decoration: BoxDecoration(color: Colors.black45),\n          )\n      ..labelBox = widget.hatchMark?.labelBox ?? const FlutterSliderSizedBox(height: 50, width: 50)\n      ..labels = widget.hatchMark?.labels\n      ..linesAlignment = widget.hatchMark?.linesAlignment ?? FlutterSliderHatchMarkAlignment.right\n      ..displayLines = widget.hatchMark?.displayLines ?? false;\n\n    if (hatchMark.displayLines ?? false) {\n      final double percent = 100 * hatchMark.density;\n      double barWidth;\n      double barHeight;\n      double distance;\n      double? linesTop;\n      double? linesLeft;\n      double? linesRight;\n      double? linesBottom;\n\n      if (widget.axis == Axis.horizontal) {\n        distance = (_constraintMaxWidth - (_handlersWidth ?? 0.0001)) / percent;\n      } else {\n        distance = (_constraintMaxHeight - (_handlersHeight ?? 0.0001)) / percent;\n      }\n\n      Alignment linesAlignment;\n      if (widget.axis == Axis.horizontal) {\n        if (hatchMark.linesAlignment == FlutterSliderHatchMarkAlignment.left) {\n          linesAlignment = Alignment.bottomCenter;\n        } else {\n          linesAlignment = Alignment.topCenter;\n        }\n      } else {\n        if (hatchMark.linesAlignment == FlutterSliderHatchMarkAlignment.left) {\n          linesAlignment = Alignment.centerRight;\n        } else {\n          linesAlignment = Alignment.centerLeft;\n        }\n      }\n\n      Widget barLine;\n      for (int p = 0; p <= percent; p++) {\n        FlutterSliderSizedBox? barLineBox = hatchMark.smallLine;\n\n        if (p % (hatchMark.smallDensity + 1) == 0) {\n          barLineBox = hatchMark.bigLine;\n        }\n\n        if (widget.axis == Axis.horizontal) {\n          barHeight = barLineBox?.height ?? 0.0001;\n          barWidth = barLineBox?.width ?? 0.0001;\n        } else {\n          barHeight = barLineBox?.width ?? 0.0001;\n          barWidth = barLineBox?.height ?? 0.0001;\n        }\n\n        barLine = Align(\n          alignment: linesAlignment,\n          child: Container(\n            decoration: barLineBox?.decoration,\n            foregroundDecoration: barLineBox?.foregroundDecoration,\n            transform: barLineBox?.transform,\n            height: barHeight,\n            width: barWidth,\n          ),\n        );\n\n        if (widget.axis == Axis.horizontal) {\n          linesLeft = (p * distance) + _handlersPadding - 0.75;\n          if (hatchMark.linesAlignment == FlutterSliderHatchMarkAlignment.right) {\n            linesTop = _containerHeight! / 2 + maxTrackBarHeight / 2 + 2;\n            linesBottom = _containerHeight! / 2 - maxTrackBarHeight - 15;\n          } else {\n            linesTop = _containerHeight! / 2 - maxTrackBarHeight - 15;\n            linesBottom = _containerHeight! / 2 + maxTrackBarHeight / 2 + 2;\n          }\n          if (hatchMark.linesAlignment == FlutterSliderHatchMarkAlignment.left) {\n            linesBottom += hatchMark.linesDistanceFromTrackBar!;\n          } else {\n            linesTop += hatchMark.linesDistanceFromTrackBar!;\n          }\n        } else {\n          linesTop = (p * distance) + _handlersPadding - 0.5;\n          if (hatchMark.linesAlignment == FlutterSliderHatchMarkAlignment.right) {\n            linesLeft = _containerWidth! / 2 + maxTrackBarHeight / 2 + 2;\n            linesRight = _containerWidth! / 2 - maxTrackBarHeight - 15;\n          } else {\n            linesLeft = _containerWidth! / 2 - maxTrackBarHeight - 15;\n            linesRight = _containerWidth! / 2 + maxTrackBarHeight / 2 + 2;\n          }\n          if (hatchMark.linesAlignment == FlutterSliderHatchMarkAlignment.left) {\n            linesRight += hatchMark.linesDistanceFromTrackBar!;\n          } else {\n            linesLeft += hatchMark.linesDistanceFromTrackBar!;\n          }\n        }\n\n        _points.add(\n          Positioned(\n            top: linesTop,\n            bottom: linesBottom,\n            left: linesLeft,\n            right: linesRight,\n            child: barLine,\n          ),\n        );\n      }\n    }\n\n    if (hatchMark.labels != null && hatchMark.labels!.isNotEmpty) {\n      List<Widget> labelWidget = [];\n      Widget? label;\n      double labelBoxHalfSize;\n      double? top;\n      double? left;\n      double? bottom;\n      double? right;\n      double? tr;\n      for (final FlutterSliderHatchMarkLabel markLabel in hatchMark.labels ?? []) {\n        label = markLabel.label;\n        tr = markLabel.percent;\n        labelBoxHalfSize = 0;\n\n        if (widget.rtl) tr = 100 - (tr ?? 0.0001);\n\n        if (widget.axis == Axis.horizontal) {\n          labelBoxHalfSize = (hatchMark.labelBox?.width ?? 0.0001) / 2 - 0.5;\n        } else {\n          labelBoxHalfSize = (hatchMark.labelBox?.height ?? 0.0001) / 2 - 0.5;\n        }\n\n        labelWidget = [\n          Container(\n            height: widget.axis == Axis.vertical ? hatchMark.labelBox?.height : null,\n            width: widget.axis == Axis.horizontal ? hatchMark.labelBox?.width : null,\n            decoration: hatchMark.labelBox?.decoration,\n            foregroundDecoration: hatchMark.labelBox?.foregroundDecoration,\n            transform: hatchMark.labelBox?.transform,\n            child: Align(child: label),\n          ),\n        ];\n\n        Widget bar;\n        if (widget.axis == Axis.horizontal) {\n          bar = Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: labelWidget,\n          );\n          left = (tr ?? 0.0001) * (_containerWidthWithoutPadding ?? 0.0001) / 100 -\n              0.5 +\n              _handlersPadding -\n              labelBoxHalfSize;\n\n          top = hatchMark.labelsDistanceFromTrackBar;\n          bottom = 0;\n        } else {\n          bar = Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: labelWidget,\n          );\n          top = (tr ?? 0.0001) * (_containerHeightWithoutPadding ?? 0.0001) / 100 -\n              0.5 +\n              _handlersPadding -\n              labelBoxHalfSize;\n          right = 0;\n          left = hatchMark.labelsDistanceFromTrackBar;\n        }\n\n        _points.add(\n          Positioned(\n            top: top,\n            bottom: bottom,\n            left: left,\n            right: right,\n            child: bar,\n          ),\n        );\n      }\n    }\n  }\n\n  void _validations() {\n    if (widget.rangeSlider == true && widget.values.length < 2) {\n      throw Exception(\n        'when range mode is true, slider needs both lower and upper values',\n      );\n    }\n\n    if (widget.fixedValues == null) {\n      if (widget.values[0] < (_widgetMin ?? 0.0001)) {\n        throw Exception('Lower value should be greater than min');\n      }\n\n      if (widget.rangeSlider == true) {\n        if (widget.values[1] > (_widgetMax ?? QuranScreen.width)) {\n          throw Exception('Upper value should be smaller than max');\n        }\n      }\n    } else {\n      if (!(widget.fixedValues != null && widget.values[0] >= 0 && widget.values[0] <= 100)) {\n        throw Exception(\n          'When using fixedValues, you should set values within the range of fixedValues',\n        );\n      }\n\n      if (widget.rangeSlider == true && widget.values.length > 1) {\n        if (!(widget.fixedValues != null && widget.values[1] >= 0 && widget.values[1] <= 100)) {\n          throw Exception(\n            'When using fixedValues, you should set values within the range of fixedValues',\n          );\n        }\n      }\n    }\n\n    if (widget.rangeSlider == true) {\n      if (widget.values[0] > widget.values[1]) {\n        throw Exception('Lower value must be smaller than upper value');\n      }\n    }\n  }\n\n  void _setParameters() {\n    _realMin = 0;\n    _widgetMax = widget.max;\n    _widgetMin = widget.min;\n\n    _ignoreSteps = [];\n\n    if (widget.fixedValues != null && widget.fixedValues!.isNotEmpty) {\n      _realMax = 100;\n      _realMin = 0;\n      _widgetStep = 1;\n      _widgetMax = 100;\n      _widgetMin = 0;\n\n      final List<double> fixedValuesIndices = [];\n      for (final FlutterSliderFixedValue fixedValue in widget.fixedValues ?? []) {\n        fixedValuesIndices.add(fixedValue.percent?.toDouble() ?? 0.0001);\n      }\n\n      double lowerIgnoreBound = -1;\n      double upperIgnoreBound;\n      final List<double> fixedV = [];\n      for (double fixedPercent = 0; fixedPercent <= 100; fixedPercent++) {\n        dynamic fValue = '';\n        for (final FlutterSliderFixedValue fixedValue in widget.fixedValues ?? []) {\n          if (fixedValue.percent == fixedPercent.toInt()) {\n            fixedValuesIndices.add(fixedValue.percent?.toDouble() ?? 0.0001);\n            fValue = fixedValue.value;\n\n            upperIgnoreBound = fixedPercent;\n            if (fixedPercent > lowerIgnoreBound + 1 || lowerIgnoreBound == 0) {\n              if (lowerIgnoreBound > 0) lowerIgnoreBound += 1;\n              upperIgnoreBound = fixedPercent - 1;\n              _ignoreSteps.add(\n                FlutterSliderIgnoreSteps(\n                  from: lowerIgnoreBound,\n                  to: upperIgnoreBound,\n                ),\n              );\n            }\n            lowerIgnoreBound = fixedPercent;\n            break;\n          }\n        }\n        _fixedValues.add(\n          FlutterSliderFixedValue(\n            percent: fixedPercent.toInt(),\n            value: fValue,\n          ),\n        );\n        if (fValue.toString().isNotEmpty) {\n          fixedV.add(fixedPercent);\n        }\n      }\n\n      final double? biggestPoint = _findBiggestIgnorePoint(ignoreBeyondBoundaries: true);\n      if (!fixedV.contains(100)) {\n        _ignoreSteps.add(\n          FlutterSliderIgnoreSteps(from: (biggestPoint ?? 0.0001) + 1, to: 101),\n        );\n      }\n    } else {\n      _realMax = (_widgetMax ?? QuranScreen.width) - (_widgetMin ?? 0.0001);\n      _widgetStep = widget.step.step;\n    }\n\n    _ignoreSteps.addAll(widget.ignoreSteps);\n\n    _handlersWidth = widget.handlerWidth ?? widget.handlerHeight ?? 35;\n    _handlersHeight = widget.handlerHeight ?? widget.handlerWidth ?? 35;\n\n    _setDivisionAndDecimalScale();\n\n    _positionedItems = [\n      _leftHandlerWidget,\n      _rightHandlerWidget,\n    ];\n\n    final FlutterSliderTooltip widgetTooltip = widget.tooltip ?? FlutterSliderTooltip();\n\n    _tooltipData = FlutterSliderTooltip();\n    _tooltipData\n      ..boxStyle = widgetTooltip.boxStyle ??\n          FlutterSliderTooltipBox(\n            decoration: BoxDecoration(\n              border: Border.all(color: Colors.black12, width: 0.5),\n              color: const Color(0xffffffff),\n            ),\n          )\n      ..textStyle = widgetTooltip.textStyle ?? const TextStyle(fontSize: 12, color: Colors.black38)\n      ..leftPrefix = widgetTooltip.leftPrefix\n      ..leftSuffix = widgetTooltip.leftSuffix\n      ..rightPrefix = widgetTooltip.rightPrefix\n      ..rightSuffix = widgetTooltip.rightSuffix\n      ..alwaysShowTooltip = widgetTooltip.alwaysShowTooltip\n      ..disabled = widgetTooltip.disabled\n      ..disableAnimation = widgetTooltip.disableAnimation\n      ..direction = widgetTooltip.direction\n      ..positionOffset = widgetTooltip.positionOffset\n      ..format = widgetTooltip.format;\n\n    _arrangeHandlersZIndex();\n\n    _generateHandler();\n\n    _handlersDistance = widget.lockDistance ?? _upperValue! - _lowerValue!;\n  }\n\n  void _setDivisionAndDecimalScale() {\n    _divisions = _realMax / (_widgetStep ?? 0.0001);\n    String tmpDecimalScale = '0';\n    final List<String> tmpDecimalScaleArr = _widgetStep.toString().split(\".\");\n    if (tmpDecimalScaleArr.length > 1) {\n      tmpDecimalScale = tmpDecimalScaleArr[1];\n    }\n    if (int.parse(tmpDecimalScale) > 0) {\n      _decimalScale = tmpDecimalScale.length;\n    }\n  }\n\n  List<double?> _calculateUpperAndLowerValues() {\n    double? localLV;\n    double? localUV;\n    localLV = widget.values[0];\n    if (widget.rangeSlider) {\n      localUV = widget.values[1];\n    } else {\n      if (widget.rtl) {\n        localUV = _widgetMax;\n      } else {\n        localLV = _widgetMin;\n      }\n    }\n\n    return [localLV, localUV];\n  }\n\n  void _setValues() {\n    final List<double?> localValues = _calculateUpperAndLowerValues();\n\n    _lowerValue = localValues[0]! - _widgetMin!;\n    _upperValue = localValues[1]! - _widgetMin!;\n\n    _outputUpperValue = _displayRealValue(_upperValue);\n    _outputLowerValue = _displayRealValue(_lowerValue);\n\n    if (widget.rtl == true) {\n      _outputLowerValue = _displayRealValue(_realMax - _lowerValue!);\n      _outputUpperValue = _displayRealValue(_realMax - _upperValue!);\n\n      final double tmpUpperValue = _realMax - _lowerValue!;\n      final double tmpLowerValue = _realMax - _upperValue!;\n\n      _lowerValue = tmpLowerValue;\n      _upperValue = tmpUpperValue;\n    }\n  }\n\n  void _arrangeHandlersPosition() {\n    if (!__dragging) {\n      if (widget.axis == Axis.horizontal) {\n        _handlersPadding = _handlersWidth! / 2;\n        _leftHandlerXPosition = getPositionByValue(_lowerValue);\n        _rightHandlerXPosition = getPositionByValue(_upperValue);\n      } else {\n        _handlersPadding = _handlersHeight! / 2;\n        _leftHandlerYPosition = getPositionByValue(_lowerValue);\n        _rightHandlerYPosition = getPositionByValue(_upperValue);\n      }\n    }\n  }\n\n  void _generateHandler() {\n    /*Right Handler Data*/\n\n    (widget.rightHandler ?? FlutterSliderHandler())\n      ..child ??= Icon(\n        (widget.axis == Axis.horizontal) ? Icons.chevron_left : Icons.expand_less,\n        color: Colors.black45,\n      )\n      ..decoration ??= const BoxDecoration(\n        boxShadow: [\n          BoxShadow(\n            color: Colors.black26,\n            blurRadius: 2,\n            spreadRadius: 0.2,\n            offset: Offset(0, 1),\n          ),\n        ],\n        color: Colors.white,\n        shape: BoxShape.circle,\n      );\n\n    rightHandler = _MakeHandler(\n      animation: _rightHandlerScaleAnimation,\n      id: rightHandlerKey,\n      visibleTouchArea: widget.visibleTouchArea,\n      handlerData: widget.rightHandler,\n      width: _handlersWidth,\n      height: _handlersHeight,\n      axis: widget.axis,\n      handlerIndex: 2,\n      touchSize: _touchSize,\n    );\n\n    leftHandler = _MakeHandler(\n      animation: _leftHandlerScaleAnimation,\n      id: leftHandlerKey,\n      visibleTouchArea: widget.visibleTouchArea,\n      handlerData: widget.handler,\n      width: _handlersWidth,\n      height: _handlersHeight,\n      rtl: widget.rtl,\n      rangeSlider: widget.rangeSlider,\n      axis: widget.axis,\n      touchSize: _touchSize,\n    );\n\n    if (widget.rangeSlider == false) {\n      rightHandler = leftHandler;\n    }\n  }\n\n  double getPositionByValue(double? valueParam) {\n    final double value = valueParam ?? 0;\n    if (widget.axis == Axis.horizontal) {\n      return (((_constraintMaxWidth - _handlersWidth!) / _realMax) * value) - _touchSize;\n    } else {\n      return (((_constraintMaxHeight - _handlersHeight!) / _realMax) * value) - _touchSize;\n    }\n  }\n\n  double getValueByPosition(double position) {\n    double value = (position / (__containerSizeWithoutPadding! / _divisions)) * _widgetStep!;\n    value = double.parse(value.toStringAsFixed(_decimalScale)) -\n        double.parse((value % _widgetStep!).toStringAsFixed(_decimalScale));\n    return value;\n  }\n\n  double? getLengthByValue(double? value) {\n    if (value == null) return null;\n    return value * __containerSizeWithoutPadding! / _realMax;\n  }\n\n  double getValueByPositionIgnoreOffset(double position) {\n    final double value = (position / (__containerSizeWithoutPadding! / _divisions)) * _widgetStep!;\n    return value;\n  }\n\n  void _leftHandlerMove(\n    PointerEvent pointer, {\n    double lockedHandlersDragOffset = 0,\n    double tappedPositionWithPadding = 0,\n    bool selectedByTap = false,\n  }) {\n    catchVoid(() {\n      if (widget.disabled || (widget.handler != null && widget.handler!.disabled)) {\n        return;\n      }\n\n      _handlersDistance = widget.lockDistance ?? _upperValue! - _lowerValue!;\n\n      if (lockedHandlersDragOffset == 0) __lockedHandlersDragOffset = 0;\n\n      if (selectedByTap) {\n        _callbacks('onDragStarted', 0);\n      }\n\n      bool validMove = true;\n\n      if (widget.axis == Axis.horizontal) {\n        __dAxis = pointer.position.dx - tappedPositionWithPadding - lockedHandlersDragOffset - _containerLeft;\n        __axisDragTmp = xDragTmp;\n        __containerSizeWithoutPadding = _containerWidthWithoutPadding;\n        __rightHandlerPosition = _rightHandlerXPosition;\n        __leftHandlerPosition = _leftHandlerXPosition;\n      } else {\n        __dAxis = pointer.position.dy - tappedPositionWithPadding - lockedHandlersDragOffset - _containerTop;\n        __axisDragTmp = yDragTmp;\n        __containerSizeWithoutPadding = _containerHeightWithoutPadding;\n        __rightHandlerPosition = _rightHandlerYPosition;\n        __leftHandlerPosition = _leftHandlerYPosition;\n      }\n\n      __axisPosTmp = __dAxis! - __axisDragTmp! + _touchSize;\n\n      _checkRangeStep(getValueByPositionIgnoreOffset(__axisPosTmp));\n\n      __rAxis = getValueByPosition(__axisPosTmp);\n\n      if (widget.rangeSlider && widget.minimumDistance > 0 && (__rAxis! + widget.minimumDistance) >= _upperValue!) {\n        _lowerValue =\n            (_upperValue! - widget.minimumDistance > _realMin!) ? _upperValue! - widget.minimumDistance : _realMin;\n        _updateLowerValue(_lowerValue);\n\n        if (lockedHandlersDragOffset == 0) validMove = validMove & false;\n      }\n\n      if (widget.rangeSlider && widget.maximumDistance > 0 && __rAxis! <= (_upperValue! - widget.maximumDistance)) {\n        _lowerValue =\n            (_upperValue! - widget.maximumDistance > _realMin!) ? _upperValue! - widget.maximumDistance : _realMin;\n        _updateLowerValue(_lowerValue);\n\n        if (lockedHandlersDragOffset == 0) validMove = validMove & false;\n      }\n\n      double? tS = _touchSize;\n      if (widget.jump) {\n        tS = _touchSize + _handlersPadding;\n      }\n\n      validMove = validMove & _leftHandlerIgnoreSteps(tS);\n\n      bool forcePosStop = false;\n      if ((__axisPosTmp <= 0) || (__axisPosTmp - tS >= __rightHandlerPosition!)) {\n        forcePosStop = true;\n      }\n\n      if (validMove && ((__axisPosTmp + _handlersPadding >= _handlersPadding) || forcePosStop)) {\n        double tmpLowerValue = __rAxis!;\n\n        if (tmpLowerValue > _realMax) tmpLowerValue = _realMax;\n        if (tmpLowerValue < _realMin!) tmpLowerValue = _realMin!;\n\n        if (tmpLowerValue > _upperValue!) tmpLowerValue = _upperValue!;\n\n        if (widget.jump == true) {\n          if (!forcePosStop) {\n            _lowerValue = tmpLowerValue;\n            _leftHandlerMoveBetweenSteps(\n              __dAxis! - __axisDragTmp!,\n              selectedByTap,\n            );\n            __leftHandlerPosition = getPositionByValue(_lowerValue);\n          } else {\n            if (__axisPosTmp - tS >= __rightHandlerPosition!) {\n              __leftHandlerPosition = __rightHandlerPosition;\n              _lowerValue = tmpLowerValue = _upperValue!;\n            } else {\n              __leftHandlerPosition = getPositionByValue(_realMin);\n              _lowerValue = tmpLowerValue = _realMin!;\n            }\n            _updateLowerValue(tmpLowerValue);\n          }\n        } else {\n          _lowerValue = tmpLowerValue;\n\n          if (!forcePosStop) {\n            __leftHandlerPosition = __dAxis! - __axisDragTmp!;\n\n            _leftHandlerMoveBetweenSteps(\n              __leftHandlerPosition ?? 0,\n              selectedByTap,\n            );\n            tmpLowerValue = _lowerValue!;\n          } else {\n            if (__axisPosTmp - tS >= __rightHandlerPosition!) {\n              __leftHandlerPosition = __rightHandlerPosition;\n              _lowerValue = tmpLowerValue = _upperValue!;\n            } else {\n              __leftHandlerPosition = getPositionByValue(_realMin);\n              _lowerValue = tmpLowerValue = _realMin!;\n            }\n            _updateLowerValue(tmpLowerValue);\n          }\n        }\n      }\n\n      if (widget.axis == Axis.horizontal) {\n        _leftHandlerXPosition = __leftHandlerPosition;\n      } else {\n        _leftHandlerYPosition = __leftHandlerPosition;\n      }\n      if (widget.lockHandlers || lockedHandlersDragOffset > 0) {\n        _lockedHandlers('leftHandler');\n      }\n      setState(() {});\n\n      if (selectedByTap) {\n        _callbacks('onDragging', 0);\n        _callbacks('onDragCompleted', 0);\n      } else {\n        _callbacks('onDragging', 0);\n      }\n    });\n  }\n\n  bool _leftHandlerIgnoreSteps(double? tS) {\n    bool validMove = true;\n    if (_ignoreSteps.isNotEmpty) {\n      if (__axisPosTmp <= 0) {\n        double? ignorePoint;\n        if (widget.rtl) {\n          ignorePoint = _findBiggestIgnorePoint();\n        } else {\n          ignorePoint = _findSmallestIgnorePoint();\n        }\n\n        __leftHandlerPosition = getPositionByValue(ignorePoint);\n        _lowerValue = ignorePoint;\n        _updateLowerValue(_lowerValue);\n        return false;\n      } else if (__axisPosTmp - tS! >= __rightHandlerPosition!) {\n        __leftHandlerPosition = __rightHandlerPosition;\n        _lowerValue = _upperValue;\n        _updateLowerValue(_lowerValue);\n        return false;\n      }\n\n      for (final FlutterSliderIgnoreSteps steps in _ignoreSteps) {\n        if (((!widget.rtl) &&\n                (getValueByPositionIgnoreOffset(__axisPosTmp) > steps.from - _widgetStep! / 2 &&\n                    getValueByPositionIgnoreOffset(__axisPosTmp) <= steps.to + _widgetStep! / 2)) ||\n            ((widget.rtl) &&\n                (_realMax - getValueByPositionIgnoreOffset(__axisPosTmp) > steps.from - _widgetStep! / 2 &&\n                    _realMax - getValueByPositionIgnoreOffset(__axisPosTmp) <= steps.to + _widgetStep! / 2))) {\n          validMove = false;\n        }\n      }\n    }\n\n    return validMove;\n  }\n\n  void _leftHandlerMoveBetweenSteps(double handlerPos, bool selectedByTap) {\n    final double nextStepMiddlePos = getPositionByValue((_lowerValue! + (_lowerValue! + _widgetStep!)) / 2);\n    final double prevStepMiddlePos = getPositionByValue((_lowerValue! - (_lowerValue! - _widgetStep!)) / 2);\n\n    if ((handlerPos > nextStepMiddlePos) || (handlerPos < prevStepMiddlePos)) {\n      if (handlerPos > nextStepMiddlePos) {\n        _lowerValue = _lowerValue! + _widgetStep!;\n        if (_lowerValue! > _realMax) _lowerValue = _realMax;\n        if (_lowerValue! > _upperValue!) _lowerValue = _upperValue;\n      } else {\n        _lowerValue = _lowerValue! - _widgetStep!;\n        if (_lowerValue! < _realMin!) _lowerValue = _realMin;\n      }\n    }\n    _updateLowerValue(_lowerValue);\n  }\n\n  void _lockedHandlers(String handler) {\n    final double? distanceOfTwoHandlers = getLengthByValue(_handlersDistance);\n\n    double? leftHandlerPos;\n    double? rightHandlerPos;\n    if (widget.axis == Axis.horizontal) {\n      leftHandlerPos = _leftHandlerXPosition;\n      rightHandlerPos = _rightHandlerXPosition;\n    } else {\n      leftHandlerPos = _leftHandlerYPosition;\n      rightHandlerPos = _rightHandlerYPosition;\n    }\n\n    if (handler == 'rightHandler') {\n      _lowerValue = _upperValue! - _handlersDistance;\n      leftHandlerPos = rightHandlerPos! - distanceOfTwoHandlers!;\n      if (getValueByPositionIgnoreOffset(__axisPosTmp) - _handlersDistance < _realMin!) {\n        _lowerValue = _realMin;\n        _upperValue = _realMin! + _handlersDistance;\n        rightHandlerPos = getPositionByValue(_upperValue);\n        leftHandlerPos = getPositionByValue(_lowerValue);\n      }\n    } else {\n      _upperValue = _lowerValue! + _handlersDistance;\n      rightHandlerPos = leftHandlerPos! + distanceOfTwoHandlers!;\n      if (getValueByPositionIgnoreOffset(__axisPosTmp) + _handlersDistance > _realMax) {\n        _upperValue = _realMax;\n        _lowerValue = _realMax - _handlersDistance;\n        rightHandlerPos = getPositionByValue(_upperValue);\n        leftHandlerPos = getPositionByValue(_lowerValue);\n      }\n    }\n\n    if (widget.axis == Axis.horizontal) {\n      _leftHandlerXPosition = leftHandlerPos;\n      _rightHandlerXPosition = rightHandlerPos;\n    } else {\n      _leftHandlerYPosition = leftHandlerPos;\n      _rightHandlerYPosition = rightHandlerPos;\n    }\n\n    _updateUpperValue(_upperValue);\n    _updateLowerValue(_lowerValue);\n  }\n\n  void _updateLowerValue(double? value) {\n    _outputLowerValue = _displayRealValue(value);\n    if (widget.rtl == true) {\n      _outputLowerValue = _displayRealValue(_realMax - (value ?? 0));\n    }\n  }\n\n  void _rightHandlerMove(\n    PointerEvent pointer, {\n    double tappedPositionWithPadding = 0,\n    bool selectedByTap = false,\n  }) {\n    catchVoid(() {\n      if (widget.disabled || (widget.rightHandler != null && (widget.rightHandler?.disabled ?? false))) {\n        return;\n      }\n\n      _handlersDistance = widget.lockDistance ?? (_upperValue ?? 0.0002) - (_lowerValue ?? 0.0001);\n\n      if (selectedByTap) _callbacks('onDragStarted', 1);\n\n      bool validMove = true;\n\n      if (widget.axis == Axis.horizontal) {\n        __dAxis = pointer.position.dx - tappedPositionWithPadding - _containerLeft;\n        __axisDragTmp = xDragTmp;\n        __containerSizeWithoutPadding = _containerWidthWithoutPadding;\n        __rightHandlerPosition = _rightHandlerXPosition;\n        __leftHandlerPosition = _leftHandlerXPosition;\n        __containerSizeWithoutHalfPadding = _constraintMaxWidth - _handlersPadding + 1;\n      } else {\n        __dAxis = pointer.position.dy - tappedPositionWithPadding - _containerTop;\n        __axisDragTmp = yDragTmp;\n        __containerSizeWithoutPadding = _containerHeightWithoutPadding;\n        __rightHandlerPosition = _rightHandlerYPosition;\n        __leftHandlerPosition = _leftHandlerYPosition;\n        __containerSizeWithoutHalfPadding = _constraintMaxHeight - _handlersPadding + 1;\n      }\n\n      __axisPosTmp = (__dAxis ?? 0.0001) - (__axisDragTmp ?? 0.0001) + _touchSize;\n\n      _checkRangeStep(getValueByPositionIgnoreOffset(__axisPosTmp));\n\n      __rAxis = getValueByPosition(__axisPosTmp);\n\n      if (widget.rangeSlider &&\n          widget.minimumDistance > 0 &&\n          ((__rAxis ?? 0.0001) - widget.minimumDistance) <= (_lowerValue ?? 0.0001)) {\n        _upperValue = ((_lowerValue ?? 0.0001) + widget.minimumDistance < _realMax)\n            ? (_lowerValue ?? 0.0001) + widget.minimumDistance\n            : _realMax;\n        validMove = validMove & false;\n        _updateUpperValue(_upperValue);\n      }\n      if (widget.rangeSlider &&\n          widget.maximumDistance > 0 &&\n          (__rAxis ?? 0.0001) >= ((_lowerValue ?? 0.0001) + widget.maximumDistance)) {\n        _upperValue = ((_lowerValue ?? 0.0001) + widget.maximumDistance < _realMax)\n            ? (_lowerValue ?? 0.0001) + widget.maximumDistance\n            : _realMax;\n        validMove = validMove & false;\n        _updateUpperValue(_upperValue);\n      }\n\n      double? tS = _touchSize;\n      double rM = _handlersPadding;\n      if (widget.jump) {\n        rM = -(_handlersWidth ?? 0.0001);\n        tS = -_touchSize;\n      }\n\n      validMove = validMove & _rightHandlerIgnoreSteps(tS);\n\n      bool forcePosStop = false;\n      if ((__axisPosTmp >= (__containerSizeWithoutPadding ?? 0.0001)) ||\n          (__axisPosTmp - tS <= (__leftHandlerPosition ?? 0.0001))) {\n        forcePosStop = true;\n      }\n\n      if (validMove && (__axisPosTmp + rM <= (__containerSizeWithoutHalfPadding ?? 0.0001) || forcePosStop)) {\n        double tmpUpperValue = __rAxis ?? 0.0001;\n\n        if (tmpUpperValue > _realMax) tmpUpperValue = _realMax;\n        if (tmpUpperValue < (_realMin ?? 0.0001)) {\n          tmpUpperValue = _realMin ?? 0.0001;\n        }\n\n        if (tmpUpperValue < (_lowerValue ?? 0.0001)) {\n          tmpUpperValue = _lowerValue ?? 0.0001;\n        }\n\n        if (widget.jump == true) {\n          if (!forcePosStop) {\n            _upperValue = tmpUpperValue;\n            _rightHandlerMoveBetweenSteps(\n              (__dAxis ?? 0.0001) - (__axisDragTmp ?? 0.0001),\n              selectedByTap,\n            );\n            __rightHandlerPosition = getPositionByValue(_upperValue);\n          } else {\n            if (__axisPosTmp - tS <= (__leftHandlerPosition ?? 0.0001)) {\n              __rightHandlerPosition = __leftHandlerPosition;\n              _upperValue = tmpUpperValue = _lowerValue ?? 0.0001;\n            } else {\n              __rightHandlerPosition = getPositionByValue(_realMax);\n              _upperValue = tmpUpperValue = _realMax;\n            }\n\n            _updateUpperValue(tmpUpperValue);\n          }\n        } else {\n          _upperValue = tmpUpperValue;\n\n          if (!forcePosStop) {\n            __rightHandlerPosition = (__dAxis ?? 0.0001) - (__axisDragTmp ?? 0.0001);\n            _rightHandlerMoveBetweenSteps(\n              __rightHandlerPosition ?? 0,\n              selectedByTap,\n            );\n            tmpUpperValue = _upperValue ?? 0.0001;\n          } else {\n            if (__axisPosTmp - tS <= (__leftHandlerPosition ?? 0.0001)) {\n              __rightHandlerPosition = __leftHandlerPosition;\n              _upperValue = tmpUpperValue = _lowerValue ?? 0.0001;\n            } else {\n              __rightHandlerPosition = getPositionByValue(_realMax) + 1;\n              _upperValue = tmpUpperValue = _realMax;\n            }\n          }\n          _updateUpperValue(tmpUpperValue);\n        }\n      }\n\n      if (widget.axis == Axis.horizontal) {\n        _rightHandlerXPosition = __rightHandlerPosition;\n      } else {\n        _rightHandlerYPosition = __rightHandlerPosition;\n      }\n      if (widget.lockHandlers) {\n        _lockedHandlers('rightHandler');\n      }\n\n      setState(() {});\n\n      if (selectedByTap) {\n        _callbacks('onDragging', 1);\n        _callbacks('onDragCompleted', 1);\n      } else {\n        _callbacks('onDragging', 1);\n      }\n    });\n  }\n\n  bool _rightHandlerIgnoreSteps(double? tS) {\n    bool validMove = true;\n    if (_ignoreSteps.isNotEmpty) {\n      if (__axisPosTmp <= 0) {\n        if (!widget.rangeSlider) {\n          double? ignorePoint;\n          if (widget.rtl) {\n            ignorePoint = _findBiggestIgnorePoint();\n          } else {\n            ignorePoint = _findSmallestIgnorePoint();\n          }\n\n          __rightHandlerPosition = getPositionByValue(ignorePoint);\n          _upperValue = ignorePoint;\n          _updateUpperValue(_upperValue);\n        } else {\n          __rightHandlerPosition = __leftHandlerPosition;\n          _upperValue = _lowerValue;\n          _updateUpperValue(_upperValue);\n        }\n        return false;\n      } else if (__axisPosTmp >= __containerSizeWithoutPadding!) {\n        double? ignorePoint;\n\n        if (widget.rtl) {\n          ignorePoint = _findSmallestIgnorePoint();\n        } else {\n          ignorePoint = _findBiggestIgnorePoint();\n        }\n\n        __rightHandlerPosition = getPositionByValue(ignorePoint);\n        _upperValue = ignorePoint;\n        _updateUpperValue(_upperValue);\n        return false;\n      }\n\n      for (final FlutterSliderIgnoreSteps steps in _ignoreSteps) {\n        if (((!widget.rtl) &&\n                (getValueByPositionIgnoreOffset(__axisPosTmp) > steps.from - _widgetStep! / 2 &&\n                    getValueByPositionIgnoreOffset(__axisPosTmp) <= steps.to + _widgetStep! / 2)) ||\n            ((widget.rtl) &&\n                (_realMax - getValueByPositionIgnoreOffset(__axisPosTmp) > steps.from - _widgetStep! / 2 &&\n                    _realMax - getValueByPositionIgnoreOffset(__axisPosTmp) <= steps.to + _widgetStep! / 2))) {\n          validMove = false;\n        }\n      }\n    }\n    return validMove;\n  }\n\n  double? _findSmallestIgnorePoint({bool ignoreBeyondBoundaries = false}) {\n    double? ignorePoint = _realMax;\n    bool beyondBoundaries = false;\n    for (final FlutterSliderIgnoreSteps steps in _ignoreSteps) {\n      if (steps.from < _realMin!) beyondBoundaries = true;\n      if (steps.from < ignorePoint! && steps.from >= _realMin!) {\n        ignorePoint = steps.from - _widgetStep!;\n      } else if (steps.to < ignorePoint && steps.to >= _realMin!) {\n        ignorePoint = steps.to + _widgetStep!;\n      }\n    }\n    if (beyondBoundaries || ignoreBeyondBoundaries) {\n      if (widget.rtl) {\n        ignorePoint = _realMax - ignorePoint!;\n      }\n      return ignorePoint;\n    } else {\n      if (widget.rtl) return _realMax;\n      return _realMin;\n    }\n  }\n\n  double? _findBiggestIgnorePoint({bool ignoreBeyondBoundaries = false}) {\n    double? ignorePoint = _realMin;\n    bool beyondBoundaries = false;\n    for (final FlutterSliderIgnoreSteps steps in _ignoreSteps) {\n      if (steps.to > _realMax) beyondBoundaries = true;\n\n      if (steps.to > ignorePoint! && steps.to <= _realMax) {\n        ignorePoint = steps.to + _widgetStep!;\n      } else if (steps.from > ignorePoint && steps.from <= _realMax) {\n        ignorePoint = steps.from - _widgetStep!;\n      }\n    }\n    if (beyondBoundaries || ignoreBeyondBoundaries) {\n      if (widget.rtl) {\n        ignorePoint = _realMax - ignorePoint!;\n      }\n\n      return ignorePoint;\n    } else {\n      if (widget.rtl) return _realMin;\n      return _realMax;\n    }\n  }\n\n  void _rightHandlerMoveBetweenSteps(double handlerPos, bool selectedByTap) {\n    final double nextStepMiddlePos = getPositionByValue((_upperValue! + (_upperValue! + _widgetStep!)) / 2);\n    final double prevStepMiddlePos = getPositionByValue((_upperValue! - (_upperValue! - _widgetStep!)) / 2);\n\n    if (handlerPos > nextStepMiddlePos || handlerPos < prevStepMiddlePos) {\n      if (handlerPos > nextStepMiddlePos) {\n        _upperValue = _upperValue! + _widgetStep!;\n        if (_upperValue! > _realMax) _upperValue = _realMax;\n      } else {\n        _upperValue = _upperValue! - _widgetStep!;\n        if (_upperValue! < _realMin!) _upperValue = _realMin;\n        if (_upperValue! < _lowerValue!) _upperValue = _lowerValue;\n      }\n    }\n    _updateUpperValue(_upperValue);\n  }\n\n  void _updateUpperValue(double? value) {\n    _outputUpperValue = _displayRealValue(value);\n    if (widget.rtl == true) {\n      _outputUpperValue = _displayRealValue(_realMax - (value ?? 0));\n    }\n  }\n\n  void _checkRangeStep(double realValue) {\n    double? sliderFromRange;\n    double? sliderToRange;\n    if (widget.step.rangeList != null) {\n      for (final FlutterSliderRangeStep rangeStep in widget.step.rangeList!) {\n        if (widget.step.isPercentRange) {\n          sliderFromRange = _widgetMax! * rangeStep.from / 100;\n          sliderToRange = _widgetMax! * rangeStep.to / 100;\n        } else {\n          sliderFromRange = rangeStep.from;\n          sliderToRange = rangeStep.to;\n        }\n\n        if (realValue >= sliderFromRange && realValue <= sliderToRange) {\n          _widgetStep = rangeStep.step;\n          _setDivisionAndDecimalScale();\n          break;\n        }\n      }\n    }\n  }\n\n  Positioned _leftHandlerWidget() {\n    if (widget.rangeSlider == false) {\n      return Positioned(\n        child: Container(),\n      );\n    }\n\n    double? bottom;\n    double? right;\n    if (widget.axis == Axis.horizontal) {\n      bottom = 0;\n    } else {\n      right = 0;\n    }\n\n    return Positioned(\n      key: const Key('leftHandler'),\n      left: _leftHandlerXPosition,\n      top: _leftHandlerYPosition,\n      bottom: bottom,\n      right: right,\n      child: Listener(\n        child: Draggable(\n          axis: widget.axis,\n          feedback: Container(),\n          child: Stack(\n            clipBehavior: Clip.none,\n            alignment: Alignment.center,\n            children: [\n              _tooltip(\n                side: 'left',\n                value: _outputLowerValue.toString(),\n                opacity: _leftTooltipOpacity,\n                animation: _leftTooltipAnimation,\n              ),\n              leftHandler,\n            ],\n          ),\n        ),\n        onPointerMove: (event) {\n          __dragging = true;\n\n          _leftHandlerMove(event);\n        },\n        onPointerDown: (event) {\n          if (widget.disabled || (widget.handler != null && widget.handler!.disabled)) return;\n\n          _renderBoxInitialization();\n\n          xDragTmp = event.position.dx - _containerLeft - _leftHandlerXPosition!;\n          yDragTmp = event.position.dy - _containerTop - _leftHandlerYPosition!;\n\n          if (!_tooltipData.disabled && _tooltipData.alwaysShowTooltip == false) {\n            _leftTooltipOpacity = 1;\n            _leftTooltipAnimationController?.forward();\n\n            if (widget.lockHandlers) {\n              _rightTooltipOpacity = 1;\n              _rightTooltipAnimationController?.forward();\n            }\n          }\n\n          _leftHandlerScaleAnimationController.forward();\n\n          setState(() {});\n\n          _callbacks('onDragStarted', 0);\n        },\n        onPointerUp: (_) {\n          __dragging = false;\n\n          _adjustLeftHandlerPosition();\n\n          if (widget.disabled || (widget.handler != null && widget.handler!.disabled)) return;\n\n          _arrangeHandlersZIndex();\n\n          _stopHandlerAnimation(\n            animation: _leftHandlerScaleAnimation,\n            controller: _leftHandlerScaleAnimationController,\n          );\n\n          _hideTooltips();\n\n          setState(() {});\n\n          _callbacks('onDragCompleted', 0);\n        },\n      ),\n    );\n  }\n\n  void _adjustLeftHandlerPosition() {\n    if (!widget.jump) {\n      double position = getPositionByValue(_lowerValue);\n      if (widget.axis == Axis.horizontal) {\n        _leftHandlerXPosition = position > _rightHandlerXPosition! ? _rightHandlerXPosition : position;\n        if (widget.lockHandlers || __lockedHandlersDragOffset > 0) {\n          position = getPositionByValue(_lowerValue! + _handlersDistance);\n          _rightHandlerXPosition = position < _leftHandlerXPosition! ? _leftHandlerXPosition : position;\n        }\n      } else {\n        _leftHandlerYPosition = position > _rightHandlerYPosition! ? _rightHandlerYPosition : position;\n        if (widget.lockHandlers || __lockedHandlersDragOffset > 0) {\n          position = getPositionByValue(_lowerValue! + _handlersDistance);\n          _rightHandlerYPosition = position < _leftHandlerYPosition! ? _leftHandlerYPosition : position;\n        }\n      }\n    }\n  }\n\n  void _hideTooltips() {\n    if (_tooltipData.alwaysShowTooltip) return;\n\n    _leftTooltipOpacity = 0;\n    _rightTooltipOpacity = 0;\n\n    _leftTooltipAnimationController?.reset();\n    _rightTooltipAnimationController?.reset();\n  }\n\n  Positioned _rightHandlerWidget() {\n    double? bottom;\n    double? right;\n    if (widget.axis == Axis.horizontal) {\n      bottom = 0;\n    } else {\n      right = 0;\n    }\n\n    return Positioned(\n      key: const Key('rightHandler'),\n      left: _rightHandlerXPosition,\n      top: _rightHandlerYPosition,\n      right: right,\n      bottom: bottom,\n      child: Listener(\n        child: Draggable(\n          axis: Axis.horizontal,\n          feedback: Container(),\n          child: Stack(\n            clipBehavior: Clip.none,\n            alignment: Alignment.center,\n            children: [\n              _tooltip(\n                side: 'right',\n                value: _outputUpperValue.toString(),\n                opacity: _rightTooltipOpacity,\n                animation: _rightTooltipAnimation,\n              ),\n              rightHandler,\n            ],\n          ),\n        ),\n        onPointerMove: (event) {\n          __dragging = true;\n\n          if (!_tooltipData.disabled && _tooltipData.alwaysShowTooltip == false) {\n            _rightTooltipOpacity = 1;\n          }\n          _rightHandlerMove(event);\n        },\n        onPointerDown: (event) {\n          if (widget.disabled || (widget.rightHandler != null && widget.rightHandler!.disabled)) {\n            return;\n          }\n\n          _renderBoxInitialization();\n\n          xDragTmp = event.position.dx - _containerLeft - _rightHandlerXPosition!;\n          yDragTmp = event.position.dy - _containerTop - _rightHandlerYPosition!;\n\n          if (!_tooltipData.disabled && _tooltipData.alwaysShowTooltip == false) {\n            _rightTooltipOpacity = 1;\n            _rightTooltipAnimationController?.forward();\n\n            if (widget.lockHandlers) {\n              _leftTooltipOpacity = 1;\n              _leftTooltipAnimationController?.forward();\n            }\n\n            setState(() {});\n          }\n          if (widget.rangeSlider == false) {\n            _leftHandlerScaleAnimationController.forward();\n          } else {\n            _rightHandlerScaleAnimationController.forward();\n          }\n\n          _callbacks('onDragStarted', 1);\n        },\n        onPointerUp: (_) {\n          __dragging = false;\n\n          _adjustRightHandlerPosition();\n\n          if (widget.disabled || (widget.rightHandler != null && widget.rightHandler!.disabled)) {\n            return;\n          }\n\n          _arrangeHandlersZIndex();\n\n          if (widget.rangeSlider == false) {\n            _stopHandlerAnimation(\n              animation: _leftHandlerScaleAnimation,\n              controller: _leftHandlerScaleAnimationController,\n            );\n          } else {\n            _stopHandlerAnimation(\n              animation: _rightHandlerScaleAnimation,\n              controller: _rightHandlerScaleAnimationController,\n            );\n          }\n\n          _hideTooltips();\n\n          setState(() {});\n\n          _callbacks('onDragCompleted', 1);\n        },\n      ),\n    );\n  }\n\n  void _adjustRightHandlerPosition() {\n    if (!widget.jump) {\n      double position = getPositionByValue(_upperValue);\n      if (widget.axis == Axis.horizontal) {\n        _rightHandlerXPosition = position < _leftHandlerXPosition! ? _leftHandlerXPosition : position;\n        if (widget.lockHandlers) {\n          position = getPositionByValue(_upperValue! - _handlersDistance);\n          _leftHandlerXPosition = position > _rightHandlerXPosition! ? _rightHandlerXPosition : position;\n        }\n      } else {\n        _rightHandlerYPosition = position < _leftHandlerYPosition! ? _leftHandlerYPosition : position;\n        if (widget.lockHandlers) {\n          position = getPositionByValue(_upperValue! - _handlersDistance);\n          _leftHandlerYPosition = position > _rightHandlerYPosition! ? _rightHandlerYPosition : position;\n        }\n      }\n    }\n  }\n\n\n  void _stopHandlerAnimation({\n    Animation<double>? animation,\n    AnimationController? controller,\n  }) {\n    if (controller == null) return;\n\n    if (widget.handlerAnimation.reverseCurve == null) {\n      controller.reset();\n      return;\n    }\n\n    if (animation == null) return;\n\n    animation.isCompleted ? controller.reverse() : controller.reset();\n  }\n\n  List<Positioned> drawHandlers() {\n    final List<Positioned> items = [\n      Function.apply(_inactiveTrack, []) as Positioned,\n      Function.apply(_centralWidget, []) as Positioned,\n      Function.apply(_activeTrack, []) as Positioned,\n      ..._points,\n    ];\n\n    double tappedPositionWithPadding = 0;\n\n    items.add(\n      Positioned(\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        child: Opacity(\n          opacity: 0,\n          child: Listener(\n            onPointerUp: (event) {\n              __dragging = false;\n              if (widget.selectByTap && !__dragging) {\n                tappedPositionWithPadding = _distance();\n                if (_distanceFromLeftHandler! < _distanceFromRightHandler!) {\n                  if (!widget.rangeSlider) {\n                    _rightHandlerMove(\n                      event,\n                      tappedPositionWithPadding: tappedPositionWithPadding,\n                      selectedByTap: true,\n                    );\n                  } else {\n                    _leftHandlerMove(\n                      event,\n                      tappedPositionWithPadding: tappedPositionWithPadding,\n                      selectedByTap: true,\n                    );\n                  }\n                } else {\n                  _rightHandlerMove(\n                    event,\n                    tappedPositionWithPadding: tappedPositionWithPadding,\n                    selectedByTap: true,\n                  );\n                }\n              } else {\n                if (_slidingByActiveTrackBar) {\n                  _callbacks('onDragCompleted', 0);\n                }\n                if (_leftTapAndSlide) {\n                  _callbacks('onDragCompleted', 0);\n                }\n                if (_rightTapAndSlide) {\n                  _callbacks('onDragCompleted', 1);\n                }\n              }\n\n              _hideTooltips();\n\n              _stopHandlerAnimation(\n                animation: _leftHandlerScaleAnimation,\n                controller: _leftHandlerScaleAnimationController,\n              );\n              _stopHandlerAnimation(\n                animation: _rightHandlerScaleAnimation,\n                controller: _rightHandlerScaleAnimationController,\n              );\n\n              setState(() {});\n            },\n            onPointerMove: (event) {\n              __dragging = true;\n\n              if (_slidingByActiveTrackBar) {\n                _trackBarSlideCallDragStated(0);\n                _leftHandlerMove(\n                  event,\n                  lockedHandlersDragOffset: __lockedHandlersDragOffset,\n                );\n              } else {\n                tappedPositionWithPadding = _distance();\n\n                if (widget.rangeSlider) {\n                  if (_leftTapAndSlide) {\n                    _trackBarSlideCallDragStated(0);\n                    if (!_tooltipData.disabled && _tooltipData.alwaysShowTooltip == false) {\n                      _leftTooltipOpacity = 1;\n                      _leftTooltipAnimationController?.forward();\n                    }\n                    _leftHandlerMove(\n                      event,\n                      tappedPositionWithPadding: tappedPositionWithPadding,\n                    );\n                  } else {\n                    _trackBarSlideCallDragStated(1);\n                    if (!_tooltipData.disabled && _tooltipData.alwaysShowTooltip == false) {\n                      _rightTooltipOpacity = 1;\n                      _rightTooltipAnimationController?.forward();\n                    }\n                    _rightHandlerMove(\n                      event,\n                      tappedPositionWithPadding: tappedPositionWithPadding,\n                    );\n                  }\n                } else {\n                  _trackBarSlideCallDragStated(1);\n                  if (!_tooltipData.disabled && _tooltipData.alwaysShowTooltip == false) {\n                    _rightTooltipOpacity = 1;\n                    _rightTooltipAnimationController?.forward();\n                  }\n                  _rightHandlerMove(\n                    event,\n                    tappedPositionWithPadding: tappedPositionWithPadding,\n                  );\n                }\n              }\n            },\n            onPointerDown: (event) {\n              _leftTapAndSlide = false;\n              _rightTapAndSlide = false;\n              _slidingByActiveTrackBar = false;\n              __dragging = false;\n              _trackBarSlideOnDragStartedCalled = false;\n\n              double leftHandlerLastPosition;\n              double rightHandlerLastPosition;\n\n              if (widget.axis == Axis.horizontal) {\n                final double lX = _leftHandlerXPosition! + _handlersPadding + _touchSize + _containerLeft;\n                final double rX = _rightHandlerXPosition! + _handlersPadding + _touchSize + _containerLeft;\n\n                _distanceFromRightHandler = rX - event.position.dx;\n                _distanceFromLeftHandler = lX - event.position.dx;\n\n                leftHandlerLastPosition = lX;\n                rightHandlerLastPosition = rX;\n              } else {\n                final double lY = _leftHandlerYPosition! + _handlersPadding + _touchSize + _containerTop;\n                final double rY = _rightHandlerYPosition! + _handlersPadding + _touchSize + _containerTop;\n\n                _distanceFromLeftHandler = lY - event.position.dy;\n                _distanceFromRightHandler = rY - event.position.dy;\n\n                leftHandlerLastPosition = lY;\n                rightHandlerLastPosition = rY;\n              }\n\n              if (widget.rangeSlider &&\n                  widget.trackBar.activeTrackBarDraggable &&\n                  _ignoreSteps.isEmpty &&\n                  _distanceFromRightHandler! > 0 &&\n                  _distanceFromLeftHandler! < 0) {\n                _slidingByActiveTrackBar = true;\n              } else {\n                final double thumbPosition = (widget.axis == Axis.vertical) ? event.position.dy : event.position.dx;\n                if (_distanceFromLeftHandler!.abs() < _distanceFromRightHandler!.abs() ||\n                    (_distanceFromLeftHandler == _distanceFromRightHandler &&\n                        thumbPosition < leftHandlerLastPosition)) {\n                  _leftTapAndSlide = true;\n                }\n                if (_distanceFromRightHandler!.abs() < _distanceFromLeftHandler!.abs() ||\n                    (_distanceFromLeftHandler == _distanceFromRightHandler &&\n                        thumbPosition < rightHandlerLastPosition)) {\n                  _rightTapAndSlide = true;\n                }\n              }\n\n              if (_distanceFromRightHandler! > 0 && _distanceFromLeftHandler! < 0) {\n                if (widget.axis == Axis.horizontal) {\n                  xDragTmp = 0;\n                  __lockedHandlersDragOffset = (_leftHandlerXPosition! + _containerLeft - event.position.dx).abs();\n                } else {\n                  yDragTmp = 0;\n                  __lockedHandlersDragOffset = (_leftHandlerYPosition! + _containerTop - event.position.dy).abs();\n                }\n              }\n\n              if (_ignoreSteps.isEmpty) {\n                if ((widget.lockHandlers || __lockedHandlersDragOffset > 0) &&\n                    !_tooltipData.disabled &&\n                    _tooltipData.alwaysShowTooltip == false) {\n                  _leftTooltipOpacity = 1;\n                  _leftTooltipAnimationController?.forward();\n                  _rightTooltipOpacity = 1;\n                  _rightTooltipAnimationController?.forward();\n                }\n\n                if (widget.lockHandlers || __lockedHandlersDragOffset > 0) {\n                  _leftHandlerScaleAnimationController.forward();\n                  _rightHandlerScaleAnimationController.forward();\n                }\n              }\n\n              setState(() {});\n            },\n            child: Draggable(\n              axis: widget.axis,\n              feedback: Container(),\n              child: Container(\n                color: Colors.transparent,\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n\n    for (final Function func in _positionedItems) {\n      items.add(Function.apply(func, []) as Positioned);\n    }\n\n    return items;\n  }\n\n  void _trackBarSlideCallDragStated(int handlerIndex) {\n    if (!_trackBarSlideOnDragStartedCalled) {\n      _callbacks('onDragStarted', handlerIndex);\n      _trackBarSlideOnDragStartedCalled = true;\n    }\n  }\n\n  double _distance() {\n    _distanceFromLeftHandler = _distanceFromLeftHandler!.abs();\n    _distanceFromRightHandler = _distanceFromRightHandler!.abs();\n\n    if (widget.axis == Axis.horizontal) {\n      return _handlersWidth! / 2 + _touchSize - xDragTmp;\n    } else {\n      return _handlersHeight! / 2 + _touchSize - yDragTmp;\n    }\n  }\n\n  Positioned _tooltip({\n    String? side,\n    required String value,\n    double? opacity,\n    required Animation<Offset> animation,\n  }) {\n    if (_tooltipData.disabled || value == '') {\n      return Positioned(\n        child: Container(),\n      );\n    }\n\n    Widget prefix;\n    Widget suffix;\n\n    if (side == 'left') {\n      prefix = _tooltipData.leftPrefix ?? Container();\n      suffix = _tooltipData.leftSuffix ?? Container();\n      if (widget.rangeSlider == false) {\n        return Positioned(\n          child: Container(),\n        );\n      }\n    } else {\n      prefix = _tooltipData.rightPrefix ?? Container();\n      suffix = _tooltipData.rightSuffix ?? Container();\n    }\n    String numberFormat = value;\n    if (_tooltipData.format != null) {\n      numberFormat = _tooltipData.format!(numberFormat);\n    }\n\n    final List<Widget> children = [\n      prefix,\n      Text(numberFormat, style: _tooltipData.textStyle),\n      suffix,\n    ];\n\n    Widget tooltipHolderWidget = Column(\n      mainAxisSize: MainAxisSize.min,\n      children: children,\n    );\n    if (_tooltipData.direction == FlutterSliderTooltipDirection.top) {\n      tooltipHolderWidget = Row(\n        children: children,\n      );\n    }\n\n    Widget tooltipWidget = IgnorePointer(\n      child: Center(\n        child: FittedBox(\n          child: Container(\n            key: (side == 'left') ? leftTooltipKey : rightTooltipKey,\n            child: Container(\n              padding: const EdgeInsets.all(8),\n              decoration: _tooltipData.boxStyle!.decoration,\n              foregroundDecoration: _tooltipData.boxStyle!.foregroundDecoration,\n              transform: _tooltipData.boxStyle!.transform,\n              child: tooltipHolderWidget,\n            ),\n          ),\n        ),\n      ),\n    );\n\n    double? top;\n    double? right;\n    double? bottom;\n    double? left;\n    switch (_tooltipData.direction) {\n      case FlutterSliderTooltipDirection.top:\n        top = 0;\n      case FlutterSliderTooltipDirection.left:\n        left = 0;\n      case FlutterSliderTooltipDirection.right:\n        right = 0;\n    }\n\n    if (_tooltipData.positionOffset != null) {\n      if (_tooltipData.positionOffset!.top != null) {\n        top = (top ?? 0) + _tooltipData.positionOffset!.top!;\n      }\n      if (_tooltipData.positionOffset!.left != null) {\n        left = (left ?? 0) + _tooltipData.positionOffset!.left!;\n      }\n      if (_tooltipData.positionOffset!.right != null) {\n        right = (right ?? 0) + _tooltipData.positionOffset!.right!;\n      }\n      if (_tooltipData.positionOffset!.bottom != null) {\n        bottom = (bottom ?? 0) + _tooltipData.positionOffset!.bottom!;\n      }\n    }\n\n    tooltipWidget = SlideTransition(\n      position: animation,\n      child: tooltipWidget,\n    );\n\n    return Positioned(\n      left: left,\n      right: right,\n      top: top,\n      bottom: bottom,\n      child: Opacity(\n        opacity: opacity!,\n        child: Center(child: tooltipWidget),\n      ),\n    );\n  }\n\n  Positioned _inactiveTrack() {\n    final BoxDecoration boxDecoration = widget.trackBar.inactiveTrackBar ?? const BoxDecoration();\n\n    Color trackBarColor = boxDecoration.color ?? const Color(0x110000ff);\n    if (widget.disabled) {\n      trackBarColor = widget.trackBar.inactiveDisabledTrackBarColor;\n    }\n\n    double? top;\n    double? bottom;\n    double? left;\n    double? right;\n    double? width;\n    double? height;\n\n    top = left = right = width = height = 0;\n    right = bottom = null;\n\n    if (widget.axis == Axis.horizontal) {\n      bottom = 0;\n      left = _handlersPadding;\n      width = _containerWidthWithoutPadding;\n      height = widget.trackBar.inactiveTrackBarHeight;\n      top = 0;\n    } else {\n      right = 0;\n      height = _containerHeightWithoutPadding;\n      top = _handlersPadding;\n      width = widget.trackBar.inactiveTrackBarHeight;\n    }\n\n    return Positioned(\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      child: Center(\n        child: Container(\n          height: height,\n          width: width,\n          decoration: BoxDecoration(\n            color: trackBarColor,\n            backgroundBlendMode: boxDecoration.backgroundBlendMode,\n            shape: boxDecoration.shape,\n            gradient: boxDecoration.gradient,\n            border: boxDecoration.border,\n            borderRadius: boxDecoration.borderRadius,\n            boxShadow: boxDecoration.boxShadow,\n            image: boxDecoration.image,\n          ),\n        ),\n      ),\n    );\n  }\n\n  Positioned _activeTrack() {\n    final BoxDecoration boxDecoration = widget.trackBar.activeTrackBar ?? const BoxDecoration();\n\n    Color trackBarColor = boxDecoration.color ?? const Color(0xff2196F3);\n    if (widget.disabled) {\n      trackBarColor = widget.trackBar.activeDisabledTrackBarColor;\n    }\n\n    double? top;\n    double? bottom;\n    double? left;\n    double? right;\n    double? width;\n    double? height;\n\n    top = left = width = height = 0;\n    right = bottom = null;\n\n    if (widget.axis == Axis.horizontal) {\n      bottom = 0;\n      height = widget.trackBar.activeTrackBarHeight;\n      if (!widget.centeredOrigin || widget.rangeSlider) {\n        width = _rightHandlerXPosition! - _leftHandlerXPosition!;\n        left = _leftHandlerXPosition! + _handlersWidth! / 2 + _touchSize;\n\n        if (widget.rtl == true && widget.rangeSlider == false) {\n          left = null;\n          right = _handlersWidth! / 2;\n          width = _containerWidthWithoutPadding! - _rightHandlerXPosition! - _touchSize;\n        }\n      } else {\n        if (_containerWidthWithoutPadding! / 2 - _touchSize > _rightHandlerXPosition!) {\n          width = _containerWidthWithoutPadding! / 2 - _rightHandlerXPosition! - _touchSize;\n          left = _rightHandlerXPosition! + _handlersWidth! / 2 + _touchSize;\n        } else {\n          left = _containerWidthWithoutPadding! / 2 + _handlersPadding;\n          width = _rightHandlerXPosition! + _touchSize - _containerWidthWithoutPadding! / 2;\n        }\n      }\n    } else {\n      right = 0;\n      width = widget.trackBar.activeTrackBarHeight;\n\n      if (!widget.centeredOrigin || widget.rangeSlider) {\n        height = _rightHandlerYPosition! - _leftHandlerYPosition!;\n        top = _leftHandlerYPosition! + _handlersHeight! / 2 + _touchSize;\n        if (widget.rtl == true && widget.rangeSlider == false) {\n          top = null;\n          bottom = _handlersHeight! / 2;\n          height = _containerHeightWithoutPadding! - _rightHandlerYPosition! - _touchSize;\n        }\n      } else {\n        if (_containerHeightWithoutPadding! / 2 - _touchSize > _rightHandlerYPosition!) {\n          height = _containerHeightWithoutPadding! / 2 - _rightHandlerYPosition! - _touchSize;\n          top = _rightHandlerYPosition! + _handlersHeight! / 2 + _touchSize;\n        } else {\n          top = _containerHeightWithoutPadding! / 2 + _handlersPadding;\n          height = _rightHandlerYPosition! + _touchSize - _containerHeightWithoutPadding! / 2;\n        }\n      }\n    }\n\n    width = (width < 0) ? 0 : width;\n    height = (height < 0) ? 0 : height;\n\n    return Positioned(\n      left: left,\n      right: right,\n      top: top,\n      bottom: bottom,\n      child: Center(\n        child: Container(\n          height: height,\n          width: width,\n          decoration: BoxDecoration(\n            color: trackBarColor,\n            backgroundBlendMode: boxDecoration.backgroundBlendMode,\n            shape: boxDecoration.shape,\n            gradient: boxDecoration.gradient,\n            border: boxDecoration.border,\n            borderRadius: boxDecoration.borderRadius,\n            boxShadow: boxDecoration.boxShadow,\n            image: boxDecoration.image,\n          ),\n        ),\n      ),\n    );\n  }\n\n  Positioned _centralWidget() {\n    return Positioned(\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n      child: Center(child: widget.trackBar.centralWidget ?? Container()),\n    );\n  }\n\n  void _callbacks(String callbackName, int handlerIndex) {\n    double lowerValue = double.tryParse(_outputLowerValue.toString()) ?? 0;\n    double upperValue = double.tryParse(_outputUpperValue.toString()) ?? 0;\n    if (widget.rtl == true || widget.rangeSlider == false) {\n      lowerValue = double.tryParse(_outputUpperValue.toString()) ?? 0;\n      upperValue = double.tryParse(_outputLowerValue.toString()) ?? 0;\n    }\n\n    switch (callbackName) {\n      case 'onDragging':\n        if (widget.onDragging != null) {\n          widget.onDragging?.call(handlerIndex, lowerValue, upperValue);\n        }\n      case 'onDragCompleted':\n        if (widget.onDragCompleted != null) {\n          widget.onDragCompleted?.call(handlerIndex, lowerValue, upperValue);\n        }\n      case 'onDragStarted':\n        if (widget.onDragStarted != null) {\n          widget.onDragStarted?.call(handlerIndex, lowerValue, upperValue);\n        }\n    }\n  }\n\n  dynamic _displayRealValue(double? value) {\n    if (_fixedValues.isNotEmpty) {\n      return _fixedValues[value!.toInt()].value;\n    }\n\n    return double.parse((value! + _widgetMin!).toStringAsFixed(_decimalScale));\n  }\n\n  void _arrangeHandlersZIndex() {\n    if (_lowerValue! >= (_realMax / 2)) {\n      _positionedItems = [_rightHandlerWidget, _leftHandlerWidget];\n    } else {\n      _positionedItems = [_leftHandlerWidget, _rightHandlerWidget];\n    }\n  }\n\n  void _renderBoxInitialization() {\n    if (_containerLeft <= 0 || (QuranScreen.width - _constraintMaxWidth) <= _containerLeft) {\n      final RenderBox? containerRenderBox = containerKey.currentContext?.findRenderObject() as RenderBox?;\n      _containerLeft = containerRenderBox?.localToGlobal(Offset.zero).dx ?? 0;\n    }\n    if (_containerTop <= 0 || (QuranScreen.height - _constraintMaxHeight) <= _containerTop) {\n      final RenderBox? containerRenderBox = containerKey.currentContext!.findRenderObject() as RenderBox?;\n      _containerTop = containerRenderBox?.localToGlobal(Offset.zero).dy ?? 0;\n    }\n  }\n}\n\nclass _MakeHandler extends StatelessWidget {\n  const _MakeHandler({\n    this.id,\n    this.handlerData,\n    this.visibleTouchArea,\n    this.width,\n    this.height,\n    required this.animation,\n    this.rtl = false,\n    this.rangeSlider = false,\n    this.axis,\n    this.handlerIndex,\n    this.touchSize,\n  });\n\n  final double? width;\n  final double? height;\n  final GlobalKey? id;\n  final FlutterSliderHandler? handlerData;\n  final bool? visibleTouchArea;\n  final Animation<double> animation;\n  final Axis? axis;\n  final int? handlerIndex;\n  final bool rtl;\n  final bool rangeSlider;\n  final double? touchSize;\n\n  @override\n  Widget build(BuildContext context) {\n    final double touchOpacity = (visibleTouchArea ?? false) ? 1 : 0;\n\n    double localWidth;\n    double localHeight;\n    localHeight = height! + (touchSize! * 2);\n    localWidth = width! + (touchSize! * 2);\n\n    final FlutterSliderHandler handler = handlerData ?? FlutterSliderHandler();\n\n    if (handlerIndex == 2) {\n      handler.child ??= Icon(\n        (axis == Axis.horizontal) ? Icons.chevron_left : Icons.expand_less,\n        color: Colors.black45,\n      );\n    } else {\n      IconData hIcon = (axis == Axis.horizontal) ? Icons.chevron_right : Icons.expand_more;\n      if (rtl && !rangeSlider) {\n        hIcon = (axis == Axis.horizontal) ? Icons.chevron_left : Icons.expand_less;\n      }\n      handler.child ??= Icon(hIcon, color: Colors.black45);\n    }\n\n    handler.decoration ??= const BoxDecoration(\n      boxShadow: [\n        BoxShadow(\n          color: Colors.black26,\n          blurRadius: 2,\n          spreadRadius: 0.2,\n          offset: Offset(0, 1),\n        )\n      ],\n      color: Colors.white,\n      shape: BoxShape.circle,\n    );\n\n    return Center(\n      child: SizedBox(\n        key: id,\n        width: localWidth,\n        height: localHeight,\n        child: Stack(\n          children: <Widget>[\n            Opacity(\n              opacity: touchOpacity,\n              child: ColoredBox(\n                color: Colors.black12,\n                child: Container(),\n              ),\n            ),\n            Center(\n              child: ScaleTransition(\n                scale: animation,\n                child: Opacity(\n                  opacity: handler.opacity,\n                  child: Container(\n                    alignment: Alignment.center,\n                    foregroundDecoration: handler.foregroundDecoration,\n                    decoration: handler.decoration,\n                    transform: handler.transform,\n                    width: width,\n                    height: height,\n                    child: handler.child,\n                  ),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass FlutterSliderHandler {\n  FlutterSliderHandler({\n    this.child,\n    this.decoration,\n    this.foregroundDecoration,\n    this.transform,\n    this.disabled = false,\n    this.opacity = 1,\n  });\n\n  BoxDecoration? decoration;\n  BoxDecoration? foregroundDecoration;\n  Matrix4? transform;\n  Widget? child;\n  bool disabled;\n  double opacity;\n\n  @override\n  String toString() {\n    return '$child-$disabled-$decoration-$foregroundDecoration-$transform-$opacity';\n  }\n}\n\nclass FlutterSliderTooltip {\n  FlutterSliderTooltip({\n    this.format,\n    this.textStyle,\n    this.boxStyle,\n    this.leftPrefix,\n    this.leftSuffix,\n    this.rightPrefix,\n    this.rightSuffix,\n    this.alwaysShowTooltip = false,\n    this.disableAnimation = false,\n    this.disabled = false,\n    this.direction = FlutterSliderTooltipDirection.top,\n    this.positionOffset,\n  });\n\n  String Function(String value)? format;\n  TextStyle? textStyle;\n  FlutterSliderTooltipBox? boxStyle;\n  Widget? leftPrefix;\n  Widget? leftSuffix;\n  Widget? rightPrefix;\n  Widget? rightSuffix;\n  bool alwaysShowTooltip;\n  bool disabled;\n  bool disableAnimation;\n  FlutterSliderTooltipDirection direction;\n  FlutterSliderTooltipPositionOffset? positionOffset;\n\n  @override\n  String toString() {\n    return '$textStyle-$boxStyle-$leftPrefix-$leftSuffix-$rightPrefix-$rightSuffix-$alwaysShowTooltip-$disabled-$disableAnimation-$direction-$positionOffset';\n  }\n}\n\nclass FlutterSliderTooltipPositionOffset {\n  FlutterSliderTooltipPositionOffset({\n    this.top,\n    this.left,\n    this.right,\n    this.bottom,\n  });\n\n  double? top;\n  double? left;\n  double? right;\n  double? bottom;\n\n  @override\n  String toString() {\n    return '$top-$left-$bottom-$right';\n  }\n}\n\nclass FlutterSliderTooltipBox {\n  const FlutterSliderTooltipBox({\n    this.decoration,\n    this.foregroundDecoration,\n    this.transform,\n  });\n\n  final BoxDecoration? decoration;\n  final BoxDecoration? foregroundDecoration;\n  final Matrix4? transform;\n\n  @override\n  String toString() {\n    return '$decoration-$foregroundDecoration-$transform';\n  }\n}\n\nclass FlutterSliderTrackBar {\n  const FlutterSliderTrackBar({\n    this.inactiveTrackBar,\n    this.activeTrackBar,\n    this.activeDisabledTrackBarColor = const Color(0xffe3f5f1),\n    this.inactiveDisabledTrackBarColor = const Color(0xffe3f5f1),\n    this.activeTrackBarHeight = 3.5,\n    this.inactiveTrackBarHeight = 3,\n    this.centralWidget,\n    this.activeTrackBarDraggable = true,\n  }) : assert(activeTrackBarHeight > 0 && inactiveTrackBarHeight > 0);\n  final BoxDecoration? inactiveTrackBar;\n  final BoxDecoration? activeTrackBar;\n  final Color activeDisabledTrackBarColor;\n  final Color inactiveDisabledTrackBarColor;\n  final double activeTrackBarHeight;\n  final double inactiveTrackBarHeight;\n  final Widget? centralWidget;\n  final bool activeTrackBarDraggable;\n\n  @override\n  String toString() {\n    return '$inactiveTrackBar-$activeTrackBar-$activeDisabledTrackBarColor-$inactiveDisabledTrackBarColor-$activeTrackBarHeight-$inactiveTrackBarHeight-$centralWidget';\n  }\n}\n\nclass FlutterSliderIgnoreSteps {\n  FlutterSliderIgnoreSteps({required this.from, required this.to}) : assert(from <= to);\n  final double from;\n  final double to;\n\n  @override\n  String toString() => '$from-$to';\n}\n\nclass FlutterSliderFixedValue {\n  FlutterSliderFixedValue({this.percent, this.value})\n      : assert(\n          percent != null && value != null && percent >= 0 && percent <= 100,\n        );\n  final int? percent;\n  final dynamic value;\n\n  @override\n  String toString() {\n    return '$percent-$value';\n  }\n}\n\nclass FlutterSliderHandlerAnimation {\n  const FlutterSliderHandlerAnimation({\n    this.curve = Curves.elasticOut,\n    this.reverseCurve,\n    this.duration = const Duration(milliseconds: 700),\n    this.scale = 1.3,\n  });\n\n  final Curve curve;\n  final Curve? reverseCurve;\n  final Duration duration;\n  final double scale;\n\n  @override\n  String toString() {\n    return '$curve-$reverseCurve-$duration-$scale';\n  }\n}\n\nclass FlutterSliderHatchMark {\n  FlutterSliderHatchMark({\n    this.disabled = false,\n    this.density = 1,\n    this.smallDensity = 4,\n    this.linesDistanceFromTrackBar,\n    this.labelsDistanceFromTrackBar,\n    this.labels,\n    this.smallLine,\n    this.bigLine,\n    this.linesAlignment = FlutterSliderHatchMarkAlignment.right,\n    this.labelBox,\n    this.displayLines,\n  })  : assert(density > 0 && density <= 2),\n        assert(smallDensity >= 0);\n  bool disabled;\n  double density;\n  double? linesDistanceFromTrackBar;\n  double? labelsDistanceFromTrackBar;\n  List<FlutterSliderHatchMarkLabel>? labels;\n  FlutterSliderSizedBox? smallLine;\n  FlutterSliderSizedBox? bigLine;\n\n  int smallDensity;\n  FlutterSliderSizedBox? labelBox;\n  FlutterSliderHatchMarkAlignment linesAlignment;\n  bool? displayLines;\n\n  @override\n  String toString() {\n    return '$disabled-$density-$linesDistanceFromTrackBar-$labelsDistanceFromTrackBar-$labels-$smallLine-$bigLine-$labelBox-$linesAlignment-$displayLines';\n  }\n}\n\nclass FlutterSliderHatchMarkLabel {\n  FlutterSliderHatchMarkLabel({\n    this.percent,\n    this.label,\n  }) : assert(\n          (label == null && percent == null) || (label != null && percent != null && percent >= 0),\n        );\n\n  final double? percent;\n  final Widget? label;\n\n  @override\n  String toString() {\n    return '$percent-$label';\n  }\n}\n\nclass FlutterSliderSizedBox {\n  const FlutterSliderSizedBox({\n    this.decoration,\n    this.foregroundDecoration,\n    this.transform,\n    required this.height,\n    required this.width,\n  }) : assert(width > 0 && height > 0);\n\n  final BoxDecoration? decoration;\n  final BoxDecoration? foregroundDecoration;\n  final Matrix4? transform;\n  final double width;\n  final double height;\n\n  @override\n  String toString() {\n    return '$width-$height-$decoration-$foregroundDecoration-$transform';\n  }\n}\n\nclass FlutterSliderStep {\n  const FlutterSliderStep({\n    this.step = 1,\n    this.isPercentRange = true,\n    this.rangeList,\n  });\n\n  final double step;\n  final bool isPercentRange;\n  final List<FlutterSliderRangeStep>? rangeList;\n\n  @override\n  String toString() {\n    return '$step-$isPercentRange-$rangeList';\n  }\n}\n\nclass FlutterSliderRangeStep {\n  FlutterSliderRangeStep({\n    required this.from,\n    required this.to,\n    required this.step,\n  });\n\n  final double from;\n  final double to;\n  final double step;\n\n  @override\n  String toString() => '$from-$to-$step';\n}\n\nenum FlutterSliderTooltipDirection { top, left, right }\n\nenum FlutterSliderHatchMarkAlignment { left, right }\n"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/presentable_widget_builder.dart", "file_name": "presentable_widget_builder.dart", "line": 19, "line_from": 19, "line_to": 60, "snippet": "  final Widget Function() builder;\n\n  @override\n  State<PresentableWidgetBuilder<T>> createState() => _PresentableWidgetBuilderState<T>();\n}\n\nclass _PresentableWidgetBuilderState<T extends DisposableInterface> extends State<PresentableWidgetBuilder<T>> {\n  T? _previousState;\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.onInit != null) {\n      widget.onInit!();\n    }\n    if (widget.presenter != null) {\n      Get.put(widget.presenter!);\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.dispose != null) {\n      widget.dispose!();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Obx(() {\n      final currentState = widget.presenter;\n      if (widget.shouldRebuild != null) {\n        if (!widget.shouldRebuild!(_previousState, currentState)) {\n          return widget.builder();\n        }\n      }\n      _previousState = currentState;\n      return widget.builder();\n    });\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "The builder of title.\n\nTypically a [Button] widget that call [toggleFunction] when pressed.", "module": "external_libs", "file_path": "core/external_libs/expansion_widget.dart", "file_name": "expansion_widget.dart", "line": 26, "line_from": 26, "line_to": 83, "snippet": "  final Widget Function(double animationValue, double easeInValue,\n      bool isExpanded, Function({bool animated}) toggleFunction) titleBuilder;\n\n  /// Function to save expansion state\n  /// Called when expansion state changed\n  final void Function(bool isExpanded)? onSaveState;\n\n  /// function to restore expansion state.\n  /// Return null if there is no state to store;\n  /// in this case, [initiallyExpanded] will be used\n  final bool? Function()? onRestoreState;\n\n  /// The length of time of animation\n  final Duration duration;\n\n  /// Called when the widget expands or collapses.\n  ///\n  /// When the widget starts expanding, this function is called with the value\n  /// true. When the tile starts collapsing, this function is called with\n  /// the value false.\n  final void Function(bool)? onExpansionChanged;\n\n  /// Called when the widget will change expanded state.\n  ///\n  /// When the widget is going to start expanding/collapsing, this function is\n  /// called with the value true/false.\n  ///\n  /// Return false to prevent expanded state to change.\n  /// Return true(default) to allow expanded state changing.\n  final bool Function(bool)? onExpansionWillChange;\n\n  /// The widget that are displayed when the expansionWidget expands.\n  final Widget content;\n\n  /// Specifies if the expansionWidget is initially expanded (true) or collapsed (false, the default).\n  final bool initiallyExpanded;\n\n  /// Specifies whether the state of the content is maintained when the expansionWidget expands and collapses.\n  ///\n  /// When true, the content are kept in the tree while the expansionWidget is collapsed.\n  /// When false (default), the content are removed from the tree when the expansionWidget is\n  /// collapsed and recreated upon expansion.\n  final bool maintainState;\n\n  /// Specifies the alignment of [content], which are arranged in a column when\n  /// the expansionWidget is expanded.\n  ///\n  /// The internals of the expanded expansionWidget make use of a [Column] widget for\n  /// [content], and [Align] widget to align the column. The `expandedAlignment`\n  /// parameter is passed directly into the [Align].\n  ///\n  /// Modifying this property controls the alignment of the column within the\n  /// expanded expansionWidget.\n  final Alignment expandedAlignment;\n\n  @override\n  ExpansionWidgetState createState() => ExpansionWidgetState();\n}"}, {"structure_type": "function", "name": "cancel", "docstring": "", "module": "external_libs", "file_path": "core/external_libs/throttle_service.dart", "file_name": "throttle_service.dart", "line": 51, "line_from": 51, "line_to": 73, "snippet": "  static void cancel(String tag) {\n    _operations[tag]?.timer.cancel();\n    _operations.remove(tag);\n  }\n\n  static void cancelAll() {\n    for (final _ThrottleOperation operation in _operations.values) {\n      operation.timer.cancel();\n    }\n    _operations.clear();\n  }\n\n  static int count() => _operations.length;\n}\n\ntypedef EasyDebounceCallback = void Function();\n\nclass _EasyDebounceOperation {\n  _EasyDebounceOperation(this.callback, this.timer);\n\n  EasyDebounceCallback callback;\n  Timer timer;\n}"}, {"structure_type": "function", "name": "initState", "docstring": "A controller for [ExpandedTile].\n\nAn ExpandedTileController would let you control programatically the expansion\nstate of an [ExpandedTile] widget.\n\nIf you are going to use in a ListView builder, assign a controller constructor 'ExpandedTileController()' not an initialized one.\n\n\nSee also:\n\n* [ExpandedTile], which is the widget this object controls.\n\n\n{@tool snippet}\n\n\n```dart\nclass _ExampleState extends State<Example> {\n\nlate ExpandedTileController _controller;\n", "module": "external_libs", "file_path": "core/external_libs/expanded_tile.dart", "file_name": "expanded_tile.dart", "line": 27, "line_from": 27, "line_to": 644, "snippet": "///   void initState() {\n///     _controller = ExpandedTileController();\n///     super.initState();\n///   }\n///\n///  ExpandedTile(\n///  controller: _controller,\n///  title:\n///  content:\n///  ...\n/// )\n///\n/// ```\n/// {@end-tool}\nclass ExpandedTileController extends ChangeNotifier {\n  bool _isExpanded;\n\n  /// Getter for the current expansion state of the [ExpandedTile] widget.\n  bool get isExpanded => _isExpanded;\n  set _setExpanded(bool ex) {\n    _isExpanded = ex;\n  }\n\n  ExpandedTileController copyWith({\n    bool? isExpanded,\n  }) {\n    return ExpandedTileController(\n      isExpanded: isExpanded ?? _isExpanded,\n    );\n  }\n\n  ExpandedTileController({\n    int? key,\n    bool isExpanded = false,\n  }) : _isExpanded = isExpanded;\n\n  /// VoidCallback that expands the [ExpandedTile] widget if it is collapsed.\n  void expand() {\n    _setExpanded = true;\n    notifyListeners();\n  }\n\n  /// VoidCallback that collapses the [ExpandedTile] widget if it is expanded.\n  void collapse() {\n    _setExpanded = false;\n    notifyListeners();\n  }\n\n  /// VoidCallback that toggles the expansion state of the [ExpandedTile] widget.\n  void toggle() {\n    isExpanded ? collapse() : expand();\n  }\n}\n\n/// Theming data for the [ExpandedTile] widget, Mostly Colors & Spacing.\n///\n/// {@tool snippet}\n///\n/// ```dart\n/// ExpandedTile(\n///  ...\n///  theme: ExpandedTileThemeData(\n///  headerColor: Colors.green,\n/// headerRadius: 24.0,\n/// headerPadding: EdgeInsets.all(24.0),\n/// headerSplashColor: Colors.red,\n/// ),\n///\n///\n///  ...\n/// )\n///\n/// ```\n/// {@end-tool}\nclass ExpandedTileThemeData {\n  ////? Header\n  final Color? headerColor;\n  final Color? headerSplashColor;\n  final EdgeInsetsGeometry? headerPadding;\n  final double? headerRadius;\n  // leading\n  final EdgeInsetsGeometry? leadingPadding;\n  // title\n  final EdgeInsetsGeometry? titlePadding;\n  // trailing\n  final EdgeInsetsGeometry? trailingPadding;\n  ////? Content\n  final Color? contentBackgroundColor;\n  final EdgeInsetsGeometry? contentPadding;\n  final double? contentRadius;\n  const ExpandedTileThemeData({\n    key,\n    this.headerColor = const Color(0xfffafafa),\n    this.headerSplashColor = const Color(0xffeeeeee),\n    this.headerPadding = const EdgeInsets.all(16.0),\n    this.headerRadius = 8.0,\n    this.leadingPadding = const EdgeInsets.symmetric(horizontal: 4.0),\n    this.titlePadding = const EdgeInsets.symmetric(horizontal: 10.0),\n    this.trailingPadding = const EdgeInsets.symmetric(horizontal: 6.0),\n    this.contentBackgroundColor = const Color(0xffeeeeee),\n    this.contentPadding = const EdgeInsets.all(16.0),\n    this.contentRadius = 8.0,\n  });\n}\n\n/// An Expansion tile similar to the list tile supports leading widget,\n/// Trailing widget and programatic control with content expansion animation.\n///\n///\n/// {@tool snippet}\n///\n/// ```dart\n/// class _ExampleState extends State<Example> {\n///\n///   late ExpandedTileController _controller;\n///\n///   void initState() {\n///     _controller = ExpandedTileController();\n///     super.initState();\n///   }\n///\n///  ExpandedTile(\n///  controller: _controller,\n///  onTap: (){\n/// },\n/// onLongTap: (){\n/// },\n/// theme: ExpandedTileThemeData(),\n///  title:\n///  content:\n///  ...\n/// )\n///\n/// ```\n/// {@end-tool}\nclass ExpandedTile extends StatefulWidget {\n////? Header\n// Leading\n  final Widget? leading; // default is none\n// Title\n  final Widget title; // required\n// Trailing\n  final Widget? trailing; // default is chevron icon\n  final double? trailingRotation; // default is 90\n////? Content\n  final Widget content; // required\n  final double? contentseparator; // default is 6.0\n////? Misc\n  final bool enabled;\n  final ExpandedTileThemeData? theme; // default themedata\n  final ExpandedTileController controller; // required\n  final bool? disableAnimation;\n  final Curve? expansionAnimationCurve; // default is ease\n  final Duration? expansionDuration; // default is 200ms\n  final VoidCallback? onTap;\n  final VoidCallback? onLongTap;\n  const ExpandedTile({\n    super.key,\n    ////? Header\n    // Leading\n    // Title\n    // Trailing\n    ////? Content\n    ////? Misc\n    // Misc\n    this.leading,\n    required this.title,\n    this.trailing = const Icon(Icons.chevron_right),\n    this.trailingRotation = 90,\n    required this.content,\n    this.contentseparator = 6.0,\n    this.enabled = true,\n    this.theme = const ExpandedTileThemeData(),\n    required this.controller,\n    this.disableAnimation = false,\n    this.expansionAnimationCurve = Curves.ease,\n    this.expansionDuration = const Duration(milliseconds: 200),\n    this.onTap,\n    this.onLongTap,\n  });\n\n  /// Returns a new [ExpandedTile] widget with the same arguments unless stated otherwise.\n  ///\n  ///\n  ExpandedTile copyWith({\n    ////? Header\n// Leading\n    final Widget? leading, // default is none\n// Title\n    final Widget? title, // required\n// Trailing\n    final Widget? trailing, // default is chevron icon\n    final double? trailingRotation, // default is 90\n////? Content\n    final Widget? content, // required\n    final double? contentseparator, // default is 6.0\n////? Misc\n    final bool? enabled,\n    final ExpandedTileThemeData? theme, // default themedata\n    final ExpandedTileController? controller, // required\n    final bool? disableAnimation,\n    final Curve? expansionAnimationCurve, // default is ease\n    final Duration? expansionDuration, // default is 200ms\n    final VoidCallback? onTap,\n    final VoidCallback? onLongTap,\n  }) {\n    return ExpandedTile(\n      key: key,\n////? Header\n// Leading\n      leading: leading ?? this.leading,\n// Title\n      title: title ?? this.title,\n// Trailing\n      trailing: trailing ?? this.trailing,\n      trailingRotation: trailingRotation ?? this.trailingRotation,\n////? Content\n      content: content ?? this.content,\n      contentseparator: contentseparator ?? this.contentseparator,\n////? Misc\n      enabled: enabled ?? this.enabled,\n      controller: controller ?? this.controller,\n      theme: theme ?? this.theme,\n      disableAnimation: disableAnimation ?? this.disableAnimation,\n      expansionDuration: expansionDuration ?? this.expansionDuration,\n      expansionAnimationCurve:\n          expansionAnimationCurve ?? this.expansionAnimationCurve,\n      onTap: onTap ?? this.onTap,\n      onLongTap: onLongTap ?? this.onLongTap,\n      // Misc\n    );\n  }\n\n  @override\n  ExpandedTileState createState() => ExpandedTileState();\n}\n\nclass ExpandedTileState extends State<ExpandedTile>\n    with SingleTickerProviderStateMixin {\n  late ExpandedTileController tileController;\n  late bool _isExpanded;\n  @override\n  void initState() {\n    tileController = widget.controller;\n    _isExpanded = tileController.isExpanded;\n    tileController.addListener(() {\n      if (mounted) {\n        setState(() {\n          _isExpanded = tileController.isExpanded;\n        });\n      }\n    });\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    // tileController.dispose();\n    super.dispose();\n  }\n\n  double angleToRad(double angle) {\n    return angle * 0.0174533;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        //* Header\n        Material(\n          color: !_isExpanded\n              ? Theme.of(context).cardColor\n              : widget.theme!.headerColor,\n          borderRadius: BorderRadius.vertical(\n            top: Radius.circular(widget.theme!.headerRadius!),\n            bottom: _isExpanded\n                ? const Radius.circular(0)\n                : Radius.circular(widget.theme!.headerRadius!),\n          ),\n          child: InkWell(\n            borderRadius: BorderRadius.vertical(\n                top: Radius.circular(widget.theme!.headerRadius!)),\n            splashColor: widget.theme!.headerSplashColor,\n            onTap: !widget.enabled\n                ? () {}\n                : () {\n                    tileController.toggle();\n                    if (widget.onTap != null) {\n                      return widget.onTap!();\n                    }\n                  },\n            onLongPress: !widget.enabled\n                ? () {}\n                : () {\n                    if (widget.onLongTap != null) {\n                      return widget.onLongTap!();\n                    }\n                  },\n            child: Container(\n              decoration: BoxDecoration(\n                borderRadius: BorderRadius.vertical(\n                  top: Radius.circular(widget.theme!.headerRadius!),\n                ),\n              ),\n              padding: widget.theme!.headerPadding,\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                children: <Widget>[\n                  widget.leading != null\n                      ? Padding(\n                          padding: widget.theme!.leadingPadding!,\n                          child: widget.leading,\n                        )\n                      : Container(),\n                  Expanded(\n                    child: Container(\n                      padding: widget.theme!.titlePadding,\n                      child: widget.title,\n                    ),\n                  ),\n                  Transform.rotate(\n                    angle: widget.trailingRotation != null\n                        ? _isExpanded\n                            ? angleToRad(widget.trailingRotation!)\n                            : 0\n                        : 0,\n                    child: Padding(\n                      padding: widget.theme!.trailingPadding!,\n                      child: widget.trailing,\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n        SizedBox(\n          height: widget.contentseparator,\n        ),\n        //* Content\n        widget.disableAnimation!\n            ? Container(\n                child: !_isExpanded\n                    ? null\n                    : Container(\n                        decoration: BoxDecoration(\n                          color: widget.theme!.contentBackgroundColor,\n                          borderRadius: BorderRadius.vertical(\n                            bottom:\n                                Radius.circular(widget.theme!.contentRadius!),\n                          ),\n                        ),\n                        padding: widget.theme!.contentPadding,\n                        width: double.infinity,\n                        child: widget.content,\n                      ),\n              )\n            : AnimatedSize(\n                duration: widget.expansionDuration!,\n                curve: widget.expansionAnimationCurve!,\n                child: Container(\n                  child: !_isExpanded\n                      ? null\n                      : Container(\n                          decoration: BoxDecoration(\n                            color: widget.theme!.contentBackgroundColor,\n                            borderRadius: BorderRadius.vertical(\n                              bottom:\n                                  Radius.circular(widget.theme!.contentRadius!),\n                            ),\n                          ),\n                          padding: widget.theme!.contentPadding,\n                          width: double.infinity,\n                          child: widget.content,\n                        ),\n                ),\n              ),\n      ],\n    );\n  }\n}\n\nenum TileListConstructor {\n  builder,\n  separated,\n}\n\ntypedef ExpandedTileBuilder = ExpandedTile Function(\n    BuildContext context, int index, ExpandedTileController controller);\n\n/// An extension of the listview returning a list of [ExpandedTile] widgets which are\n/// Expansion tile similar to the list tile supports leading widget,\n/// Trailing widget and programatic control with content expansion animation.\n///\n///\n/// This ListView also supports separate controllers for each tile with separate programatic controls.\n///\n///\n/// Available constructors right now: [ExpandedListTile.builder()] , [ExpandedListTile.separated()]\n///\n///\n/// P.S : Supplied Controllers are overlooked in the [ExpandedTileList] builder widget, supply a new or initialized controller, it doesn't matter!\n///\n/// {@tool snippet}\n///\n/// ```dart\n/// ExpandedTileList.builder(\n///  itemCount: 7,\n///  maxOpened: 2,\n///   itemBuilder: (context, index, controller) {\n///     return ExpandedTile(\n///       controller:controller,\n///       onTap: (){\n///       },\n///       onLongTap: (){\n///       },\n///       theme: ExpandedTileThemeData(),\n///       title:\n///       content:\n///       ...\n///   }\n/// )\n///\n/// ```\n/// {@end-tool}\nclass ExpandedTileList extends StatefulWidget {\n  final bool reverse;\n  final bool shrinkWrap;\n  final ScrollPhysics? physics;\n  final EdgeInsetsGeometry? padding;\n  final ExpandedTileBuilder itemBuilder;\n  final IndexedWidgetBuilder? separatorBuilder;\n  final int itemCount;\n  final String? restorationId;\n  final int maxOpened;\n  final ScrollController? scrollController;\n  final TileListConstructor _constructor;\n\n  const ExpandedTileList.builder({\n    super.key,\n    required this.itemCount,\n    required this.itemBuilder,\n    this.padding,\n    this.physics,\n    this.restorationId,\n    this.reverse = false,\n    this.shrinkWrap = true,\n    this.maxOpened = 1,\n    this.scrollController,\n  })  : assert(itemCount != 0),\n        assert(maxOpened != 0),\n        _constructor = TileListConstructor.builder,\n        separatorBuilder = null;\n\n  const ExpandedTileList.separated({\n    super.key,\n    required this.itemCount,\n    required this.itemBuilder,\n    required this.separatorBuilder,\n    this.padding,\n    this.physics,\n    this.restorationId,\n    this.reverse = false,\n    this.shrinkWrap = true,\n    this.maxOpened = 1,\n    this.scrollController,\n  })  : assert(itemCount != 0),\n        assert(maxOpened != 0),\n        _constructor = TileListConstructor.separated;\n\n  @override\n  ExpandedTileListState createState() => ExpandedTileListState();\n}\n\nclass ExpandedTileListState extends State<ExpandedTileList> {\n  late List<ExpandedTileController> tileControllers;\n  late List<ExpandedTileController> openedTilesControllers;\n  late ScrollController scrollController;\n  @override\n  void initState() {\n    super.initState();\n    scrollController = widget.scrollController ?? ScrollController();\n    tileControllers = List.generate(\n      widget.itemCount,\n      (index) => ExpandedTileController(key: index),\n    );\n    openedTilesControllers = [];\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return widget._constructor == TileListConstructor.builder\n        ? ListView.builder(\n            shrinkWrap: widget.shrinkWrap,\n            controller: scrollController,\n            itemCount: widget.itemCount,\n            reverse: widget.reverse,\n            physics: widget.physics,\n            padding: widget.padding,\n            itemBuilder: (context, index) {\n              return widget\n                  .itemBuilder(\n                    context,\n                    index,\n                    tileControllers[index],\n                  )\n                  .copyWith(\n                      controller: tileControllers[index],\n                      onTap: !widget\n                              .itemBuilder(\n                                context,\n                                index,\n                                tileControllers[index],\n                              )\n                              .enabled\n                          ? () {}\n                          : () {\n                              int openedTiles0 = tileControllers\n                                  .where((c) => c.isExpanded == true)\n                                  .toList()\n                                  .length;\n                              if (openedTiles0 > widget.maxOpened) {\n                                tileControllers\n                                    .where((c) =>\n                                        c.isExpanded == true &&\n                                        c != tileControllers[index])\n                                    .first\n                                    .collapse();\n                              }\n                              if (widget\n                                      .itemBuilder(\n                                        context,\n                                        index,\n                                        tileControllers[index],\n                                      )\n                                      .onTap !=\n                                  null) {\n                                widget\n                                    .itemBuilder(\n                                      context,\n                                      index,\n                                      tileControllers[index],\n                                    )\n                                    .onTap!();\n                              }\n                            });\n            },\n          )\n        : ListView.separated(\n            shrinkWrap: widget.shrinkWrap,\n            controller: scrollController,\n            itemCount: widget.itemCount,\n            reverse: widget.reverse,\n            physics: widget.physics,\n            padding: widget.padding,\n            separatorBuilder: (context, index) {\n              return widget.separatorBuilder!(\n                context,\n                index,\n              );\n            },\n            itemBuilder: (context, index) {\n              return widget\n                  .itemBuilder(\n                    context,\n                    index,\n                    tileControllers[index],\n                  )\n                  .copyWith(\n                      controller: tileControllers[index],\n                      onTap: !widget\n                              .itemBuilder(\n                                context,\n                                index,\n                                tileControllers[index],\n                              )\n                              .enabled\n                          ? () {}\n                          : () {\n                              int openedTiles = openedTilesControllers.length;\n                              if (tileControllers[index].isExpanded) {\n                                if (openedTiles == widget.maxOpened) {\n                                  openedTilesControllers.last.collapse();\n                                  openedTilesControllers\n                                      .remove(openedTilesControllers.last);\n                                }\n                                openedTilesControllers\n                                    .add(tileControllers[index]);\n                              } else {\n                                openedTilesControllers\n                                    .remove(tileControllers[index]);\n                              }\n                              if (widget\n                                      .itemBuilder(\n                                        context,\n                                        index,\n                                        tileControllers[index],\n                                      )\n                                      .onTap !=\n                                  null) {\n                                widget\n                                    .itemBuilder(\n                                      context,\n                                      index,\n                                      tileControllers[index],\n                                    )\n                                    .onTap!();\n                              }\n                            });\n            },\n          );\n  }\n}\n"}, {"structure_type": "function", "name": "onReady;", "docstring": "", "module": "carousel_slider", "file_path": "core/external_libs/carousel_slider/carousel_controller.dart", "file_name": "carousel_controller.dart", "line": 13, "line_from": 13, "line_to": 26, "snippet": "  Future<void> get onReady;\n\n  Future<void> nextPage({Duration? duration, Curve? curve});\n\n  Future<void> previousPage({Duration? duration, Curve? curve});\n\n  void jumpToPage(int page);\n\n  Future<void> animateToPage(int page, {Duration? duration, Curve? curve});\n\n  void startAutoPlay();\n\n  void stopAutoPlay();\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "carousel_slider", "file_path": "core/external_libs/carousel_slider/carousel_slider.dart", "file_name": "carousel_slider.dart", "line": 12, "line_from": 12, "line_to": 409, "snippet": "typedef ExtendedIndexedWidgetBuilder = Widget Function(\n  BuildContext context,\n  int index,\n  int realIndex,\n);\n\nclass CarouselSlider extends StatefulWidget {\n  CarouselSlider({\n    required this.items,\n    required this.options,\n    this.disableGesture,\n    CarouselControllerHelper? carouselController,\n    super.key,\n  })  : itemBuilder = null,\n        itemCount = items != null ? items.length : 0,\n        _carouselController = carouselController != null\n            ? carouselController as CarouselControllerImpl\n            : CarouselControllerHelper() as CarouselControllerImpl;\n\n  CarouselSlider.builder({\n    required this.itemCount,\n    required this.itemBuilder,\n    required this.options,\n    this.disableGesture,\n    CarouselControllerHelper? carouselController,\n    super.key,\n  })  : items = null,\n        _carouselController = carouselController != null\n            ? carouselController as CarouselControllerImpl\n            : CarouselControllerHelper() as CarouselControllerImpl;\n\n  final CarouselOptions options;\n\n  final bool? disableGesture;\n\n  final List<Widget>? items;\n\n  final ExtendedIndexedWidgetBuilder? itemBuilder;\n\n  final CarouselControllerImpl _carouselController;\n\n  final int? itemCount;\n\n  @override\n  // ignore: no_logic_in_create_state\n  CarouselSliderState createState() => CarouselSliderState(_carouselController);\n}\n\nclass CarouselSliderState extends State<CarouselSlider>\n    with TickerProviderStateMixin {\n  CarouselSliderState(this.carouselController);\n\n  final CarouselControllerImpl carouselController;\n  Timer? timer;\n\n  CarouselOptions get options => widget.options;\n\n  CarouselState? carouselState;\n\n  PageController? pageController;\n\n  CarouselPageChangedReason _mode = CarouselPageChangedReason.controller;\n\n  set mode(CarouselPageChangedReason mode) => _mode = mode;\n\n  @override\n  void didUpdateWidget(CarouselSlider oldWidget) {\n    carouselState!.options = options;\n    carouselState!.itemCount = widget.itemCount;\n\n    // pageController needs to be re-initialized to respond to state changes\n    pageController = PageController(\n      viewportFraction: options.viewportFraction,\n      initialPage: carouselState!.realPage,\n    );\n    carouselState!.pageController = pageController;\n\n    // handle autoplay when state changes\n    handleAutoPlay();\n\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    carouselState =\n        CarouselState(options, clearTimer, resumeTimer, (m) => mode = m);\n\n    carouselState!.itemCount = widget.itemCount;\n    carouselController.state = carouselState;\n    carouselState!.initialPage = widget.options.initialPage;\n    carouselState!.realPage = options.enableInfiniteScroll\n        ? carouselState!.realPage + carouselState!.initialPage\n        : carouselState!.initialPage;\n    handleAutoPlay();\n\n    pageController = PageController(\n      viewportFraction: options.viewportFraction,\n      initialPage: carouselState!.realPage,\n    );\n\n    carouselState!.pageController = pageController;\n  }\n\n  Timer? getTimer() {\n    return catchAndReturn(() {\n      if (!widget.options.autoPlay) throw Exception(\"Autoplay is not enabled\");\n\n      return Timer.periodic(widget.options.autoPlayInterval, (_) {\n        if (!mounted) {\n          clearTimer();\n          return;\n        }\n\n        final ModalRoute<Object?>? route = ModalRoute.of(context);\n        if (route?.isCurrent == false) return;\n\n        final CarouselPageChangedReason previousReason = _mode;\n        mode = CarouselPageChangedReason.timed;\n\n        final int currentPage =\n            carouselState?.pageController?.page?.round() ?? 0;\n        int nextPage = currentPage + 1;\n        final int itemCount = widget.itemCount ?? widget.items?.length ?? 1;\n\n        if (nextPage >= itemCount &&\n            widget.options.enableInfiniteScroll == false) {\n          if (widget.options.pauseAutoPlayInFiniteScroll) {\n            clearTimer();\n            return;\n          }\n          nextPage = 0;\n        }\n\n        carouselState?.pageController\n            ?.animateToPage(\n              nextPage,\n              duration: widget.options.autoPlayAnimationDuration,\n              curve: widget.options.autoPlayCurve,\n            )\n            .then((_) => mode = previousReason);\n      });\n    });\n  }\n\n  void clearTimer() {\n    if (timer != null) {\n      timer?.cancel();\n      timer = null;\n    }\n  }\n\n  void resumeTimer() {\n    timer ??= getTimer();\n  }\n\n  void handleAutoPlay() {\n    final bool autoPlayEnabled = widget.options.autoPlay;\n\n    if (autoPlayEnabled && timer != null) return;\n\n    clearTimer();\n    if (autoPlayEnabled) {\n      resumeTimer();\n    }\n  }\n\n  Widget getGestureWrapper(Widget child) {\n    Widget wrapper;\n    if (widget.options.height != null) {\n      wrapper = SizedBox(height: widget.options.height, child: child);\n    } else {\n      wrapper =\n          AspectRatio(aspectRatio: widget.options.aspectRatio, child: child);\n    }\n\n    if (true == widget.disableGesture) {\n      return NotificationListener(\n        onNotification: (Notification notification) {\n          if (widget.options.onScrolled != null &&\n              notification is ScrollUpdateNotification) {\n            widget.options.onScrolled!(carouselState!.pageController!.page);\n          }\n          return false;\n        },\n        child: wrapper,\n      );\n    }\n\n    return RawGestureDetector(\n      behavior: HitTestBehavior.opaque,\n      gestures: {\n        _MultipleGestureRecognizer:\n            GestureRecognizerFactoryWithHandlers<_MultipleGestureRecognizer>(\n                _MultipleGestureRecognizer.new,\n                (_MultipleGestureRecognizer instance) {\n          instance\n            ..onStart = (_) {\n              onStart();\n            }\n            ..onDown = (_) {\n              onPanDown();\n            }\n            ..onEnd = (_) {\n              onPanUp();\n            }\n            ..onCancel = onPanUp;\n        }),\n      },\n      child: NotificationListener(\n        onNotification: (Notification notification) {\n          if (widget.options.onScrolled != null &&\n              notification is ScrollUpdateNotification) {\n            widget.options.onScrolled!(carouselState!.pageController!.page);\n          }\n          return false;\n        },\n        child: wrapper,\n      ),\n    );\n  }\n\n  Widget getCenterWrapper(Widget child) {\n    if (widget.options.disableCenter) {\n      return Container(\n        child: child,\n      );\n    }\n    return Center(child: child);\n  }\n\n  Widget getEnlargeWrapper(\n    Widget? child, {\n    double? width,\n    double? height,\n    double? scale,\n    required double itemOffset,\n  }) {\n    if (widget.options.enlargeStrategy == CenterPageEnlargeStrategy.height) {\n      return SizedBox(width: width, height: height, child: child);\n    }\n    if (widget.options.enlargeStrategy == CenterPageEnlargeStrategy.zoom) {\n      late Alignment alignment;\n      final bool horizontal = options.scrollDirection == Axis.horizontal;\n      if (itemOffset > 0) {\n        alignment = horizontal ? Alignment.centerRight : Alignment.bottomCenter;\n      } else {\n        alignment = horizontal ? Alignment.centerLeft : Alignment.topCenter;\n      }\n      return Transform.scale(scale: scale, alignment: alignment, child: child);\n    }\n    return Transform.scale(\n      scale: scale,\n      child: SizedBox(width: width, height: height, child: child),\n    );\n  }\n\n  void onStart() {\n    mode = CarouselPageChangedReason.manual;\n  }\n\n  void onPanDown() {\n    if (widget.options.pauseAutoPlayOnTouch) {\n      clearTimer();\n    }\n\n    mode = CarouselPageChangedReason.manual;\n  }\n\n  void onPanUp() {\n    if (widget.options.pauseAutoPlayOnTouch) {\n      resumeTimer();\n    }\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    clearTimer();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return getGestureWrapper(\n      PageView.builder(\n        padEnds: widget.options.padEnds,\n        scrollBehavior: ScrollConfiguration.of(context).copyWith(\n          scrollbars: false,\n          overscroll: false,\n          dragDevices: {\n            PointerDeviceKind.touch,\n            PointerDeviceKind.mouse,\n          },\n        ),\n        clipBehavior: widget.options.clipBehavior,\n        physics: widget.options.scrollPhysics,\n        scrollDirection: widget.options.scrollDirection,\n        pageSnapping: widget.options.pageSnapping,\n        controller: carouselState!.pageController,\n        reverse: widget.options.reverse,\n        itemCount:\n            widget.options.enableInfiniteScroll ? null : widget.itemCount,\n        onPageChanged: (int index) {\n          final int currentPage = getRealIndex(\n            index + carouselState!.initialPage,\n            carouselState!.realPage,\n            widget.itemCount,\n          );\n          widget.options.onPageChanged?.call(currentPage, _mode);\n        },\n        itemBuilder: (BuildContext context, int idx) {\n          final int index = getRealIndex(\n            idx + carouselState!.initialPage,\n            carouselState!.realPage,\n            widget.itemCount,\n          );\n\n          return AnimatedBuilder(\n            animation: carouselState!.pageController!,\n            child: (widget.items != null)\n                ? (widget.items!.isNotEmpty\n                    ? widget.items![index]\n                    : Container())\n                : widget.itemBuilder!(context, index, idx),\n            builder: (BuildContext context, child) {\n              double distortionValue = 1;\n              // if `enlargeCenterPage` is true, we must calculate the carousel item's height\n              // to display the visual effect\n              double itemOffset = 0;\n              if (widget.options.enlargeCenterPage != null &&\n                  (widget.options.enlargeCenterPage ?? false)) {\n                // pageController.page can only be accessed after the first build,\n                // so in the first build we calculate the itemoffset manually\n                final position = carouselState?.pageController?.position;\n                if (position != null &&\n                    position.hasPixels &&\n                    position.hasContentDimensions) {\n                  final page = carouselState?.pageController?.page;\n                  if (page != null) {\n                    itemOffset = page - idx;\n                  }\n                } else {\n                  final BuildContext storageContext = carouselState!\n                      .pageController!.position.context.storageContext;\n                  final double? previousSavedPosition =\n                      PageStorage.of(storageContext).readState(storageContext)\n                          as double?;\n                  if (previousSavedPosition != null) {\n                    itemOffset = previousSavedPosition - idx.toDouble();\n                  } else {\n                    itemOffset =\n                        carouselState!.realPage.toDouble() - idx.toDouble();\n                  }\n                }\n\n                final double enlargeFactor =\n                    options.enlargeFactor.clamp(0.0, 1.0);\n                final num distortionRatio =\n                    (1 - (itemOffset.abs() * enlargeFactor)).clamp(0.0, 1.0);\n                distortionValue =\n                    Curves.easeOut.transform(distortionRatio as double);\n              }\n\n              final double height = widget.options.height ??\n                  MediaQuery.of(context).size.width *\n                      (1 / widget.options.aspectRatio);\n\n              if (widget.options.scrollDirection == Axis.horizontal) {\n                return getCenterWrapper(\n                  getEnlargeWrapper(\n                    child,\n                    height: distortionValue * height,\n                    scale: distortionValue,\n                    itemOffset: itemOffset,\n                  ),\n                );\n              } else {\n                return getCenterWrapper(\n                  getEnlargeWrapper(\n                    child,\n                    width: distortionValue * MediaQuery.of(context).size.width,\n                    scale: distortionValue,\n                    itemOffset: itemOffset,\n                  ),\n                );\n              }\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _MultipleGestureRecognizer extends PanGestureRecognizer {}\n"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "draggable_scrollbar_positioned_list", "file_path": "core/external_libs/draggable_scrollbar_positioned_list/draggable_scrollbar_positioned_list.dart", "file_name": "draggable_scrollbar_positioned_list.dart", "line": 63, "line_from": 63, "line_to": 152, "snippet": "  final void Function({required bool dragging})? onDragging;\n\n  @override\n  DraggableScrollbarPositionedListState createState() =>\n      DraggableScrollbarPositionedListState();\n\n  static Widget buildScrollThumb({\n    required Widget scrollThumb,\n    required Color backgroundColor,\n    required Animation<double> thumbAnimation,\n    required bool alwaysVisibleScrollThumb,\n  }) {\n    if (alwaysVisibleScrollThumb) return scrollThumb;\n\n    return SlideFadeTransition(\n      key: const ValueKey('SlideFadeTransition2938492'),\n      animation: thumbAnimation,\n      child: scrollThumb,\n    );\n  }\n\n  static ScrollThumbBuilder _thumbArrowBuilder(\n    Key? scrollThumbKey,\n    bool alwaysVisibleScrollThumb,\n  ) {\n    return (\n      Color backgroundColor,\n      Animation<double> thumbAnimation,\n      double height,\n    ) {\n      // creates a ClipPath widget named scrollThumb that represents a scroll\n      // thumb used in a scrollbar. The scroll thumb is a rectangular container\n      // with rounded corners, and it uses an ArrowClipper as its clipper to\n      // give it an arrow-shaped appearance.\n      final ClipPath scrollThumb = ClipPath(\n        key: const Key(\"ScrollThumbBuilderClipPath\"),\n        child: Container(\n          key: scrollThumbKey,\n          alignment: Alignment.center,\n          height: 40,\n          width: 16,\n          decoration: BoxDecoration(\n            color: backgroundColor,\n            borderRadius: BorderRadius.circular(4),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              SvgPicture.asset(\n                'assets/images/svg/chevrons_left.svg',\n              ),\n              SvgPicture.asset(\n                'assets/images/svg/chevrons_right.svg',\n              ),\n            ],\n          ),\n        ),\n      );\n      // final ClipPath scrollThumb = ClipPath(\n      //   key: const Key(\"ScrollThumbBuilderClipPath\"),\n      //   // clipper: ArrowClipper(),\n      //   child: Container(\n      //     key: scrollThumbKey,\n      //     height: 50,\n      //     width: 50,\n      //     decoration: BoxDecoration(\n      //       color: backgroundColor,\n      //       borderRadius: const BorderRadius.only(\n      //         topLeft: Radius.circular(50),\n      //         bottomLeft: Radius.circular(50),\n      //         topRight: Radius.circular(50),\n      //       ),\n      //     ),\n      //     child: Icon(\n      //       Icons.unfold_more,\n      //       color: Colors.grey.shade100,\n      //     ),\n      //   ),\n      // );\n\n      return buildScrollThumb(\n        scrollThumb: scrollThumb,\n        backgroundColor: backgroundColor,\n        thumbAnimation: thumbAnimation,\n        alwaysVisibleScrollThumb: alwaysVisibleScrollThumb,\n      );\n    };\n  }\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "circular_seek_bar-master", "file_path": "core/external_libs/circular_seek_bar-master/circular_seek_bar.dart", "file_name": "circular_seek_bar.dart", "line": 142, "line_from": 142, "line_to": 628, "snippet": "  void initState() {\n    super.initState();\n    _progress = widget.progress;\n  }\n\n  /// Reset CircularSeekBar's progress.\n  @override\n  void didUpdateWidget(CircularSeekBar oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.progress != widget.progress) {\n      _progress = widget.progress;\n    }\n  }\n\n  /// Get size of CircularSeekBar with RenderBox.\n  // Size _getSize(GlobalKey key) {\n  //   final RenderBox renderBox =\n  //       key.currentContext!.findRenderObject() as RenderBox;\n  //   Size size = renderBox.size;\n  //   return size;\n  // }\n\n  /// Converts the x and y coordinate values received by the onTapDown callback to progress.\n  // void _handleGesture(details) {\n  //   double dx = details.localPosition.dx;\n  //   double dy = details.localPosition.dy;\n  //   Size size = _getSize(_key);\n  //   double centerX = size.width / 2.0;\n  //   double centerY = size.height / 2.0;\n  //   double angle = _getTouchedDegrees(centerX, dx, centerY, dy);\n  //   double progress = (widget.dashWidth > 0 && widget.dashGap > 0)\n  //       ? _angleToDashedProgress(\n  //           angle > 0 ? angle : angle + 360,\n  //           widget.startAngle,\n  //           widget.sweepAngle,\n  //           widget.dashWidth,\n  //           widget.dashGap)\n  //       : _angleToProgress(angle > 0 ? angle : angle + 360, widget.startAngle,\n  //           widget.sweepAngle);\n  //   if (progress >= widget.minProgress && progress <= widget.maxProgress) {\n  //     setState(() {\n  //       _progress = progress;\n  //     });\n  //   }\n  // }\n\n  // /// Method to get relative angle of CircularSeekBar.\n  // double _getRelativeAngle(double angle, double startAngle) {\n  //   return (angle - startAngle) >= 0\n  //       ? (angle - startAngle)\n  //       : (360 - startAngle + angle);\n  // }\n\n  /// Convert (x, y) coordinates to an angle.\n  // double _getTouchedDegrees(\n  //     double centerX, double dx, double centerY, double dy) {\n  //   return _radiansToDegrees(atan2(centerX - dx, dy - centerY));\n  // }\n\n  /// Convert angle to progress.\n  // double _angleToProgress(double angle, double startAngle, double sweepAngle) {\n  //   double relativeAngle = _getRelativeAngle(angle, startAngle);\n  //   return (relativeAngle / sweepAngle) * 100;\n  // }\n\n  // /// Convert the angle of dashed seekbar to progress\n  // double _angleToDashedProgress(double angle, double startAngle,\n  //     double sweepAngle, double dashWidth, double dashGap) {\n  //   double relativeAngle = (angle - startAngle) >= 0\n  //       ? (angle - startAngle)\n  //       : (360 - startAngle + angle);\n  //   double dashSum = dashWidth + dashGap;\n\n  //   int trackDashCounts =\n  //       sweepAngle >= (sweepAngle ~/ dashSum) * dashSum + dashWidth\n  //           ? (sweepAngle ~/ dashSum) + 1\n  //           : (sweepAngle ~/ dashSum);\n  //   double totalTrackDashWidth = dashWidth * trackDashCounts;\n\n  //   for (int i = 0; i <= trackDashCounts; i++) {\n  //     double relativeDashStartAngle = dashSum * i;\n  //     double relativeDashEndAngle = (relativeDashStartAngle + dashWidth) % 360;\n\n  //     if (relativeAngle >= relativeDashStartAngle &&\n  //         relativeAngle <= relativeDashEndAngle) {\n  //       double totalFilledDashRatio =\n  //           (dashWidth * i) / totalTrackDashWidth.toDouble();\n  //       double totalHalfWidthDashRatio =\n  //           ((relativeAngle - dashSum * i) / dashWidth.toDouble()) /\n  //               trackDashCounts;\n\n  //       return _lerp(widget.minProgress, widget.maxProgress,\n  //           totalFilledDashRatio + totalHalfWidthDashRatio);\n  //     }\n  //   }\n  //   return -1;\n  // }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animation) {\n      return GestureDetector(\n        key: _key,\n        onTapDown: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        onPanUpdate: (details) {\n          if (widget.interactive) {\n          //  _handleGesture(details);\n          }\n        },\n        child: TweenAnimationBuilder(\n            duration: Duration(milliseconds: widget.animDurationMillis),\n            tween: Tween(begin: widget.minProgress, end: _progress!),\n            curve: widget.curves,\n            onEnd: widget.onEnd,\n            builder: (BuildContext context, double progress, __) {\n              widget.valueNotifier?.value = progress;\n              return CustomPaint(\n                size: Size(widget.width, widget.height),\n                painter: _SeekBarPainter(\n                  progress: progress,\n                  minProgress: widget.minProgress,\n                  maxProgress: widget.maxProgress,\n                  startAngle: widget.startAngle,\n                  sweepAngle: widget.sweepAngle,\n                  barWidth: widget.barWidth,\n                  trackColor: widget.trackColor,\n                  trackGradientColors: widget.trackGradientColors,\n                  progressColor: widget.progressColor,\n                  progressGradientColors: widget.progressGradientColors,\n                  strokeCap: widget.strokeCap,\n                  innerThumbRadius: widget.innerThumbRadius,\n                  innerThumbStrokeWidth: widget.innerThumbStrokeWidth,\n                  innerThumbColor: widget.innerThumbColor,\n                  outerThumbRadius: widget.outerThumbRadius,\n                  outerThumbStrokeWidth: widget.outerThumbStrokeWidth,\n                  outerThumbColor: widget.outerThumbColor,\n                  dashWidth: widget.dashWidth,\n                  dashGap: widget.dashGap,\n                ),\n                child: SizedBox(\n                  width: widget.width,\n                  height: widget.height,\n                  child: widget.child,\n                ),\n              );\n            }),\n      );\n    } else {\n      widget.valueNotifier?.value = _progress!;\n      return GestureDetector(\n        key: _key,\n        onTapDown: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        onPanUpdate: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        child: CustomPaint(\n          size: Size(widget.width, widget.height),\n          painter: _SeekBarPainter(\n            progress: _progress!,\n            minProgress: widget.minProgress,\n            maxProgress: widget.maxProgress,\n            startAngle: widget.startAngle,\n            sweepAngle: widget.sweepAngle,\n            barWidth: widget.barWidth,\n            trackColor: widget.trackColor,\n            trackGradientColors: widget.trackGradientColors,\n            progressColor: widget.progressColor,\n            progressGradientColors: widget.progressGradientColors,\n            strokeCap: widget.strokeCap,\n            innerThumbRadius: widget.innerThumbRadius,\n            innerThumbStrokeWidth: widget.innerThumbStrokeWidth,\n            innerThumbColor: widget.innerThumbColor,\n            outerThumbRadius: widget.outerThumbRadius,\n            outerThumbStrokeWidth: widget.outerThumbStrokeWidth,\n            outerThumbColor: widget.outerThumbColor,\n            dashWidth: widget.dashWidth,\n            dashGap: widget.dashGap,\n          ),\n          child: SizedBox(\n            width: widget.width,\n            height: widget.height,\n            child: widget.child,\n          ),\n        ),\n      );\n    }\n  }\n}\n\nclass _SeekBarPainter extends CustomPainter {\n  /// Current value of seek bar.\n  final double progress;\n\n  /// Minimum value of seek bar.\n  final double minProgress;\n\n  /// Maximum value of seek bar.\n  final double maxProgress;\n\n  /// The Angle to start drawing this seek bar from\n  final double startAngle;\n\n  /// The Angle through which to draw the seek bar\n  final double sweepAngle;\n\n  /// The thickness of the seek bar.\n  final double barWidth;\n\n  /// Background track color of seek bar.\n  final Color trackColor;\n\n  /// Background track gradient colors of seek bar.\n  final List<Color> trackGradientColors;\n\n  /// Foreground progress color of seek bar.\n  final Color progressColor;\n\n  /// Foreground trackGradientColors of seek bar.\n  final List<Color> progressGradientColors;\n\n  /// Styles to use for arcs endings.\n  final StrokeCap strokeCap;\n\n  /// The radius of the seekbar inner thumb.\n  final double innerThumbRadius;\n\n  /// The stroke width of the seekbar inner thumb.\n  final double innerThumbStrokeWidth;\n\n  /// Color of the seekbar inner thumb.\n  final Color innerThumbColor;\n\n  /// The radius of the seekbar outer thumb.\n  final double outerThumbRadius;\n\n  /// The stroke width of the seekbar outer thumb.\n  final double outerThumbStrokeWidth;\n\n  /// Color of the seekbar outer thumb.\n  final Color outerThumbColor;\n\n  /// Dash width of seek bar\n  final double dashWidth;\n\n  /// Dash gap of seek bar.\n  final double dashGap;\n\n  /// The initial rotational offset 90\n  static const double angleOffset = 90;\n\n  _SeekBarPainter(\n      {required this.progress,\n      required this.minProgress,\n      required this.maxProgress,\n      required this.startAngle,\n      required this.sweepAngle,\n      required this.barWidth,\n      required this.trackColor,\n      required this.trackGradientColors,\n      required this.progressColor,\n      required this.progressGradientColors,\n      required this.strokeCap,\n      required this.innerThumbRadius,\n      required this.innerThumbStrokeWidth,\n      required this.innerThumbColor,\n      required this.outerThumbRadius,\n      required this.outerThumbStrokeWidth,\n      required this.outerThumbColor,\n      required this.dashWidth,\n      required this.dashGap});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    if (sweepAngle > 0.0) {\n      Paint trackPaint = Paint()\n        ..style = PaintingStyle.stroke\n        ..color = trackColor\n        ..strokeCap = strokeCap\n        ..strokeWidth = barWidth;\n\n      Paint progressPaint = Paint()\n        ..style = PaintingStyle.stroke\n        ..color = progressColor\n        ..strokeCap = strokeCap\n        ..strokeWidth = barWidth;\n\n      final Offset center = Offset(size.width / 2, size.height / 2);\n      final double largerThumbWidth =\n          (outerThumbRadius / 2 + outerThumbStrokeWidth / 2) >=\n                  (innerThumbRadius / 2 + innerThumbStrokeWidth / 2)\n              ? (outerThumbRadius / 2 + outerThumbStrokeWidth / 2)\n              : (innerThumbRadius / 2 + innerThumbStrokeWidth / 2);\n      final double seekBarMargin =\n          largerThumbWidth >= (barWidth / 2) ? largerThumbWidth : barWidth / 2;\n      final double radius = min(center.dx, center.dy) - seekBarMargin;\n      double realStartAngle = startAngle + angleOffset;\n\n      double startAngleWithOffsetRadian = _degreesToRadians(realStartAngle);\n      Rect rect = Rect.fromCenter(\n          center: center, width: 2 * radius, height: 2 * radius);\n\n      double sweepAngleRadian = _degreesToRadians(sweepAngle);\n\n      // Set gradients\n      if (trackGradientColors.isNotEmpty) {\n        Gradient trackGradient = SweepGradient(\n          center: Alignment.center,\n          startAngle: 0,\n          endAngle: sweepAngleRadian,\n          tileMode: TileMode.mirror,\n          colors: trackGradientColors,\n          transform: GradientRotation(\n              startAngleWithOffsetRadian - asin((barWidth / 2) / radius)),\n        );\n        trackPaint.shader = trackGradient.createShader(rect);\n      }\n\n      if (progressGradientColors.isNotEmpty) {\n        Gradient progressGradient = SweepGradient(\n          center: Alignment.center,\n          startAngle: 0,\n          endAngle: sweepAngleRadian,\n          tileMode: TileMode.mirror,\n          colors: progressGradientColors,\n          transform: GradientRotation(\n              startAngleWithOffsetRadian - asin((barWidth / 2) / radius)),\n        );\n\n        progressPaint.shader = progressGradient.createShader(rect);\n      }\n\n      if (dashWidth > 0 && dashGap > 0) {\n        double dashSum = dashWidth + dashGap;\n        double dashWidthRadian = _degreesToRadians(dashWidth);\n        double dashSumRadian = _degreesToRadians(dashSum);\n\n        int trackDashCounts =\n            sweepAngle >= (sweepAngle ~/ dashSum) * dashSum + dashWidth\n                ? (sweepAngle ~/ dashSum) + 1\n                : (sweepAngle ~/ dashSum);\n        int progressDashCounts =\n            (trackDashCounts * _lerpRatio(minProgress, maxProgress, progress))\n                .floor();\n        double fullProgressRatio =\n            (progressDashCounts / trackDashCounts.toDouble());\n\n        // Draw track dashes.\n        for (int i = 0; i < trackDashCounts; i++) {\n          canvas.drawArc(\n            rect,\n            startAngleWithOffsetRadian + dashSumRadian * i,\n            dashWidthRadian,\n            false,\n            trackPaint,\n          );\n        }\n\n        // Draw progress dashes.\n        for (int i = 0; i < progressDashCounts; i++) {\n          canvas.drawArc(\n            rect,\n            startAngleWithOffsetRadian + dashSumRadian * i,\n            dashWidthRadian,\n            false,\n            progressPaint,\n          );\n        }\n\n        canvas.drawArc(\n          rect,\n          startAngleWithOffsetRadian + dashSumRadian * (progressDashCounts),\n          dashWidthRadian *\n              (_lerpRatio(minProgress, maxProgress, progress) -\n                  fullProgressRatio) *\n              trackDashCounts,\n          false,\n          progressPaint,\n        );\n\n        double totalTrackDashWidth = dashWidth * trackDashCounts;\n        double totalRatio = _lerpRatio(minProgress, maxProgress, progress);\n        double totalFilledAngleRatio =\n            (dashWidth * progressDashCounts) / totalTrackDashWidth.toDouble();\n        double totalHalfWidthAngleRatio = totalRatio - totalFilledAngleRatio;\n        double halfWidthAngleRatio = totalHalfWidthAngleRatio * trackDashCounts;\n\n        double halfWidthProgressAngle =\n            _lerp(0, dashWidth, halfWidthAngleRatio);\n        double filledProgressAngle = trackDashCounts >= progressDashCounts + 1\n            ? dashSum * progressDashCounts\n            : dashSum * (progressDashCounts - 1) + dashWidth;\n        double progressAngle = filledProgressAngle + halfWidthProgressAngle;\n\n        double thumbX = center.dx -\n            sin(_degreesToRadians(startAngle + progressAngle)) * radius;\n        double thumbY = center.dy +\n            cos(_degreesToRadians(startAngle + progressAngle)) * radius;\n        Offset thumbCenter = Offset(thumbX, thumbY);\n\n        canvas.drawCircle(\n            thumbCenter,\n            outerThumbRadius,\n            Paint()\n              ..color = outerThumbColor\n              ..style = PaintingStyle.stroke\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = outerThumbStrokeWidth);\n\n        canvas.drawCircle(\n            thumbCenter,\n            innerThumbRadius,\n            Paint()\n              ..color = innerThumbColor\n              ..style = PaintingStyle.fill\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = innerThumbStrokeWidth);\n      } else {\n        double progressAngle = _lerp(\n            0, sweepAngle, _lerpRatio(minProgress, maxProgress, progress));\n        double progressAngleRadian = _degreesToRadians(progressAngle);\n\n        canvas.drawArc(rect, startAngleWithOffsetRadian, sweepAngleRadian,\n            false, trackPaint);\n        canvas.drawArc(rect, startAngleWithOffsetRadian, progressAngleRadian,\n            false, progressPaint);\n\n        double thumbX = center.dx -\n            sin(_degreesToRadians(startAngle + progressAngle)) * radius;\n        double thumbY = center.dy +\n            cos(_degreesToRadians(startAngle + progressAngle)) * radius;\n\n        Offset thumbCenter = Offset(thumbX, thumbY);\n\n        canvas.drawCircle(\n            thumbCenter,\n            outerThumbRadius,\n            Paint()\n              ..color = outerThumbColor\n              ..style = PaintingStyle.stroke\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = outerThumbStrokeWidth);\n\n        canvas.drawCircle(\n            thumbCenter,\n            innerThumbRadius,\n            Paint()\n              ..color = innerThumbColor\n              ..style = PaintingStyle.fill\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = innerThumbStrokeWidth);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant _SeekBarPainter oldDelegate) {\n    return oldDelegate.progress != progress ||\n        oldDelegate.minProgress != minProgress ||\n        oldDelegate.maxProgress != maxProgress ||\n        oldDelegate.startAngle != startAngle ||\n        oldDelegate.sweepAngle != sweepAngle ||\n        oldDelegate.barWidth != barWidth ||\n        oldDelegate.trackColor != trackColor ||\n        oldDelegate.trackGradientColors != trackGradientColors ||\n        oldDelegate.progressColor != progressColor ||\n        oldDelegate.progressGradientColors != progressGradientColors ||\n        oldDelegate.strokeCap != strokeCap ||\n        oldDelegate.innerThumbRadius != innerThumbRadius ||\n        oldDelegate.innerThumbStrokeWidth != innerThumbStrokeWidth ||\n        oldDelegate.innerThumbColor != innerThumbColor ||\n        oldDelegate.outerThumbRadius != outerThumbRadius ||\n        oldDelegate.outerThumbStrokeWidth != outerThumbStrokeWidth ||\n        oldDelegate.outerThumbColor != outerThumbColor ||\n        oldDelegate.dashWidth != dashWidth ||\n        oldDelegate.dashGap != dashGap;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "expandable_bottom_sheet", "file_path": "core/external_libs/expandable_bottom_sheet/expandable_bottom_sheet.dart", "file_name": "expandable_bottom_sheet.dart", "line": 42, "line_from": 42, "line_to": 382, "snippet": "  final void Function()? onIsExtendedCallback;\n\n  final void Function()? onIsContractedCallback;\n\n  final bool enableToggle;\n\n  final bool isDraggable;\n  bool isExpanded;\n\n  ExpandableBottomSheetState? expandableBottomSheetState;\n\n  // // ignore: no_logic_in_create_state\n  // ExpandableBottomSheetState createState() {\n  //   expandableBottomSheetState = ExpandableBottomSheetState();\n  //   return expandableBottomSheetState;\n  // }\n  @override\n  ExpandableBottomSheetState createState() => ExpandableBottomSheetState();\n}\n\nclass ExpandableBottomSheetState extends State<ExpandableBottomSheet>\n    with TickerProviderStateMixin {\n  final GlobalKey _contentKey = GlobalKey(debugLabel: 'contentKey');\n  final GlobalKey _headerKey = GlobalKey(debugLabel: 'headerKey');\n  final GlobalKey _footerKey = GlobalKey(debugLabel: 'footerKey');\n\n  late AnimationController _controller;\n\n  double _draggableHeight = 0;\n  double? _positionOffset;\n  double _startOffsetAtDragDown = 0;\n  double? _startPositionAtDragDown = 0;\n\n  double _minOffset = 0;\n  double _maxOffset = 0;\n  double _animationMinOffset = 0;\n\n  AnimationStatus _oldStatus = AnimationStatus.dismissed;\n\n  bool _useDrag = true;\n  bool _callCallbacks = false;\n\n  void expand() {\n    _afterUpdateWidgetBuild(false);\n    _callCallbacks = true;\n    widget.isExpanded = true;\n    _animateToTop();\n  }\n\n  void contract() {\n    _afterUpdateWidgetBuild(false);\n    _callCallbacks = true;\n    _animateToBottom();\n  }\n\n  ExpansionStatus get expansionStatus {\n    if (_positionOffset == null) return ExpansionStatus.contracted;\n    if (_positionOffset == _maxOffset) return ExpansionStatus.contracted;\n    if (_positionOffset == _minOffset) return ExpansionStatus.expanded;\n    return ExpansionStatus.middle;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this);\n    _controller.addStatusListener(_handleAnimationStatusUpdate);\n    WidgetsBinding.instance\n        .addPostFrameCallback((_) => _afterUpdateWidgetBuild(true));\n   \n  }\n  \n\n  @override\n  Widget build(BuildContext context) {\n    WidgetsBinding.instance\n        .addPostFrameCallback((_) => _afterUpdateWidgetBuild(false));\n    return Column(\n      children: <Widget>[\n        Expanded(\n          child: Stack(\n            children: <Widget>[\n              Align(\n                alignment: Alignment.topLeft,\n                child: InkWell(\n                  onTap: () => context.navigatorPop<void>(),\n                  child: widget.background,\n                ),\n              ),\n              AnimatedBuilder(\n                animation: _controller,\n                builder: (_, Widget? child) {\n                  if (_controller.isAnimating) {\n                    _positionOffset = _animationMinOffset +\n                        _controller.value * _draggableHeight;\n                  }\n                  return Positioned(\n                    top: _positionOffset,\n                    right: 0,\n                    left: 0,\n                    child: child!,\n                  );\n                },\n                child: GestureDetector(\n                  onTap: _toggle,\n                  onVerticalDragDown: widget.isDraggable ? _dragDown : (_) {},\n                  onVerticalDragUpdate:\n                      widget.isDraggable ? _dragUpdate : (_) {},\n                  onVerticalDragEnd: widget.isDraggable ? _dragEnd : (_) {},\n                  child: Padding(\n                    padding: const EdgeInsets.only(top: 40),\n                    child: Column(\n                      mainAxisSize: MainAxisSize.min,\n                      children: <Widget>[\n                        Container(\n                          key: _headerKey,\n                          child: widget.persistentHeader ?? Container(),\n                        ),\n                        Container(\n                          key: _contentKey,\n                          child: widget.expandableContent,\n                        ),\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n        Container(\n          key: _footerKey,\n          child: widget.persistentFooter ?? Container(),\n        ),\n      ],\n    );\n  }\n\n  void _handleAnimationStatusUpdate(AnimationStatus status) {\n    if (status == AnimationStatus.completed) {\n      if (_oldStatus == AnimationStatus.forward) {\n        setState(() {\n          _draggableHeight = _maxOffset - _minOffset;\n          _positionOffset = _minOffset;\n        });\n        if (widget.onIsExtendedCallback != null && _callCallbacks) {\n          widget.onIsExtendedCallback!();\n        }\n      }\n      if (_oldStatus == AnimationStatus.reverse) {\n        setState(() {\n          _draggableHeight = _maxOffset - _minOffset;\n          _positionOffset = _maxOffset;\n        });\n        if (widget.onIsContractedCallback != null && _callCallbacks) {\n          widget.onIsContractedCallback!();\n        }\n      }\n    }\n  }\n\n  void _afterUpdateWidgetBuild(bool isFirstBuild) {\n    final double headerHeight = _headerKey.currentContext!.size!.height;\n    final double footerHeight = _footerKey.currentContext!.size!.height;\n    final double contentHeight = _contentKey.currentContext!.size!.height;\n\n    final double checkedPersistentContentHeight =\n        (widget.persistentContentHeight < contentHeight)\n            ? widget.persistentContentHeight\n            : contentHeight;\n\n    _minOffset =\n        context.size!.height - headerHeight - contentHeight - footerHeight;\n    _maxOffset = context.size!.height -\n        headerHeight -\n        footerHeight -\n        checkedPersistentContentHeight;\n\n    if (!isFirstBuild) {\n      _positionOutOfBounds();\n    } else {\n      setState(() {\n        _positionOffset = _maxOffset;\n        _draggableHeight = _maxOffset - _minOffset;\n      });\n    }\n  }\n\n  void _positionOutOfBounds() {\n    if (_positionOffset! < _minOffset) {\n      //the extend is larger than contentHeight\n      _callCallbacks = false;\n      _animateToMin();\n    } else {\n      if (_positionOffset! > _maxOffset) {\n        //the extend is smaller than persistentContentHeight\n        _callCallbacks = false;\n        _animateToMax();\n      } else {\n        _draggableHeight = _maxOffset - _minOffset;\n      }\n    }\n  }\n\n  void _animateOnIsAnimating() {\n    if (_controller.isAnimating) {\n      _controller.stop();\n    }\n  }\n\n  void _toggle() {\n    if (widget.enableToggle) {\n      if (expansionStatus == ExpansionStatus.expanded) {\n        _callCallbacks = true;\n        _animateToBottom();\n      }\n      if (expansionStatus == ExpansionStatus.contracted) {\n        _callCallbacks = true;\n        _animateToTop();\n      }\n    }\n  }\n\n  void _dragDown(DragDownDetails details) {\n    if (_controller.isAnimating) {\n      _useDrag = false;\n    } else {\n      _useDrag = true;\n      _startOffsetAtDragDown = details.localPosition.dy;\n      _startPositionAtDragDown = _positionOffset;\n    }\n  }\n\n  void _dragUpdate(DragUpdateDetails details) {\n    if (!_useDrag) return;\n    final double offset = details.localPosition.dy;\n    final double newOffset =\n        _startPositionAtDragDown! + offset - _startOffsetAtDragDown;\n    if (_minOffset <= newOffset && _maxOffset >= newOffset) {\n      setState(() {\n        _positionOffset = newOffset;\n      });\n    } else {\n      if (_minOffset > newOffset) {\n        setState(() {\n          _positionOffset = _minOffset;\n        });\n      }\n      if (_maxOffset < newOffset) {\n        setState(() {\n          _positionOffset = _maxOffset;\n        });\n      }\n    }\n  }\n\n  void _dragEnd(DragEndDetails details) {\n    if (_startPositionAtDragDown == _positionOffset || !_useDrag) return;\n    if (details.primaryVelocity! < -250) {\n      //drag up ended with high speed\n      _callCallbacks = true;\n      _animateToTop();\n    } else {\n      if (details.primaryVelocity! > 250) {\n        //drag down ended with high speed\n        _callCallbacks = true;\n        _animateToBottom();\n      } else {\n        if (_positionOffset == _maxOffset &&\n            widget.onIsContractedCallback != null) {\n          widget.onIsContractedCallback!();\n        }\n        if (_positionOffset == _minOffset &&\n            widget.onIsExtendedCallback != null) {\n          widget.onIsExtendedCallback!();\n        }\n      }\n    }\n  }\n\n  void _animateToTop() {\n    // booksC.isBottomSheetExpanded.value = true;\n    _animateOnIsAnimating();\n    _controller.value = (_positionOffset! - _minOffset) / _draggableHeight;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.forward;\n    _controller.animateTo(\n      .001,\n      duration: widget.animationDurationExtend,\n      curve: widget.animationCurveExpand,\n    );\n  }\n\n  void _animateToBottom() {\n    // booksC.isBottomSheetExpanded.value = false;\n    _animateOnIsAnimating();\n\n    _controller.value = (_positionOffset! - _minOffset) / _draggableHeight;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.reverse;\n    _controller.animateTo(\n      0.999,\n      duration: widget.animationDurationContract,\n      curve: widget.animationCurveContract,\n    );\n  }\n\n  void _animateToMax() {\n    _animateOnIsAnimating();\n\n    _controller.value = 1.0;\n    _draggableHeight = _positionOffset! - _maxOffset;\n    _animationMinOffset = _maxOffset;\n    _oldStatus = AnimationStatus.reverse;\n    _controller.animateTo(\n      0.001,\n      duration: widget.animationDurationExtend,\n      curve: widget.animationCurveExpand,\n    );\n  }\n\n  void _animateToMin() {\n    _animateOnIsAnimating();\n\n    _controller.value = 1.0;\n    _draggableHeight = _positionOffset! - _minOffset;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.forward;\n    _controller.animateTo(\n      0.0001,\n      duration: widget.animationDurationContract,\n      curve: widget.animationCurveContract,\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/zooms.dart", "file_name": "zooms.dart", "line": 21, "line_from": 21, "line_to": 94, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  ZoomInState createState() => ZoomInState();\n}\n\nclass ZoomInState extends State<ZoomIn> with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> fade;\n  late Animation<double> opacity;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n    fade = Tween(begin: 0.001, end: widget.from)\n        .animate(CurvedAnimation(curve: Curves.easeOut, parent: controller!));\n\n    opacity = Tween<double>(begin: 0, end: 1).animate(\n      CurvedAnimation(parent: controller!, curve: const Interval(0, 0.65)),\n    );\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: fade,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.scale(\n          scale: fade.value,\n          child: Opacity(\n            opacity: opacity.value,\n            child: widget.child,\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/fades.dart", "file_name": "fades.dart", "line": 20, "line_from": 20, "line_to": 85, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n\n  @override\n  FadeInState createState() => FadeInState();\n}\n\nclass FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n\n  bool disposed = false;\n\n  late Animation<double> animation;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n    animation = CurvedAnimation(curve: Curves.easeOut, parent: controller!);\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: animation,\n      builder: (BuildContext context, Widget? child) {\n        return Opacity(\n          opacity: animation.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/bounces.dart", "file_name": "bounces.dart", "line": 21, "line_from": 21, "line_to": 93, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  BounceInDownState createState() => BounceInDownState();\n}\n\nclass BounceInDownState extends State<BounceInDown>\n    with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> animation;\n  late Animation<double> opacity;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n\n    opacity = Tween<double>(begin: 0, end: 1).animate(\n      CurvedAnimation(parent: controller!, curve: const Interval(0, 0.65)),\n    );\n\n    animation = Tween<double>(begin: widget.from * -1, end: 0)\n        .animate(CurvedAnimation(parent: controller!, curve: Curves.bounceOut));\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: controller!,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.translate(\n          offset: Offset(0, animation.value),\n          child: Opacity(opacity: opacity.value, child: widget.child),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "core/external_libs/animate_do/slides.dart", "file_name": "slides.dart", "line": 21, "line_from": 21, "line_to": 88, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  SlideInUpState createState() => SlideInUpState();\n}\n\nclass SlideInUpState extends State<SlideInUp>\n    with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> animation;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n\n    animation = Tween<double>(begin: widget.from, end: 0)\n        .animate(CurvedAnimation(parent: controller!, curve: Curves.easeOut));\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: controller!,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.translate(\n          offset: Offset(0, animation.value),\n          child: widget.child,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "core/external_libs/flutter_animated_dialog/src/custom_dialog_transitions.dart", "file_name": "custom_dialog_transitions.dart", "line": 20, "line_from": 20, "line_to": 57, "snippet": "  Widget build(BuildContext context) {\n    final double turnsValue = turns.value;\n    final Matrix4 transform = Matrix4.identity()\n      ..setEntry(3, 2, 0.0006)\n      ..rotateY(turnsValue);\n    return Transform(\n      transform: transform,\n      alignment: FractionalOffset.center,\n      child: child,\n    );\n  }\n}\n\nclass CustomRotationTransition extends AnimatedWidget {\n  const CustomRotationTransition({\n    super.key,\n    required Animation<double> turns,\n    this.alignment = Alignment.center,\n    this.child,\n  }) : super(listenable: turns);\n\n  Animation<double> get turns => listenable as Animation<double>;\n\n  final Alignment? alignment;\n\n  final Widget? child;\n\n  @override\n  Widget build(BuildContext context) {\n    final double turnsValue = turns.value;\n    final Matrix4 transform = Matrix4.rotationZ(turnsValue * math.pi);\n    return Transform(\n      transform: transform,\n      alignment: alignment,\n      child: child,\n    );\n  }\n}"}, {"structure_type": "function", "name": "Builder", "docstring": "", "module": "src", "file_path": "core/external_libs/flutter_animated_dialog/src/animated_dialog.dart", "file_name": "animated_dialog.dart", "line": 53, "line_from": 53, "line_to": 289, "snippet": "      final Widget pageChild = Builder(builder: builder);\n      return SafeArea(\n        top: false,\n        child: Builder(\n          builder: (BuildContext context) {\n            return Theme(data: theme, child: pageChild);\n          },\n        ),\n      );\n    },\n    barrierDismissible: barrierDismissible,\n    barrierLabel: \"Close dialog\",\n    barrierColor: barrierColor ?? Colors.black54,\n    transitionDuration: duration ?? const Duration(milliseconds: 400),\n    transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      switch (animationType) {\n        case DialogTransitionType.fade:\n          return FadeTransition(opacity: animation, child: child);\n        case DialogTransitionType.slideFromRight:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromLeft:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(-1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromRightFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromLeftFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(-1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromTop:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(0, -1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromTopFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(0, -1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromBottom:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(0, 1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromBottomFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(0, 1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.scale:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: child,\n          );\n        case DialogTransitionType.fadeScale:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: FadeTransition(\n              opacity: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.scaleRotate:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: CustomRotationTransition(\n              alignment: alignment,\n              turns: Tween<double>(begin: 1, end: 2).animate(\n                CurvedAnimation(\n                  parent: animation,\n                  curve: Interval(0, 1, curve: curve),\n                ),\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.rotate:\n          return CustomRotationTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: 1, end: 2).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: child,\n          );\n        case DialogTransitionType.fadeRotate:\n          return CustomRotationTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: 1, end: 2).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: FadeTransition(\n              opacity: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.rotate3D:\n          return Rotation3DTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: math.pi, end: 2.0 * math.pi).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: FadeTransition(\n              opacity: Tween<double>(begin: 0, end: 1).animate(\n                CurvedAnimation(\n                  parent: animation,\n                  curve: const Interval(0.5, 1, curve: Curves.elasticOut),\n                ),\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.size:\n          return Align(\n            alignment: alignment,\n            child: SizeTransition(\n              sizeFactor: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              axis: axis ?? Axis.vertical,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.sizeFade:\n          return Align(\n            alignment: alignment,\n            child: SizeTransition(\n              sizeFactor: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: FadeTransition(\n                opacity: CurvedAnimation(\n                  parent: animation,\n                  curve: curve,\n                ),\n                child: child,\n              ),\n            ),\n          );\n        case DialogTransitionType.none:\n          return child;\n      }\n    },"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "core/external_libs/flutter_animated_dialog/src/animated_dialog.dart", "file_name": "animated_dialog.dart", "line": 338, "line_from": 338, "line_to": 497, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final DialogThemeData dialogTheme = DialogTheme.of(context);\n    final List<Widget> children = <Widget>[];\n    String? label = semanticLabel;\n\n    if (title != null) {\n      children.add(\n        Padding(\n          padding: titlePadding ?? EdgeInsets.fromLTRB(24, 24, 24, content == null ? 20.0 : 0.0),\n          child: DefaultTextStyle(\n            style: (titleTextStyle ?? dialogTheme.titleTextStyle ?? theme.textTheme.titleLarge)!,\n            child: Semantics(\n              namesRoute: true,\n              container: true,\n              child: title,\n            ),\n          ),\n        ),\n      );\n    } else {\n      switch (defaultTargetPlatform) {\n        case TargetPlatform.iOS:\n          label = semanticLabel;\n        case TargetPlatform.android:\n        case TargetPlatform.fuchsia:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n        case TargetPlatform.linux:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n        case TargetPlatform.macOS:\n          label = semanticLabel;\n        case TargetPlatform.windows:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n      }\n    }\n\n    if (content != null) {\n      children.add(\n        Flexible(\n          child: Padding(\n            padding: contentPadding!,\n            child: DefaultTextStyle(\n              style: (contentTextStyle ?? dialogTheme.contentTextStyle ?? theme.textTheme.titleMedium)!,\n              child: content!,\n            ),\n          ),\n        ),\n      );\n    }\n\n    if (bottomWidget != null) {\n      children.add(bottomWidget!);\n    } else if (actions != null) {\n      children.add(\n        ButtonBarTheme(\n          data: ButtonBarTheme.of(context),\n          // ignore: deprecated_member_use\n          child: ButtonBar(\n            children: actions!,\n          ),\n        ),\n      );\n    }\n\n    Widget dialogChild = IntrinsicWidth(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: children,\n      ),\n    );\n\n    if (label != null) {\n      dialogChild = Semantics(\n        namesRoute: true,\n        label: label,\n        child: dialogChild,\n      );\n    }\n\n    dialogChild = CustomDialog(\n      backgroundColor: backgroundColor,\n      elevation: elevation,\n      minWidth: minWidth,\n      shape: shape,\n      child: dialogChild,\n    );\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(\n      value: SystemUiOverlayStyle.light.copyWith(\n        statusBarIconBrightness: Brightness.light,\n        statusBarColor: Colors.transparent,\n        systemNavigationBarColor: Colors.white,\n        systemNavigationBarIconBrightness: Brightness.dark,\n      ),\n      child: dialogChild,\n    );\n  }\n}\n\nclass CustomDialog extends StatelessWidget {\n  const CustomDialog({\n    super.key,\n    this.backgroundColor,\n    this.elevation,\n    this.insetAnimationDuration = const Duration(milliseconds: 100),\n    this.insetAnimationCurve = Curves.decelerate,\n    this.minWidth = 280.0,\n    this.shape,\n    this.child,\n  });\n\n  final Color? backgroundColor;\n\n  final double? elevation;\n\n  final Duration? insetAnimationDuration;\n\n  final Curve? insetAnimationCurve;\n\n  final double? minWidth;\n\n  final ShapeBorder? shape;\n\n  final Widget? child;\n\n  static const RoundedRectangleBorder _defaultDialogShape = RoundedRectangleBorder(\n    borderRadius: BorderRadius.all(Radius.circular(2)),\n  );\n  static const double _defaultElevation = 24;\n\n  @override\n  Widget build(BuildContext context) {\n    final DialogThemeData dialogTheme = DialogTheme.of(context);\n    return AnimatedPadding(\n      padding: MediaQuery.of(context).viewInsets + const EdgeInsets.symmetric(horizontal: 40, vertical: 24),\n      duration: insetAnimationDuration!,\n      curve: insetAnimationCurve!,\n      child: MediaQuery.removeViewInsets(\n        removeLeft: true,\n        removeTop: true,\n        removeRight: true,\n        removeBottom: true,\n        context: context,\n        child: Center(\n          child: ConstrainedBox(\n            constraints: BoxConstraints(minWidth: minWidth ?? 280.0),\n            child: Material(\n              color: backgroundColor ?? dialogTheme.backgroundColor,\n              elevation: elevation ?? dialogTheme.elevation ?? _defaultElevation,\n              shape: shape ?? dialogTheme.shape ?? _defaultDialogShape,\n              type: MaterialType.card,\n              child: child,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 10, "line_from": 10, "line_to": 23, "snippet": "  final Widget child;\n\n  final ValueNotifier<Set<Element>?>? elementNotifier;\n\n  @override\n  State<StatefulWidget> createState() => _RegistryWidgetState();\n}\n\nclass RegisteredElementWidget extends ProxyWidget {\n  const RegisteredElementWidget({super.key, required super.child});\n\n  @override\n  Element createElement() => _RegisteredElement(this);\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 29, "line_from": 29, "line_to": 45, "snippet": "  Widget build(BuildContext context) => _InheritedRegistryWidget(\n        state: this,\n        child: widget.child,\n      );\n}\n\nclass _InheritedRegistryWidget extends InheritedWidget {\n  const _InheritedRegistryWidget({\n    required this.state,\n    required super.child,\n  });\n\n  final _RegistryWidgetState state;\n\n  @override\n  bool updateShouldNotify(InheritedWidget oldWidget) => true;\n}"}, {"structure_type": "function", "name": "notifyClients", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 51, "line_from": 51, "line_to": 84, "snippet": "  void notifyClients(ProxyWidget oldWidget) {}\n\n  late _RegistryWidgetState _registryWidgetState;\n\n  @override\n  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    final inheritedRegistryWidget =\n        dependOnInheritedWidgetOfExactType<_InheritedRegistryWidget>()!;\n    _registryWidgetState = inheritedRegistryWidget.state;\n    _registryWidgetState.registeredElements.add(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final inheritedRegistryWidget =\n        dependOnInheritedWidgetOfExactType<_InheritedRegistryWidget>()!;\n    _registryWidgetState = inheritedRegistryWidget.state;\n    _registryWidgetState.registeredElements.add(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n  }\n\n  @override\n  void unmount() {\n    _registryWidgetState.registeredElements.remove(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n    super.unmount();\n  }\n}"}, {"structure_type": "function", "name": "jumpTo", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/scrollable_positioned_list.dart", "file_name": "scrollable_positioned_list.dart", "line": 119, "line_from": 119, "line_to": 178, "snippet": "  void jumpTo({required int index, double alignment = 0}) {\n    _scrollableListState?._jumpTo(index: index, alignment: alignment);\n  }\n\n  Future<void> scrollTo({\n    required int index,\n    double alignment = 0,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    List<double> opacityAnimationWeights = const [40, 20, 40],\n  }) {\n    assert(_scrollableListState != null);\n    assert(opacityAnimationWeights.length == 3);\n    assert(duration > Duration.zero);\n    return _scrollableListState!._scrollTo(\n      index: index,\n      alignment: alignment,\n      duration: duration,\n      curve: curve,\n      opacityAnimationWeights: opacityAnimationWeights,\n    );\n  }\n\n  void _attach(_ScrollablePositionedListState scrollableListState) {\n    assert(_scrollableListState == null);\n    _scrollableListState = scrollableListState;\n  }\n\n  void _detach() {\n    _scrollableListState = null;\n  }\n}\n\nclass ScrollOffsetController {\n  Future<void> animateScroll({\n    required double offset,\n    required Duration duration,\n    Curve curve = Curves.linear,\n  }) async {\n    final currentPosition =\n        _scrollableListState!.primary.scrollController.offset;\n    final newPosition = currentPosition + offset;\n    await _scrollableListState!.primary.scrollController.animateTo(\n      newPosition,\n      duration: duration,\n      curve: curve,\n    );\n  }\n\n  _ScrollablePositionedListState? _scrollableListState;\n\n  void _attach(_ScrollablePositionedListState scrollableListState) {\n    assert(_scrollableListState == null);\n    _scrollableListState = scrollableListState;\n  }\n\n  void _detach() {\n    _scrollableListState = null;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/scrollable_positioned_list.dart", "file_name": "scrollable_positioned_list.dart", "line": 188, "line_from": 188, "line_to": 544, "snippet": "  void Function() startAnimationCallback = () {};\n\n  bool _isTransitioning = false;\n\n  late AnimationController _animationController =\n      AnimationController(vsync: this);\n\n  double previousOffset = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    final ItemPosition? initialPosition =\n        PageStorage.of(context).readState(context) as ItemPosition?;\n    primary = _ListDisplayDetails(\n      const ValueKey('Ping'),\n      widget.itemScrollController?.scrollController ??\n          ScrollController(keepScrollOffset: false),\n    );\n    secondary = _ListDisplayDetails(\n      const ValueKey('Pong'),\n      ScrollController(keepScrollOffset: false),\n    );\n    primary\n      ..target = initialPosition?.index ?? widget.initialScrollIndex\n      ..alignment = initialPosition?.itemLeadingEdge ?? widget.initialAlignment;\n    if (widget.itemCount > 0 && primary.target > widget.itemCount - 1) {\n      primary.target = widget.itemCount - 1;\n    }\n    widget.itemScrollController?._attach(this);\n    widget.scrollOffsetController?._attach(this);\n    primary.itemPositionsNotifier.itemPositions.addListener(_updatePositions);\n    secondary.itemPositionsNotifier.itemPositions.addListener(_updatePositions);\n    primary.scrollController.addListener(() {\n      final currentOffset = primary.scrollController.offset;\n      final offsetChange = currentOffset - previousOffset;\n      previousOffset = currentOffset;\n      if (!_isTransitioning |\n          (widget.scrollOffsetNotifier?.recordProgrammaticScrolls ?? false)) {\n        widget.scrollOffsetNotifier?.changeController.add(offsetChange);\n      }\n    });\n  }\n\n  @override\n  void activate() {\n    super.activate();\n    widget.itemScrollController?._attach(this);\n    widget.scrollOffsetController?._attach(this);\n  }\n\n  @override\n  void deactivate() {\n    widget.itemScrollController?._detach();\n    widget.scrollOffsetController?._detach();\n    super.deactivate();\n  }\n\n  @override\n  void dispose() {\n    primary.itemPositionsNotifier.itemPositions\n        .removeListener(_updatePositions);\n    secondary.itemPositionsNotifier.itemPositions\n        .removeListener(_updatePositions);\n    // _animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(ScrollablePositionedList oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.itemScrollController?._scrollableListState == this) {\n      oldWidget.itemScrollController?._detach();\n    }\n    if (widget.itemScrollController?._scrollableListState != this) {\n      widget.itemScrollController?._detach();\n      widget.itemScrollController?._attach(this);\n    }\n\n    if (widget.itemCount == 0) {\n      setState(() {\n        primary.target = 0;\n        secondary.target = 0;\n      });\n    } else {\n      if (primary.target > widget.itemCount - 1) {\n        setState(() {\n          primary.target = widget.itemCount - 1;\n        });\n      }\n      if (secondary.target > widget.itemCount - 1) {\n        setState(() {\n          secondary.target = widget.itemCount - 1;\n        });\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final cacheExtent = _cacheExtent(constraints);\n        return Listener(\n          onPointerDown: (_) => _stopScroll(canceled: true),\n          child: Stack(\n            children: <Widget>[\n              PostMountCallback(\n                key: primary.key,\n                callback: startAnimationCallback,\n                child: FadeTransition(\n                  opacity: ReverseAnimation(opacity),\n                  child: NotificationListener<ScrollNotification>(\n                    onNotification: (_) => _isTransitioning,\n                    child: PositionedList(\n                      itemBuilder: widget.itemBuilder,\n                      separatorBuilder: widget.separatorBuilder,\n                      itemCount: widget.itemCount,\n                      positionedIndex: primary.target,\n                      controller: primary.scrollController,\n                      itemPositionsNotifier: primary.itemPositionsNotifier,\n                      scrollDirection: widget.scrollDirection,\n                      reverse: widget.reverse,\n                      cacheExtent: cacheExtent,\n                      alignment: primary.alignment,\n                      physics: widget.physics,\n                      shrinkWrap: widget.shrinkWrap,\n                      addSemanticIndexes: widget.addSemanticIndexes,\n                      semanticChildCount: widget.semanticChildCount,\n                      padding: widget.padding,\n                      addAutomaticKeepAlives: widget.addAutomaticKeepAlives,\n                      addRepaintBoundaries: widget.addRepaintBoundaries,\n                    ),\n                  ),\n                ),\n              ),\n              if (_isTransitioning)\n                PostMountCallback(\n                  key: secondary.key,\n                  callback: startAnimationCallback,\n                  child: FadeTransition(\n                    opacity: opacity,\n                    child: NotificationListener<ScrollNotification>(\n                      onNotification: (_) => false,\n                      child: PositionedList(\n                        itemBuilder: widget.itemBuilder,\n                        separatorBuilder: widget.separatorBuilder,\n                        itemCount: widget.itemCount,\n                        itemPositionsNotifier: secondary.itemPositionsNotifier,\n                        positionedIndex: secondary.target,\n                        controller: secondary.scrollController,\n                        scrollDirection: widget.scrollDirection,\n                        reverse: widget.reverse,\n                        cacheExtent: cacheExtent,\n                        alignment: secondary.alignment,\n                        physics: widget.physics,\n                        shrinkWrap: widget.shrinkWrap,\n                        addSemanticIndexes: widget.addSemanticIndexes,\n                        semanticChildCount: widget.semanticChildCount,\n                        padding: widget.padding,\n                        addAutomaticKeepAlives: widget.addAutomaticKeepAlives,\n                        addRepaintBoundaries: widget.addRepaintBoundaries,\n                      ),\n                    ),\n                  ),\n                ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n\n  double _cacheExtent(BoxConstraints constraints) => max(\n        (widget.scrollDirection == Axis.vertical\n                ? constraints.maxHeight\n                : constraints.maxWidth) *\n            _screenScrollCount,\n        widget.minCacheExtent ?? 0,\n      );\n\n  void _jumpTo({required int index, required double alignment}) {\n    _stopScroll(canceled: true);\n    if (index > widget.itemCount - 1) {\n      index = widget.itemCount - 1;\n    }\n    setState(() {\n      primary.scrollController.jumpTo(0);\n      primary\n        ..target = index\n        ..alignment = alignment;\n    });\n  }\n\n  Future<void> _scrollTo({\n    required int index,\n    required double alignment,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    required List<double> opacityAnimationWeights,\n  }) async {\n    if (index > widget.itemCount - 1) {\n      index = widget.itemCount - 1;\n    }\n    if (_isTransitioning) {\n      final scrollCompleter = Completer<void>();\n      _stopScroll(canceled: true);\n      SchedulerBinding.instance.addPostFrameCallback((_) async {\n        await _startScroll(\n          index: index,\n          alignment: alignment,\n          duration: duration,\n          curve: curve,\n          opacityAnimationWeights: opacityAnimationWeights,\n        );\n        scrollCompleter.complete();\n      });\n      await scrollCompleter.future;\n    } else {\n      await _startScroll(\n        index: index,\n        alignment: alignment,\n        duration: duration,\n        curve: curve,\n        opacityAnimationWeights: opacityAnimationWeights,\n      );\n    }\n  }\n\n  Future<void> _startScroll({\n    required int index,\n    required double alignment,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    required List<double> opacityAnimationWeights,\n  }) async {\n    final direction = index > primary.target ? 1 : -1;\n    final itemPosition = primary.itemPositionsNotifier.itemPositions.value\n        .firstWhereOrNull((itemPosition) => itemPosition.index == index);\n    if (itemPosition != null) {\n      final localScrollAmount = itemPosition.itemLeadingEdge *\n          primary.scrollController.position.viewportDimension;\n      await primary.scrollController.animateTo(\n        primary.scrollController.offset +\n            localScrollAmount -\n            alignment * primary.scrollController.position.viewportDimension,\n        duration: duration,\n        curve: curve,\n      );\n    } else {\n      final scrollAmount = _screenScrollCount *\n          primary.scrollController.position.viewportDimension;\n      final startCompleter = Completer<void>();\n      final endCompleter = Completer<void>();\n      startAnimationCallback = () {\n        SchedulerBinding.instance.addPostFrameCallback((_) {\n          startAnimationCallback = () {};\n          _animationController.dispose();\n          _animationController =\n              AnimationController(vsync: this, duration: duration)..forward();\n          opacity.parent = _opacityAnimation(opacityAnimationWeights)\n              .animate(_animationController);\n          secondary.scrollController.jumpTo(\n            -direction *\n                (_screenScrollCount *\n                        primary.scrollController.position.viewportDimension -\n                    alignment *\n                        secondary.scrollController.position.viewportDimension),\n          );\n\n          startCompleter.complete(\n            primary.scrollController.animateTo(\n              primary.scrollController.offset + direction * scrollAmount,\n              duration: duration,\n              curve: curve,\n            ),\n          );\n          endCompleter.complete(\n            secondary.scrollController\n                .animateTo(0, duration: duration, curve: curve),\n          );\n        });\n      };\n      setState(() {\n        secondary\n          ..target = index\n          ..alignment = alignment;\n        _isTransitioning = true;\n      });\n      await Future.wait<void>([startCompleter.future, endCompleter.future]);\n      _stopScroll();\n    }\n  }\n\n  void _stopScroll({bool canceled = false}) {\n    if (!_isTransitioning) {\n      return;\n    }\n\n    if (canceled) {\n      if (primary.scrollController.hasClients) {\n        primary.scrollController.jumpTo(primary.scrollController.offset);\n      }\n      if (secondary.scrollController.hasClients) {\n        secondary.scrollController.jumpTo(secondary.scrollController.offset);\n      }\n    }\n    if (mounted) {\n      setState(() {\n        if (opacity.value >= 0.5) {\n          final temp = primary;\n          primary = secondary;\n          secondary = temp;\n        }\n        _isTransitioning = false;\n        opacity.parent = const AlwaysStoppedAnimation<double>(0);\n      });\n    }\n  }\n\n  Animatable<double> _opacityAnimation(List<double> opacityAnimationWeights) {\n    const startOpacity = 0.0;\n    const endOpacity = 1.0;\n    return TweenSequence<double>(<TweenSequenceItem<double>>[\n      TweenSequenceItem<double>(\n        tween: ConstantTween<double>(startOpacity),\n        weight: opacityAnimationWeights[0],\n      ),\n      TweenSequenceItem<double>(\n        tween: Tween<double>(begin: startOpacity, end: endOpacity),\n        weight: opacityAnimationWeights[1],\n      ),\n      TweenSequenceItem<double>(\n        tween: ConstantTween<double>(endOpacity),\n        weight: opacityAnimationWeights[2],\n      ),\n    ]);\n  }\n\n  void _updatePositions() {\n    final itemPositions =\n        primary.itemPositionsNotifier.itemPositions.value.where(\n      (position) =>\n          position.itemLeadingEdge < 1 && position.itemTrailingEdge > 0,\n    );\n    if (itemPositions.isNotEmpty) {\n      PageStorage.of(context).writeState(\n        context,\n        itemPositions.reduce(\n          (value, element) =>\n              value.itemLeadingEdge < element.itemLeadingEdge ? value : element,\n        ),\n      );\n    }\n    widget.itemPositionsNotifier?.itemPositions.value = itemPositions;\n  }\n}"}, {"structure_type": "function", "name": "updateRenderObject", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 70, "line_from": 70, "line_to": 348, "snippet": "  void updateRenderObject(\n    BuildContext context,\n    CustomRenderShrinkWrappingViewport renderObject,\n  ) {\n    renderObject\n      ..axisDirection = axisDirection\n      ..crossAxisDirection = crossAxisDirection ??\n          Viewport.getDefaultCrossAxisDirection(context, axisDirection)\n      ..anchor = anchor\n      ..offset = offset\n      ..cacheExtent = cacheExtent\n      ..cacheExtentStyle = cacheExtentStyle\n      ..clipBehavior = clipBehavior;\n  }\n}\n\n/// A render object that is bigger on the inside and shrink wraps its children\n/// in the main axis.\n///\n/// [RenderShrinkWrappingViewport] displays a subset of its children according\n/// to its own dimensions and the given [offset]. As the offset varies, different\n/// children are visible through the viewport.\n///\n/// [RenderShrinkWrappingViewport] differs from [RenderViewport] in that\n/// [RenderViewport] expands to fill the main axis whereas\n/// [RenderShrinkWrappingViewport] sizes itself to match its children in the\n/// main axis. This shrink wrapping behavior is expensive because the children,\n/// and hence the viewport, could potentially change size whenever the [offset]\n/// changes (e.g., because of a collapsing header).\n///\n/// [RenderShrinkWrappingViewport] cannot contain [RenderBox] children directly.\n/// Instead, use a [RenderSliverList], [RenderSliverFixedExtentList],\n/// [RenderSliverGrid], or a [RenderSliverToBoxAdapter], for example.\n///\n/// See also:\n///\n///  * [RenderViewport], a viewport that does not shrink-wrap its contents.\n///  * [RenderSliver], which explains more about the Sliver protocol.\n///  * [RenderBox], which explains more about the Box protocol.\n///  * [RenderSliverToBoxAdapter], which allows a [RenderBox] object to be\n///    placed inside a [RenderSliver] (the opposite of this class).\nclass CustomRenderShrinkWrappingViewport extends CustomRenderViewport {\n  /// Creates a viewport (for [RenderSliver] objects) that shrink-wraps its\n  /// contents.\n  ///\n  /// The [offset] must be specified. For testing purposes, consider passing a\n  /// [ViewportOffset.zero] or [ViewportOffset.fixed].\n  CustomRenderShrinkWrappingViewport({\n    super.axisDirection,\n    required super.crossAxisDirection,\n    required super.offset,\n    double anchor = 0.0,\n    super.children,\n    super.center,\n    super.cacheExtent,\n  }) : _anchor = anchor;\n\n  double _anchor;\n\n  @override\n  double get anchor => _anchor;\n\n  @override\n  bool get sizedByParent => false;\n\n  double lastMainAxisExtent = -1;\n\n  @override\n  set anchor(double value) {\n    if (value == _anchor) return;\n    _anchor = value;\n    markNeedsLayout();\n  }\n\n  late double _shrinkWrapExtent;\n\n  /// This value is set during layout based on the [CacheExtentStyle].\n  ///\n  /// When the style is [CacheExtentStyle.viewport], it is the main axis extent\n  /// of the viewport multiplied by the requested cache extent, which is still\n  /// expressed in pixels.\n  double? _calculatedCacheExtent;\n\n  /// While List in a wrapping container, eg. ListView\uff0cthe mainAxisExtent will\n  /// be infinite. This time need to change mainAxisExtent to this value.\n  final double _maxMainAxisExtent = double.maxFinite;\n\n  @override\n  void performLayout() {\n    if (center == null) {\n      assert(firstChild == null);\n      _minScrollExtent = 0.0;\n      _maxScrollExtent = 0.0;\n      _hasVisualOverflow = false;\n      offset.applyContentDimensions(0, 0);\n      return;\n    }\n\n    assert(center!.parent == this);\n\n    final BoxConstraints constraints = this.constraints;\n    if (firstChild == null) {\n      switch (axis) {\n        case Axis.vertical:\n          assert(constraints.hasBoundedWidth);\n          size = Size(constraints.maxWidth, constraints.minHeight);\n        case Axis.horizontal:\n          assert(constraints.hasBoundedHeight);\n          size = Size(constraints.minWidth, constraints.maxHeight);\n      }\n      offset.applyViewportDimension(0);\n      _maxScrollExtent = 0.0;\n      _shrinkWrapExtent = 0.0;\n      _hasVisualOverflow = false;\n      offset.applyContentDimensions(0, 0);\n      return;\n    }\n\n    double mainAxisExtent;\n    final double crossAxisExtent;\n    switch (axis) {\n      case Axis.vertical:\n        assert(constraints.hasBoundedWidth);\n        mainAxisExtent = constraints.maxHeight;\n        crossAxisExtent = constraints.maxWidth;\n      case Axis.horizontal:\n        assert(constraints.hasBoundedHeight);\n        mainAxisExtent = constraints.maxWidth;\n        crossAxisExtent = constraints.maxHeight;\n    }\n\n    if (mainAxisExtent.isInfinite) {\n      mainAxisExtent = _maxMainAxisExtent;\n    }\n\n    final centerOffsetAdjustment = center!.centerOffsetAdjustment;\n\n    double correction = 0;\n    double effectiveExtent = 0;\n    do {\n      correction = _attemptLayout(\n        mainAxisExtent,\n        crossAxisExtent,\n        offset.pixels + centerOffsetAdjustment,\n      );\n      if (correction != 0.0) {\n        offset.correctBy(correction);\n      } else {\n        switch (axis) {\n          case Axis.vertical:\n            effectiveExtent = constraints.constrainHeight(_shrinkWrapExtent);\n          case Axis.horizontal:\n            effectiveExtent = constraints.constrainWidth(_shrinkWrapExtent);\n        }\n        // *** Difference from [RenderViewport].\n        final top = _minScrollExtent + mainAxisExtent * anchor;\n        final bottom = _maxScrollExtent - mainAxisExtent * (1.0 - anchor);\n\n        final double maxScrollOffset = math.max(math.min(0, top), bottom);\n        final double minScrollOffset = math.min(top, maxScrollOffset);\n\n        final bool didAcceptViewportDimension =\n            offset.applyViewportDimension(effectiveExtent);\n        final bool didAcceptContentDimension =\n            offset.applyContentDimensions(minScrollOffset, maxScrollOffset);\n        if (didAcceptViewportDimension && didAcceptContentDimension) {\n          break;\n        }\n      }\n    } while (int.tryParse(\"1\") == 1);\n    switch (axis) {\n      case Axis.vertical:\n        size =\n            constraints.constrainDimensions(crossAxisExtent, effectiveExtent);\n      case Axis.horizontal:\n        size =\n            constraints.constrainDimensions(effectiveExtent, crossAxisExtent);\n    }\n  }\n\n  double _attemptLayout(\n    double mainAxisExtent,\n    double crossAxisExtent,\n    double correctedOffset,\n  ) {\n    assert(!mainAxisExtent.isNaN);\n    assert(mainAxisExtent >= 0.0);\n    assert(crossAxisExtent.isFinite);\n    assert(crossAxisExtent >= 0.0);\n    assert(correctedOffset.isFinite);\n    _minScrollExtent = 0.0;\n    _maxScrollExtent = 0.0;\n    _hasVisualOverflow = false;\n    _shrinkWrapExtent = 0.0;\n\n    // centerOffset is the offset from the leading edge of the RenderViewport\n    // to the zero scroll offset (the line between the forward slivers and the\n    // reverse slivers).\n    final centerOffset = mainAxisExtent * anchor - correctedOffset;\n    final reverseDirectionRemainingPaintExtent =\n        centerOffset.clamp(0.0, mainAxisExtent);\n    final forwardDirectionRemainingPaintExtent =\n        (mainAxisExtent - centerOffset).clamp(0.0, mainAxisExtent);\n\n    switch (cacheExtentStyle) {\n      case CacheExtentStyle.pixel:\n        _calculatedCacheExtent = cacheExtent;\n      case CacheExtentStyle.viewport:\n        _calculatedCacheExtent = mainAxisExtent * cacheExtent!;\n    }\n\n    final fullCacheExtent = mainAxisExtent + 2 * _calculatedCacheExtent!;\n    final centerCacheOffset = centerOffset + _calculatedCacheExtent!;\n    final reverseDirectionRemainingCacheExtent =\n        centerCacheOffset.clamp(0.0, fullCacheExtent);\n    final forwardDirectionRemainingCacheExtent =\n        (fullCacheExtent - centerCacheOffset).clamp(0.0, fullCacheExtent);\n\n    final leadingNegativeChild = childBefore(center!);\n\n    if (leadingNegativeChild != null) {\n      // negative scroll offsets\n      final result = layoutChildSequence(\n        child: leadingNegativeChild,\n        scrollOffset: math.max(mainAxisExtent, centerOffset) - mainAxisExtent,\n        overlap: 0,\n        layoutOffset: forwardDirectionRemainingPaintExtent,\n        remainingPaintExtent: reverseDirectionRemainingPaintExtent,\n        mainAxisExtent: mainAxisExtent,\n        crossAxisExtent: crossAxisExtent,\n        growthDirection: GrowthDirection.reverse,\n        advance: childBefore,\n        remainingCacheExtent: reverseDirectionRemainingCacheExtent,\n        cacheOrigin: (mainAxisExtent - centerOffset)\n            .clamp(-_calculatedCacheExtent!, 0.0),\n      );\n      if (result != 0.0) return -result;\n    }\n\n    // positive scroll offsets\n    return layoutChildSequence(\n      child: center,\n      scrollOffset: math.max(0, -centerOffset),\n      overlap: leadingNegativeChild == null ? math.min(0, -centerOffset) : 0.0,\n      layoutOffset: centerOffset >= mainAxisExtent\n          ? centerOffset\n          : reverseDirectionRemainingPaintExtent,\n      remainingPaintExtent: forwardDirectionRemainingPaintExtent,\n      mainAxisExtent: mainAxisExtent,\n      crossAxisExtent: crossAxisExtent,\n      growthDirection: GrowthDirection.forward,\n      advance: childAfter,\n      remainingCacheExtent: forwardDirectionRemainingCacheExtent,\n      cacheOrigin: centerOffset.clamp(-_calculatedCacheExtent!, 0.0),\n    );\n  }\n\n  @override\n  bool get hasVisualOverflow => _hasVisualOverflow;\n\n  @override\n  void updateOutOfBandData(\n    GrowthDirection growthDirection,\n    SliverGeometry childLayoutGeometry,\n  ) {\n    switch (growthDirection) {\n      case GrowthDirection.forward:\n        _maxScrollExtent += childLayoutGeometry.scrollExtent;\n      case GrowthDirection.reverse:\n        _minScrollExtent -= childLayoutGeometry.scrollExtent;\n    }\n    if (childLayoutGeometry.hasVisualOverflow) _hasVisualOverflow = true;\n    _shrinkWrapExtent += childLayoutGeometry.maxPaintExtent;\n    growSize = _shrinkWrapExtent;\n  }\n\n  @override\n  String labelForChild(int index) => 'child $index';\n}"}, {"structure_type": "function", "name": "slivers.where", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 404, "line_from": 404, "line_to": 551, "snippet": "              slivers.where((Widget child) => child.key == center).length == 1,\n        ),\n        assert(\n          cacheExtentStyle != CacheExtentStyle.viewport || cacheExtent != null,\n        ),\n        super(children: slivers);\n\n  /// The direction in which the [offset]'s [ViewportOffset.pixels] increases.\n  ///\n  /// For example, if the [axisDirection] is [AxisDirection.down], a scroll\n  /// offset of zero is at the top of the viewport and increases towards the\n  /// bottom of the viewport.\n  final AxisDirection axisDirection;\n\n  /// The direction in which child should be laid out in the cross axis.\n  ///\n  /// If the [axisDirection] is [AxisDirection.down] or [AxisDirection.up], this\n  /// property defaults to [AxisDirection.left] if the ambient [Directionality]\n  /// is [TextDirection.rtl] and [AxisDirection.right] if the ambient\n  /// [Directionality] is [TextDirection.ltr].\n  ///\n  /// If the [axisDirection] is [AxisDirection.left] or [AxisDirection.right],\n  /// this property defaults to [AxisDirection.down].\n  final AxisDirection? crossAxisDirection;\n\n  /// The relative position of the zero scroll offset.\n  ///\n  /// For example, if [anchor] is 0.5 and the [axisDirection] is\n  /// [AxisDirection.down] or [AxisDirection.up], then the zero scroll offset is\n  /// vertically centered within the viewport. If the [anchor] is 1.0, and the\n  /// [axisDirection] is [AxisDirection.right], then the zero scroll offset is\n  /// on the left edge of the viewport.\n  final double anchor;\n\n  /// Which part of the content inside the viewport should be visible.\n  ///\n  /// The [ViewportOffset.pixels] value determines the scroll offset that the\n  /// viewport uses to select which part of its content to display. As the user\n  /// scrolls the viewport, this value changes, which changes the content that\n  /// is displayed.\n  ///\n  /// Typically a [ScrollPosition].\n  final ViewportOffset offset;\n\n  /// The first child in the [GrowthDirection.forward] growth direction.\n  ///\n  /// Children after [center] will be placed in the [axisDirection] relative to\n  /// the [center]. Children before [center] will be placed in the opposite of\n  /// the [axisDirection] relative to the [center].\n  ///\n  /// The [center] must be the key of a child of the viewport.\n  final Key? center;\n\n  /// {@macro flutter.rendering.RenderViewportBase.cacheExtent}\n  ///\n  /// See also:\n  ///\n  ///  * [cacheExtentStyle], which controls the units of the [cacheExtent].\n  final double? cacheExtent;\n\n  /// {@macro flutter.rendering.RenderViewportBase.cacheExtentStyle}\n  final CacheExtentStyle cacheExtentStyle;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Given a [BuildContext] and an [AxisDirection], determine the correct cross\n  /// axis direction.\n  ///\n  /// This depends on the [Directionality] if the `axisDirection` is vertical;\n  /// otherwise, the default cross axis direction is downwards.\n  static AxisDirection getDefaultCrossAxisDirection(\n    BuildContext context,\n    AxisDirection axisDirection,\n  ) {\n    switch (axisDirection) {\n      case AxisDirection.up:\n        assert(\n          debugCheckHasDirectionality(\n            context,\n            why:\n                \"to determine the cross-axis direction when the viewport has an 'up' axisDirection\",\n            alternative:\n                \"Alternatively, consider specifying the 'crossAxisDirection' argument on the Viewport.\",\n          ),\n        );\n        return textDirectionToAxisDirection(Directionality.of(context));\n      case AxisDirection.right:\n        return AxisDirection.down;\n      case AxisDirection.down:\n        assert(\n          debugCheckHasDirectionality(\n            context,\n            why:\n                \"to determine the cross-axis direction when the viewport has a 'down' axisDirection\",\n            alternative:\n                \"Alternatively, consider specifying the 'crossAxisDirection' argument on the Viewport.\",\n          ),\n        );\n        return textDirectionToAxisDirection(Directionality.of(context));\n      case AxisDirection.left:\n        return AxisDirection.down;\n    }\n  }\n\n  @override\n  CustomRenderViewport createRenderObject(BuildContext context);\n\n  @override\n  ViewportElement createElement() => ViewportElement(this);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty<AxisDirection>('axisDirection', axisDirection))\n      ..add(\n        EnumProperty<AxisDirection>(\n          'crossAxisDirection',\n          crossAxisDirection,\n          defaultValue: null,\n        ),\n      )\n      ..add(DoubleProperty('anchor', anchor))\n      ..add(DiagnosticsProperty<ViewportOffset>('offset', offset));\n    if (center != null) {\n      properties.add(DiagnosticsProperty<Key>('center', center));\n    } else if (children.isNotEmpty && children.first.key != null) {\n      properties.add(\n        DiagnosticsProperty<Key>(\n          'center',\n          children.first.key,\n          tooltip: 'implicit',\n        ),\n      );\n    }\n    properties\n      ..add(DiagnosticsProperty<double>('cacheExtent', cacheExtent))\n      ..add(\n        DiagnosticsProperty<CacheExtentStyle>(\n          'cacheExtentStyle',\n          cacheExtentStyle,\n        ),\n      );\n  }\n}"}, {"structure_type": "function", "name": "mount", "docstring": "", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 565, "line_from": 565, "line_to": 612, "snippet": "  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    _updateCenter();\n  }\n\n  @override\n  void update(MultiChildRenderObjectWidget newWidget) {\n    super.update(newWidget);\n    _updateCenter();\n  }\n\n  void _updateCenter() {\n    if (widget.center != null) {\n      renderObject.center = children\n          .singleWhere((Element element) => element.widget.key == widget.center)\n          .renderObject as RenderSliver?;\n    } else if (children.isNotEmpty) {\n      renderObject.center = children.first.renderObject as RenderSliver?;\n    } else {\n      renderObject.center = null;\n    }\n  }\n\n  @override\n  void debugVisitOnstageChildren(ElementVisitor visitor) {\n    children.where((Element e) {\n      final RenderSliver renderSliver = e.renderObject! as RenderSliver;\n      return renderSliver.geometry!.visible;\n    }).forEach(visitor);\n  }\n}\n\nclass CustomSliverPhysicalContainerParentData\n    extends SliverPhysicalContainerParentData {\n  /// The position of the child relative to the zero scroll offset.\n  ///\n  /// The number of pixels from from the zero scroll offset of the parent sliver\n  /// (the line at which its [SliverConstraints.scrollOffset] is zero) to the\n  /// side of the child closest to that offset. A [layoutOffset] can be null\n  /// when it cannot be determined. The value will be set after layout.\n  ///\n  /// In a typical list, this does not change as the parent is scrolled.\n  ///\n  /// Defaults to null.\n  double? layoutOffset;\n\n  GrowthDirection? growthDirection;\n}"}, {"structure_type": "function", "name": "child;", "docstring": "The widget below this widget in the tree.", "module": "src", "file_path": "core/external_libs/scrollable_positioned_list/src/post_mount_callback.dart", "file_name": "post_mount_callback.dart", "line": 13, "line_from": 13, "line_to": 34, "snippet": "  final Widget child;\n\n  /// Callback to call when the element for this widget is mounted.\n  final void Function()? callback;\n\n  @override\n  StatelessElement createElement() => _PostMountCallbackElement(this);\n\n  @override\n  Widget build(BuildContext context) => child;\n}\n\nclass _PostMountCallbackElement extends StatelessElement {\n  _PostMountCallbackElement(PostMountCallback super.widget);\n\n  @override\n  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    final PostMountCallback postMountCallback = widget as PostMountCallback;\n    postMountCallback.callback?.call();\n  }\n}"}, {"structure_type": "function", "name": "dismiss", "docstring": "", "module": "services", "file_path": "core/external_libs/services/keyboard_service.dart", "file_name": "keyboard_service.dart", "line": 24, "line_from": 24, "line_to": 43, "snippet": "  static void dismiss({BuildContext? context, FocusNode? focusNode}) =>\n      catchVoid(() {\n        final BuildContext anyContext = (context != null && context.mounted)\n            ? context\n            : QuranMajeed.globalContext;\n\n        if (!isVisible(anyContext)) return;\n\n        SystemChannels.textInput.invokeMethod<void>('TextInput.hide');\n\n        // Focus handling\n        if (focusNode != null) {\n          if (focusNode.hasFocus || focusNode.hasPrimaryFocus) {\n            focusNode.unfocus();\n          }\n        } else {\n          FocusScope.of(anyContext).unfocus();\n        }\n      });\n}"}, {"structure_type": "function", "name": "toggleLoading", "docstring": "", "module": "base", "file_path": "core/base/base_presenter.dart", "file_name": "base_presenter.dart", "line": 19, "line_from": 19, "line_to": 96, "snippet": "  Future<void> toggleLoading({required bool loading});\n\n  // Function to add user message\n  Future<void> addUserMessage(String message);\n\n  // Function to handle stream events\n  @protected\n  Future<void> handleStreamEvents<T>({\n    required Stream<Either<String, T>> stream,\n    required void Function(T) onData,\n    required StreamSubscription<Either<String, T>>? subscription,\n  }) async {\n    await subscription?.cancel();\n    subscription = stream.listen(\n      (result) => result.fold(addUserMessage, onData),\n      onError: (Object e) => logDebugStatic('Error in handleStreamEvents:', e.toString()),\n      onDone: () async => subscription?.cancel(),\n    );\n  }\n\n  // Function to execute a task with loading state\n  @protected\n  Future<void> executeTaskWithLoading(FutureOr<void> Function() task) async {\n    await toggleLoading(loading: true);\n    await task();\n    await toggleLoading(loading: false);\n  }\n\n  // Function to execute a use case that only shows a message\n  @protected\n  Future<void> executeMessageOnlyUseCase(\n    FutureOr<Either<String, String>> Function() task, {\n    bool showMessage = true,\n    VoidCallback? onSuccess,\n  }) async {\n    await toggleLoading(loading: true);\n    final Either<String, String> result = await task();\n    await result.fold(addUserMessage, (message) async {\n      if (showMessage) await addUserMessage(message);\n      onSuccess?.call();\n    });\n    await toggleLoading(loading: false);\n  }\n\n  // Function to parse data from Either with user message\n  @protected\n  Future<void> parseDataFromEitherWithUserMessage<T>({\n    required FutureOr<Either<String, T>> Function() task,\n    required void Function(T) onDataLoaded,\n    bool showLoading = false,\n    T? valueOnError,\n  }) async {\n    if (showLoading) await toggleLoading(loading: true);\n    final Either<String, T> result = await task();\n    result.fold(\n      (message) {\n        addUserMessage(message);\n        if (valueOnError != null) onDataLoaded(valueOnError);\n      },\n      onDataLoaded,\n    );\n    if (showLoading) await toggleLoading(loading: false);\n  }\n\n  // Function to map data from Either with user message\n  @protected\n  Future<T?> mapDataFromEitherWithUserMessage<T>({\n    required FutureOr<Either<String, T>> Function() task,\n    bool showLoading = false,\n  }) async {\n    T? data;\n    if (showLoading) await toggleLoading(loading: true);\n    final Either<String, T> result = await task();\n    if (showLoading) await toggleLoading(loading: false);\n    result.fold(addUserMessage, (d) => data = d);\n    return data;\n  }\n}"}, {"structure_type": "function", "name": "BaseUiState>", "docstring": "", "module": "utility", "file_path": "core/utility/ui_helper.dart", "file_name": "ui_helper.dart", "line": 18, "line_from": 18, "line_to": 142, "snippet": "  static Future<void> onMessage<T extends BaseUiState>(\n    Obs<T> uiStateStream,\n  ) async {\n    StreamSubscription<T>? subscription;\n    await doOnPageLoaded(() {\n      try {\n        subscription = uiStateStream.listen(\n          (uiState) => showMessage(message: uiState.userMessage),\n          onDone: () => subscription?.cancel(),\n          onError: (e) => subscription?.cancel(),\n          cancelOnError: true,\n        );\n      } catch (e) {\n        logErrorStatic(e, _fileName);\n        subscription?.cancel();\n        subscription = null;\n      }\n    });\n  }\n\n  static bool onScrollNotification({\n    required ScrollNotification scrollNotification,\n    required void Function({required bool toTop}) onScrolled,\n  }) {\n    if (scrollNotification is! ScrollUpdateNotification) return false;\n    final bool reachedAtTop = scrollNotification.metrics.pixels == 0;\n    onScrolled(toTop: reachedAtTop);\n    return false;\n  }\n\n  static Future<void> doOnPageLoaded(void Function() onLoaded) async {\n    // Takes a callback function onLoaded as a parameter. When called, this\n    // method schedules the onLoaded callback to be executed after the current\n    // frame has finished rendering, by adding it to the end of the post-frame\n    // callbacks list using WidgetsBinding.instance.addPostFrameCallback.\n    //\n    // To add a slight delay to the execution of the onLoaded callback, the\n    // method also uses Future.delayed to wait for 64 milliseconds before\n    // invoking the callback. The entire method is wrapped in a\n    // catchFutureOrVoid function which catches any exceptions thrown during the\n    // execution of the callback and handles them appropriately.\n    await catchFutureOrVoid(() async {\n      WidgetsBinding.instance.addPostFrameCallback((timeStamp) async {\n        onLoaded();\n      });\n    });\n  }\n\n  static void doOnPageDestroy(VoidCallback onDestroy) {\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      onDestroy();\n    });\n  }\n\n  static Future<void> toggleFullScreen({required bool makeFullScreen}) async {\n    await catchFutureOrVoid(() async {\n      await SystemChrome.setEnabledSystemUIMode(\n        SystemUiMode.manual,\n        overlays: makeFullScreen ? [] : SystemUiOverlay.values,\n      );\n    });\n  }\n\n  /// Listens to the scroll events and triggers the provided callback function when scrolled.\n  ///\n  /// The [scrollController] is an instance of [ItemScrollController] that controls the scrolling behavior.\n  /// The [onScrolled] is a callback function that takes a boolean parameter [toTop] indicating whether the scroll is towards the top or not.\n  ///\n  /// Example usage:\n  /// ```dart\n  /// await UiHelper.listenToScroll(\n  ///   scrollController: myScrollController,\n  ///   onScrolled: ({required bool toTop}) {\n  ///     // Handle scroll event\n  ///   },\n  /// );\n  /// ```\n  static Future<void> listenToScroll({\n    required ItemScrollController scrollController,\n    required void Function({required bool toTop}) onScrolled,\n  }) async {\n    await UiHelper.doOnPageLoaded(() async {\n      onScrolled(toTop: false);\n\n      if (!scrollController.isAttached) return;\n      final ScrollController? rootScrollController =\n          scrollController.scrollController;\n      if (rootScrollController == null) return;\n      if (!rootScrollController.hasClients) return;\n\n      rootScrollController.addListener(() {\n        Throttle.throttle(\n          _onListScrollingToTopThrottleTag,\n          480.inMilliseconds,\n          () {\n            final bool scrollingFromBottomToTop =\n                rootScrollController.position.userScrollDirection.name ==\n                    'reverse';\n            onScrolled(toTop: scrollingFromBottomToTop);\n          },\n        );\n      });\n    });\n  }\n\n  static const String _onListScrollingToTopThrottleTag =\n      'onListScrollingToTopThrottleTag';\n}\n\nclass UpgradeAppDialogContainer extends StatelessWidget {\n  const UpgradeAppDialogContainer({\n    super.key,\n    required this.child,\n  });\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    return UpgradeAlert(\n      upgrader: Upgrader(),\n      child: child,\n    );\n  }\n}"}, {"structure_type": "function", "name": "logError", "docstring": "Logs an error message with the provided [exception].\n\nIf [showLog] is false, nothing will be logged.\n\nExample usage:\n\n```dart\n\nfinal error = Exception('Something went wrong');\nthis.logError();\n\n[MyClass] [ERROR] - 2023-04-08 11:30:00\nException: Something went wrong\n#0 main (file:///path/to/main.dart:10:11)\n\n```\n", "module": "utility", "file_path": "core/utility/logger_utility.dart", "file_name": "logger_utility.dart", "line": 122, "line_from": 122, "line_to": 171, "snippet": "  void logError(Object? exception) {\n    // to avoid runtimeType.toString() in release mode\n    // as this can hamper performance, we use showLog\n    // to check if we are in debug mode or not\n    if (!showLog) return;\n    // we are logging only in debug mode, so the performance hit can be ignored\n    // ignore: no_runtimeType_toString\n    logErrorStatic(exception, runtimeType.toString());\n  }\n\n  /// Logs a debug message with the provided [object].\n  ///\n  /// If [showLog] is false, nothing will be logged.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  ///\n  /// this.logDebug('This is a debug message');\n  ///\n  /// [MyClass] [DEBUG] - 2023-04-08 11:30:00\n  /// This is a debug message\n  ///\n  /// ```\n  ///\n  void logDebug(Object object) {\n    // to avoid runtimeType.toString() in release mode\n    // as this can hamper performance, we use showLog\n    // to check if we are in debug mode or not\n    if (!showLog) return;\n    // we are logging only in debug mode, so the performance hit can be ignored\n    // ignore: no_runtimeType_toString\n    logDebugStatic(object, runtimeType.toString());\n  }\n}\n\n/// A utility class for logging messages\nclass Logger {\n  static void info(String message, [String tag = '']) {\n    logInfoStatic(message, tag);\n  }\n\n  static void error(String message, [String tag = '']) {\n    logErrorStatic(message, tag);\n  }\n\n  static void debug(String message, [String tag = '']) {\n    logDebugStatic(message, tag);\n  }\n}"}, {"structure_type": "function", "name": "navigatorPush<T>", "docstring": "", "module": "utility", "file_path": "core/utility/utility.dart", "file_name": "utility.dart", "line": 44, "line_from": 44, "line_to": 158, "snippet": "  Future<T?> navigatorPush<T>(Widget page) async {\n    try {\n      if (!mounted) return null;\n      final CupertinoPageRoute<T> route =\n          CupertinoPageRoute<T>(builder: (context) => page);\n      return Navigator.push<T>(this, route);\n    } catch (e) {\n      logError(\"Failed to navigate to ${e.runtimeType} -> $e\");\n      return null;\n    }\n  }\n\n  // Generic navigation method with custom transition\n  void customNavigatorPush(BuildContext context, Widget nextPage) {\n    Navigator.push(\n      context,\n      PageRouteBuilder(\n        transitionDuration: const Duration(milliseconds: 500),\n        pageBuilder: (context, animation, secondaryAnimation) => nextPage,\n        transitionsBuilder: (context, animation, secondaryAnimation, child) {\n          Offset begin = const Offset(0.0, 1.0);\n          Offset end = Offset.zero;\n          Tween<Offset> tween = Tween(begin: begin, end: end);\n          Animation<Offset> offsetAnimation = animation.drive(tween);\n\n          return SlideTransition(\n            position: offsetAnimation,\n            child: child,\n          );\n        },\n      ),\n    );\n  }\n\n  Future<T?> navigatorPushReplacement<T>(Widget page) async {\n    try {\n      if (!mounted) return null;\n      final CupertinoPageRoute<T> route =\n          CupertinoPageRoute<T>(builder: (context) => page);\n      return Navigator.pushReplacement(this, route);\n    } catch (e) {\n      logError(\"Failed to navigate to ${e.runtimeType} -> $e\");\n      return null;\n    }\n  }\n\n  Future<T?> showBottomSheetLegacy<T>(Widget bottomSheet) async {\n    return Get.bottomSheet<T>(\n      bottomSheet,\n      isScrollControlled: true,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n    );\n  }\n\n  Future<T?> showBottomSheet<T>(\n    Widget bottomSheet,\n    BuildContext context,\n  ) async {\n    if (!mounted) return null;\n    final T? result = await showModalBottomSheet<T>(\n      context: context,\n      builder: (_) => bottomSheet,\n      backgroundColor: Colors.transparent,\n      isScrollControlled: true,\n      enableDrag: true,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n    );\n    return result;\n  }\n\n  void navigatorPop<T>({T? result}) {\n    if (!mounted) return;\n    Navigator.pop(this, result);\n  }\n}\n\nFuture<T?> showSlideDownDialog<T>({\n  required Widget content,\n  required BuildContext context,\n  bool barrierDismissible = true,\n  Duration transitionDuration = const Duration(milliseconds: 300),\n  Color? barrierColor,\n}) async {\n  if (!context.mounted) return null;\n\n  final T? result = await showGeneralDialog<T>(\n    context: context,\n    barrierDismissible: barrierDismissible,\n    barrierColor: barrierColor ?? Colors.black.withOpacityInt(0.4),\n    barrierLabel: '',\n    transitionDuration: transitionDuration,\n    transitionBuilder: (context, animation, __, Widget child) {\n      return SlideTransition(\n        position: Tween<Offset>(\n          begin: const Offset(0, -1), // Top to bottom\n          end: Offset.zero,\n        ).animate(animation),\n        child: child,\n      );\n    },\n    pageBuilder: (context, animation, __) => content,\n  );\n\n  return result;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "utility", "file_path": "core/utility/utility.dart", "file_name": "utility.dart", "line": 1286, "line_from": 1286, "line_to": 1314, "snippet": "  required void Function(String) onError,\n}) async {\n  try {\n    if (!await file.exists()) {\n      onError(\"Downloaded file is incomplete. Please try again.\");\n      return false;\n    }\n\n    // Try to read the first few bytes to verify file integrity\n    try {\n      await file.openRead(0, 1024).first;\n      return true;\n    } catch (e) {\n      logErrorStatic(\"Error validating file integrity: $e\", \"FileValidation\");\n      await file.delete();\n      if (context?.mounted ?? false) {\n        onError(\"Downloaded file is corrupted. Please try again.\");\n      }\n      return false;\n    }\n  } catch (e) {\n    logErrorStatic(\"Error validating downloaded file: $e\", \"FileValidation\");\n    await file.delete();\n    if (context?.mounted ?? false) {\n      onError(\"Failed to validate downloaded file. Please try again.\");\n    }\n    return false;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "nuzul", "file_path": "data/repository/nuzul/nuzul_repository_impl.dart", "file_name": "nuzul_repository_impl.dart", "line": 78, "line_from": 78, "line_to": 95, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _remoteDataSource.downloadResourceDatabase(\n        fileName: _nuzulDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Nuzul database download was cancelled', 'NuzulRepositoryImpl');\n        rethrow;\n      }\n      logErrorStatic('Error downloading nuzul database: $e', 'NuzulRepositoryImpl');\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "getAllPages", "docstring": "", "module": "page", "file_path": "data/repository/page/page_repository_impl.dart", "file_name": "page_repository_impl.dart", "line": 14, "line_from": 14, "line_to": 37, "snippet": "  Future<Either<String, List<PageEntity>>> getAllPages() async {\n    try {\n      final pages = await _localDataSource.getAllPages();\n      final mappedPages = await compute(_mapToEntities, pages);\n      return Right(mappedPages);\n    } catch (e) {\n      return Left(e.toString());\n    }\n  }\n}\n\n// Compute function for mapping PageTableData to PageEntity\nList<PageEntity> _mapToEntities(List<PageTableData> tableData) {\n  return tableData\n      .map((page) => PageEntity(\n            id: page.id,\n            startSurahNo: page.startSurahNo,\n            endSurahNo: page.endSurahNo,\n            startAyatNo: page.startAyatNo,\n            endAyatNo: page.endAyatNo,\n            arabicInitial: page.arabicInitial,\n          ))\n      .toList();\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "grammar", "file_path": "data/repository/grammar/grammar_repository_impl.dart", "file_name": "grammar_repository_impl.dart", "line": 45, "line_from": 45, "line_to": 62, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _remoteDataSource.downloadResourceDatabase(\n        fileName: _grammarDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Grammar database download was cancelled', _tag);\n        rethrow;\n      }\n      logErrorStatic('Error downloading grammar database: $e', _tag);\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation", "file_path": "data/repository/translation/translation_repository_impl.dart", "file_name": "translation_repository_impl.dart", "line": 24, "line_from": 24, "line_to": 38, "snippet": "    required void Function(int percentage) onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await remoteDataSource.downloadDatabase(\n        fileName: fileName,\n        url: downloadLink,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) return;\n      logErrorStatic(\"Error downloading file: $e\", \"TranslationRepositoryImpl\");\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation", "file_path": "data/repository/translation/translation_repository_impl.dart", "file_name": "translation_repository_impl.dart", "line": 43, "line_from": 43, "line_to": 58, "snippet": "    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final dbFile = File(await getDatabaseFilePath(file.fileName));\n\n    if (!await dbFile.exists()) {\n      await _downloadDatabaseFile(\n        fileName: file.fileName,\n        downloadLink: file.link,\n        onProgress: onProgress!,\n        cancelToken: cancelToken,\n      );\n    } else {\n      await selectTranslation(file: file);\n    }\n  }"}, {"structure_type": "function", "name": "searchAcrossTranslations", "docstring": "", "module": "search", "file_path": "data/repository/search/search_repository_impl.dart", "file_name": "search_repository_impl.dart", "line": 27, "line_from": 27, "line_to": 380, "snippet": "  Future<List<SearchResultEntity>> searchAcrossTranslations({\n    required String query,\n    required List<String> databaseFiles,\n    required SearchTypeEntity searchType,\n  }) async {\n    final Map<String, List<Verse>> results = {};\n\n    for (String dbFile in databaseFiles) {\n      if (['bn_bayaan', 'en_sahih'].contains(dbFile)) {\n        try {\n          final List<Verse> verses = await _searchLocalDataSource.searchTranslation(\n            query: query,\n            language: dbFile == 'bn_bayaan' ? 'bn' : 'en',\n            searchType: searchType,\n          );\n          results[dbFile] = verses;\n        } catch (e) {\n          logDebugStatic('Error searching in $dbFile: $e', 'SearchRepositoryImpl');\n          continue;\n        }\n      } else {\n        final database = TranslationDatabase(File(await getDatabaseFilePath(dbFile)));\n        try {\n          final List<Verse> verses = await database.searchVerses(\n            query: query,\n            searchType: searchType,\n          );\n          results[dbFile] = verses;\n        } finally {\n          await database.close();\n        }\n      }\n    }\n\n    return _processResults(results);\n  }\n\n  List<SearchResultEntity> _processResults(Map<String, List<Verse>> results) {\n    final Map<String, Map<String, String>> groupedResults = {};\n\n    results.forEach((String dbFile, List<Verse> verses) {\n      for (Verse verse in verses) {\n        final String key = '${verse.suraId}-${verse.ayahId}';\n        groupedResults.putIfAbsent(key, () => {});\n        if (verse.verseText != null) {\n          groupedResults[key]![dbFile] = verse.verseText!;\n        }\n      }\n    });\n\n    return groupedResults.entries.map((MapEntry<String, Map<String, String>> entry) {\n      final List<String> parts = entry.key.split('-');\n      return SearchResultEntity(\n        surahId: int.parse(parts[0]),\n        ayahId: int.parse(parts[1]),\n        resultText: entry.value,\n      );\n    }).toList();\n  }\n\n  @override\n  Future<List<SearchResultEntity>> searchAcrossTafseers({\n    required String query,\n    required List<String> databaseFiles,\n    required SearchTypeEntity searchType,\n  }) async {\n    final Map<String, List<Map<String, dynamic>>> results = {};\n\n    await Future.wait(databaseFiles.map((dbFile) async {\n      final mainFile = File(await getDatabaseFilePath(dbFile));\n      if (!await mainFile.exists()) {\n        const String assetPath = \"assets/database\";\n        final String dbPath = \"$assetPath/$dbFile.db\";\n        await moveDatabaseFromAssetToInternal(file: mainFile, assetPath: dbPath);\n      }\n      final database = TafseerDatabase(mainFile);\n      try {\n        final TafseerType tafseerType = determineTafseerType(dbFile);\n        switch (tafseerType) {\n          case TafseerType.common:\n            final List<CommonTafseerTableData> tafseer = await database.searchTafsirTextFromCommonTafseerTable(\n              query: query,\n              searchType: searchType,\n            );\n            if (tafseer.isNotEmpty) {\n              results[dbFile] = tafseer.map((t) => t.toJson()).toList();\n            }\n            break;\n          case TafseerType.unique:\n            final List<UniqueTafseerTableData> tafseer = await database.searchTafsirTextFromUniqueTafseerTable(\n              query: query,\n              searchType: searchType,\n            );\n            if (tafseer.isNotEmpty) {\n              results[dbFile] = tafseer.map((t) => t.toJson()).toList();\n            }\n            break;\n        }\n      } finally {\n        await database.close();\n      }\n    }));\n\n    return _processTafseerResults(results, query, searchType);\n  }\n\n  List<SearchResultEntity> _processTafseerResults(\n      Map<String, List<Map<String, dynamic>>> results, String query, SearchTypeEntity searchType) {\n    final Map<String, Map<String, String>> mergedAyahTexts = {};\n\n    for (final MapEntry<String, List<Map<String, dynamic>>> entry in results.entries) {\n      final String dbFile = entry.key;\n      final List<Map<String, dynamic>> tafseer = entry.value;\n\n      for (final Map<String, dynamic> tafsir in tafseer) {\n        final String tafsirText = tafsir['tafsirText'] as String? ?? '';\n        bool shouldInclude = false;\n\n        if (searchType == SearchTypeEntity.exact) {\n          shouldInclude = tafsirText.toLowerCase().contains(query.toLowerCase());\n        } else if (searchType == SearchTypeEntity.normal) {\n          final words = query.split(' ');\n          final validWords = words.where((word) => word.trim().isNotEmpty).toList();\n          if (validWords.isNotEmpty) {\n            shouldInclude = validWords.every(\n              (word) => tafsirText.toLowerCase().contains(word.toLowerCase()),\n            );\n          } else {\n            shouldInclude = tafsirText.isNotEmpty;\n          }\n        } else if (searchType == SearchTypeEntity.partial) {\n          final words = query.split(' ');\n          final validWords = words.where((word) => word.trim().isNotEmpty).toList();\n          if (validWords.isNotEmpty) {\n            shouldInclude = validWords.any(\n              (word) => tafsirText.toLowerCase().contains(word.toLowerCase()),\n            );\n          } else {\n            shouldInclude = tafsirText.isNotEmpty;\n          }\n        }\n\n        if (shouldInclude) {\n          if (tafsir.containsKey('suraId') && tafsir.containsKey('ayahId')) {\n            _processCommonTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n          } else {\n            _processUniqueTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n          }\n        }\n      }\n    }\n\n    return mergedAyahTexts.entries.map((MapEntry<String, Map<String, String>> entry) {\n      final List<String> parts = entry.key.split('_');\n      return SearchResultEntity(\n        surahId: int.parse(parts[0]),\n        ayahId: int.parse(parts[1]),\n        resultText: entry.value,\n      );\n    }).toList();\n  }\n\n  List<SearchResultEntity> mergeResults(Map<String, List<Verse>> results) {\n    final Map<String, SearchResultEntity> mergedResults = {};\n\n    for (final MapEntry<String, List<Verse>> entry in results.entries) {\n      final String dbFile = entry.key;\n      final List<Verse> verses = entry.value;\n\n      for (final Verse verse in verses) {\n        final String key = '${verse.suraId}_${verse.ayahId}';\n\n        if (mergedResults.containsKey(key)) {\n          mergedResults[key]!.resultText[dbFile] = verse.verseText ?? '';\n        } else {\n          mergedResults[key] = SearchResultEntity(\n            surahId: verse.suraId!,\n            ayahId: verse.ayahId!,\n            resultText: {dbFile: verse.verseText ?? ''},\n          );\n        }\n      }\n    }\n\n    return mergedResults.values.toList();\n  }\n\n  List<SearchResultEntity> mergeTafseerResults(Map<String, dynamic> params) {\n    final Map<String, List<Map<String, dynamic>>> results =\n        params['results'] as Map<String, List<Map<String, dynamic>>>;\n    final String query = params['query'] as String;\n\n    final Map<String, Map<String, String>> mergedAyahTexts = {};\n\n    for (final MapEntry<String, List<Map<String, dynamic>>> entry in results.entries) {\n      final String dbFile = entry.key;\n      final List<Map<String, dynamic>> tafseer = entry.value;\n\n      for (final Map<String, dynamic> tafsir in tafseer) {\n        if (tafsir.containsKey('suraId') && tafsir.containsKey('ayahId')) {\n          _processCommonTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n        } else {\n          _processUniqueTafseerJson(tafsir, dbFile, mergedAyahTexts, query);\n        }\n      }\n    }\n\n    return mergedAyahTexts.entries.map((MapEntry<String, Map<String, String>> entry) {\n      final List<String> parts = entry.key.split('_');\n      return SearchResultEntity(\n        surahId: int.parse(parts[0]),\n        ayahId: int.parse(parts[1]),\n        resultText: entry.value,\n      );\n    }).toList();\n  }\n\n  void _processCommonTafseerJson(\n    Map<String, dynamic> tafsir,\n    String dbFile,\n    Map<String, Map<String, String>> mergedAyahTexts,\n    String query,\n  ) {\n    final String key = '${tafsir['suraId']}_${tafsir['ayahId']}';\n    mergedAyahTexts.putIfAbsent(key, () => {});\n\n    final String truncatedText = _getTruncatedTafseerText(\n      text: tafsir['tafsirText'] ?? '',\n      query: query,\n    );\n\n    final String tafseerName = _getTafseerName(dbFile);\n    mergedAyahTexts[key]![tafseerName] = truncatedText;\n  }\n\n  void _processUniqueTafseerJson(\n    Map<String, dynamic> tafsir,\n    String dbFile,\n    Map<String, Map<String, String>> mergedAyahTexts,\n    String query,\n  ) {\n    final int startAyah = tafsir['start'] ?? 1;\n    final int endAyah = tafsir['end'] ?? startAyah;\n    final int suraId = tafsir['suraId'] ?? 1;\n\n    for (int ayahId = startAyah; ayahId <= endAyah; ayahId++) {\n      final String key = '${suraId}_$ayahId';\n      mergedAyahTexts.putIfAbsent(key, () => {});\n\n      final String truncatedText = _getTruncatedTafseerText(\n        text: tafsir['tafsirText'] ?? '',\n        query: query,\n      );\n\n      mergedAyahTexts[key]![dbFile] = truncatedText;\n    }\n  }\n\n  String _getTruncatedTafseerText({\n    required String text,\n    required String query,\n  }) {\n    final int matchIndex = text.toLowerCase().indexOf(query.toLowerCase());\n    if (matchIndex == -1) return text;\n\n    int startIndex = (matchIndex - 100).clamp(0, text.length);\n    int endIndex = (matchIndex + query.length + 100).clamp(0, text.length);\n\n    // Adjust start index to include complete word\n    while (startIndex > 0 && text[startIndex] != ' ') {\n      startIndex--;\n    }\n\n    // Adjust end index to include complete word\n    while (endIndex < text.length && text[endIndex] != ' ') {\n      endIndex++;\n    }\n\n    final String prefix = startIndex > 0 ? '...' : '';\n    final String suffix = endIndex < text.length ? '...' : '';\n\n    return prefix + text.substring(startIndex, endIndex).trim() + suffix;\n  }\n\n  @override\n  Future<List<SearchResultEntity>> searchArabic({\n    required String query,\n    required SearchTypeEntity searchType,\n  }) async {\n    final String normalizedQuery = ArabicTextHighlighter.normalizeArabicString(query);\n    final List<AyahDatabaseTableData> results = await _quranDatabase.searchArabicText(\n      query: normalizedQuery,\n      searchType: searchType,\n    );\n\n    // Process results and get Arabic text for each result\n    final List<SearchResultEntity> searchResults = [];\n    for (final result in results) {\n      final arabicText = await _getArabicTextForSearch(result.surahId as int, result.ayahId as int);\n      searchResults.add(SearchResultEntity(\n        surahId: result.surahId as int,\n        ayahId: result.ayahId as int,\n        resultText: {'arabic': arabicText},\n      ));\n    }\n\n    return searchResults;\n  }\n\n  // Helper method to get Arabic text for search result\n  Future<String> _getArabicTextForSearch(int surahId, int ayahId) async {\n    final wordDbData = await _quranDatabase.getWordsByWordForSpecificAyah(surahId, ayahId);\n\n    // Convert to WordByWordEntity\n    final List<WordByWordEntity> words = wordDbData\n        .map((dbData) => WordByWordEntity(\n              surah: dbData.surah,\n              ayah: dbData.ayah,\n              word: dbData.word,\n              uthmani: dbData.uthmani,\n              indopak: dbData.indopak,\n              en: dbData.en,\n              bn: dbData.bn,\n              clean: dbData.clean,\n              juz: dbData.juz,\n              page: dbData.page,\n              hijb: dbData.hijb,\n              summary: dbData.summary,\n            ))\n        .toList();\n\n    if (words.isEmpty) return '';\n\n    // Get the script from settings (default to uthmani if not available)\n    const isUthmani = true; // Default to uthmani for search\n    return AyahEntity.getArabicTextFromWords(words, isUthmani);\n  }\n\n  // Cache for tafseer name mappings\n  static final Map<String, String> _tafseerNameCache = {};\n\n  String _getTafseerName(String fileName) {\n    // Return cached name if available\n    if (_tafseerNameCache.containsKey(fileName)) {\n      return _tafseerNameCache[fileName]!;\n    }\n\n    // Look up name and cache it\n    final String? name = locate<TafseerPresenter>().getNameOfTafseerFromFileName(fileName: fileName);\n\n    _tafseerNameCache[fileName] = name!;\n    return name;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "info", "file_path": "data/repository/info/info_repository_impl.dart", "file_name": "info_repository_impl.dart", "line": 34, "line_from": 34, "line_to": 51, "snippet": "    required void Function(PromotionalMessageEntity?) onMessage,\n  }) async {\n    await _infoRemoteDataSource.getPromotionalMessage(\n      onMessage: (promotionalMessage) async {\n        final bool shouldPublish = await _infoLocalDataSource.shouldPublishPromotionalMessage(\n          notification: promotionalMessage,\n        );\n\n        if (!shouldPublish) {\n          onMessage(null);\n          return;\n        }\n\n        _notification = promotionalMessage;\n        onMessage(promotionalMessage);\n      },\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "info", "file_path": "data/repository/info/info_repository_impl.dart", "file_name": "info_repository_impl.dart", "line": 143, "line_from": 143, "line_to": 160, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _resourceRemoteDataSource.downloadResourceDatabase(\n        fileName: _infoDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Info database download was cancelled', 'InfoRepositoryImpl');\n        rethrow;\n      }\n      logErrorStatic('Error downloading info database: $e', 'InfoRepositoryImpl');\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "downloadAudioFiles", "docstring": "", "module": "audio", "file_path": "data/repository/audio/audio_repository_impl.dart", "file_name": "audio_repository_impl.dart", "line": 26, "line_from": 26, "line_to": 234, "snippet": "  Future<void> downloadAudioFiles({\n    required int surahID,\n    required Reciter reciter,\n    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    if (cancelToken.isCancelled) return;\n\n    try {\n      final String audioFile = CacheData.audioFiles[surahID]!.audioLink;\n      await _downloadSurahAudio(audioFile, surahID, reciter, onProgress, cancelToken);\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        await _audioLocalDataSource.removeAudioFileFromCache(surahID, ReciterMapper.toDatabase(reciter));\n      }\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> persistSurahAudioPath({\n    required List<int> surahs,\n    required Reciter reciter,\n  }) async {\n    String directoryPath = await getApplicationDirectoryPath();\n\n    for (int surah in surahs) {\n      final String generatedPath = await generateAudioFilePath(surah: surah, reciter: reciter);\n      final String savePath = p.join(directoryPath, generatedPath);\n      await _audioLocalDataSource.persistSurahAudioPath(surah, ReciterMapper.toDatabase(reciter), savePath);\n    }\n  }\n\n  @override\n  Future<AudioFile> getAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  }) async {\n    return await _audioLocalDataSource.getAudioFilesBySurahAndReciter(surahNumber, ReciterMapper.toDatabase(reciter));\n  }\n\n  Future<void> _downloadSurahAudio(\n    String url,\n    int surah,\n    Reciter reciter,\n    void Function(int percentage)? onProgress,\n    CancelToken? cancelToken,\n  ) async {\n    if (cancelToken?.isCancelled ?? false) return;\n\n    try {\n      String filePath = await generateAudioFilePath(surah: surah, reciter: reciter);\n      await _audioRemoteDataSource.fetchAndDownloadAudio(\n        url: url,\n        filePath: filePath,\n        onProgress: onProgress!,\n        cancelToken: cancelToken,\n      );\n      if (!(cancelToken?.isCancelled ?? false)) {\n        await _audioLocalDataSource.persistSurahAudioPath(surah, ReciterMapper.toDatabase(reciter), filePath);\n      }\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        await _audioLocalDataSource.removeAudioFileFromCache(surah, ReciterMapper.toDatabase(reciter));\n      }\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> deleteAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  }) async {\n    final String audioPath = await generateAudioFilePath(surah: surahNumber, reciter: reciter);\n    await _audioLocalDataSource.deleteAudioFilesBySurahAndReciter(\n        surahNumber, ReciterMapper.toDatabase(reciter), audioPath);\n  }\n\n  @override\n  Future<String> generateAudioFilePath({required int surah, required Reciter reciter}) async {\n    String directoryPath = p.join('audio', reciter.name);\n    return p.join(directoryPath, '$surah.mp3');\n  }\n\n  @override\n  Future<String> getAudioPath({required int surah, required Reciter reciter, bool isOnlineStream = false}) async {\n    if (isOnlineStream) {\n      final AudioFile audioFile = CacheData.audioFiles[surah]!;\n      return audioFile.audioLink;\n    }\n    return await _audioLocalDataSource.fetchLocalAudioPath(surah, ReciterMapper.toDatabase(reciter));\n  }\n\n  @override\n  Future<bool> isSurahAudioAvailable({required int surahNumber, required Reciter reciter}) =>\n      _audioLocalDataSource.checkIfSurahAudioDownloaded(surahNumber, ReciterMapper.toDatabase(reciter));\n\n  @override\n  Future<List<VerseTiming>> getVerseTimings({\n    required int surahID,\n    required int reciterID,\n  }) async {\n    try {\n      List<VerseTiming> verseTimings = await _audioLocalDataSource.getVerseTimingsBySurahId(reciterID, surahID);\n      return verseTimings;\n    } catch (e) {\n      logErrorStatic('Error in getVerseTimings: $e', 'AudioRepositoryImpl');\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> playVerseWithDelay(VerseTiming verseTiming, Duration delay) async {\n    try {\n      await AudioPlayerService.playVerseAfterDelay(verseTiming, delay);\n    } catch (e) {\n      logErrorStatic('Error in playVerseWithDelay: $e', 'AudioRepositoryImpl');\n      rethrow;\n    }\n  }\n\n  @override\n  Future<void> playSurahPlaylist() async {\n    await AudioPlayerService.startPlaylistPlayback();\n  }\n\n  @override\n  Future<void> seekAudio(Duration position) async {\n    await AudioPlayerService.seekAudioPosition(position);\n  }\n\n  @override\n  Future<void> addToPlayl1ist({\n    required String audioPath,\n    required String title,\n    bool isOnlineStream = false,\n  }) async {\n    await AudioPlayerService.enqueueAudioToPlaylist(\n      audioPath: audioPath,\n      title: title,\n      isOnlineStream: isOnlineStream,\n    );\n  }\n\n  @override\n  Future<void> clearPlaylist() async {\n    await AudioPlayerService.clearPlaylist();\n  }\n\n  @override\n  Future<void> stopAudio() async {\n    await AudioPlayerService.stopPlayback();\n  }\n\n  @override\n  Future<void> pausePlayback() async {\n    await AudioPlayerService.pausePlayback();\n  }\n\n  @override\n  Future<void> resumePlayback() async {\n    await AudioPlayerService.resumePlayback();\n  }\n\n  @override\n  Future<void> playWordAudio({required WordByWordEntity word}) async {\n    try {\n      if (word.surah == null || word.ayah == null || word.word == null) return;\n\n      final String surahFormatted = word.surah.toString().padLeft(3, '0');\n      final String ayahFormatted = word.ayah.toString().padLeft(3, '0');\n      final String wordFormatted = word.word.toString().padLeft(3, '0');\n\n      final String audioUrl = 'https://verses.quran.com/wbw/${surahFormatted}_${ayahFormatted}_$wordFormatted.mp3';\n\n      await AudioPlayerService.stopPlayback();\n\n      final player = AudioPlayer();\n      try {\n        await player.setAudioSource(\n          AudioSource.uri(\n            Uri.parse(audioUrl),\n            tag: MediaItem(\n              id: audioUrl,\n              title: 'Word Audio',\n              album: 'Quran Majeed',\n            ),\n          ),\n        );\n\n        await player.play();\n\n        player.playerStateStream.listen((state) {\n          if (state.processingState == ProcessingState.completed) {\n            player.dispose();\n          }\n        });\n      } catch (e) {\n        await player.dispose();\n        logErrorStatic('Error playing word audio: $e', 'AudioRepositoryImpl');\n        rethrow;\n      }\n    } catch (e) {\n      logErrorStatic('Error in audio playback: $e', 'AudioRepositoryImpl');\n      rethrow;\n    }\n  }\n}"}, {"structure_type": "function", "name": "getSelectedTafseers", "docstring": "", "module": "tafseer", "file_path": "data/repository/tafseer/tafseer_repository_impl.dart", "file_name": "tafseer_repository_impl.dart", "line": 30, "line_from": 30, "line_to": 241, "snippet": "  Future<Set<String>> getSelectedTafseers() async {\n    final selectedTafseersSerialised = localCacheService.getData(key: CacheKeys.selectedTafseer);\n    if (selectedTafseersSerialised == null) return {};\n    final Set<String> selectedTafseers = Set<String>.from(jsonDecode(selectedTafseersSerialised));\n\n    // Check if the default tafseer should be included\n    final bool includeDefault = localCacheService.getData(key: CacheKeys.includeDefaultTafseer) ?? true;\n    if (includeDefault && !selectedTafseers.contains('en_kathir')) {\n      selectedTafseers.add('en_kathir');\n    }\n\n    return selectedTafseers;\n  }\n\n  @override\n  Future<void> saveSelectedTafseers(Set<String> selectedTafseers) async {\n    final serialisedString = jsonEncode(selectedTafseers.toList());\n    await localCacheService.saveData(key: CacheKeys.selectedTafseer, value: serialisedString);\n\n    // Update the flag for including the default tafseer\n    final bool includeDefault = selectedTafseers.contains('en_kathir');\n    await localCacheService.saveData(key: CacheKeys.includeDefaultTafseer, value: includeDefault);\n  }\n\n  @override\n  Future<void> selectTafseer({\n    required TTDbFileModel file,\n    required int surahID,\n    required TafseerType tafseerType,\n  }) async {\n    final String dbPath = await getDatabaseFilePath(file.fileName);\n    final TafseerDatabase database = TafseerDatabase(File(dbPath));\n    try {\n      switch (tafseerType) {\n        case TafseerType.common:\n          final List<CommonTafseerTableData> tafseer =\n              await tafseerLocalDataSource.getCommonTafseerData(surahID: surahID, database: database);\n          CacheData.tafseerCache[file.fileName] = await _convertCommonTafseerToMap(tafseer);\n     \n          break;\n        case TafseerType.unique:\n          final List<UniqueTafseerTableData> tafseer =\n              await tafseerLocalDataSource.getUniqueTafseerData(surahID: surahID, database: database);\n          CacheData.tafseerCache[file.fileName] = await _convertUniqueTafseerToMap(tafseer, surahID);\n        \n          break;\n      }\n    } catch (e) {\n      logErrorStatic(\"Error in selectTafseer: $e\", \"TafseerRepositoryImpl\");\n      rethrow;\n    }\n  }\n\n  Future<Map<int, Map<int, String>>> _convertCommonTafseerToMap(List<CommonTafseerTableData> tafseer) async {\n    List<Map<String, dynamic>> tafseerData = tafseer\n        .map((item) => {\n              'suraId': item.suraId,\n              'ayahId': item.ayahId,\n              'tafsirText': item.tafsirText,\n            })\n        .toList();\n    return compute(convertCommonTafseerToMapIsolate, tafseerData);\n  }\n\n  Future<Map<int, Map<int, String>>> _convertUniqueTafseerToMap(\n      List<UniqueTafseerTableData> tafseer, int surahId) async {\n    List<Map<String, dynamic>> tafseerData = tafseer\n        .map((item) => {\n              'start': item.start,\n              'end': item.end,\n              'tafsirText': item.tafsirText,\n            })\n        .toList();\n    return compute(\n      convertUniqueTafseerToMapIsolate,\n      {'tafseerData': tafseerData, 'surahId': surahId},\n    );\n  }\n\n  @override\n  List<String> getAvailableTafseers() {\n    final availableTafseersSerialised = localCacheService.getData(key: CacheKeys.availableTafseer);\n    Set<String> availableTafseers;\n\n    if (availableTafseersSerialised == null) {\n      // Initialize with empty set since there are no default tafseers\n      availableTafseers = {};\n      final String serializedString = jsonEncode([]);\n      localCacheService.saveData(key: CacheKeys.availableTafseer, value: serializedString);\n    } else {\n      availableTafseers = Set.from(_convertSerialisedStringToAvailableeTafseers(availableTafseersSerialised));\n      // No need to include default tafseers since they don't exist anymore\n    }\n\n    return availableTafseers.toList();\n  }\n\n  @override\n  Future<void> saveAvailableTafseers({required Set<String> availableTafseers, required String newItem}) async {\n    availableTafseers.add(newItem);\n    final String serialisedString = jsonEncode(availableTafseers.toList());\n    await localCacheService.saveData(key: CacheKeys.availableTafseer, value: serialisedString);\n  }\n\n  @override\n  Future<void> deleteAvailableTafseer({required TTDbFileModel file}) async {\n    final availableeTafseersSerialised = localCacheService.getData(key: CacheKeys.availableTafseer);\n    if (availableeTafseersSerialised == null) return;\n    final List<String> availableeTafseers = _convertSerialisedStringToAvailableeTafseers(availableeTafseersSerialised);\n    availableeTafseers.remove(file.fileName);\n    final String serialisedString = jsonEncode(availableeTafseers);\n    await localCacheService.saveData(key: CacheKeys.availableTafseer, value: serialisedString);\n  }\n\n  @override\n  Future<void> deleteTafseerDatabase({required String fileName}) async {\n    final dbFile = File(await getDatabaseFilePath(fileName));\n    if (await dbFile.exists()) {\n      try {\n        await dbFile.delete();\n      } catch (e) {\n        logErrorStatic(\"Error deleting database: $e\", \"TranslationRepositoryImpl\");\n        rethrow;\n      }\n    }\n  }\n\n  @override\n  Future<void> saveAvailableItemsCount(int count) async {\n    await localCacheService.saveData(key: 'available_items_count_tafseer', value: count.toString());\n  }\n\n  @override\n  Future<int> fetchAvailableItemsCount() async {\n    final countString = localCacheService.getData(key: 'available_items_count_tafseer');\n    return countString != null ? int.parse(countString) : 20; // default to 20 if not found\n  }\n\n\n  List<String> _convertSerialisedStringToAvailableeTafseers(String serialisedString) =>\n      jsonDecode(serialisedString).cast<String>();\n\n  @override\n  Future<void> getTafseer({\n    required TTDbFileModel file,\n    void Function(int percentage)? onProgress,\n    required int surahID,\n    required TafseerType tafseerType,\n    required CancelToken cancelToken,\n  }) async {\n    final File dbFile = File(await getDatabaseFilePath(file.fileName));\n    final bool exists = await dbFile.exists();\n\n    // All tafseers need to be downloaded - no more default ones\n    if (!exists && !cancelToken.isCancelled) {\n      await _downloadDatabaseFile(\n        fileName: file.fileName,\n        downloadLink: file.link,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    }\n\n    if (exists || !cancelToken.isCancelled) {\n      await selectTafseer(file: file, surahID: surahID, tafseerType: tafseerType);\n    }\n  }\n\n  Future<void> _downloadDatabaseFile({\n    required String fileName,\n    required String downloadLink,\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await remoteDataSource.downloadDatabase(\n        fileName: fileName,\n        url: downloadLink,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) return;\n      logErrorStatic(\"Error downloading database file: $e\", \"TafseerRepositoryImpl\");\n    }\n  }\n\n  @override\n  Future<void> saveSelectedTabIndex(int index) async {\n    await localCacheService.saveData(key: CacheKeys.selectedTafseerTabIndex, value: index.toString());\n  }\n\n  @override\n  Future<int> getSelectedTabIndex() async {\n    final selectedTabIndex = localCacheService.getData(key: CacheKeys.selectedTafseerTabIndex);\n    return selectedTabIndex == null ? 0 : int.parse(selectedTabIndex);\n  }\n}\n\n// For common tafseer\nMap<int, Map<int, String>> convertCommonTafseerToMapIsolate(List<Map<String, dynamic>> tafseerData) {\n  Map<int, Map<int, String>> result = {};\n  for (var item in tafseerData) {\n    int? suraId = item['suraId'];\n    int? ayahId = item['ayahId'];\n    String? tafsirText = item['tafsirText'];\n    if (suraId != null && ayahId != null) {\n      result.putIfAbsent(suraId, () => {}).putIfAbsent(ayahId, () => tafsirText ?? \"No tafseer is found for this ayah\");\n    }\n  }\n  return result;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "text_mushaf", "file_path": "data/repository/text_mushaf/text_mushaf_repository_impl.dart", "file_name": "text_mushaf_repository_impl.dart", "line": 30, "line_from": 30, "line_to": 117, "snippet": "    void Function(int received, int total)? onProgress, // Changed signature to match Dio\n    CancelToken? cancelToken,\n  }) async {\n    final bool dbExists = await isDatabaseAvailable();\n\n    if (!dbExists) {\n      final File dbFile = await _localDataSource.getTextMushafDatabaseFile();\n      // Ensure directory exists\n      final Directory parentDir = dbFile.parent;\n      if (!await parentDir.exists()) {\n        await parentDir.create(recursive: true);\n        logInfoStatic('Created database directory: ${parentDir.path}', _tag);\n      }\n\n      // Make sure we're using a non-null cancel token\n      final token = cancelToken ?? CancelToken();\n\n      try {\n        logInfoStatic('Starting download of Text Mushaf database from $_dbDownloadUrl', _tag);\n\n        // Check connection first with a more reliable method\n        try {\n          final result = await InternetAddress.lookup('google.com');\n          if (result.isEmpty || result[0].rawAddress.isEmpty) {\n            throw const SocketException('No internet connection available');\n          }\n        } on SocketException catch (e) {\n          logErrorStatic('Network connectivity check failed: $e', _tag);\n          throw Exception('No internet connection. Please check your network settings and try again.');\n        }\n\n        await _remoteDataSource.downloadTextMushafDatabase(\n          url: _dbDownloadUrl,\n          dbFile: dbFile,\n          onProgress: onProgress,\n          cancelToken: token,\n        );\n\n        logInfoStatic('Text Mushaf database download completed successfully', _tag);\n      } on DioException catch (e) {\n        String errorMessage = 'Error downloading Text Mushaf database';\n\n        if (e.type == DioExceptionType.connectionTimeout ||\n            e.type == DioExceptionType.receiveTimeout ||\n            e.type == DioExceptionType.sendTimeout) {\n          errorMessage = 'Connection timeout. Please check your internet connection.';\n        } else if (e.type == DioExceptionType.badResponse) {\n          errorMessage = 'Server error (${e.response?.statusCode}). Please try again later.';\n        } else if (e.type == DioExceptionType.cancel) {\n          errorMessage = 'Download cancelled.';\n        } else if (e.type == DioExceptionType.connectionError) {\n          errorMessage = 'Connection error. Please check your internet connection.';\n        }\n\n        logErrorStatic('$errorMessage: $e', _tag);\n\n        // Ensure any partially downloaded files are cleaned up\n        if (await dbFile.exists()) {\n          try {\n            await dbFile.delete();\n            logInfoStatic('Deleted incomplete database file', _tag);\n          } catch (deleteError) {\n            logErrorStatic('Error deleting incomplete database file: $deleteError', _tag);\n          }\n        }\n\n        throw Exception(errorMessage);\n      } catch (e) {\n        logErrorStatic('Error downloading Text Mushaf database: $e', _tag);\n\n        // Ensure any partially downloaded files are cleaned up\n        if (await dbFile.exists()) {\n          try {\n            await dbFile.delete();\n            logInfoStatic('Deleted incomplete database file', _tag);\n          } catch (deleteError) {\n            logErrorStatic('Error deleting incomplete database file: $deleteError', _tag);\n          }\n        }\n\n        rethrow; // Re-throw the original error for proper handling upstream\n      }\n    } else {\n      logInfoStatic('Text Mushaf database already exists, skipping download', _tag);\n      // If database exists but we have a progress callback, call it with 100% to update UI\n      onProgress?.call(100, 100);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "dua", "file_path": "data/repository/dua/dua_repository_impl.dart", "file_name": "dua_repository_impl.dart", "line": 54, "line_from": 54, "line_to": 71, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      await _remoteDataSource.downloadResourceDatabase(\n        fileName: _duaDbFileName,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) {\n        logDebugStatic('Dua database download was cancelled', 'DuaRepositoryImpl');\n        rethrow;\n      }\n      logErrorStatic('Error downloading dua database: $e', 'DuaRepositoryImpl');\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "sealed_classes", "file_path": "data/sealed_classes/surah_ayah_presenter.dart", "file_name": "surah_ayah_presenter.dart", "line": 9, "line_from": 9, "line_to": 36, "snippet": "  void Function(String)? get onSurahSearchChanged;\n  TextEditingController get surahNameSearchController;\n\n  void Function(String)? get onAyahSearchChanged;\n  TextEditingController get ayahNumberSearchController;\n\n  factory SurahAyahPresenter.ayah(AyahPresenter presenter) = AyahSurahAyahPresenter;\n  factory SurahAyahPresenter.audio(AudioPresenter presenter) = AudioSurahAyahPresenter;\n  factory SurahAyahPresenter.memorization(MemorizationPresenter presenter) = MemorizationSurahAyahPresenter;\n}\n\nclass AyahSurahAyahPresenter extends SurahAyahPresenter {\n  final AyahPresenter presenter;\n\n  const AyahSurahAyahPresenter(this.presenter);\n\n  @override\n  void Function(String)? get onSurahSearchChanged => presenter.onSurahSearchChanged;\n\n  @override\n  TextEditingController get surahNameSearchController => presenter.surahNameSearchController;\n\n  @override\n  void Function(String)? get onAyahSearchChanged => presenter.onAyahSearchChanged;\n\n  @override\n  TextEditingController get ayahNumberSearchController => presenter.ayahNumberSearchController;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "sealed_classes", "file_path": "data/sealed_classes/surah_ayah_presenter.dart", "file_name": "surah_ayah_presenter.dart", "line": 43, "line_from": 43, "line_to": 70, "snippet": "  void Function(String)? get onSurahSearchChanged => presenter.onSurahSearchChanged;\n\n  @override\n  TextEditingController get surahNameSearchController => presenter.surahNameSearchController;\n\n  @override\n  void Function(String)? get onAyahSearchChanged => presenter.onAyahSearchChanged;\n\n  @override\n  TextEditingController get ayahNumberSearchController => presenter.ayahNumberSearchController;\n}\n\nclass MemorizationSurahAyahPresenter extends SurahAyahPresenter {\n  final MemorizationPresenter presenter;\n  const MemorizationSurahAyahPresenter(this.presenter);\n\n  @override\n  void Function(String)? get onSurahSearchChanged => presenter.onSurahSearchChanged;\n\n  @override\n  TextEditingController get surahNameSearchController => presenter.surahNameSearchController;\n\n  @override\n  void Function(String)? get onAyahSearchChanged => presenter.onAyahSearchChanged;\n\n  @override\n  TextEditingController get ayahNumberSearchController => presenter.ayahNumberSearchController;\n}"}, {"structure_type": "function", "name": "getNuzulBySurahId", "docstring": "", "module": "nuzul", "file_path": "data/data_sources/local_data_source/nuzul/nuzul_local_data_source.dart", "file_name": "nuzul_local_data_source.dart", "line": 7, "line_from": 7, "line_to": 106, "snippet": "  Future<List<NuzulDatabaseTableData>> getNuzulBySurahId(int surahId);\n  Future<List<NuzulDatabaseTableData>> getAllNuzul();\n  Future<List<int>> getUniqueNuzulSurahIds();\n}\n\nclass NuzulLocalDataSourceImpl implements NuzulLocalDataSource {\n  static const String _tag = 'NuzulLocalDataSourceImpl';\n  final QuranDatabase _database;\n  final String _externalDbName = 'nuzul.db'; // Using the same DB file as QuranInfo\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true;\n\n  NuzulLocalDataSourceImpl({QuranDatabase? database}) : _database = database ?? locate<QuranDatabase>();\n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n        // First check if the external database exists\n        final exists = await ExternalDbFactory.doesExternalDbExist(_externalDbName);\n        if (!exists) {\n         \n          _useExternalDb = false;\n          return;\n        }\n\n        // If it exists, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<List<NuzulDatabaseTableData>> getNuzulBySurahId(int surahId) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final dataList = await _externalDbService!.getNuzulBySurahId(surahId);\n          if (dataList.isNotEmpty) {\n            return dataList.map((data) => _externalDbService!.mapToNuzulDatabaseTableData(data)).toList();\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting Nuzul from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    return await _database.getNuzulBySurahId(surahId);\n  }\n\n  @override\n  Future<List<NuzulDatabaseTableData>> getAllNuzul() async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final dataList = await _externalDbService!.getAllNuzul();\n          if (dataList.isNotEmpty) {\n            return dataList.map((data) => _externalDbService!.mapToNuzulDatabaseTableData(data)).toList();\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting all Nuzul from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    return await _database.getAllNuzul();\n  }\n\n  @override\n  Future<List<int>> getUniqueNuzulSurahIds() async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final surahIds = await _externalDbService!.getUniqueNuzulSurahIds();\n          if (surahIds.isNotEmpty) {\n            return surahIds;\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting unique Nuzul surah IDs from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    return await _database.getUniqueNuzulSurahIds();\n  }\n}"}, {"structure_type": "function", "name": "getGrammarSummaryData", "docstring": "Get grammar summary data for a specific ayah and word", "module": "grammar", "file_path": "data/data_sources/local_data_source/grammar/grammar_local_data_source.dart", "file_name": "grammar_local_data_source.dart", "line": 7, "line_from": 7, "line_to": 75, "snippet": "  Future<GrammarSummaryData?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  });\n}\n\nclass GrammarLocalDataSourceImpl implements GrammarLocalDataSource {\n  static const String _tag = 'GrammarLocalDataSourceImpl';\n  final String _externalDbName = 'same_exact_summary.db';\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true;\n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n        // First check if the external database exists\n        final exists = await ExternalDbFactory.doesExternalDbExist(_externalDbName);\n        if (!exists) {\n          _useExternalDb = false;\n          return;\n        }\n\n        // If it exists, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<GrammarSummaryData?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  }) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final data = await _externalDbService!.getGrammarSummaryData(\n            surahId: surahId,\n            ayahId: ayahId,\n            wordIndex: wordIndex,\n          );\n          if (data != null) {\n            return _externalDbService!.mapToGrammarSummaryTableData(data);\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting grammar summary from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    try {\n      // Since we haven't implemented drift tables for this functionality yet,\n      // we'll just return null\n      return null;\n    } catch (e) {\n      Logger.error('Error getting grammar summary from drift tables: $e', _tag);\n      return null;\n    }\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "user", "file_path": "data/data_sources/local_data_source/user/user_data_local_data_source.dart", "file_name": "user_data_local_data_source.dart", "line": 168, "line_from": 168, "line_to": 172, "snippet": "    required void Function() onBookmarkFolderDeleted,\n  }) async {\n    await _userDataStorage.deleteBookmarkFolderByName(folderName: folderName);\n    onBookmarkFolderDeleted();\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "user", "file_path": "data/data_sources/local_data_source/user/user_data_local_data_source.dart", "file_name": "user_data_local_data_source.dart", "line": 272, "line_from": 272, "line_to": 332, "snippet": "    required void Function(List<BookmarkEntity>) onBookmarksSaved,\n  }) async {\n    // Get current bookmarks for this ayah\n    final List<BookmarkData> bookmarkDataList = await _userDataStorage.getBookmarkFolderBySurahAndAyah(\n      surahID: surahID,\n      ayahID: ayahID,\n    );\n\n    // Convert BookmarkData to BookmarkEntity\n    final List<BookmarkEntity> currentBookmarks = await bookmarkDataList.toBookmarkEntities();\n\n    // Create sets of folder names for comparison\n    final Set<String> currentFolderNames = currentBookmarks.map((b) => b.folderName).toSet();\n    final Set<String> newFolderNames = bookmarks.map((b) => b.folderName).toSet();\n\n    // Find folders to remove (in current but not in new)\n    final Set<String> foldersToRemove = currentFolderNames.difference(newFolderNames);\n\n    // For each folder that would be removed, check if it would become empty\n    for (final folderName in foldersToRemove) {\n      // Remove the specific bookmark from this folder\n      await _userDataStorage.deleteAyahFromBookmarkFolder(\n        surahID: surahID,\n        ayahID: ayahID,\n        folderName: folderName,\n      );\n\n      // Check if this folder would become empty\n      final List<BookmarkData> folderBookmarks = await _userDataStorage.getBookmarksByFolderName(\n        folderName: folderName,\n      ) as List<BookmarkData>;\n\n      // If folder would become empty, create a placeholder bookmark to preserve the folder\n      if (folderBookmarks.isEmpty) {\n        // Get the folder color from the original bookmark\n        final String folderColor =\n            getHexFromColor(currentBookmarks.firstWhere((b) => b.folderName == folderName).color);\n\n        // Create a placeholder bookmark with special IDs to mark it as a placeholder\n        // Using surahID=0, ayahID=0 to indicate this is a placeholder\n        await _userDataStorage.addAyahToBookmarkFolder(\n          surahID: 0,\n          ayahID: 0,\n          folderName: folderName,\n          color: folderColor,\n        );\n      }\n    }\n\n    // Add new bookmarks\n    final List<BookmarkEntity> savedBookmarks = List.empty(growable: true);\n    await Future.forEach(\n      bookmarks,\n      (bookmark) async => catchFutureOrVoid(\n        () => addAyahToBookmarkFolder(\n          bookmark: bookmark,\n        ),\n      ),\n    );\n    onBookmarksSaved(savedBookmarks);\n  }"}, {"structure_type": "function", "name": "getQuranInfoBySurahId", "docstring": "", "module": "info", "file_path": "data/data_sources/local_data_source/info/quran_info_local_data_source.dart", "file_name": "quran_info_local_data_source.dart", "line": 8, "line_from": 8, "line_to": 64, "snippet": "  Future<QuranInfoTableData?> getQuranInfoBySurahId(int surahId);\n\n}\n\nclass QuranInfoLocalDataSourceImpl implements QuranInfoLocalDataSource {\n  static const String _tag = 'QuranInfoLocalDataSourceImpl';\n  final QuranDatabase _database;\n  final String _externalDbName = 'info.db';\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true; // Flag to control which data source to use\n\n\n  QuranInfoLocalDataSourceImpl({QuranDatabase? database}) : _database = database ?? locate<QuranDatabase>();\n\n \n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n\n        // If it exists and is valid, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n       \n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<QuranInfoTableData?> getQuranInfoBySurahId(int surahId) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final data = await _externalDbService!.getQuranInfoBySurahId(surahId);\n          if (data != null) {\n            return _externalDbService!.mapToQuranInfoTableData(data);\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting QuranInfo from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables if external DB is not available or has an error\n    try {\n      return await _database.getQuranInfoBySurahId(surahId);\n    } catch (e) {\n      Logger.error('Error getting QuranInfo from drift tables: $e', _tag);\n      return null;\n    }\n  }\n}"}, {"structure_type": "function", "name": "getDuasByCategoryId", "docstring": "Get duas by category ID", "module": "dua", "file_path": "data/data_sources/local_data_source/dua/dua_local_data_source.dart", "file_name": "dua_local_data_source.dart", "line": 9, "line_from": 9, "line_to": 65, "snippet": "  Future<List<DuaEntity>> getDuasByCategoryId(int categoryId);\n}\n\nclass DuaLocalDataSourceImpl implements DuaLocalDataSource {\n  static const String _tag = 'DuaLocalDataSourceImpl';\n  final QuranDatabase _database;\n  final String _externalDbName = 'dua.db';\n  ExternalDbService? _externalDbService;\n  bool _useExternalDb = true;\n\n  DuaLocalDataSourceImpl({QuranDatabase? database}) : _database = database ?? locate<QuranDatabase>();\n\n  Future<void> _initializeExternalDb() async {\n    if (_externalDbService == null) {\n      try {\n        // First check if the external database exists\n        final exists = await ExternalDbFactory.doesExternalDbExist(_externalDbName);\n        if (!exists) {\n          _useExternalDb = false;\n          return;\n        }\n\n        // If it exists, try to get the service\n        _externalDbService = await ExternalDbFactory.getService(_externalDbName);\n      } catch (e) {\n        Logger.error('Error initializing external database: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if external DB not available\n      }\n    }\n  }\n\n  @override\n  Future<List<DuaEntity>> getDuasByCategoryId(int categoryId) async {\n    // Try to load from external DB first\n    if (_useExternalDb) {\n      try {\n        await _initializeExternalDb();\n        if (_externalDbService != null) {\n          final dataList = await _externalDbService!.getDuasByCategoryId(categoryId);\n          if (dataList.isNotEmpty) {\n            return dataList.map((data) {\n              final duaData = _externalDbService!.mapToDuaDatabaseTableData(data);\n              return DuaEntity.fromDatabaseModel(duaData);\n            }).toList();\n          }\n        }\n      } catch (e) {\n        Logger.error('Error getting Duas from external DB: $e', _tag);\n        _useExternalDb = false; // Fall back to drift tables if there's an error\n      }\n    }\n\n    // Fall back to using drift tables\n    final databaseDuas = await _database.getDuasByCategoryId(categoryId);\n    return databaseDuas.map((dua) => DuaEntity.fromDatabaseModel(dua)).toList();\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "network", "file_path": "data/data_sources/remote_data_source/network/file_downloader.dart", "file_name": "file_downloader.dart", "line": 13, "line_from": 13, "line_to": 28, "snippet": "    required void Function(int) onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    // Check if savePath is an absolute path\n    if (savePath.startsWith('/')) {\n      // It's already an absolute path, use it directly\n      return await _downloadWithProgress(\n          url: url, filePath: savePath, onProgress: onProgress, cancelToken: cancelToken);\n    } else {\n      // It's a relative path, prepend the application directory path\n      String directoryPath = await getApplicationDirectoryPath();\n      String filePath = \"$directoryPath/$savePath\";\n      return await _downloadWithProgress(\n          url: url, filePath: filePath, onProgress: onProgress, cancelToken: cancelToken);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "network", "file_path": "data/data_sources/remote_data_source/network/file_downloader.dart", "file_name": "file_downloader.dart", "line": 33, "line_from": 33, "line_to": 61, "snippet": "    required void Function(int) onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    try {\n      // Ensure the directory exists\n      final directory = Directory(File(filePath).parent.path);\n      if (!await directory.exists()) {\n        await directory.create(recursive: true);\n      }\n\n      await DioClient.downloadFile(\n        url,\n        filePath,\n        onReceiveProgress: (received, total) {\n          if (total != -1) {\n            int percentage = ((received / total) * 100).floor();\n            onProgress(percentage);\n          }\n        },\n        cancelToken: cancelToken,\n      );\n\n      return filePath;\n    } catch (e) {\n      if (e is DioException && e.type == DioExceptionType.cancel) rethrow;\n      Logger.error(\"Error downloading file: $e\", _tag);\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "[];", "docstring": "", "module": "network", "file_path": "data/data_sources/remote_data_source/network/dio_client.dart", "file_name": "dio_client.dart", "line": 76, "line_from": 76, "line_to": 87, "snippet": "      final List<Future<Response>> downloadFutures = [];\n      for (int i = 0; i < urls.length; i++) {\n        downloadFutures.add(_dio.download(urls[i], savePaths[i],\n            cancelToken: cancelToken, onReceiveProgress: onReceiveProgress));\n      }\n      final List<Response> responses = await Future.wait(downloadFutures);\n      return responses;\n    } on DioException catch (e) {\n      // Handle DioException\n      logErrorStatic('Error in downloading multiple files: $e', 'DioClient');\n      rethrow;\n    }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "info", "file_path": "data/data_sources/remote_data_source/info/info_remote_data_source.dart", "file_name": "info_remote_data_source.dart", "line": 14, "line_from": 14, "line_to": 26, "snippet": "    required void Function(PromotionalMessageEntity) onMessage,\n  }) async {\n    await _backendAsAService.getRemoteNotice(\n      onNotification: (map) async {\n        await catchFutureOrVoid(() async {\n          final Map<String, Object?> remoteNoticeMap = map.map(MapEntry.new);\n          final PromotionalMessageEntity promotionalMessage =\n              await convertJsonMapToPromotionalMessage(map: remoteNoticeMap);\n          onMessage(promotionalMessage);\n        });\n      },\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "audio", "file_path": "data/data_sources/remote_data_source/audio/audio_remote_data_source.dart", "file_name": "audio_remote_data_source.dart", "line": 10, "line_from": 10, "line_to": 19, "snippet": "    required void Function(int percentage) onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    return await _fileDownloader.downloadFile(\n      url: url,\n      savePath: filePath,\n      onProgress: (int progress) => onProgress(progress),\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation_and_tafseer", "file_path": "data/data_sources/remote_data_source/translation_and_tafseer/translation_tafseer_remote_data_source.dart", "file_name": "translation_tafseer_remote_data_source.dart", "line": 10, "line_from": 10, "line_to": 20, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    // Call the downloadFile method from the FileDownloader class\n    await _fileDownloader.downloadFile(\n      url: url,\n      savePath: fileName,\n      onProgress: (int percentage) => onProgress?.call(percentage),\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word", "file_path": "data/data_sources/remote_data_source/word_by_word/word_by_word_remote_data_source.dart", "file_name": "word_by_word_remote_data_source.dart", "line": 10, "line_from": 10, "line_to": 19, "snippet": "    required void Function(int percentage) onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    await _fileDownloader.downloadFile(\n      url: url,\n      savePath: fileName,\n      onProgress: onProgress,\n      cancelToken: cancelToken,\n    );\n  }"}, {"structure_type": "function", "name": "downloadMushaf", "docstring": "", "module": "mushaf", "file_path": "data/data_sources/remote_data_source/mushaf/mushaf_remote_data_source.dart", "file_name": "mushaf_remote_data_source.dart", "line": 9, "line_from": 9, "line_to": 61, "snippet": "  Future<void> downloadMushaf({\n    required String mushafName,\n    ProgressCallback? onProgress,\n    CancelToken? cancelToken,\n  });\n}\n\nclass MushafRemoteDataSource implements IMushafRemoteDataSource {\n  static const String baseUrl = 'https://download.quranmazid.com/mushaf/';\n\n  @override\n  Future<void> downloadMushaf({\n    required String mushafName,\n    ProgressCallback? onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    try {\n      final String fileName = '$mushafName.zip';\n      final String downloadUrl = '$baseUrl$fileName';\n\n      logDebugStatic('Downloading Mushaf from: $downloadUrl', 'MushafRemoteDataSource');\n\n      final Directory appDir = await getApplicationDocumentsDirectory();\n      final Directory mushafDir = Directory('${appDir.path}/mushaf');\n      final File zipFile = File('${mushafDir.path}/$fileName');\n\n      logDebugStatic('Saving to path: ${zipFile.path}', 'MushafRemoteDataSource');\n\n      if (!await mushafDir.exists()) {\n        await mushafDir.create(recursive: true);\n        logDebugStatic('Created mushaf directory: ${mushafDir.path}', 'MushafRemoteDataSource');\n      }\n\n      final response = await DioClient.downloadFile(\n        downloadUrl,\n        zipFile.path,\n        onReceiveProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n\n      if (response.statusCode == 200) {\n        logDebugStatic('Successfully downloaded and saved Mushaf file', 'MushafRemoteDataSource');\n      } else {\n        final String error = 'Failed to download mushaf: ${response.statusCode}';\n        logErrorStatic(error, 'MushafRemoteDataSource');\n        throw Exception(error);\n      }\n    } catch (e, stackTrace) {\n      logErrorStatic('Error downloading Mushaf: $e\\n$stackTrace', 'MushafRemoteDataSource');\n      rethrow;\n    }\n  }\n}"}, {"structure_type": "function", "name": "downloadTextMushafDatabase", "docstring": "Downloads the Text Mushaf database file.", "module": "mushaf", "file_path": "data/data_sources/remote_data_source/mushaf/text_mushaf_remote_data_source.dart", "file_name": "text_mushaf_remote_data_source.dart", "line": 8, "line_from": 8, "line_to": 117, "snippet": "  Future<void> downloadTextMushafDatabase({\n    required File dbFile,\n    required String url, // URL should be configurable or constant\n    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  });\n}\n\n/// Implementation of [ITextMushafRemoteDataSource] using Dio for network requests.\nclass TextMushafRemoteDataSource implements ITextMushafRemoteDataSource {\n  final Dio _dio;\n  static const String _tag = 'TextMushafRemoteDataSource';\n\n  // Inject Dio instance.\n  TextMushafRemoteDataSource({required Dio dio}) : _dio = dio;\n\n  @override\n  Future<void> downloadTextMushafDatabase({\n    required File dbFile,\n    required String url,\n    void Function(int received, int total)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    logInfoStatic('Starting download for Text Mushaf DB from $url to ${dbFile.path}', _tag);\n\n    // Set up Dio options with timeouts and retry policy\n    final options = Options(\n      receiveTimeout: const Duration(minutes: 2),\n      sendTimeout: const Duration(minutes: 2),\n      headers: {\n        'Connection': 'keep-alive',\n      },\n    );\n\n    try {\n      // Perform connection check before attempting download\n      try {\n        final result = await InternetAddress.lookup('google.com');\n        if (result.isEmpty || result[0].rawAddress.isEmpty) {\n          throw const SocketException('Network connectivity check failed');\n        }\n      } on SocketException {\n        logErrorStatic('Network connectivity check failed - no internet connection', _tag);\n        throw Exception('No internet connection available. Please check your network settings.');\n      }\n\n      // Proceed with download if internet is available\n      await _dio.download(\n        url,\n        dbFile.path,\n        onReceiveProgress: onProgress,\n        cancelToken: cancelToken,\n        deleteOnError: true,\n        options: options,\n      );\n\n      if (!cancelToken.isCancelled) {\n        logInfoStatic('Text Mushaf DB downloaded successfully to ${dbFile.path}', _tag);\n\n        // Verify file exists and has content\n        if (!await dbFile.exists() || await dbFile.length() == 0) {\n          throw Exception('Download completed but file is missing or empty');\n        }\n      } else {\n        logInfoStatic('Text Mushaf DB download cancelled for ${dbFile.path}', _tag);\n        if (await dbFile.exists()) {\n          await dbFile.delete();\n          logInfoStatic('Deleted cancelled download file', _tag);\n        }\n        throw Exception('Download cancelled by user');\n      }\n    } on DioException catch (e) {\n      String errorMessage;\n\n      if (e.type == DioExceptionType.cancel) {\n        errorMessage = 'Download cancelled';\n        logInfoStatic('$errorMessage: ${e.message}', _tag);\n      } else if (e.type == DioExceptionType.connectionTimeout ||\n          e.type == DioExceptionType.receiveTimeout ||\n          e.type == DioExceptionType.sendTimeout) {\n        errorMessage = 'Connection timeout';\n        logErrorStatic('$errorMessage: ${e.message}', _tag);\n      } else if (e.type == DioExceptionType.badResponse) {\n        errorMessage = 'Server error (${e.response?.statusCode})';\n        logErrorStatic('$errorMessage: ${e.message}', _tag);\n      } else {\n        errorMessage = 'Network error';\n        logErrorStatic('$errorMessage: ${e.message}', _tag);\n      }\n\n      // Clean up any partial downloads\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n        logInfoStatic('Deleted incomplete database file after error', _tag);\n      }\n\n      throw Exception('$errorMessage. Please check your internet connection and try again.');\n    } catch (e) {\n      logErrorStatic('Unexpected error downloading Text Mushaf DB: $e', _tag);\n\n      // Clean up any partial downloads\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n        logInfoStatic('Deleted incomplete database file after unexpected error', _tag);\n      }\n\n      throw Exception('An unexpected error occurred during download. Please try again.');\n    }\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "resource", "file_path": "data/data_sources/remote_data_source/resource/resource_remote_data_source.dart", "file_name": "resource_remote_data_source.dart", "line": 20, "line_from": 20, "line_to": 53, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    final String url = '$_baseUrl$fileName';\n\n    try {\n      // Get the correct path for external databases\n      final String dbPath = await ExternalDbFactory.getExternalDbPath(fileName);\n      final File dbFile = File(dbPath);\n\n      // Create directory if it doesn't exist\n      if (!await dbFile.parent.exists()) {\n        await dbFile.parent.create(recursive: true);\n      }\n\n      // Delete existing file if it exists\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n      }\n\n\n      // Call the downloadFile method from the FileDownloader class with the correct path\n      await _fileDownloader.downloadFile(\n        url: url,\n        savePath: dbPath,\n        onProgress: (int percentage) => onProgress?.call(percentage),\n        cancelToken: cancelToken,\n      );\n\n    } catch (e) {\n      Logger.error('Error downloading database $fileName: $e', _tag);\n      rethrow;\n    }\n  }"}, {"structure_type": "function", "name": "toNoteEntities", "docstring": "", "module": "note", "file_path": "data/mappers/note/note_mapper.dart", "file_name": "note_mapper.dart", "line": 31, "line_from": 31, "line_to": 48, "snippet": "  Future<List<NoteEntity>> toNoteEntities() async {\n    return map((note) => NoteEntity(\n          surahId: note.surahId,\n          ayahNumber: note.ayahNumber,\n          title: note.title,\n          content: note.content,\n          color: note.color,\n          createdAt: note.createdAt,\n          updatedAt: note.updatedAt,\n        )).toList();\n  }\n}\n\nextension NoteEntitiesToBeSavedMapper on Pair<List<NoteEntity>, List<NoteEntity>> {\n  Future<List<NoteEntity>> findOutNotesToBeSaved() async {\n    return await compute(_findOutNotesToBeSavedStatic, this);\n  }\n}"}, {"structure_type": "function", "name": "toSerialisedString", "docstring": "", "module": "settings", "file_path": "data/mappers/settings/setting_entity_mapper.dart", "file_name": "setting_entity_mapper.dart", "line": 16, "line_from": 16, "line_to": 23, "snippet": "  Future<String> toSerialisedString() async =>\n      compute(_convertSettingsEntityToSerialisedString, this);\n}\n\nextension SerialisedStringToSettingStateEntity on String {\n  Future<SettingsStateEntity> toSettingStateEntity() async =>\n      compute(_convertSerialisedStringToSettingStateEntity, this);\n}"}, {"structure_type": "function", "name": "toPinEntities", "docstring": "", "module": "pin", "file_path": "data/mappers/pin/pin_mapper.dart", "file_name": "pin_mapper.dart", "line": 23, "line_from": 23, "line_to": 46, "snippet": "  Future<List<PinEntity>> toPinEntities() async {\n    return map((pin) => PinEntity(\n          surahId: pin.surahId,\n          ayahNumber: pin.ayahNumber,\n          name: pin.name,\n          color: pin.color,\n          createdAt: pin.createdAt,\n          updatedAt: pin.updatedAt,\n        )).toList();\n  }\n}\n\nextension PinEntityToDtoMapper on PinData {\n  PinEntity toPinEntity() {\n    return PinEntity(\n      surahId: surahId,\n      ayahNumber: ayahNumber,\n      name: name,\n      color: color,\n      createdAt: createdAt,\n      updatedAt: updatedAt,\n    );\n  }\n}"}, {"structure_type": "function", "name": "findOutPinsToBeSaved", "docstring": "", "module": "pin", "file_path": "data/mappers/pin/pin_mapper.dart", "file_name": "pin_mapper.dart", "line": 49, "line_from": 49, "line_to": 84, "snippet": "  Future<List<PinEntity>> findOutPinsToBeSaved() async {\n    return await compute(_findOutPinsToBeSavedStatic, this);\n  }\n}\n\nList<PinEntity> _findOutPinsToBeSavedStatic(\n  Pair<List<PinEntity>, List<PinEntity>> params,\n) {\n  // Here we define a local variable to hold the pins that need to be saved.\n  final List<PinEntity>? pinsToBeSaved = catchAndReturn(() {\n    // First we create a set of the IDs of the existing pins, so we can easily\n    // check if a new pin already exists or not.\n    final List<PinEntity> existingPins = params.first;\n    final Set<String> existingPinUniqueIdentifiers =\n        existingPins.map((pin) => \"${pin.surahId}-${pin.ayahNumber}-${pin.name}\").toSet();\n\n    // Then we filter out the new pins that already exist by checking if their\n    // ID is present in the set we just created.\n    // Using a Set helps to improve performance by removing duplicates and\n    // enabling faster membership testing.\n    final List<PinEntity> savingPins = params.second;\n    final Set<PinEntity> pinsToBeSaved = savingPins\n        .where(\n          (pin) => !existingPinUniqueIdentifiers.contains(\"${pin.surahId}-${pin.ayahNumber}-${pin.name}\"),\n        )\n        .toSet();\n\n    // Finally, we return the filtered set of new pins.\n    final List<PinEntity> pinsToBeSavedList = pinsToBeSaved.toList(growable: true);\n    return pinsToBeSavedList;\n  });\n\n  // If there was an error during the pin filtering process, return an\n  // empty list instead.\n  return pinsToBeSaved ?? [];\n}"}, {"structure_type": "function", "name": "toBookmarkEntities", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 22, "line_from": 22, "line_to": 32, "snippet": "  Future<List<BookmarkEntity>> toBookmarkEntities() async {\n    final List<BookmarkEntity> bookmarkEntities = await compute(_convertBookmarkDtoToBookmarkEntities, this);\n    return bookmarkEntities;\n  }\n}\n\nextension BookmarkEntitiesToBookmarkFolderEntitiesMapper on Pair<List<BookmarkEntity>, List<BookmarkEntity>> {\n  Future<List<BookmarkEntity>> findOutBookmarksToBeSaved() async {\n    return await compute(_findOutBookmarksToBeSavedStatic, this);\n  }\n}"}, {"structure_type": "function", "name": "groupBookmarksInFolders", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 68, "line_from": 68, "line_to": 125, "snippet": "  Future<List<BookmarkFolderEntity>> groupBookmarksInFolders() async {\n    return await compute(_groupBookmarksInFoldersStatic, this);\n  }\n}\n\nList<BookmarkFolderEntity> _groupBookmarksInFoldersStatic(\n  List<BookmarkData?> params,\n) {\n  final List<BookmarkFolderEntity>? folders = catchAndReturn(() {\n    final List<BookmarkData?> bookmarkDataList = params;\n\n    // Group bookmarks by name\n    final Map<String, List<BookmarkData?>> bookmarkDataMapGroupedByName =\n        bookmarkDataList.groupListsBy((bk) => bk!.foldername);\n\n    final List<BookmarkFolderEntity> allFolders = List.empty(growable: true);\n    int folderId = 1;\n\n    // Iterate over each group (folder)\n    for (final String folderName in bookmarkDataMapGroupedByName.keys) {\n      final List<BookmarkData?>? bookmarks = bookmarkDataMapGroupedByName[folderName];\n\n      if (bookmarks == null) continue;\n\n      // We allow empty folders to exist - removed the check for bookmarks.isEmpty\n      // Get folder color (use a default if no bookmarks)\n      final Color folderColor = bookmarks.isNotEmpty\n          ? getColorFromHex(bookmarks.first!.color)\n          : const Color(0xff66BB6A); // Default color for empty folders\n\n      // count total number of bookmarks in the folder\n      final int totalBookmarks =\n          bookmarks.isNotEmpty ? bookmarks.where((b) => b != null && b.suraId > 0 && b.ayahId > 0).length : 0;\n\n      // Get folder created and updated time\n      final (folderCreatedAt, folderUpdatedAt) = getBookmarkFolderCreatedAndUpdatedTime(bookmarks);\n\n      // Create a new bookmark folder entity\n      allFolders.add(\n        BookmarkFolderEntity(\n          id: folderId++,\n          name: folderName,\n          color: folderColor,\n          count: totalBookmarks,\n          updatedAt: folderUpdatedAt,\n          createdAt: folderCreatedAt,\n        ),\n      );\n    }\n\n    // Sort folders by name\n    allFolders.sort((a, b) => a.name.compareTo(b.name));\n\n    return allFolders;\n  });\n\n  return folders ?? [];\n}"}, {"structure_type": "function", "name": "param.map", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 147, "line_from": 147, "line_to": 163, "snippet": "  final List<Future<BookmarkEntity>> futures = param.map((dto) async => _convertDtoToBookmarkEntity(dto!)).toList();\n  return Future.wait(futures);\n}\n\nBookmarkEntity _convertDtoToBookmarkEntity(BookmarkData dto) => BookmarkEntity(\n      id: dto.id,\n      folderName: dto.foldername,\n      color: getColorFromHex(dto.color),\n      surahID: dto.suraId,\n      ayahID: dto.ayahId,\n      createdAt: dto.createdAt,\n      updatedAt: dto.updatedAt,\n    );\n\nextension BookmarkToDtoMap on BookmarkEntity {\n  Future<Map<String, Object?>> toMap() async => compute(_convertBookmarkToDtoMap, this);\n}"}, {"structure_type": "function", "name": "toMapList", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 180, "line_from": 180, "line_to": 191, "snippet": "  Future<List<Map<String, Object?>>> toMapList() async => compute(convertBookmarkListToDtoMap, this);\n}\n\nFuture<List<Map<String, Object?>>> convertBookmarkListToDtoMap(\n  List<BookmarkEntity> bookmarks,\n) async {\n  final List<Future<Map<String, Object?>>> futures = bookmarks.map((bookmark) async {\n    return _convertBookmarkToDtoMap(bookmark);\n  }).toList();\n  final List<Map<String, Object?>> result = await Future.wait(futures);\n  return result;\n}"}, {"structure_type": "function", "name": "toBookmarks", "docstring": "", "module": "bookmark", "file_path": "data/mappers/bookmark/bookmark_mapper.dart", "file_name": "bookmark_mapper.dart", "line": 208, "line_from": 208, "line_to": 224, "snippet": "  Future<List<BookmarkEntity>> toBookmarks() async {\n    return compute(_convertMapsToBookmarkList, this);\n  }\n}\n\nFuture<List<BookmarkEntity>> _convertMapsToBookmarkList(\n  List<Map<String, Object?>> bookmarkMaps,\n) async {\n  final List<Future<BookmarkEntity>> futures = bookmarkMaps\n      .map(\n        (bookmarkMap) => Future<BookmarkEntity>.value(\n          _convertMapToBookmarkEntity(bookmarkMap),\n        ),\n      )\n      .toList();\n  return Future.wait(futures);\n}"}, {"structure_type": "function", "name": "toNotificationPayload", "docstring": "", "module": "notification", "file_path": "data/mappers/notification/notification_entity_mapper.dart", "file_name": "notification_entity_mapper.dart", "line": 56, "line_from": 56, "line_to": 62, "snippet": "  Future<NotificationPayLoadEntity> toNotificationPayload() async =>\n      compute(_convertJsonMapToNotificationPayLoadStatic, this);\n}\n\nextension NotificationPayLoadToJsonMap on NotificationPayLoadEntity {\n  Future<Map<String, String>> toJsonMap() async => compute(_convertNotificationPayLoadToJsonMapStatic, this);\n}"}, {"structure_type": "class", "name": "TTJsonModel", "docstring": "", "module": "content", "file_path": "data/mappers/content/tt_json_mapper.dart", "file_name": "tt_json_mapper.dart", "line": 6, "line_from": 6, "line_to": 105, "snippet": "class TTJsonModel {\n  Map<String, List<TTDbFileModel>> trans;\n  Map<String, List<TTDbFileModel>> tafsir;\n\n  TTJsonModel({\n    required this.trans,\n    required this.tafsir,\n  });\n\n  factory TTJsonModel.empty() {\n    return TTJsonModel(tafsir: {}, trans: {});\n  }\n\n  factory TTJsonModel.fromJson(Map<String, dynamic> json) => TTJsonModel(\n        trans: Map.from(json[\"trans\"]).map((k, v) => MapEntry<String, List<TTDbFileModel>>(\n            k, List<TTDbFileModel>.from(v.map((x) => TTDbFileModel.fromJson(x))))),\n        tafsir: Map.from(json[\"tafsir\"]).map((k, v) => MapEntry<String, List<TTDbFileModel>>(\n            k, List<TTDbFileModel>.from(v.map((x) => TTDbFileModel.fromJson(x))))),\n      );\n\n  Map<String, dynamic> toJson() => {\n        \"trans\":\n            Map.from(trans).map((k, v) => MapEntry<String, dynamic>(k, List<dynamic>.from(v.map((x) => x.toJson())))),\n        \"tafsir\":\n            Map.from(tafsir).map((k, v) => MapEntry<String, dynamic>(k, List<dynamic>.from(v.map((x) => x.toJson())))),\n      };\n}\n\nclass TTDbFileModel {\n  String name;\n  String fileName;\n  String size;\n  String language;\n  String languageCode;\n  Type type;\n  String link;\n\n  TTDbFileModel({\n    required this.name,\n    required this.fileName,\n    required this.size,\n    required this.language, // Changed to String\n    required this.type,\n    required this.link,\n    required this.languageCode,\n  });\n\n  factory TTDbFileModel.fromJson(Map<String, dynamic> json) => TTDbFileModel(\n        name: json[\"name\"],\n        fileName: json[\"file_name\"],\n        size: json[\"size\"],\n        language: json[\"language\"], // Changed from \"lang\"\n        type: typeValues.map[json[\"type\"]]!,\n        link: json[\"link\"],\n        languageCode: json[\"language_code\"],\n      );\n\n  Map<String, dynamic> toJson() => {\n        \"name\": name,\n        \"file_name\": fileName,\n        \"size\": size,\n        \"language\": language, // Changed to \"language\"\n        \"type\": typeValues.reverse[type],\n        \"link\": link,\n        \"language_code\": languageCode,\n      };\n\n  Map<String, Object> toMap() {\n    return {\n      'name': name,\n      'file_name': fileName,\n      'size': size,\n      'language': language, // Directly use the language string\n      'type': typeValues.reverse[type]!,\n      'link': link,\n      'language_code': languageCode,\n    };\n  }\n}\n\n// Adjusted Type and Lang enums are not needed anymore if Lang is directly a string.\n// Consider removing or adjusting Lang enum if it's used elsewhere in your code.\n\nenum Type { tafseer, translation }\n\nfinal typeValues = EnumValues({\"tafseer\": Type.tafseer, \"translation\": Type.translation});\n\nclass EnumValues<T> {\n  Map<String, T> map;\n  late Map<T, String> reverseMap;\n\n  EnumValues(this.map);\n\n  Map<T, String> get reverse {\n    reverseMap = map.map((k, v) => MapEntry(v, k));\n    return reverseMap;\n  }\n}\n"}, {"structure_type": "function", "name": "toAyahEntity", "docstring": "", "module": "quran", "file_path": "data/mappers/quran/ayah_mapper.dart", "file_name": "ayah_mapper.dart", "line": 8, "line_from": 8, "line_to": 28, "snippet": "  Future<List<AyahEntity>> toAyahEntity() async {\n    final List<AyahDatabaseTableData> dtoList = this;\n    final List<AyahEntity> ayahEntityList = await compute(_convertAyahFtsToAyahEntity, dtoList);\n    return ayahEntityList;\n  }\n}\n\nList<AyahEntity> _convertAyahFtsToAyahEntity(List<AyahDatabaseTableData> dtoList) =>\n    dtoList.map(_convertDtoToAyahEntity).toList();\n\nAyahEntity _convertDtoToAyahEntity(AyahDatabaseTableData ayahDto) {\n  return AyahEntity(\n    id: ayahDto.id,\n    surahID: ayahDto.surahId!,\n    ayahID: ayahDto.ayahId!,\n    juz: ayahDto.juz,\n    hijb: ayahDto.hijb,\n    page: ayahDto.page,\n    clean: ayahDto.clean,\n  );\n}"}, {"structure_type": "function", "name": "toPageListEntity", "docstring": "", "module": "surah", "file_path": "data/mappers/surah/surah_mapper.dart", "file_name": "surah_mapper.dart", "line": 28, "line_from": 28, "line_to": 48, "snippet": "  Future<List<SurahEntity>> toPageListEntity() async {\n    final List<SurahDatabaseTableData> dtoList = this;\n    final List<SurahEntity> surahList = await compute(_convertSurahDtoToSurahEntity, dtoList);\n    return surahList;\n  }\n}\n\nList<SurahEntity> _convertSurahDtoToSurahEntity(List<SurahDatabaseTableData> dtoList) =>\n    dtoList.map(_convertDtoToSurahEntity).toList();\n\nSurahEntity _convertDtoToSurahEntity(SurahDatabaseTableData surahDto) {\n  return SurahEntity(\n      serial: surahDto.serial!,\n      name: surahDto.name!,\n      nameBn: surahDto.nameBn!,\n      meaning: surahDto.meaning!,\n      totalAyah: surahDto.totalAyah!,\n      nameEn: surahDto.nameEn!,\n      meaningBn: surahDto.meaningBn!,\n      type: surahDto.type!);\n}"}, {"structure_type": "function", "name": "toWordByWordListEntity", "docstring": "", "module": "word_by_word", "file_path": "data/mappers/word_by_word/word_by_word_mapper.dart", "file_name": "word_by_word_mapper.dart", "line": 6, "line_from": 6, "line_to": 18, "snippet": "  Future<List<WordByWordEntity>> toWordByWordListEntity() async {\n    final List<WordByWordDatabaseTableData> dtoList = this;\n    final List<WordByWordEntity> wordByWordList = await compute(_convertWordByWordDtoToWordByWordEntity, dtoList);\n    return wordByWordList;\n  }\n}\n\nextension DtoToWordByWordMapper on WordByWordDatabaseTableData {\n  WordByWordEntity toWordByWordEntity() {\n    final WordByWordDatabaseTableData wordByWordDto = this;\n    return _convertDtoToWordByWordEntity(wordByWordDto);\n  }\n}"}, {"structure_type": "function", "name": "_initAnalytics", "docstring": "", "module": "service", "file_path": "data/service/backend_as_a_service.dart", "file_name": "backend_as_a_service.dart", "line": 43, "line_from": 43, "line_to": 781, "snippet": "  void _initAnalytics() {\n    _analytics.setAnalyticsCollectionEnabled(true).then((_) => _analytics.logAppOpen());\n  }\n\n  Future<String> signIn() async => _signIn();\n\n  Future<void> signOut() async => _signOut();\n\n  Future<bool> get isAuthenticated async => _checkAuthentication();\n\n  Future<void> listenToDeviceToken({\n    required void Function(String) onTokenFound,\n  }) async =>\n      _listenToDeviceToken(onTokenFound: onTokenFound);\n\n  Future<void> listenToFirebaseNotification() async {\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {\n      final Map<String, String?> payLoadMap = message.data.map(\n        (key, value) => MapEntry(key, (value as Object?)?.toString()),\n      );\n\n      final NotificationPayLoadEntity payLoad = await payLoadMap.toNotificationPayload();\n      final NotificationService notificationService = locate<NotificationService>();\n\n      await notificationService.onNotificationClickedForPushNotification(\n        payLoad: payLoad,\n        actionButtonKey: null,\n      );\n    });\n\n    FirebaseMessaging.onMessageOpenedApp.listen(onBackgroundPushNotificationReceived);\n  }\n\n  Future<void> logPromotionMessageSeen({required int messageId}) async {\n    await logEvent(\n      name: \"home_notification_seen\",\n      parameters: {\n        \"time\": DateTime.now().toIso8601String(),\n        \"user_id\": _auth.currentUser?.uid ?? \"\",\n        \"user_email\": _auth.currentUser?.email ?? \"\",\n        \"device_info\": await getDeviceInfo(),\n        \"message_id\": messageId,\n      },\n    );\n  }\n\n  Future<void> logEvent({required String name, Map<String, Object>? parameters}) async {\n    await _analytics.logEvent(name: name, parameters: parameters);\n  }\n\n  Future<void> addBookmark({required Map<String, Object?> bookmark}) async =>\n      _addItem(item: bookmark, folderName: _bookmarkFolderName);\n\n  Future<void> addPin({required Map<String, Object?> pin}) async => _addItem(item: pin, folderName: _pinFolderName);\n\n  Future<void> deleteAyahFromBookmarks({required int surahID, required int ayahID}) async => _deleteAyahFromCollection(\n        surahID: surahID,\n        ayahID: ayahID,\n        folderName: _bookmarkFolderName,\n      );\n\n  Future<void> deleteBookmarkFolder({required String folderName}) async => _deleteItemsByName(\n        name: folderName,\n        nameKey: \"folder_name\",\n        folderName: _bookmarkFolderName,\n      );\n\n  Future<void> deletePinByName({required String pinName}) async => _deleteItemsByName(\n        name: pinName,\n        nameKey: \"name\",\n        folderName: _pinFolderName,\n      );\n\n  Future<void> saveBookmarks({\n    required List<Map<String, Object?>> bookmarks,\n  }) async =>\n      _saveItems(\n        items: bookmarks,\n        folderName: _bookmarkFolderName,\n        nameKey: \"folder_name\",\n      );\n\n  Future<void> savePins({required List<Map<String, Object?>> pins}) async => _saveItems(\n        items: pins,\n        folderName: _pinFolderName,\n        nameKey: \"pin_name\",\n      );\n\n  Future<List<Map<String, Object?>>> getSavedBookmarks() async => _getSavedItems(folderName: _bookmarkFolderName);\n\n  Future<List<Map<String, Object?>>> getSavedPins() async => _getSavedItems(folderName: _pinFolderName);\n\n  Future<void> updateBookmarkFolderName({\n    required String folderName,\n    required String newFolderName,\n    required Color color,\n  }) async =>\n      _updateCollection(\n        collectionFolderName: _bookmarkFolderName,\n        itemName: folderName,\n        newItemName: newFolderName,\n        nameField: \"folder_name\",\n        itemColor: color,\n      );\n\n  Future<void> updatePin({\n    required int surahId,\n    required int ayahNumber,\n    required String name,\n    required String color,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _pinFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> querySnapshot =\n          await collection.where('surah_id', isEqualTo: surahId).get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      if (documents.isEmpty) return;\n\n      final WriteBatch batch = _fireStore.batch();\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        final Map<String, Object> data = {\n          'ayah_number': ayahNumber,\n          'name': name,\n          'color': color,\n          'updated_at': DateTime.now().toIso8601String(),\n        };\n        batch.update(document.reference, data);\n      }\n      await batch.commit();\n    });\n  }\n\n  Future<void> saveMemorizationPlans({required List<Map<String, Object?>> plans}) async => _saveItems(\n        items: plans,\n        folderName: _memorizationPlanFolderName,\n        nameKey: \"plan_name\",\n      );\n\n  Future<List<Map<String, Object?>>> getSavedMemorizationPlans() async =>\n      _getSavedItems(folderName: _memorizationPlanFolderName);\n\n  Future<void> deleteMemorizationPlan({required String planName}) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _memorizationPlanFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> querySnapshot =\n          await collection.where('plan_name', isEqualTo: planName).get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      if (documents.isEmpty) return;\n\n      await Future.wait(documents.map((doc) => doc.reference.delete()));\n    });\n  }\n\n  Future<void> updateMemorizationPlan({\n    required String planName,\n    String? newPlanName,\n    int? startSurahId,\n    int? startAyahId,\n    int? endSurahId,\n    int? endAyahId,\n    int? estimatedDays,\n    bool? hasNotification,\n    DateTime? notificationTime,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _memorizationPlanFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> querySnapshot =\n          await collection.where('plan_name', isEqualTo: planName).get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      if (documents.isEmpty) return;\n\n      final Map<String, Object?> updates = {\n        if (newPlanName != null) 'plan_name': newPlanName,\n        if (startSurahId != null) 'start_surah_id': startSurahId,\n        if (startAyahId != null) 'start_ayah_id': startAyahId,\n        if (endSurahId != null) 'end_surah_id': endSurahId,\n        if (endAyahId != null) 'end_ayah_id': endAyahId,\n        if (estimatedDays != null) 'estimated_days': estimatedDays,\n        if (hasNotification != null) 'has_notification': hasNotification,\n        if (notificationTime != null) 'notification_time': notificationTime.toIso8601String(),\n        'updated_at': DateTime.now().toIso8601String(),\n      };\n\n      await Future.wait(documents.map((doc) => doc.reference.update(updates)));\n    });\n  }\n\n  Future<void> saveNotes({required List<Map<String, Object?>> notes}) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _noteFolderName,\n      );\n\n      final WriteBatch batch = _fireStore.batch();\n      for (final note in notes) {\n        final DocumentReference<Map<String, Object?>> docRef = collection.doc();\n        batch.set(docRef, note);\n      }\n      await batch.commit();\n    });\n  }\n\n  Future<List<Map<String, Object?>>> getSavedNotes() async {\n    List<Map<String, Object?>> items = [];\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _noteFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> snapshot = await collection.get();\n      items = snapshot.docs.map((doc) => doc.data()).toList();\n    });\n\n    return items;\n  }\n\n  Future<void> deleteNote({required int surahId, required int ayahNumber}) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _noteFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> querySnapshot = await collection\n          .where(\n            'surah_id',\n            isEqualTo: surahId,\n          )\n          .where(\n            'ayah_number',\n            isEqualTo: ayahNumber,\n          )\n          .get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      if (documents.isEmpty) return;\n\n      final WriteBatch batch = _fireStore.batch();\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        batch.delete(document.reference);\n      }\n      await batch.commit();\n    });\n  }\n\n  Future<void> updateNote({\n    required int surahId,\n    required int ayahNumber,\n    required String title,\n    required String content,\n    required String color,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _noteFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> snapshot = await collection.where('surahId', isEqualTo: surahId).get();\n\n      if (snapshot.docs.isNotEmpty) {\n        final DocumentReference<Map<String, Object?>> doc = snapshot.docs.first.reference;\n        await doc.update({\n          'surah_id': surahId,\n          'ayah_number': ayahNumber,\n          'title': title,\n          'content': content,\n          'color': color,\n          'created_at': createdAt?.toIso8601String() ?? DateTime.now().toIso8601String(),\n          'updated_at': updatedAt?.toIso8601String() ?? DateTime.now().toIso8601String(),\n        });\n      }\n    });\n  }\n\n  late final GoogleSignIn _googleSignIn = GoogleSignIn();\n  late final FirebaseAuth _auth = FirebaseAuth.instance;\n  late final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;\n  late final FirebaseFirestore _fireStore = FirebaseFirestore.instance;\n  late final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n\n  Future<void> getRemoteNotice({\n    required void Function(Map<String, Object?>) onNotification,\n  }) async {\n    _fireStore.collection('remote-notice').doc('notice-bn').snapshots().listen((docSnapshot) {\n      onNotification(docSnapshot.data() ?? {});\n    });\n  }\n\n  Future<Map<String, dynamic>> getAppUpdateInfo() async {\n    Map<String, dynamic>? appUpdateInfo = {};\n    appUpdateInfo = await catchAndReturnFuture(() async {\n      final DocumentSnapshot<Map<String, dynamic>> docSnapshot =\n          await _fireStore.collection(\"remote-notice\").doc(\"app-update\").get();\n      return docSnapshot.data();\n    });\n    return appUpdateInfo ?? {};\n  }\n\n  Future<void> _deleteItemsByName({\n    required String name,\n    required String nameKey,\n    required String folderName,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n\n      final CollectionReference<Map<String, Object?>> collection =\n          _getFirestoreCollection(email: email, folderName: folderName);\n      final QuerySnapshot<Map<String, Object?>> querySnapshot = await collection.where(nameKey, isEqualTo: name).get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n      if (documents.isEmpty) return;\n\n      final WriteBatch batch = _fireStore.batch();\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        batch.delete(document.reference);\n      }\n      await batch.commit();\n    });\n  }\n\n  Future<List<Map<String, Object?>>> _getSavedItems({\n    required String folderName,\n  }) async {\n    List<Map<String, Object?>> items = [];\n\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n\n      final CollectionReference<Map<String, Object?>> collection =\n          _getFirestoreCollection(email: email, folderName: folderName);\n      final QuerySnapshot<Map<String, Object?>> snapshot = await collection.get();\n\n      items = snapshot.docs.map((doc) => doc.data()).toList();\n    });\n\n    return items;\n  }\n\n  Future<void> _updateCollection({\n    required String collectionFolderName,\n    required String itemName,\n    required String newItemName,\n    required String nameField,\n    required Color itemColor,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        folderName: collectionFolderName,\n        email: email,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> querySnapshot =\n          await collection.where(nameField, isEqualTo: itemName).get();\n\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      if (documents.isEmpty) return;\n\n      final WriteBatch batch = _fireStore.batch();\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        final String hexColor = getHexFromColor(itemColor);\n        final Map<String, Object> data = {\n          nameField: newItemName,\n          'color': hexColor,\n          'updated_at': DateTime.now().millisecondsSinceEpoch,\n        };\n        batch.update(document.reference, data);\n      }\n      await batch.commit();\n    });\n  }\n\n  CollectionReference<Map<String, Object?>> _getFirestoreCollection({\n    required String email,\n    required String folderName,\n  }) =>\n      _fireStore.collection(_collectionRootFolderName).doc(email).collection(folderName);\n\n  Future<void> _saveItems({\n    required List<Map<String, Object?>> items,\n    required String folderName,\n    required String nameKey,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      if (items.isEmpty) return;\n\n      // Ensure root document exists before saving items\n      await createRootDocument();\n\n      const String idKey = \"id\";\n      const String surahIdKey = \"surah_id\";\n      const String ayahIdKey = \"ayah_id\";\n\n      final String email = await _currentUserEmail;\n\n      final CollectionReference<Map<String, Object?>> collection =\n          _getFirestoreCollection(email: email, folderName: folderName);\n\n      // Performance optimization: Only query existing items if we need to check for duplicates\n      // This avoids an unnecessary Firestore read for single item operations\n      final bool checkForDuplicates = items.length > 1;\n      Set<int> existingIds = {};\n      Set<String> existingItemsWithSameContent = {};\n\n      if (checkForDuplicates) {\n        final QuerySnapshot<Map<String, Object?>> snapshot = await collection.get();\n\n        // Extract existing item IDs from the snapshot\n        existingIds = snapshot.docs.map((doc) => doc.data()[idKey] as int? ?? 0).toSet();\n\n        // Extract existing items with the same content from the snapshot\n        existingItemsWithSameContent = snapshot.docs.map((doc) {\n          final int surahId = doc.data()[surahIdKey] as int? ?? -1;\n          final int ayahId = doc.data()[ayahIdKey] as int? ?? -1;\n          final String folderName = doc.data()[nameKey] as String? ?? \"\";\n          return \"$surahId-$ayahId-$folderName\";\n        }).toSet();\n      }\n\n      final WriteBatch batch = _fireStore.batch();\n      int batchCount = 0;\n\n      for (final Map<String, Object?> item in items) {\n        // Skip duplicate check for single item operations\n        if (checkForDuplicates) {\n          final bool itemExists = existingIds.contains(item['id'] as int? ?? 0);\n          // Prevent saving the same bookmark item twice in the same folder\n          final bool itemWithSameContentExists =\n              existingItemsWithSameContent.contains(\"${item[surahIdKey]}-${item[ayahIdKey]}-${item[nameKey]}\");\n          if (itemExists && itemWithSameContentExists) continue;\n        }\n\n        batch.set(collection.doc(), item);\n        batchCount++;\n\n        // Firebase has a limit of 500 operations per batch\n        // Split into multiple batches if needed\n        if (batchCount >= 400) {\n          await batch.commit();\n          batchCount = 0;\n        }\n      }\n\n      // Only commit if we have operations in the batch\n      if (batchCount > 0) {\n        await batch.commit();\n      }\n    });\n  }\n\n  Future<void> _addItem({\n    required Map<String, Object?> item,\n    required String folderName,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      // Retrieve current user's email\n      final String email = await _currentUserEmail;\n\n      // Get the Firestore collection for the specified folder and user email\n      final CollectionReference<Map<String, Object?>> collection =\n          _getFirestoreCollection(email: email, folderName: folderName);\n\n      // Add the item to the collection\n      await collection.add(item);\n    });\n  }\n\n  Future<AuthCredential?> _signInWithGoogle() async {\n    return catchAndReturnFuture(() async {\n      // Sign in with Google\n      final GoogleSignInAccount? currentUser = await _googleSignIn.signIn();\n      if (currentUser == null) throw SignInException();\n\n      // Retrieve Google authentication data\n      final GoogleSignInAuthentication googleSignInAuthentication = await currentUser.authentication;\n      final String? accessToken = googleSignInAuthentication.accessToken;\n      final String? idToken = googleSignInAuthentication.idToken;\n\n      // Create Google AuthCredential using the retrieved data\n      final AuthCredential credential = GoogleAuthProvider.credential(\n        accessToken: accessToken,\n        idToken: idToken,\n      );\n\n      return credential;\n    });\n  }\n\n  Future<void> _purgeCredentialCache() async {\n    _currentUserIdCache = null;\n    _currentUserEmailCache = null;\n  }\n\n  String? _currentUserIdCache;\n\n  Future<String> get _currentUserId async {\n    _currentUserIdCache ??= _auth.currentUser?.uid ?? \"\";\n    return _currentUserIdCache!;\n  }\n\n  String? _currentUserEmailCache;\n\n  Future<String> get _currentUserEmail async {\n    _currentUserEmailCache ??= _auth.currentUser?.email ?? \"\";\n    return _currentUserEmailCache!;\n  }\n\n  static const String _collectionRootFolderName = 'collections';\n  static const String _bookmarkFolderName = 'bookmarks';\n  static const String _pinFolderName = 'pins';\n  static const String _memorizationPlanFolderName = \"memorization_plans\";\n  static const String _noteFolderName = \"notes\";\n\n  Future<String> _signIn() async {\n    // Check if the user is already signed in\n    if (_auth.currentUser != null) return _auth.currentUser!.uid;\n\n    // Sign in with Google and retrieve the authentication credential\n    final AuthCredential? credential = await _signInWithGoogle();\n\n    // If the credential is null, throw a SignInException\n    if (credential == null) throw SignInException();\n\n    // Use the credential to sign in the user\n    final UserCredential userCredential = await _auth.signInWithCredential(credential);\n\n    // Retrieve the signed-in user from the UserCredential\n    final User? user = userCredential.user;\n\n    // If the user is null, throw a SignInException\n    if (user == null) throw SignInException();\n    // Retrieve the user ID\n    final String userId = user.uid;\n\n    // Cache the current user ID and email\n    _currentUserIdCache = userId;\n    _currentUserEmailCache = user.email;\n\n    // Log the login event to analytics\n    await _analytics.logLogin(loginMethod: \"Google Sign In\");\n\n    return userId;\n  }\n\n  Future<void> _signOut() async {\n    await _onAuthenticationValidated(() async {\n      await _googleSignIn.signOut();\n      await _auth.signOut();\n      await _purgeCredentialCache();\n    });\n  }\n\n  Future<bool> _checkAuthentication() async {\n    final bool? isAuthenticated = await catchAndReturnFuture(\n      () async => (await _currentUserId).isNotEmpty && (await _currentUserEmail).isNotEmpty,\n    );\n    return isAuthenticated ?? false;\n  }\n\n  Future<void> _onAuthenticationValidated(\n    FutureOr<void> Function() onValidated,\n  ) async {\n    final bool isAuthenticated = await _checkAuthentication();\n    isAuthenticated ? await onValidated() : logDebug(\"User is not authenticated\");\n  }\n\n  final Lock _listenToDeviceTokenLock = Lock();\n  String? _inMemoryDeviceToken;\n\n  Future<void> _listenToDeviceToken({\n    required void Function(String) onTokenFound,\n  }) async {\n    // prevents this function to be called multiple times in short period\n    await _listenToDeviceTokenLock.synchronized(() async {\n      _inMemoryDeviceToken ??= await _firebaseMessaging.getToken();\n      logDebug(\"token -> $_inMemoryDeviceToken\");\n      if (_inMemoryDeviceToken != null) onTokenFound(_inMemoryDeviceToken!);\n      _firebaseMessaging.onTokenRefresh.listen((String? token) {\n        if (token != null) onTokenFound(token);\n      });\n    });\n  }\n\n  Future<void> _deleteAyahFromCollection({\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n  }) async {\n    // Validate authentication before proceeding\n    await _onAuthenticationValidated(() async {\n      // Define the key for the surah ID field\n      const String surahIdKey = \"surah_id\";\n      const String ayahIdKey = \"ayah_id\";\n\n      // Retrieve the current user's email\n      final String email = await _currentUserEmail;\n\n      // Get the Firestore collection for the specified folder and user\n      final CollectionReference<Map<String, Object?>> collection =\n          _getFirestoreCollection(email: email, folderName: folderName);\n\n      // Query the collection for documents with matching surah and ayah IDs\n      final QuerySnapshot<Map<String, Object?>> querySnapshot =\n          await collection.where(surahIdKey, isEqualTo: surahID).where(ayahIdKey, isEqualTo: ayahID).get();\n\n      // Retrieve the list of documents\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      // If no documents match the query, return\n      if (documents.isEmpty) return;\n\n      // Create a WriteBatch to perform the delete operation\n      final WriteBatch batch = _fireStore.batch();\n\n      // Add the delete operation for each document to the batch\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        batch.delete(document.reference);\n      }\n\n      // Commit the batch operation to delete the documents\n      await batch.commit();\n    });\n  }\n\n  Future<void> deleteAyahFromBookmarkFolder({\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n  }) async {\n    await _onAuthenticationValidated(() async {\n      // Retrieve the current user's email\n      final String email = await _currentUserEmail;\n\n      // Key for the \"surah_id\" field in Firestore\n      const String surahIdKey = \"surah_id\";\n      const String ayahIdKey = \"ayah_id\";\n\n      // Get the Firestore collection for bookmarks\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _bookmarkFolderName,\n      );\n\n      // Query Firestore for documents with matching folder name and surah ID\n      final QuerySnapshot<Map<String, Object?>> querySnapshot = await collection\n          .where(\"folder_name\", isEqualTo: folderName)\n          .where(surahIdKey, isEqualTo: surahID)\n          .where(ayahIdKey, isEqualTo: ayahID)\n          .get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      // If no matching documents found, return\n      if (documents.isEmpty) return;\n\n      // Create a batch operation for efficient deletion\n      final WriteBatch batch = _fireStore.batch();\n\n      // Delete each matching document in the batch\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        batch.delete(document.reference);\n      }\n\n      // Commit the batch operation to delete the documents\n      await batch.commit();\n    });\n  }\n\n  Future<void> deletePin({required String name}) async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n      final CollectionReference<Map<String, Object?>> collection = _getFirestoreCollection(\n        email: email,\n        folderName: _pinFolderName,\n      );\n\n      final QuerySnapshot<Map<String, Object?>> querySnapshot = await collection.where('name', isEqualTo: name).get();\n      final List<QueryDocumentSnapshot<Map<String, Object?>>> documents = querySnapshot.docs;\n\n      if (documents.isEmpty) return;\n\n      final WriteBatch batch = _fireStore.batch();\n      for (final QueryDocumentSnapshot<Map<String, Object?>> document in documents) {\n        batch.delete(document.reference);\n      }\n      await batch.commit();\n    });\n  }\n\n  // Add this new method to create the root document\n  Future<void> createRootDocument() async {\n    await _onAuthenticationValidated(() async {\n      final String email = await _currentUserEmail;\n\n      // Create the root collection document if it doesn't exist\n      final DocumentReference<Map<String, Object?>> docRef =\n          _fireStore.collection(_collectionRootFolderName).doc(email);\n\n      // Only create if it doesn't exist\n      final docSnapshot = await docRef.get();\n      if (!docSnapshot.exists) {\n        await docRef.set({\n          'created_at': DateTime.now().toIso8601String(),\n          'email': email,\n          'last_synced': DateTime.now().toIso8601String(),\n          'user_id': await _currentUserId,\n        });\n        logDebug(\"Created root document for user: $email\");\n      }\n    });\n  }\n}"}, {"structure_type": "function", "name": "setUp", "docstring": "", "module": "service", "file_path": "data/service/local_cache_service.dart", "file_name": "local_cache_service.dart", "line": 13, "line_from": 13, "line_to": 133, "snippet": "  static Future<void> setUp() async {\n    final Directory document = await getApplicationDocumentsDirectory();\n    final String documentPath = document.path;\n    Hive.init(documentPath);\n    await Hive.openBox<Object>(_storageFileName);\n  }\n\n  static String get _storageFileName => \"${_secretVaultName}_239090\";\n\n  /// Saves the provided `value` to the persistent storage using the specified `key`.\n  ///\n  /// The type parameter `T` represents the type of the `value` being saved,\n  /// and it must be a subtype of `Object`.\n  ///\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  /// await saveData(key: CacheKeys.userId, value: 'sufi_bhai_28283');\n  /// ```\n  Future<void> saveData<T extends Object>({\n    required String key,\n    required T value,\n  }) async {\n    await catchFutureOrVoid(() async {\n      if (key.isEmpty) return;\n      await _hiveBox.put(key, value);\n    });\n  }\n\n  // Future<String?> getOldBookmarkJsonFile() async {\n  //   bool hasPermission = await PermissionService.checkPermission();\n\n  //   if (hasPermission) {\n  //     const String bookmarkFilePath = '/storage/emulated/0/quranAppBookmark/bookmark.json';\n  //     final File bookmarkFile = File(bookmarkFilePath);\n  //     if (await bookmarkFile.exists()) {\n  //       return await bookmarkFile.readAsString();\n  //     }\n  //   }\n  //   return null;\n  // }\n\n  Future<String?> getOldBookmarkJsonFile() async {\n    const MethodChannel platformMethodChannel = MethodChannel(\"com.ihadis.quran/legacy\");\n\n    if (!Platform.isAndroid) {\n      logError(\"Platform is not android, skipping legacy data retrieval\");\n      return null;\n    }\n\n    final bool alreadyRetrieved = getData(key: CacheKeys.retrievedPreviousBookmarks) ?? false;\n\n    if (alreadyRetrieved) {\n      logError(\"Already retrieved legacy data, skipping\");\n      return null;\n    }\n\n    try {\n      final String? legacyBookmarkJson = await platformMethodChannel.invokeMethod<String>(\"fetch_bookmarks\");\n\n      if (legacyBookmarkJson == null || legacyBookmarkJson.isEmpty) {\n        logError(\"Legacy bookmark json is null or empty\");\n        return null;\n      }\n\n      await saveData(key: CacheKeys.retrievedPreviousBookmarks, value: true);\n      return legacyBookmarkJson;\n    } catch (e) {\n      logError(\"Error fetching legacy bookmarks: $e\");\n      return null;\n    }\n  }\n\n  /// Retrieves data from persistent storage using the specified `key`.\n  ///\n  /// The type parameter `T` represents the type of the data being retrieved,\n  /// and it allows writing type-safe and reusable code that can operate on\n  /// different data types.\n  ///\n  ///\n  /// If an error occurs during the retrieval process, an error message is logged,\n  /// and `null` is returned.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  /// String? userId = getData<String>(key: CacheKeys.userId);\n  /// bool? isFirstTime = getData<bool>(key: CacheKeys.firstTime);\n  /// ```\n  ///\n  /// Note: This function assumes that the `_hiveBox` instance is properly initialized\n  /// and accessible within the scope of this function.\n  T? getData<T>({required String key}) {\n    try {\n      final T? result = _hiveBox.get(key) as T?;\n      return result;\n    } catch (e) {\n      logError(\"getData: key: $key\\nerror: $e\");\n      return null;\n    }\n  }\n\n  /// Deletes data from persistent storage for the specified `key`.\n  ///\n  /// If the `key` does not exist, the operation completes without any effect.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  /// await deleteData(key: CacheKeys.userId);\n  /// ```\n  Future<void> deleteData({required String key}) async {\n    await catchFutureOrVoid(() async {\n      if (key.isEmpty) return;\n      await _hiveBox.delete(key);\n    });\n  }\n\n  late final Box<Object> _hiveBox = Hive.box(_storageFileName);\n}"}, {"structure_type": "function", "name": "initialize", "docstring": "Initialize the database connection", "module": "database", "file_path": "data/service/database/external_db_service.dart", "file_name": "external_db_service.dart", "line": 25, "line_from": 25, "line_to": 355, "snippet": "  Future<void> initialize() async {\n    if (_database != null) return;\n\n    try {\n      final dbFile = File(_dbFilePath);\n\n      if (!await dbFile.exists()) {\n        throw Exception('External database file not found at: $_dbFilePath');\n      }\n\n      _database = await openDatabase(\n        _dbFilePath,\n        readOnly: true,\n      );\n    } catch (e) {\n      Logger.error('Error initializing external database: $e', _tag);\n      throw Exception('Failed to initialize external database: $e');\n    }\n  }\n\n  /// Close the database connection\n  Future<void> close() async {\n    if (_database != null) {\n      await _database!.close();\n      _database = null;\n    }\n  }\n\n  /// Helper method to ensure database is initialized\n  Future<Database> get database async {\n    if (_database == null) {\n      await initialize();\n    }\n    return _database!;\n  }\n\n  /// Get QuranInfo data by surah ID\n  Future<Map<String, dynamic>?> getQuranInfoBySurahId(int surahId) async {\n    try {\n      final db = await database;\n      final List<Map<String, dynamic>> result = await db.query(\n        'info',\n        where: 'surah_id = ?',\n        whereArgs: [surahId],\n      );\n\n      return result.isNotEmpty ? result.first : null;\n    } catch (e) {\n      Logger.error('Error getting QuranInfo by surahId: $e', _tag);\n      return null;\n    }\n  }\n\n  /// Get Nuzul data by surah ID\n  Future<List<Map<String, dynamic>>> getNuzulBySurahId(int surahId) async {\n    try {\n      final db = await database;\n      return await db.query(\n        'nuzul',\n        where: 'surah_id = ?',\n        whereArgs: [surahId],\n        orderBy: 'from_ayah ASC',\n      );\n    } catch (e) {\n      Logger.error('Error getting Nuzul by surahId: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Get all Nuzul data\n  Future<List<Map<String, dynamic>>> getAllNuzul() async {\n    try {\n      final db = await database;\n      return await db.query(\n        'nuzul',\n        orderBy: 'surah_id ASC, from_ayah ASC',\n      );\n    } catch (e) {\n      Logger.error('Error getting all Nuzul data: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Get unique Nuzul surah IDs\n  Future<List<int>> getUniqueNuzulSurahIds() async {\n    try {\n      final db = await database;\n      final List<Map<String, dynamic>> result = await db.rawQuery(\n        'SELECT DISTINCT surah_id FROM nuzul ORDER BY surah_id ASC',\n      );\n\n      return result.map((row) => row['surah_id'] as int).toList();\n    } catch (e) {\n      Logger.error('Error getting unique Nuzul surah IDs: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Get Duas by category ID\n  Future<List<Map<String, dynamic>>> getDuasByCategoryId(int categoryId) async {\n    try {\n      final db = await database;\n      return await db.query(\n        'dua',\n        where: 'category_id = ?',\n        whereArgs: [categoryId],\n        orderBy: 'id ASC',\n      );\n    } catch (e) {\n      Logger.error('Error getting Duas by category ID: $e', _tag);\n      return [];\n    }\n  }\n\n  /// Helper method to convert result to QuranInfoTableData\n  QuranInfoTableData? mapToQuranInfoTableData(Map<String, dynamic>? data) {\n    if (data == null) return null;\n\n    return QuranInfoTableData(\n      surahId: data['surah_id'] as int,\n      en: data['en'] as String,\n      bn: data['bn'] as String,\n    );\n  }\n\n  /// Helper method to convert result to NuzulDatabaseTableData\n  NuzulDatabaseTableData mapToNuzulDatabaseTableData(Map<String, dynamic> data) {\n    return NuzulDatabaseTableData(\n      surahId: data['surah_id'] as int,\n      fromAyah: data['from_ayah'] as int,\n      toAyah: data['to_ayah'] as int,\n      bn: data['bn'] as String,\n      en: data['en'] as String,\n    );\n  }\n\n  /// Helper method to convert result to DuaDatabaseTableData\n  DuaDatabaseTableData mapToDuaDatabaseTableData(Map<String, dynamic> data) {\n    return DuaDatabaseTableData(\n      id: data['id'] as int,\n      categoryId: data['category_id'] as int,\n      surahId: data['surah_id'] as int?,\n      ayahId: data['ayah_id'] as String?,\n      lang: data['lang'] as String?,\n      name: data['name'] as String?,\n      uthmani: data['uthmani'] as String?,\n      indopak: data['indopak'] as String?,\n      translation: data['translation'] as String?,\n      note: data['note'] as String?,\n      reference: data['reference'] as String?,\n      audio: data['audio'] as int?,\n    );\n  }\n\n  /// Get grammar summary data\n  Future<Map<String, dynamic>?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  }) async {\n    try {\n      final db = await database;\n      final List<Map<String, dynamic>> result = await db.query(\n        'same_exact_summary_data_table',\n        where: 'surah = ? AND ayah = ? AND word = ?',\n        whereArgs: [surahId, ayahId, wordIndex],\n      );\n\n      return result.isNotEmpty ? result.first : null;\n    } catch (e) {\n      Logger.error('Error getting grammar summary data: $e', _tag);\n      return null;\n    }\n  }\n\n  /// Helper method to convert result to GrammarSummaryTableData\n  GrammarSummaryData mapToGrammarSummaryTableData(Map<String, dynamic> data) {\n    return GrammarSummaryData(\n      surah: data['surah'] as int,\n      ayah: data['ayah'] as int,\n      word: data['word'] as int,\n      sameRoot: data['same_root'] as String?,\n      exactMatch: data['exact_match'] as String?,\n      summary: data['summary'] as String?,\n    );\n  }\n}\n\n/// A factory to create and manage external database services\nclass ExternalDbFactory {\n  static final Map<String, ExternalDbService> _instances = {};\n  static const String _tag = 'ExternalDbFactory';\n\n  /// Get external database path\n  static Future<String> getExternalDbPath(String dbName) async {\n    try {\n      // Use getApplicationDocumentsDirectory for iOS compatibility\n      // For Android, this will map to the app's internal storage\n      final appDir = await getApplicationDocumentsDirectory();\n      final path = p.join(appDir.path, 'external_dbs', dbName);\n\n      return path;\n    } catch (e) {\n      Logger.error('Error getting external DB path: $e', _tag);\n      rethrow;\n    }\n  }\n\n  /// Get an ExternalDbService instance for a specific database\n  static Future<ExternalDbService> getService(String dbName) async {\n    if (_instances.containsKey(dbName)) {\n      return _instances[dbName]!;\n    }\n\n    final dbPath = await getExternalDbPath(dbName);\n    final service = ExternalDbService(dbPath);\n\n    try {\n      await service.initialize();\n      _instances[dbName] = service;\n      return service;\n    } catch (e) {\n      Logger.error('Failed to get external db service for $dbName: $e', _tag);\n      throw Exception('Failed to get external db service for $dbName: $e');\n    }\n  }\n\n  /// Download an external database file from the server\n  static Future<bool> downloadExternalDb({\n    required String dbName,\n    required String url,\n    void Function(int percentage)? onProgress,\n    required bool Function() isCancelled,\n  }) async {\n    try {\n      final dbPath = await getExternalDbPath(dbName);\n      final dbFile = File(dbPath);\n\n      // Create directory if it doesn't exist\n      if (!await dbFile.parent.exists()) {\n        await dbFile.parent.create(recursive: true);\n      }\n\n      // Delete existing file if it exists\n      if (await dbFile.exists()) {\n        await dbFile.delete();\n      }\n\n      // Download the file\n      final dio = Dio();\n      await dio.download(\n        url,\n        dbPath,\n        onReceiveProgress: (received, total) {\n          if (total != -1) {\n            final percentage = (received / total * 100).round();\n            onProgress?.call(percentage);\n          }\n\n          // Check if the download should be cancelled\n          if (isCancelled()) {\n            throw Exception('Download cancelled by user');\n          }\n        },\n      );\n\n      // Validate the downloaded database\n      try {\n        final db = await openDatabase(dbPath, readOnly: true);\n\n        // Check if required tables exist\n        final tables =\n            await db.query('sqlite_master', where: \"type = 'table' AND name IN ('quran_info', 'nuzul', 'dua')\");\n\n        await db.close();\n\n        if (tables.isEmpty) {\n          Logger.error('Downloaded database $dbName is missing required tables', _tag);\n          await dbFile.delete();\n          return false;\n        }\n\n        return true;\n      } catch (e) {\n        Logger.error('Error validating downloaded database $dbName: $e', _tag);\n        await dbFile.delete();\n        return false;\n      }\n    } catch (e) {\n      Logger.error('Error downloading external database $dbName: $e', _tag);\n      return false;\n    }\n  }\n\n  /// Close all database connections\n  static Future<void> closeAll() async {\n    for (final service in _instances.values) {\n      await service.close();\n    }\n    _instances.clear();\n  }\n\n  /// Check if an external database exists\n  static Future<bool> doesExternalDbExist(String dbName) async {\n    try {\n      final dbPath = await getExternalDbPath(dbName);\n      final dbFile = File(dbPath);\n      final exists = await dbFile.exists();\n      return exists;\n    } catch (e) {\n      Logger.error('Error checking if external DB exists: $e', _tag);\n      return false;\n    }\n  }\n\n  /// Ensure the external database directory exists\n  static Future<void> ensureExternalDbDirectoryExists() async {\n    try {\n      final appDir = await getApplicationDocumentsDirectory();\n      final dirPath = p.join(appDir.path, 'external_dbs');\n      final dir = Directory(dirPath);\n\n      if (!await dir.exists()) {\n        await dir.create(recursive: true);\n      }\n    } catch (e) {\n      Logger.error('Error ensuring external DB directory exists: $e', _tag);\n      rethrow;\n    }\n  }\n}"}, {"structure_type": "function", "name": "=>", "docstring": "", "module": "collection", "file_path": "data/service/database/collection/user_data_storage.dart", "file_name": "user_data_storage.dart", "line": 47, "line_from": 47, "line_to": 643, "snippet": "  Future<List<BookmarkData>> get allBookmarks =>\n      (select(bookmark)..orderBy([(tbl) => OrderingTerm(expression: tbl.foldername)])).get();\n\n  Future<BookmarkData?> getBookmarksOfSameFolderWithSameAyah({\n    required int surahID,\n    required String folderName,\n    required int ayahID,\n  }) =>\n      ((select(bookmark))\n            ..where(\n                (tbl) => tbl.suraId.equals(surahID) & tbl.ayahId.equals(ayahID) & tbl.foldername.equals(folderName)))\n          .getSingleOrNull();\n\n  Future<int> addAyahToBookmarkFolder({\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n    required String color,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n  }) {\n    return transaction(() async {\n      // First check if a bookmark with the same folder, surah, and ayah already exists\n      final existingBookmark = await (select(bookmark)\n            ..where(\n                (tbl) => tbl.foldername.equals(folderName) & tbl.suraId.equals(surahID) & tbl.ayahId.equals(ayahID)))\n          .getSingleOrNull();\n\n      if (existingBookmark != null) {\n        // If it exists, update it instead of inserting a new one\n        return await (update(bookmark)..where((tbl) => tbl.id.equals(existingBookmark.id))).write(BookmarkCompanion(\n          color: Value(color),\n          updatedAt: Value(updatedAt ?? DateTime.now()),\n        ));\n      } else {\n        // If it doesn't exist, insert a new one\n        return await into(bookmark).insert(\n          BookmarkCompanion.insert(\n            foldername: folderName,\n            suraId: surahID,\n            ayahId: ayahID,\n            color: color,\n            createdAt: createdAt ?? DateTime.now(),\n            updatedAt: updatedAt ?? DateTime.now(),\n          ),\n        );\n      }\n    });\n  }\n\n  Future<void> deleteAyahFromBookmarkFolder({\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n  }) {\n    return transaction(() async {\n      // First, get the folder color BEFORE deleting the bookmark\n      // This ensures we preserve the original color\n      final folderBookmarks = await (select(bookmark)..where((tbl) => tbl.foldername.equals(folderName))).get();\n      final String originalColor = folderBookmarks.firstWhereOrNull((b) => true)?.color ?? \"66BB6A\";\n\n      // Delete the specific bookmark\n      await (delete(bookmark)\n            ..where(\n                (tbl) => tbl.suraId.equals(surahID) & tbl.ayahId.equals(ayahID) & tbl.foldername.equals(folderName)))\n          .go();\n\n      // Check if this folder is now empty\n      final remainingBookmarks = await (select(bookmark)..where((tbl) => tbl.foldername.equals(folderName))).get();\n\n      // If folder is empty, create a placeholder bookmark to preserve the folder with the ORIGINAL color\n      if (remainingBookmarks.isEmpty) {\n        await into(bookmark).insert(\n          BookmarkCompanion.insert(\n            foldername: folderName,\n            suraId: 0, // Special ID to mark as placeholder\n            ayahId: 0, // Special ID to mark as placeholder\n            color: originalColor,\n            createdAt: DateTime.now(),\n            updatedAt: DateTime.now(),\n          ),\n        );\n      }\n    });\n  }\n\n  Future<void> deleteBookmarkFolderByName({required String folderName}) {\n    return transaction(() async {\n      await (delete(bookmark)..where((tbl) => tbl.foldername.equals(folderName))).go();\n    });\n  }\n\n  Future<List<BookmarkData?>> getBookmarksByFolderName({required String folderName}) =>\n      (select(bookmark)..where((tbl) => tbl.foldername.equals(folderName))).get();\n\n  Future<List<BookmarkData>> getBookmarkFolderBySurahAndAyah({\n    required int surahID,\n    required int ayahID,\n  }) {\n    return (select(bookmark)..where((tbl) => tbl.suraId.equals(surahID) & tbl.ayahId.equals(ayahID))).get();\n  }\n\n  // deleteAllBookmarksOfSurahAndAyah\n\n  Future<void> deleteAllBookmarksOfSurahAndAyah({\n    required int surahID,\n    required int ayahID,\n  }) {\n    return transaction(() async {\n      await (delete(bookmark)..where((tbl) => tbl.suraId.equals(surahID) & tbl.ayahId.equals(ayahID))).go();\n    });\n  }\n\n  Future<void> updateBookmarkFolderName({\n    required String folderName,\n    required String newFolderName,\n    required String color,\n  }) {\n    return transaction(() async {\n      await (update(bookmark)..where((tbl) => tbl.foldername.equals(folderName))).write(BookmarkCompanion(\n        foldername: Value(newFolderName),\n        color: Value(color),\n        updatedAt: Value(DateTime.now()),\n      ));\n    });\n  }\n\n  // Pin methods\n  Future<List<PinData>> get allPins => (select(pin)..orderBy([(tbl) => OrderingTerm(expression: tbl.createdAt)])).get();\n\n  Future<PinData?> getPinBySurah({required int surahId}) =>\n      (select(pin)..where((tbl) => tbl.surahId.equals(surahId))).getSingleOrNull();\n\n  Future<PinData?> getPinByName({required String name}) =>\n      (select(pin)..where((tbl) => tbl.name.equals(name))).getSingleOrNull();\n\n  Future<int> addPin({\n    required int surahId,\n    required int ayahNumber,\n    required String name,\n    required String color,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n  }) {\n    return transaction(() async {\n      // First check if a pin already exists with this name\n      final existingPin = await getPinByName(name: name);\n      if (existingPin != null) {\n        // If pin exists, update it\n        await updatePin(\n          surahId: surahId,\n          ayahNumber: ayahNumber,\n          name: name,\n          color: color,\n        );\n        return existingPin.id;\n      }\n\n      // If no pin exists, create a new one\n      return into(pin).insert(\n        PinCompanion.insert(\n          surahId: surahId,\n          ayahNumber: ayahNumber,\n          name: name,\n          color: color,\n          createdAt: createdAt ?? DateTime.now(),\n          updatedAt: updatedAt ?? DateTime.now(),\n        ),\n      );\n    });\n  }\n\n  Future<void> updatePin({\n    required int surahId,\n    required int ayahNumber,\n    required String name,\n    required String color,\n  }) {\n    return transaction(() async {\n      await (update(pin)..where((tbl) => tbl.name.equals(name))).write(\n        PinCompanion(\n          surahId: Value(surahId),\n          ayahNumber: Value(ayahNumber),\n          name: Value(name),\n          color: Value(color),\n          updatedAt: Value(DateTime.now()),\n        ),\n      );\n    });\n  }\n\n  Future<void> deletePin({required String name}) {\n    return transaction(() async {\n      await (delete(pin)..where((tbl) => tbl.name.equals(name))).go();\n    });\n  }\n\n  // Memorization Plan Operations\n  Future<List<MemorizationPlanData>> get allMemorizationPlans =>\n      (select(memorizationPlan)..orderBy([(tbl) => OrderingTerm(expression: tbl.createdAt)])).get();\n\n  Future<MemorizationPlanData?> getMemorizationPlanByName(String planName) =>\n      (select(memorizationPlan)..where((tbl) => tbl.planName.equals(planName))).getSingleOrNull();\n\n  Future<void> addMemorizationPlan({\n    required String planName,\n    required int startSurahId,\n    required int startAyahId,\n    required int endSurahId,\n    required int endAyahId,\n    required int estimatedDays,\n    required bool hasNotification,\n    DateTime? notificationTime,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n  }) {\n    return transaction(() async {\n      await into(memorizationPlan).insert(\n        MemorizationPlanCompanion.insert(\n          planName: planName,\n          startSurahId: startSurahId,\n          startAyahId: startAyahId,\n          endSurahId: endSurahId,\n          endAyahId: endAyahId,\n          estimatedDays: estimatedDays,\n          hasNotification: hasNotification,\n          notificationTime: Value(notificationTime),\n          createdAt: createdAt ?? DateTime.now(),\n          updatedAt: updatedAt ?? DateTime.now(),\n        ),\n      );\n    });\n  }\n\n  Future<void> updateMemorizationPlan({\n    required String planName,\n    String? newPlanName,\n    int? startSurahId,\n    int? startAyahId,\n    int? endSurahId,\n    int? endAyahId,\n    int? estimatedDays,\n    bool? hasNotification,\n    DateTime? notificationTime,\n  }) {\n    return transaction(() async {\n      final query = update(memorizationPlan)..where((tbl) => tbl.planName.equals(planName));\n\n      if (newPlanName != null) {\n        // If planName is being updated, we need to update the memorized Ayahs first\n        final existingPlan = await getMemorizationPlanByName(planName);\n        if (existingPlan != null) {\n          // Update memorized Ayahs to reference the new plan name\n          await (update(memorizedAyah)..where((tbl) => tbl.planName.equals(planName)))\n              .write(MemorizedAyahCompanion(planName: Value(newPlanName)));\n\n          // Delete old plan and create new one with updated values\n          await deleteMemorizationPlan(planName: planName);\n          await addMemorizationPlan(\n            planName: newPlanName,\n            startSurahId: startSurahId ?? existingPlan.startSurahId,\n            startAyahId: startAyahId ?? existingPlan.startAyahId,\n            endSurahId: endSurahId ?? existingPlan.endSurahId,\n            endAyahId: endAyahId ?? existingPlan.endAyahId,\n            estimatedDays: estimatedDays ?? existingPlan.estimatedDays,\n            hasNotification: hasNotification ?? existingPlan.hasNotification,\n            notificationTime: notificationTime ?? existingPlan.notificationTime,\n            createdAt: existingPlan.createdAt,\n          );\n        }\n      } else {\n        await query.write(\n          MemorizationPlanCompanion(\n            startSurahId: startSurahId == null ? const Value.absent() : Value(startSurahId),\n            startAyahId: startAyahId == null ? const Value.absent() : Value(startAyahId),\n            endSurahId: endSurahId == null ? const Value.absent() : Value(endSurahId),\n            endAyahId: endAyahId == null ? const Value.absent() : Value(endAyahId),\n            estimatedDays: estimatedDays == null ? const Value.absent() : Value(estimatedDays),\n            hasNotification: hasNotification == null ? const Value.absent() : Value(hasNotification),\n            notificationTime: notificationTime == null ? const Value.absent() : Value(notificationTime),\n            updatedAt: Value(DateTime.now()),\n          ),\n        );\n      }\n    });\n  }\n\n  Future<void> deleteMemorizationPlan({required String planName}) {\n    return transaction(() async {\n      await (delete(memorizationPlan)..where((tbl) => tbl.planName.equals(planName))).go();\n    });\n  }\n\n  Future<void> memorizeAyah({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  }) {\n    return transaction(() async {\n      await into(memorizedAyah).insert(\n        MemorizedAyahCompanion.insert(\n          planName: planName,\n          surahId: surahId,\n          ayahId: ayahId,\n          memorizedAt: DateTime.now(),\n        ),\n      );\n    });\n  }\n\n  Future<void> unmemorizeAyah({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  }) {\n    return transaction(() async {\n      await (delete(memorizedAyah)\n            ..where((tbl) => tbl.planName.equals(planName) & tbl.surahId.equals(surahId) & tbl.ayahId.equals(ayahId)))\n          .go();\n    });\n  }\n\n  Future<bool> isAyahMemorized({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  }) async {\n    final result = await (select(memorizedAyah)\n          ..where((tbl) => tbl.planName.equals(planName) & tbl.surahId.equals(surahId) & tbl.ayahId.equals(ayahId)))\n        .get();\n    return result.isNotEmpty;\n  }\n\n  Future<int> getMemorizedAyahsCount({\n    required String planName,\n    required int surahId,\n  }) async {\n    final result = await (select(memorizedAyah)\n          ..where((tbl) => tbl.planName.equals(planName) & tbl.surahId.equals(surahId)))\n        .get();\n    return result.length;\n  }\n\n  Future<MemorizedAyahEntity?> getLastMemorizedAyah(String planName) async {\n    final result = await (select(memorizedAyah)\n          ..where((tbl) => tbl.planName.equals(planName))\n          ..orderBy([\n            (tbl) => OrderingTerm(expression: tbl.surahId, mode: OrderingMode.desc),\n            (tbl) => OrderingTerm(expression: tbl.ayahId, mode: OrderingMode.desc),\n          ])\n          ..limit(1))\n        .getSingleOrNull();\n\n    if (result == null) return null;\n\n    return MemorizedAyahEntity(\n      surahId: result.surahId,\n      ayahId: result.ayahId,\n      memorizedAt: result.memorizedAt,\n    );\n  }\n\n  // Note methods\n  Future<List<NoteData>> get allNotes =>\n      (select(note)..orderBy([(tbl) => OrderingTerm(expression: tbl.createdAt)])).get();\n\n  Future<NoteData?> getNoteBySurah({required int surahId}) =>\n      (select(note)..where((tbl) => tbl.surahId.equals(surahId))).getSingleOrNull();\n\n  Future<NoteData?> getNoteByAyah({required int surahId, required int ayahNumber}) =>\n      (select(note)..where((tbl) => tbl.surahId.equals(surahId) & tbl.ayahNumber.equals(ayahNumber))).getSingleOrNull();\n\n  Future<List<NoteData>> getNotesBySurah({required int surahId}) =>\n      (select(note)..where((tbl) => tbl.surahId.equals(surahId))).get();\n\n  Future<int> addNote({\n    required int surahId,\n    required int ayahNumber,\n    required String title,\n    required String content,\n    required String color,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n    bool isImport = false,\n  }) {\n    return transaction(() async {\n      // Skip the duplicate check if it's an import operation\n      if (!isImport) {\n        // Check if a note already exists for this surah and ayah combination\n        final existingNote = await getNoteByAyah(surahId: surahId, ayahNumber: ayahNumber);\n        if (existingNote != null) {\n          // If note exists for this specific ayah, update it\n          await updateNote(\n            surahId: surahId,\n            ayahNumber: ayahNumber,\n            title: title,\n            content: content,\n            color: color,\n            updatedAt: updatedAt,\n          );\n          return existingNote.id;\n        }\n      }\n\n      // If no note exists for this specific ayah or it's an import, create a new one\n      return into(note).insert(\n        NoteCompanion.insert(\n          surahId: surahId,\n          ayahNumber: ayahNumber,\n          title: title,\n          content: content,\n          color: color,\n          createdAt: createdAt ?? DateTime.now(),\n          updatedAt: updatedAt ?? DateTime.now(),\n        ),\n      );\n    });\n  }\n\n  Future<void> updateNote({\n    required int surahId,\n    required String title,\n    required String content,\n    required String color,\n    required int ayahNumber,\n    DateTime? updatedAt,\n  }) async {\n    return transaction(() async {\n      await (update(note)..where((tbl) => tbl.surahId.equals(surahId) & tbl.ayahNumber.equals(ayahNumber))).write(\n        NoteCompanion(\n          title: Value(title),\n          content: Value(content),\n          color: Value(color),\n          updatedAt: Value(updatedAt ?? DateTime.now()),\n        ),\n      );\n    });\n  }\n\n  Future<void> deleteNote({required int surahId, required int ayahNumber}) {\n    return transaction(() async {\n      await (delete(note)..where((tbl) => tbl.surahId.equals(surahId) & tbl.ayahNumber.equals(ayahNumber))).go();\n    });\n  }\n\n  // --- Daily Usage Methods ---\n\n\n  // Get usage data for the last N days (including today)\n  Future<List<DailyUsageData>> getUsageForLastNDays(int days) async {\n    final today = DateTime.now();\n    final dateList = List.generate(days, (index) {\n      final date = today.subtract(Duration(days: index));\n      return _formatDate(date); // Format as YYYY-MM-DD\n    });\n\n    // Query the database for entries matching these dates\n    return await (select(dailyUsage)\n          ..where((tbl) => tbl.date.isIn(dateList))\n          ..orderBy([(tbl) => OrderingTerm(expression: tbl.date)]))\n        .get();\n  }\n\n  // Helper to format date consistently\n  String _formatDate(DateTime date) {\n    return \"${date.year.toString().padLeft(4, '0')}-\"\n        \"${date.month.toString().padLeft(2, '0')}-\"\n        \"${date.day.toString().padLeft(2, '0')}\";\n  }\n\n  Future<List<DailyUsageData>> getUsageForMonth(int year, int month) async {\n  final DateTime firstDay = DateTime(year, month, 1);\n  final DateTime lastDay = DateTime(year, month + 1, 0); // Last day of month\n  \n  final String startDateString = _formatDate(firstDay);\n  final String endDateString = _formatDate(lastDay);\n  \n  return await getUsageForDateRange(startDateString, endDateString);\n}\n\n// Get usage data for a specific year\nFuture<List<DailyUsageData>> getUsageForYear(int year) async {\n  final DateTime firstDay = DateTime(year, 1, 1);\n  final DateTime lastDay = DateTime(year, 12, 31);\n  \n  final String startDateString = _formatDate(firstDay);\n  final String endDateString = _formatDate(lastDay);\n  \n  return await getUsageForDateRange(startDateString, endDateString);\n}\n\n// Get monthly aggregated data for a year\nFuture<List<MonthlyUsageData>> getMonthlyAggregatedDataForYear(int year) async {\n  // This would return data from the monthly_usage_summary table if implemented\n  // For now, we'll aggregate the data from daily_usage\n  \n  final List<DailyUsageData> dailyData = await getUsageForYear(year);\n  \n  // Group data by month and calculate totals\n  final Map<String, MonthlyUsageData> monthlyData = {};\n  \n  for (final data in dailyData) {\n    try {\n      final List<int> dateParts = data.date.split('-').map(int.parse).toList();\n      if (dateParts.length != 3) continue;\n      \n      final String yearMonth = '${dateParts[0]}-${dateParts[1].toString().padLeft(2, '0')}';\n      \n      if (!monthlyData.containsKey(yearMonth)) {\n        monthlyData[yearMonth] = MonthlyUsageData(\n          yearMonth: yearMonth,\n          totalSeconds: 0,\n          averageSecondsPerDay: 0,\n          activeDays: 0,\n          usageType: data.usageType,\n        );\n      }\n      \n      final current = monthlyData[yearMonth]!;\n      \n      // Update totals\n      final newTotalSeconds = current.totalSeconds + data.totalSeconds;\n      final newActiveDays = data.totalSeconds > 0 \n          ? current.activeDays + 1 \n          : current.activeDays;\n          \n      // Calculate new average\n      final newAverage = newActiveDays > 0 \n          ? newTotalSeconds ~/ newActiveDays \n          : 0;\n      \n      // Update the entry\n      monthlyData[yearMonth] = MonthlyUsageData(\n        yearMonth: yearMonth,\n        totalSeconds: newTotalSeconds,\n        averageSecondsPerDay: newAverage,\n        activeDays: newActiveDays,\n        usageType: data.usageType,\n      );\n    } catch (e) {\n     logErrorStatic('UserDataStorage', 'Error aggregating monthly data: $e');\n    }\n  }\n  \n  return monthlyData.values.toList();\n}\n\n// Get usage data for a date range\nFuture<List<DailyUsageData>> getUsageForDateRange(\n  String startDateString, \n  String endDateString\n) async {\n  return await (select(dailyUsage)\n    ..where((tbl) => \n        tbl.date.isBiggerOrEqualValue(startDateString) & \n        tbl.date.isSmallerOrEqualValue(endDateString))\n    ..orderBy([(tbl) => OrderingTerm(expression: tbl.date)]))\n    .get();\n}\n\n// Upsert daily usage with usage type\nFuture<void> upsertDailyUsage(\n  String dateString, \n  int secondsToAdd, \n  String usageType\n) async {\n  return transaction(() async {\n    final existingEntry = await (select(dailyUsage)\n      ..where((tbl) => \n          tbl.date.equals(dateString) & \n          tbl.usageType.equals(usageType)))\n      .getSingleOrNull();\n\n    if (existingEntry != null) {\n      // Update existing entry\n      await (update(dailyUsage)\n        ..where((tbl) => \n            tbl.date.equals(dateString) & \n            tbl.usageType.equals(usageType)))\n        .write(\n          DailyUsageCompanion(\n            totalSeconds: Value(existingEntry.totalSeconds + secondsToAdd),\n          ),\n        );\n    } else {\n      // Insert new entry\n      await into(dailyUsage).insert(\n        DailyUsageCompanion.insert(\n          date: dateString,\n          totalSeconds: Value(secondsToAdd),\n          usageType: Value(usageType),\n        ),\n      );\n    }\n  });\n}\n}"}, {"structure_type": "function", "name": "getLayoutForPage", "docstring": "Retrieves layout entries for a specific page based on the layout table name.", "module": "text_mushaf", "file_path": "data/service/database/text_mushaf/text_mushaf_database.dart", "file_name": "text_mushaf_database.dart", "line": 45, "line_from": 45, "line_to": 134, "snippet": "  Future<List<dynamic>> getLayoutForPage({\n    required int pageNumber,\n    required String layoutTableName, // e.g., 'indopak13_lines_layout'\n  }) async {\n    try {\n      switch (layoutTableName) {\n        case 'indopak13_lines_layout':\n          final query = select(indopak13LinesLayout)..where((tbl) => tbl.page.equals(pageNumber));\n          return await query.get();\n        case 'indopak15_lines_layout':\n          final query = select(indopak15LinesLayout)..where((tbl) => tbl.page.equals(pageNumber));\n          return await query.get();\n        case 'qpc_v1_layout':\n          final query = select(qpcV1Layout)..where((tbl) => tbl.page.equals(pageNumber));\n          return await query.get();\n        case 'qpc_v2_layout':\n          final query = select(qpcV2Layout)..where((tbl) => tbl.page.equals(pageNumber));\n          return await query.get();\n        default:\n          logInfoStatic('Unknown layout table name: $layoutTableName', _tag);\n          return [];\n      }\n    } catch (e) {\n      logErrorStatic('Error fetching layout for page $pageNumber, table $layoutTableName: $e', _tag);\n      return []; // Return empty list on error\n    }\n  }\n\n  /// Retrieves word entries within a specified range (based on word_number_all).\n  Future<List<TextWordEntry>> getWordsForRange({\n    required int rangeStart,\n    required int rangeEnd,\n  }) async {\n    try {\n      // Handle nullable wordNumberAll by only including entries where it's not null\n      final query = select(words)\n        ..where((tbl) =>\n            tbl.wordNumberAll.isNotNull() & tbl.wordNumberAll.isBetween(Constant(rangeStart), Constant(rangeEnd)))\n        ..orderBy([(t) => OrderingTerm(expression: t.wordNumberAll)]);\n      return await query.get();\n    } catch (e) {\n      logErrorStatic('Error fetching words for range $rangeStart-$rangeEnd: $e', _tag);\n      return []; // Return empty list on error\n    }\n  }\n\n  /// Retrieves word entries for a specific Ayah (Surah and Ayah number).\n  Future<List<TextWordEntry>> getWordsForAyah({\n    required int surahNumber,\n    required int ayahNumber,\n  }) async {\n    try {\n      final query = select(words)\n        ..where((tbl) => tbl.surahNumber.equals(surahNumber) & tbl.ayahNumber.equals(ayahNumber))\n        ..orderBy([(t) => OrderingTerm(expression: t.wordNumber)]);\n      return await query.get();\n    } catch (e) {\n      logErrorStatic('Error fetching words for Surah $surahNumber, Ayah $ayahNumber: $e', _tag);\n      return []; // Return empty list on error\n    }\n  }\n}\n\n/// Opens the connection to the Text Mushaf database lazily.\nLazyDatabase _openConnection() {\n  const String tag = 'TextMushafDatabase:openConnection';\n  return LazyDatabase(() async {\n    final Directory dbFolder = await getApplicationDocumentsDirectory();\n    // Store the database in a dedicated 'databases' subfolder for organization\n    final File file = File(p.join(dbFolder.path, 'databases', TextMushafDatabase.dbFileName));\n    logInfoStatic('Attempting to open Text Mushaf Database at: ${file.path}', tag);\n\n    // Ensure the parent directory exists\n    final Directory parentDir = file.parent;\n    if (!await parentDir.exists()) {\n      try {\n        await parentDir.create(recursive: true);\n        logInfoStatic('Created database directory: ${parentDir.path}', tag);\n      } catch (e) {\n        logErrorStatic('Error creating database directory: $e', tag);\n        // Rethrowing here might be appropriate if the DB is essential for app function\n        rethrow;\n      }\n    }\n\n    // Note: Database download logic is handled by the Repository/UseCase layer.\n    // This function assumes the file exists or will be created by Drift if needed.\n    return NativeDatabase.createInBackground(file);\n  });\n}"}, {"structure_type": "function", "name": "initSettings", "docstring": "", "module": "settings", "file_path": "domain/repositories/settings/setting_repository.dart", "file_name": "setting_repository.dart", "line": 5, "line_from": 5, "line_to": 21, "snippet": "  Future<void> initSettings();\n\n  Stream<SettingsStateEntity> get settingsStream;\n\n  Future<void> updateSettings({required SettingsStateEntity settingsState});\n\n    Future<void> scheduleNotification({\n    required TimeOfDay time,\n    required bool turnOn,\n  });\n\n  Future<SettingsStateEntity> getSettingsState();\n\n  Future<void> dispose();\n\n\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "grammar", "file_path": "domain/repositories/grammar/grammar_repository.dart", "file_name": "grammar_repository.dart", "line": 10, "line_from": 10, "line_to": 19, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  /// Get grammar summary data for a specific ayah and word\n  Future<GrammarSummaryData?> getGrammarSummaryData({\n    required int surahId,\n    required int ayahId,\n    required int wordIndex,\n  });"}, {"structure_type": "function", "name": "getAllMemorizationPlans", "docstring": "", "module": "memorization", "file_path": "domain/repositories/memorization/memorization_plan_repository.dart", "file_name": "memorization_plan_repository.dart", "line": 5, "line_from": 5, "line_to": 54, "snippet": "  Future<List<MemorizationPlanEntity>> getAllMemorizationPlans();\n\n  Future<MemorizationPlanEntity?> getMemorizationPlanByName(String planName);\n\n  Future<void> addMemorizationPlan({\n    required MemorizationPlanEntity plan,\n    bool saveToRemote = true,\n  });\n\n  Future<void> updateMemorizationPlan({\n    required String planName,\n    String? newPlanName,\n    int? startSurahId,\n    int? startAyahId,\n    int? endSurahId,\n    int? endAyahId,\n    int? estimatedDays,\n    bool? hasNotification,\n    DateTime? notificationTime,\n  });\n\n  Future<void> deleteMemorizationPlan({required String planName});\n\n  Future<List<MemorizationPlanEntity>> syncMemorizationPlansWithRemote();\n\n  Future<void> memorizeAyah({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  });\n\n  Future<void> unmemorizeAyah({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  });\n\n  Future<bool> isAyahMemorized({\n    required String planName,\n    required int surahId,\n    required int ayahId,\n  });\n\n  Future<int> getMemorizedAyahsCount({\n    required String planName,\n    required int surahId,\n  });\n\n  Future<MemorizedAyahEntity?> getLastMemorizedAyah(String planName);\n}"}, {"structure_type": "function", "name": "getNonDefaultTranslation", "docstring": "", "module": "translation", "file_path": "domain/repositories/translation/translation_repository.dart", "file_name": "translation_repository.dart", "line": 5, "line_from": 5, "line_to": 16, "snippet": "  Future<void> getNonDefaultTranslation({required TTDbFileModel file,  void Function(int percentage)? onProgress, required CancelToken cancelToken,});\n  Future<void> getDefaultTranslation(TTDbFileModel file);\n  Future<void> deleteTranslationDatabase({required String fileName});\n  Future<List<String>> getAvailableTranslations();\n  Future<void> saveAvailableTranslations({required Set<String> availableTranslations, required String newItem});\n  Future<void> selectTranslation({required TTDbFileModel file});\n  Future<void> deleteAvailableTranslation({required TTDbFileModel file});\n  Future<Set<String>> getSelectedTranslations();\n  Future<void> saveSelectedTranslations(Set<String> selectedTranslations);\n   Future<void> saveAvailableItemsCount(int count);\n   Future<int> fetchAvailableItemsCount(); \n}"}, {"structure_type": "function", "name": "getAllSurahs", "docstring": "", "module": "quran_structure", "file_path": "domain/repositories/quran_structure/surah_repository.dart", "file_name": "surah_repository.dart", "line": 5, "line_from": 5, "line_to": 12, "snippet": "  Future<List<SurahEntity>> getAllSurahs();\n  Future<List<AyahEntity>> getIDsBySurahID({required int surahId});\n\n  Future<List<AyahEntity>> getAyahsBySurahAndAyahList({\n    required int surahId,\n    required String ayahList,\n  });\n}"}, {"structure_type": "function", "name": "recordUsage", "docstring": "Records the duration the app was used for a specific date.", "module": "usage_tracking", "file_path": "domain/repositories/usage_tracking/usage_tracking_repository.dart", "file_name": "usage_tracking_repository.dart", "line": 11, "line_from": 11, "line_to": 46, "snippet": "  Future<Either<Failure, void>> recordUsage({\n    required Duration duration,\n    required DateTime date,\n    String usageType = 'reading',\n  });\n\n  /// Retrieves the aggregated usage data (minutes per day) for the last N days\n  Future<Either<Failure, List<(DateTime, double)>>> getUsageForLastNDays(int days);\n  \n  /// Retrieves the aggregated usage data (minutes per day) for a specific month\n  Future<Either<Failure, List<(DateTime, double)>>> getUsageForMonth({\n    required int year,\n    required int month,\n  });\n  \n  /// Retrieves the aggregated usage data (minutes per day) for a specific year\n  Future<Either<Failure, List<(int, int, double)>>> getUsageForYear({\n    required int year,\n  });\n  \n  /// Retrieves stats for time range (total time, average per day, etc.)\n  Future<Either<Failure, UsageStats>> getUsageStats({\n    required TimeRange timeRange,\n  });\n}\n\n/// Used to represent different time ranges for queries\nenum TimeRange {\n  last7Days,\n  last30Days,\n  currentMonth,\n  previousMonth,\n  currentYear,\n  previousYear,\n  custom,\n}"}, {"structure_type": "function", "name": "getPromotionalMessage", "docstring": "", "module": "info", "file_path": "domain/repositories/info/info_repository.dart", "file_name": "info_repository.dart", "line": 6, "line_from": 6, "line_to": 30, "snippet": "  Future<void> getPromotionalMessage({\n    required void Function(PromotionalMessageEntity?) onMessage,\n  });\n\n  Future<void> closePromotionalMessage({required bool userSeen});\n\n  Future<String> getSadaqahJariah();\n  Future<String> getPrivacyPolicy();\n  Future<String> getAboutUs();\n  Future<String> getThanksAndCredit();\n  Future<String> getContactUs();\n  Future<String> getAboutTafsir();\n  Future<String> getHelpUs();\n  Future<String> getAboutApp();\n  Future<List<OurProjectEntity>> getOurProjects();\n\n  /// Check if the info database is available\n  Future<bool> isInfoDatabaseAvailable();\n\n  /// Download the info database from the server\n  Future<void> downloadInfoDatabase({\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n}"}, {"structure_type": "function", "name": "downloadAudioFiles", "docstring": "", "module": "audio", "file_path": "domain/repositories/audio/audio_repository.dart", "file_name": "audio_repository.dart", "line": 8, "line_from": 8, "line_to": 61, "snippet": "  Future<void> downloadAudioFiles({\n    required int surahID,\n    required Reciter reciter,\n    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n\n  Future<String> generateAudioFilePath({required int surah, required Reciter reciter});\n\n  Future<void> deleteAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  });\n\n  Future<void> persistSurahAudioPath({\n    required List<int> surahs,\n    required Reciter reciter,\n  });\n  Future<bool> isSurahAudioAvailable({\n    required int surahNumber,\n    required Reciter reciter,\n  });\n  Future<List<VerseTiming>> getVerseTimings({\n    required int surahID,\n    required int reciterID,\n  });\n  Future<void> playSurahPlaylist();\n\n  Future<void> playVerseWithDelay(\n    VerseTiming verseTiming,\n    Duration delay,\n  );\n  Future<String> getAudioPath({\n    required int surah,\n    required Reciter reciter,\n    bool isOnlineStream = false,\n  });\n  Future<void> addToPlayl1ist({\n    required String audioPath,\n    required String title,\n    bool isOnlineStream = false,\n  });\n\n  Future<AudioFile> getAudioFilesBySurahAndReciter({\n    required int surahNumber,\n    required Reciter reciter,\n  });\n  Future<void> seekAudio(Duration position);\n  Future<void> clearPlaylist();\n  Future<void> stopAudio();\n  Future<void> pausePlayback();\n  Future<void> resumePlayback();\n  Future<void> playWordAudio({required WordByWordEntity word});\n}"}, {"structure_type": "function", "name": "getAllDailyAyahList", "docstring": "", "module": "dailyAyah", "file_path": "domain/repositories/dailyAyah/daily_ayah_repository.dart", "file_name": "daily_ayah_repository.dart", "line": 4, "line_from": 4, "line_to": 5, "snippet": "  Future<List<AyahDatabaseTableData>> getAllDailyAyahList({required String languageCode});\n}"}, {"structure_type": "function", "name": "getTafseer", "docstring": "", "module": "tafseer", "file_path": "domain/repositories/tafseer/tafseer_repository.dart", "file_name": "tafseer_repository.dart", "line": 6, "line_from": 6, "line_to": 24, "snippet": "  Future<void> getTafseer({\n    required TTDbFileModel file,\n    void Function(int percentage)? onProgress,\n    required int surahID,\n    required TafseerType tafseerType,\n    required CancelToken cancelToken,\n  });\n  Future<void> deleteTafseerDatabase({required String fileName});\n  List<String> getAvailableTafseers();\n  Future<void> saveAvailableTafseers({required Set<String> availableTafseers, required String newItem});\n  Future<void> selectTafseer({required TTDbFileModel file, required int surahID, required TafseerType tafseerType});\n  Future<void> deleteAvailableTafseer({required TTDbFileModel file});\n  Future<Set<String>> getSelectedTafseers();\n  Future<void> saveSelectedTafseers(Set<String> selectedTafseers);\n  Future<void> saveSelectedTabIndex(int index);\n  Future<int> getSelectedTabIndex();\n  Future<void> saveAvailableItemsCount(int count);\n  Future<int> fetchAvailableItemsCount();\n}"}, {"structure_type": "function", "name": "getSubjects", "docstring": "", "module": "subjects", "file_path": "domain/repositories/subjects/subject_repository.dart", "file_name": "subject_repository.dart", "line": 4, "line_from": 4, "line_to": 6, "snippet": "  Future<List<SubjectEntity>> getSubjects({required String language});\n  Future<SubjectEntity?> getSubjectById({required int id, required String language});\n}"}, {"structure_type": "function", "name": "doneFirstTime", "docstring": "", "module": "user_data", "file_path": "domain/repositories/user_data/user_data_repository.dart", "file_name": "user_data_repository.dart", "line": 13, "line_from": 13, "line_to": 129, "snippet": "  Future<void> doneFirstTime();\n\n  Future<bool> determineFirstRun();\n\n  Future<bool> needsMigration();\n\n  Future<List<BookmarkEntity>> getAllBookmarks();\n\n  Future<UpdateInfoEntity> fetchUpdateInfo();\n\n  Future<List<BookmarkFolderEntity>> syncBookmarksWithRemote(); \n  Future<List<PinEntity>> syncPinsWithRemote();\n  Future<List<NoteEntity>> syncNotesWithRemote();\n\n  Future<void> logAnalyticsEvent({\n    required String name,\n    required Map<String, Object>? parameters,\n  });\n\n  Future<void> migrateOldBookmarks();\n\n  Future<void> saveSortOption({required SortOptionEntity option});\n\n  Future<SortOptionEntity?> getSavedSortOption();\n\n  Future<void> addAyahToBookmarkFolder({\n    required BookmarkEntity bookmark,\n    bool saveToRemote = true,\n  });\n\n  Future<void> saveCollections({\n    required List<BookmarkEntity> bookmarks,\n    List<MemorizationPlanEntity>? memorizationPlans,\n    List<PinEntity>? pins,\n    List<NoteEntity>? notes,\n  });\n\n  Future<bool> askForReviewIfAllowed({\n    required VoidCallback askForReview,\n  });\n\n  Future<void> saveNeedsMigration();\n\n  Future<void> updateBookmark({\n    required String folderName,\n    required String newFolderName,\n    required Color color,\n  });\n\n  Future<void> deleteAyahFromBookmarks({\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n  });\n\n  Future<void> deleteBookmarkFolder({\n    required BookmarkFolderEntity folder,\n  });\n\n  Future<List<BookmarkFolderEntity>> getAllBookmarkFolders();\n\n  Future<List<BookmarkEntity>> getAyahListByBookmarkFolder({required String folderName});\n\n  Future<BookmarkFolderEntity?> getBookmarkFolder({\n    required String folderName,\n  });\n\n  Future<List<BookmarkFolderEntity>> getBookmarkFolderBySurahAndAyah({\n    required int surahID,\n    required int ayahID,\n  });\n\n  Future<void> syncCollectionsWithRemote();\n\n  Future<void> saveBookmarksToAyah({\n    required int surahID,\n    required int ayahID,\n    required List<BookmarkEntity> bookmarks,\n  });\n\n  Future<void> deleteAyahFromBookmarkFolder({\n    required int surahID,\n    required int ayahID,\n    required BookmarkFolderEntity folder,\n  });\n\n  Future<void> saveLastRead({required LastReadEntity lastRead});\n\n  Future<List<LastReadEntity>> getLastReads();\n\n  Future<List<LastReadEntity>> deleteLastReads({\n    required List<int> deletedItem,\n  });\n\n  Future<void> savePinSortOption({required SortOptionEntity option});\n\n  Future<SortOptionEntity?> getPinSortOption();\n\n  Future<void> saveNoteSortOption({required SortOptionEntity option});\n\n  Future<SortOptionEntity?> getNoteSortOption();\n\n  Future<List<MemorizationPlanEntity>> getAllMemorizationPlans();\n\n  Future<List<PinEntity>> getAllPins();\n  Future<List<NoteEntity>> getAllNotes();\n\n  Future<void> addPin({\n    required PinEntity pin,\n    bool saveToRemote = true,\n  });\n\n  Future<void> addNote({\n    required NoteEntity note,\n    bool saveToRemote = true,\n  });\n}"}, {"structure_type": "function", "name": "getReciters", "docstring": "", "module": "reciter", "file_path": "domain/repositories/reciter/reciter_repository.dart", "file_name": "reciter_repository.dart", "line": 4, "line_from": 4, "line_to": 11, "snippet": "  Future<List<Reciter>> getReciters();\n  Future<List<Reciter>> loadRecitersList();\n  Future<void> saveSelectedReciter(Reciter reciter);\n  Future<Reciter> getSelectedReciter();\n  Future<void> saveReciterWithSurahId(int surahId, Reciter reciter, {bool isDelete = false});\n  Future<List<int>> getSurahIdsForReciter(Reciter reciter);\n  Future<void> saveDownloadCount(int reciterId, int count);\n}"}, {"structure_type": "function", "name": "isExternalDbAvailable", "docstring": "Check if a specific external database is available", "module": "external_db", "file_path": "domain/repositories/external_db/external_db_repository.dart", "file_name": "external_db_repository.dart", "line": 9, "line_from": 9, "line_to": 64, "snippet": "  Future<bool> isExternalDbAvailable(String dbName);\n\n  /// Download an external database\n  Future<Either<String, bool>> downloadExternalDb({\n    required String dbName,\n    required String url,\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  });\n}\n\n/// Implementation of ExternalDbRepository\nclass ExternalDbRepositoryImpl implements ExternalDbRepository {\n  static const String _tag = 'ExternalDbRepositoryImpl';\n  final Map<String, CancelToken> _cancelTokens = {};\n\n  @override\n  Future<bool> isExternalDbAvailable(String dbName) async {\n    try {\n      return await ExternalDbFactory.doesExternalDbExist(dbName);\n    } catch (e) {\n      Logger.error('Error checking if external DB is available: $e', _tag);\n      return false;\n    }\n  }\n\n  @override\n  Future<Either<String, bool>> downloadExternalDb({\n    required String dbName,\n    required String url,\n    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    try {\n      _cancelTokens[dbName] = cancelToken;\n\n      final result = await ExternalDbFactory.downloadExternalDb(\n        dbName: dbName,\n        url: url,\n        onProgress: onProgress,\n        isCancelled: () => cancelToken.isCancelled,\n      );\n\n      if (result) {\n        return right(true);\n      } else {\n        return left('Failed to download or validate the database');\n      }\n    } catch (e) {\n      Logger.error('Error downloading external DB: $e', _tag);\n      return left('Error downloading database: $e');\n    } finally {\n      _cancelTokens.remove(dbName);\n    }\n  }\n}"}, {"structure_type": "function", "name": "getTextMushafDatabaseFile", "docstring": "Retrieves the File object representing the database file location.", "module": "mushaf", "file_path": "domain/repositories/mushaf/i_text_mushaf_local_data_source.dart", "file_name": "i_text_mushaf_local_data_source.dart", "line": 8, "line_from": 8, "line_to": 21, "snippet": "  Future<File> getTextMushafDatabaseFile();\n\n  /// Checks if the Text Mushaf database file exists on the device.\n  Future<bool> isTextMushafDatabaseAvailable();\n\n  /// Gets layout information for a specific page from a specified layout table.\n  Future<List<dynamic>> getLayoutForPage({required int pageNumber, required String layoutTableName});\n\n  /// Gets words within a specific range (based on word_number_all).\n  Future<List<TextWordEntry>> getWordsForRange({required int rangeStart, required int rangeEnd});\n\n  /// Gets words for a specific Ayah.\n  Future<List<TextWordEntry>> getWordsForAyah({required int surahNumber, required int ayahNumber});\n}"}, {"structure_type": "function", "name": "downloadMushaf", "docstring": "", "module": "mushaf", "file_path": "domain/repositories/mushaf/mushaf_repository.dart", "file_name": "mushaf_repository.dart", "line": 5, "line_from": 5, "line_to": 11, "snippet": "  Future<void> downloadMushaf(String mushafName, {ProgressCallback? onProgress, CancelToken? cancelToken});\n  Future<String> extractMushaf(String mushafName);\n  Future<bool> isMushafDownloaded(String mushafName);\n  Future<String> getMushafDirectory(String mushafName);\n  Future<void> saveLastReadPage(String mushafName, int pageNumber);\n  Future<int?> getLastReadPage(String mushafName);\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "mushaf", "file_path": "domain/repositories/mushaf/text_mushaf_repository.dart", "file_name": "text_mushaf_repository.dart", "line": 9, "line_from": 9, "line_to": 16, "snippet": "    void Function(int received, int total)? onProgress,\n    CancelToken? cancelToken,\n  });\n\n  Future<List<TextLayoutEntity>> getTextLayoutForPage({\n    required int pageNumber,\n    required String layoutType, // e.g., 'indopak_13', 'qpc_v2'\n  });"}, {"structure_type": "function", "name": "getAllPins", "docstring": "", "module": "collections", "file_path": "domain/repositories/collections/pin_repository.dart", "file_name": "pin_repository.dart", "line": 4, "line_from": 4, "line_to": 27, "snippet": "  Future<List<PinEntity>> getAllPins();\n\n  Future<PinEntity?> getPinBySurah({required int surahId});\n\n  Future<PinEntity?> getPinByName({required String name});\n\n  Future<void> addPin({\n    required PinEntity pin,\n    bool saveToRemote = true,\n  });\n\n  Future<void> deletePin({\n    required String name,\n  });\n\n  Future<void> updatePin({\n    required int surahId,\n    required int ayahNumber,\n    required String name,\n    required String color,\n  });\n\n  Future<List<PinEntity>> syncPinsWithRemote();\n}"}, {"structure_type": "function", "name": "getAllNotes", "docstring": "", "module": "collections", "file_path": "domain/repositories/collections/note_repository.dart", "file_name": "note_repository.dart", "line": 4, "line_from": 4, "line_to": 29, "snippet": "  Future<List<NoteEntity>> getAllNotes();\n\n  Future<List<NoteEntity>> getNotesBySurah({required int surahId});\n\n  Future<NoteEntity?> getNoteByAyah({required int surahId, required int ayahNumber});\n\n  Future<NoteEntity?> getNoteBySurah({required int surahId});\n\n  Future<void> addNote({\n    required NoteEntity note,\n    bool saveToRemote = true,\n  });\n\n  Future<void> deleteNote({required int surahId, required int ayahNumber});\n\n  Future<void> updateNote({\n    required String title,\n    required int surahId,\n    required int ayahNumber,\n    required String content,\n    required String color,\n  });\n\n  Future<void> syncNotesWithRemote();\n\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "grammar", "file_path": "domain/use_cases/grammar/download_grammar_database_use_case.dart", "file_name": "download_grammar_database_use_case.dart", "line": 18, "line_from": 18, "line_to": 25, "snippet": "    required void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    return mapResultToEither(() => _repository.downloadGrammarDatabase(\n          onProgress: onProgress,\n          cancelToken: cancelToken,\n        ));\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "collection", "file_path": "domain/use_cases/collection/import_collections.dart", "file_name": "import_collections.dart", "line": 24, "line_from": 24, "line_to": 110, "snippet": "  Future<Either<String, String>> execute(String collectionJsonString) async {\n    return mapResultToEither(() async {\n      try {\n        _validateFile(collectionJsonString);\n\n        final Map<String, dynamic> jsonData = jsonDecode(collectionJsonString);\n        if (!jsonData.containsKey('data')) {\n          throw Exception('Invalid file format: Missing \"data\" field');\n        }\n\n        final (bookmarks, plans, pins, notes) = await compute(_parseCollections, collectionJsonString);\n\n        await _userDataRepository.saveCollections(\n          bookmarks: bookmarks,\n          memorizationPlans: plans,\n          pins: pins,\n          notes: notes,\n        );\n\n        return \"Your collections have been imported successfully.\";\n      } catch (e) {\n        showMessage(message: \"Import failed: ${e.toString()}\\nPlease make sure you're using a valid backup file.\");\n        throw Exception(\"Import failed: ${e.toString()}\");\n      }\n    });\n  }\n\n  void _validateFile(String collectionJsonString) {\n    if (collectionJsonString.isEmpty) throw Exception(\"The file is empty.\");\n\n    try {\n      final decoded = jsonDecode(collectionJsonString);\n      if (decoded is! Map<String, dynamic>) {\n        throw Exception(\"Invalid JSON format: Root must be an object\");\n      }\n    } catch (e) {\n      throw Exception(\"Invalid JSON format: ${e.toString()}\");\n    }\n  }\n}\n\nFuture<(List<BookmarkEntity>, List<MemorizationPlanEntity>, List<PinEntity>, List<NoteEntity>)> _parseCollections(\n    String collectionJsonString) async {\n  final Map<String, dynamic> collectionMap = jsonDecode(collectionJsonString) as Map<String, dynamic>;\n\n  if (!collectionMap.containsKey(\"data\")) {\n    throw Exception(\"Invalid file format: Missing 'data' field\");\n  }\n\n  final Map<String, dynamic> data = collectionMap['data'] as Map<String, dynamic>;\n\n  // Create separate JSON strings for bookmarks, plans and pins\n  final String bookmarksJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'bookmarks': data['bookmarks'] ?? [],\n  });\n\n  final String plansJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'memorization_plans': data['memorization_plans'] ?? [],\n  });\n\n  final String pinsJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'pins': data['pins'] ?? [],\n  });\n\n  final String notesJson = jsonEncode({\n    'version': collectionMap['version'] ?? 1,\n    'last_updated': collectionMap['last_updated'] ?? DateTime.now().toIso8601String(),\n    'notes': data['notes'] ?? [],\n  });\n\n  try {\n    final List<BookmarkEntity> bookmarks = await convertJsonToBookmarks(bookmarksJson);\n    final List<MemorizationPlanEntity> plans = await convertJsonToMemorizationPlans(plansJson);\n    final List<PinEntity> pins = await convertJsonToPins(pinsJson);\n    final List<NoteEntity> notes = await convertJsonToNotes(notesJson);\n\n    return (bookmarks, plans, pins, notes);\n  } catch (e) {\n    throw Exception(\"Error parsing collections: $e\");\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "collection", "file_path": "domain/use_cases/collection/export_collections.dart", "file_name": "export_collections.dart", "line": 20, "line_from": 20, "line_to": 59, "snippet": "  Future<Either<String, String>> execute() async {\n    return mapResultToEither(() async {\n      try {\n        final List<BookmarkEntity> bookmarks = await _userDataRepository.getAllBookmarks();\n        final List<MemorizationPlanEntity> plans = await _userDataRepository.getAllMemorizationPlans();\n        final List<PinEntity> pins = await _userDataRepository.getAllPins();\n        final List<NoteEntity> notes = await _userDataRepository.getAllNotes();\n\n        final String exportData = await compute(\n          _generateExportData,\n          (bookmarks, plans, pins, notes),\n        );\n\n        return exportData;\n      } catch (e) {\n     showMessage(message: e.toString());\n        throw Exception(\"Failed to export collections.\");\n      }\n    });\n  }\n}\n\nFuture<String> _generateExportData(\n  (List<BookmarkEntity>, List<MemorizationPlanEntity>, List<PinEntity>, List<NoteEntity>) collections,\n) async {\n  final (bookmarks, plans, pins, notes) = collections;\n\n  final Map<String, dynamic> exportData = {\n    'version': 1,\n    'last_updated': DateTime.now().toIso8601String(),\n    'data': {\n      'bookmarks': bookmarks.map((b) => b.toJson()).toList(),\n      'memorization_plans': plans.map((p) => p.toJson()).toList(),\n      'pins': pins.map((p) => p.toJson()).toList(),\n      'notes': notes.map((n) => n.toJson()).toList(),\n    },\n  };\n\n  return jsonEncode(exportData);\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "pins", "file_path": "domain/use_cases/collection/pins/sort_pin_use_case.dart", "file_name": "sort_pin_use_case.dart", "line": 19, "line_from": 19, "line_to": 42, "snippet": "  Future<Either<String, List<PinEntity>>> execute({\n    required SortOptionEntity option,\n    required List<PinEntity> pins,\n  }) async {\n    return mapResultToEither(() async {\n      final List<PinEntity> sortedPins = await compute(_sortPins, SortParams(option, pins));\n      return sortedPins;\n    });\n  }\n}\n\nList<PinEntity> _sortPins(SortParams params) {\n  final option = params.option;\n  final pins = params.pins;\n\n  switch (option.type) {\n    case SortOptionType.name:\n      return _sortByName(pins);\n    case SortOptionType.createdDate:\n      return _sortByCreatedAt(pins);\n    case SortOptionType.updatedDate:\n      return _sortByUpdatedAt(pins);\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "notes", "file_path": "domain/use_cases/collection/notes/sort_note_use_case.dart", "file_name": "sort_note_use_case.dart", "line": 19, "line_from": 19, "line_to": 42, "snippet": "  Future<Either<String, List<NoteEntity>>> execute({\n    required SortOptionEntity option,\n    required List<NoteEntity> notes,\n  }) async {\n    return mapResultToEither(() async {\n      final List<NoteEntity> sortedNotes = await compute(_sortNotes, SortParams(option, notes));\n      return sortedNotes;\n    });\n  }\n}\n\nList<NoteEntity> _sortNotes(SortParams params) {\n  final option = params.option;\n  final notes = params.notes;\n\n  switch (option.type) {\n    case SortOptionType.name:\n      return _sortByName(notes);\n    case SortOptionType.createdDate:\n      return _sortByCreatedAt(notes);\n    case SortOptionType.updatedDate:\n      return _sortByUpdatedAt(notes);\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "bookmarks", "file_path": "domain/use_cases/collection/bookmarks/search_bookmark.dart", "file_name": "search_bookmark.dart", "line": 12, "line_from": 12, "line_to": 36, "snippet": "  Future<Either<String, List<BookmarkFolderEntity>>> execute({\n    required String query,\n    required List<BookmarkFolderEntity> allFolders,\n  }) async {\n    return mapResultToEither(() async {\n      return _searchLock.synchronized(() async {\n        if (query.isEmpty) return allFolders;\n        final List<BookmarkFolderEntity> filteredFolders =\n            await compute(_filterFolderByQuery, (allFolders, query));\n        return filteredFolders;\n      });\n    });\n  }\n}\n\nFuture<List<BookmarkFolderEntity>> _filterFolderByQuery(\n  (List<BookmarkFolderEntity>, String) param,\n) async {\n  final (allFolders, query) = param;\n  final String normalizedQuery = query.trim().toLowerCase();\n\n  return allFolders.where((folder) => \n    folder.name.toLowerCase().contains(normalizedQuery)\n  ).toList();\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "bookmarks", "file_path": "domain/use_cases/collection/bookmarks/sort_bookmark.dart", "file_name": "sort_bookmark.dart", "line": 19, "line_from": 19, "line_to": 45, "snippet": "  Future<Either<String, List<BookmarkFolderEntity>>> execute({\n    required SortOptionEntity option,\n    required List<BookmarkFolderEntity> folders,\n  }) async {\n    return mapResultToEither(() async {\n      // Use compute with SortParams\n      final List<BookmarkFolderEntity> sortedBookmarks =\n          await compute(_sortBookmarks, SortParams(option, folders));\n      return sortedBookmarks;\n    });\n  }\n}\n\n// Update the sorting function to accept SortParams\nList<BookmarkFolderEntity> _sortBookmarks(SortParams params) {\n  final option = params.option;\n  final folders = params.folders;\n\n  switch (option.type) {\n    case SortOptionType.name:\n      return _sortByName(folders);\n    case SortOptionType.createdDate:\n      return _sortByCreatedAt(folders);\n    case SortOptionType.updatedDate:\n      return _sortByUpdatedAt(folders);\n  }\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "bookmarks", "file_path": "domain/use_cases/collection/bookmarks/save_bookmarks_to_ayah.dart", "file_name": "save_bookmarks_to_ayah.dart", "line": 16, "line_from": 16, "line_to": 56, "snippet": "  Future<Either<String, String>> execute({\n    required int surahID,\n    required int ayahID,\n    required List<BookmarkFolderEntity> savingFolders,\n  }) async {\n    return mapResultToEither(() async {\n      final List<BookmarkEntity> generatedBookmarks =\n          await _mapBookmarkFoldersIntoBookmarks(savingFolders, surahID, ayahID);\n      await _userDataRepository.saveBookmarksToAyah(\n        surahID: surahID,\n        ayahID: ayahID,\n        bookmarks: generatedBookmarks,\n      );\n      return savingFolders.isNotEmpty ? \"Collection saved\" : \"\";\n    });\n  }\n\n  Future<List<BookmarkEntity>> _mapBookmarkFoldersIntoBookmarks(\n    List<BookmarkFolderEntity> folders,\n    int surahID,\n    int ayahID,\n  ) async {\n    final List<BookmarkEntity> bookmarks = await compute(\n      _mapBookmarkFoldersIntoBookmarksPure,\n      (folders, surahID, ayahID),\n    );\n    return bookmarks;\n  }\n}\n\nList<BookmarkEntity> _mapBookmarkFoldersIntoBookmarksPure(\n  (List<BookmarkFolderEntity>, int, int) param,\n) {\n  final (folders, surahID, ayahID) = param;\n  final List<BookmarkEntity> generatedBookmarks = folders\n      .map(\n        (folder) => _mapBookmarkFolderToBookmark(folder: folder, surahID: surahID, ayahID: ayahID),\n      )\n      .toList();\n  return generatedBookmarks;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "translation", "file_path": "domain/use_cases/translation/get_non_default_use_case.dart", "file_name": "get_non_default_use_case.dart", "line": 15, "line_from": 15, "line_to": 23, "snippet": "    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) {\n    return mapResultToEither(() => _translationRepository.getNonDefaultTranslation(\n          file: file,\n          onProgress: onProgress,\n          cancelToken: cancelToken,\n        ));\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "corpus", "file_path": "domain/use_cases/corpus/get_corpus_data_use_case.dart", "file_name": "get_corpus_data_use_case.dart", "line": 16, "line_from": 16, "line_to": 34, "snippet": "  Future<List<CorpusTableData>> execute(GetCorpusDataParams params) async {\n    return getRight(\n      () => repository.getCorpusData(\n        suraId: params.suraId,\n        ayahId: params.ayahId,\n      ),\n    );\n  }\n}\n\nclass GetCorpusDataParams {\n  final int suraId;\n  final int ayahId;\n\n  GetCorpusDataParams({\n    required this.suraId,\n    required this.ayahId,\n  });\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "subjectwise", "file_path": "domain/use_cases/subjectwise/get_subject_by_id_usecase.dart", "file_name": "get_subject_by_id_usecase.dart", "line": 16, "line_from": 16, "line_to": 32, "snippet": "  Future<Either<String, SubjectEntity?>> execute({required GetSubjectByIdParams params}) async {\n    return mapResultToEither(() => _repository.getSubjectById(\n          id: params.id,\n          language: params.language,\n        ));\n  }\n}\n\nclass GetSubjectByIdParams {\n  final int id;\n  final String language;\n\n  const GetSubjectByIdParams({\n    required this.id,\n    required this.language,\n  });\n}"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "info", "file_path": "domain/use_cases/info/get_drawer_information.dart", "file_name": "get_drawer_information.dart", "line": 14, "line_from": 14, "line_to": 50, "snippet": "  Future<Either<String, String>> execute({\n    required DrawerInfo info,\n  }) async =>\n      mapResultToEither(() async => _getText(info));\n\n  Future<String> _getText(DrawerInfo info) async {\n    switch (info) {\n      case DrawerInfo.sadaqahJariah:\n        return _infoRepository.getSadaqahJariah();\n      case DrawerInfo.privacyPolicy:\n        return _infoRepository.getPrivacyPolicy();\n      case DrawerInfo.aboutUs:\n        return _infoRepository.getAboutUs();\n      case DrawerInfo.thanksAndCredit:\n        return _infoRepository.getThanksAndCredit();        \n      case DrawerInfo.contactUs:\n        return _infoRepository.getContactUs();      \n      case DrawerInfo.aboutTafsir:\n        return _infoRepository.getAboutTafsir();      \n      case DrawerInfo.helpUs:\n        return _infoRepository.getHelpUs();\n      case DrawerInfo.aboutApp:\n        return _infoRepository.getAboutApp();   \n    }\n  }\n}\n\nenum DrawerInfo {\n  sadaqahJariah,\n  privacyPolicy,\n  aboutUs,\n  thanksAndCredit,\n  contactUs,\n  aboutTafsir,\n  helpUs,\n  aboutApp,\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "audio", "file_path": "domain/use_cases/audio/download_and_save_audio_location_use_case.dart", "file_name": "download_and_save_audio_location_use_case.dart", "line": 15, "line_from": 15, "line_to": 26, "snippet": "    void Function(int percentage)? onProgress,\n    required CancelToken cancelToken,\n  }) {\n    return mapResultToEither(() async {\n      await _audioRepository.downloadAudioFiles(\n        surahID: surahID,\n        reciter: reciter,\n        onProgress: onProgress,\n        cancelToken: cancelToken,\n      );\n    });\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "tafseer", "file_path": "domain/use_cases/tafseer/get_tafseer_use_case.dart", "file_name": "get_tafseer_use_case.dart", "line": 19, "line_from": 19, "line_to": 33, "snippet": "    void Function(int percentage)? onProgress,\n    required int surahID,\n    required TafseerType tafseerType,\n    required CancelToken cancelToken,\n  }) async {\n    return mapResultToEither(\n      () async => _tafseerRepository.getTafseer(\n        file: file,\n        onProgress: onProgress,\n        surahID: surahID,\n        tafseerType: tafseerType,\n        cancelToken: cancelToken,\n      ),\n    );\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "word_by_word", "file_path": "domain/use_cases/word_by_word/get_words_for_multiple_ayahs_use_case.dart", "file_name": "get_words_for_multiple_ayahs_use_case.dart", "line": 15, "line_from": 15, "line_to": 36, "snippet": "  Future<Either<String, List<WordByWordEntity>>> execute({\n    required List<int> surahNumbers,\n    required List<int> ayahNumbers,\n  }) async {\n    return mapResultToEither(() async {\n      return await _repository.getWordsForMultipleAyahs(\n        surahNumbers: surahNumbers,\n        ayahNumbers: ayahNumbers,\n      );\n    });\n  }\n}\n\nclass GetWordsForMultipleAyahsParams {\n  final List<int> surahNumbers;\n  final List<int> ayahNumbers;\n\n  GetWordsForMultipleAyahsParams({\n    required this.surahNumbers,\n    required this.ayahNumbers,\n  });\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word", "file_path": "domain/use_cases/word_by_word/download_wbw_language_use_case.dart", "file_name": "download_wbw_language_use_case.dart", "line": 15, "line_from": 15, "line_to": 23, "snippet": "    required void Function(int) onProgress,\n    required CancelToken cancelToken,\n  }) async {\n    return mapResultToEither(() => _repository.downloadWbwLanguage(\n          wbwFile,\n          onProgress,\n          cancelToken,\n        ));\n  }"}, {"structure_type": "function", "name": "execute", "docstring": "", "module": "text_mushaf", "file_path": "domain/use_cases/text_mushaf/get_words_for_range_text_mushaf_use_case.dart", "file_name": "get_words_for_range_text_mushaf_use_case.dart", "line": 14, "line_from": 14, "line_to": 33, "snippet": "  Future<Either<String, List<TextWordEntity>>> execute({required GetWordsForRangeParams params}) async {\n\n      final List<TextWordEntity> words = await _repository.getWordsForRange(\n        rangeStart: params.rangeStart,\n        rangeEnd: params.rangeEnd,\n      );\n      return Right(words);\n    \n  }\n}\n\nclass GetWordsForRangeParams {\n  final int rangeStart;\n  final int rangeEnd;\n\n  const GetWordsForRangeParams({\n    required this.rangeStart,\n    required this.rangeEnd,\n  });\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "text_mushaf", "file_path": "domain/use_cases/text_mushaf/initialize_text_mushaf_database_use_case.dart", "file_name": "initialize_text_mushaf_database_use_case.dart", "line": 17, "line_from": 17, "line_to": 24, "snippet": "    void Function(int received, int total)? onProgress,\n    CancelToken? cancelToken,\n  }) async {\n    return mapResultToEither(() => _repository.initializeDatabase(\n          onProgress: onProgress,\n          cancelToken: cancelToken,\n        ));\n  }"}, {"structure_type": "class", "name": "CopyEntity", "docstring": "", "module": "ui", "file_path": "domain/entities/ui/copy_entity.dart", "file_name": "copy_entity.dart", "line": 1, "line_from": 1, "line_to": 32, "snippet": "class CopyEntity {\n  final String arabicText;\n  final String translationText;\n  final CopyType copyType;\n  final int startAyah;\n  final int endAyah;\n  final String surahName;\n\n  const CopyEntity({\n    required this.arabicText,\n    required this.translationText,\n    required this.copyType,\n    required this.startAyah,\n    required this.endAyah,\n    required this.surahName,\n  });\n\n  String get formattedText {\n    switch (copyType) {\n      case CopyType.normalCopy:\n        return arabicText;\n      case CopyType.translationCopy:\n        return translationText;\n      case CopyType.arabicCopy:\n        return arabicText;\n    }\n  }\n}\n\nenum CopyType { normalCopy, translationCopy, arabicCopy }\n"}, {"structure_type": "class", "name": "SettingsStateEntity extends Equatable", "docstring": "", "module": "settings", "file_path": "domain/entities/settings/setting_state_entity.dart", "file_name": "setting_state_entity.dart", "line": 5, "line_from": 5, "line_to": 168, "snippet": "class SettingsStateEntity extends Equatable {\n  const SettingsStateEntity({\n    required this.showArabic,\n    required this.showTranslation,\n    required this.arabicFontSize,\n    required this.localFontSize,\n    required this.arabicFontScript,\n    required this.arabicFont,\n    required this.keepScreenOn,\n    required this.showWordByWord,\n    required this.tafseerFontSize,\n    required this.showDailyNotification,\n    required this.dailyNotificationTime,\n    required this.currentThemeName,\n    required this.currentLanguage,\n    required this.fontFamily,\n    required this.fontSize,\n    required this.showTajweed,\n  });\n\n  factory SettingsStateEntity.empty() {\n    return const SettingsStateEntity(\n      showArabic: true,\n      showTranslation: true,\n      arabicFontSize: 27,\n      localFontSize: 15,\n      arabicFontScript: ArabicFontScript.uthmani,\n      arabicFont: ArabicFonts.kfgq,\n      keepScreenOn: false,\n      showWordByWord: false,\n      tafseerFontSize: 15,\n      showDailyNotification: true,\n      dailyNotificationTime: TimeOfDay(hour: 9, minute: 0),\n      currentThemeName: 'Light',\n      currentLanguage: 'English',\n      fontFamily: FontFamily.inter,\n      fontSize: 14,\n      showTajweed: false,\n    );\n  }\n\n  final bool showArabic;\n  final bool showTranslation;\n  final double arabicFontSize;\n  final double localFontSize;\n  final ArabicFontScript arabicFontScript;\n  final ArabicFonts arabicFont;\n  final bool keepScreenOn;\n  final bool showWordByWord;\n  final double tafseerFontSize;\n  final bool showDailyNotification;\n  final TimeOfDay dailyNotificationTime;\n  final String currentThemeName;\n  final String currentLanguage;\n  final String fontFamily;\n  final double fontSize;\n  final bool showTajweed;\n\n  @override\n  List<Object?> get props => [\n        showArabic,\n        showTranslation,\n        arabicFontSize,\n        localFontSize,\n        arabicFontScript,\n        arabicFont,\n        keepScreenOn,\n        showWordByWord,\n        tafseerFontSize,\n        showDailyNotification,\n        dailyNotificationTime,\n        currentThemeName,\n        currentLanguage,\n        fontFamily,\n        fontSize,\n        showTajweed,\n      ];\n\n  SettingsStateEntity copyWith({\n    bool? showArabic,\n    bool? showTranslation,\n    double? arabicFontSize,\n    double? localFontSize,\n    ArabicFontScript? arabicFontScript,\n    ArabicFonts? arabicFont,\n    bool? keepScreenOn,\n    bool? showWordByWord,\n    double? tafseerFontSize,\n    bool? showDailyNotification,\n    TimeOfDay? dailyNotificationTime,\n    String? currentThemeName,\n    String? currentLanguage,\n    String? fontFamily,\n    double? fontSize,\n    bool? showTajweed,\n  }) {\n    return SettingsStateEntity(\n      showArabic: showArabic ?? this.showArabic,\n      showTranslation: showTranslation ?? this.showTranslation,\n      arabicFontSize: arabicFontSize ?? this.arabicFontSize,\n      localFontSize: localFontSize ?? this.localFontSize,\n      arabicFontScript: arabicFontScript ?? this.arabicFontScript,\n      arabicFont: arabicFont ?? this.arabicFont,\n      keepScreenOn: keepScreenOn ?? this.keepScreenOn,\n      showWordByWord: showWordByWord ?? this.showWordByWord,\n      tafseerFontSize: tafseerFontSize ?? this.tafseerFontSize,\n      showDailyNotification:\n          showDailyNotification ?? this.showDailyNotification,\n      dailyNotificationTime:\n          dailyNotificationTime ?? this.dailyNotificationTime,\n      currentThemeName: currentThemeName ?? this.currentThemeName,\n      currentLanguage: currentLanguage ?? this.currentLanguage,\n      fontFamily: fontFamily ?? this.fontFamily,\n      fontSize: fontSize ?? this.fontSize,\n      showTajweed: showTajweed ?? this.showTajweed,\n    );\n  }\n}\n\nenum ArabicFontScript { uthmani, indoPak }\n\nenum ArabicFonts {\n  kfgq,\n  meQuran,\n  kitab,\n  alQalamQuranMajeed,\n  amiriQuran,\n  lateef,\n  nooreHira,\n  nooreHuda,\n  indoPakNastaleeq,\n  uthmani,\n  husrevHatti,\n}\n\nMap<ArabicFonts, String> arabicFontToFontFamilyMap = {\n  ArabicFonts.kfgq: FontFamily.kfgq,\n  ArabicFonts.meQuran: FontFamily.meQuran,\n  ArabicFonts.kitab: FontFamily.kitab,\n  ArabicFonts.alQalamQuranMajeed: FontFamily.alQalamQuranMajeed,\n  ArabicFonts.amiriQuran: FontFamily.amiriQuran,\n  ArabicFonts.lateef: FontFamily.lateef,\n  ArabicFonts.nooreHira: FontFamily.nooreHira,\n  ArabicFonts.nooreHuda: FontFamily.nooreHuda,\n  ArabicFonts.indoPakNastaleeq: FontFamily.indoPakNastaleeq,\n  ArabicFonts.uthmani: FontFamily.uthmani,\n  ArabicFonts.husrevHatti: FontFamily.husrevHatti,\n};\n\nMap<ArabicFonts, String> arabicFontToNameMap = {\n  ArabicFonts.kfgq: \"KFGQ\",\n  ArabicFonts.meQuran: \"MeQuran\",\n  ArabicFonts.kitab: \"Kitab\",\n  ArabicFonts.alQalamQuranMajeed: \"Al Qalam Quran Majeed\",\n  ArabicFonts.amiriQuran: \"Amiri Quran\",\n  ArabicFonts.lateef: \"Lateef\",\n  ArabicFonts.nooreHira: \"Noore Hira\",\n  ArabicFonts.nooreHuda: \"Noore Huda\",\n  ArabicFonts.indoPakNastaleeq: \"IndoPak Nastaleeq\",\n  ArabicFonts.uthmani: \"Uthmani\",\n  ArabicFonts.husrevHatti: \"Husrev Hatti\",\n};\n"}, {"structure_type": "class", "name": "AnnouncementEntity extends Equatable", "docstring": "", "module": "notification", "file_path": "domain/entities/notification/announcement_entity.dart", "file_name": "announcement_entity.dart", "line": 5, "line_from": 5, "line_to": 35, "snippet": "class AnnouncementEntity extends Equatable {\n  const AnnouncementEntity({\n    required this.ayahList,\n    required this.promotionalMessage,\n    required this.announcementType,\n  });\n\n  factory AnnouncementEntity.empty() => AnnouncementEntity(\n        ayahList: const [\n        ],\n        promotionalMessage: PromotionalMessageEntity.empty(),\n        announcementType: AnnouncementType.ayah,\n      );\n\n  final List<DailyAyah> ayahList;\n  final PromotionalMessageEntity? promotionalMessage;\n  final AnnouncementType announcementType;\n\n  @override\n  List<Object?> get props => [ayahList, promotionalMessage, announcementType];\n\n  AnnouncementEntity close() => AnnouncementEntity(\n        ayahList: ayahList,\n        promotionalMessage: null,\n        announcementType: AnnouncementType.ayah,\n      );\n}\n\nenum AnnouncementType { ayah, promotionalMessage }\n"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "widgets", "file_path": "presentation/settings/widgets/custom_slider.dart", "file_name": "custom_slider.dart", "line": 35, "line_from": 35, "line_to": 202, "snippet": "  void initState() {\n    super.initState();\n    _currentSliderValue = widget.defaultValue;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final Color activeColor = widget.activeColor ?? context.color.primaryColor;\n    final Color inactiveColor =\n        widget.inactiveColor ?? activeColor.withOpacityInt(0.35);\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(\n          widget.title,\n          style: theme.textTheme.bodyMedium!.copyWith(\n            fontWeight: FontWeight.w600,\n            color: isDarkMode(context)\n                ? context.color.subtitleColor\n                : context.color.blackColor,\n          ),\n        ),\n        gapH10,\n        Row(\n          children: [\n            Expanded(\n              child: SliderTheme(\n                data: SliderTheme.of(context).copyWith(\n                  // valueIndicatorTextStyle: TextStyle(\n                  //   color: context.color.primaryColor,\n                  //   fontSize: bodyMediumFontSize,\n                  //   fontWeight: FontWeight.w600,\n                  // ),\n                  // valueIndicatorShape: AbovePointerSliderValueIndicatorShape(\n                  //   valueStyle: TextStyle(\n                  //     color: context.color.primaryColor,\n                  //     fontSize: bodyMediumFontSize,\n                  //     fontWeight: FontWeight.w600,\n                  //   ),\n                  //   context: context,\n                  // ),\n                  // showValueIndicator: ShowValueIndicator.always,\n                  trackHeight: _trackHeight,\n                  activeTrackColor: activeColor,\n                  inactiveTrackColor: inactiveColor,\n                  thumbColor: activeColor,\n                  thumbShape:\n                      const RoundSliderThumbShape(enabledThumbRadius: 5),\n                  overlayShape:\n                      const RoundSliderOverlayShape(overlayRadius: 12),\n                  tickMarkShape: SliderTickMarkShape.noTickMark,\n                  trackShape: CustomTrackShape(trackHeight: _trackHeight),\n                ),\n                child: Slider(\n                  value: _currentSliderValue,\n                  min: widget.min,\n                  max: widget.max,\n                  label: _currentSliderValue\n                      .round()\n                      .toString()\n                      .toLocalizedNumber(context),\n                  onChanged: (double value) {\n                    setState(() {\n                      _currentSliderValue = value;\n                    });\n                    widget.onChanged(value);\n                  },\n                ),\n              ),\n            ),\n            gapW5,\n            Container(\n              alignment: Alignment.centerRight,\n              width: 20,\n              child: Text(\n                _currentSliderValue\n                    .round()\n                    .toString()\n                    .toLocalizedNumber(context),\n                style: TextStyle(\n                  fontSize: 13,\n                  fontWeight: FontWeight.w600,\n                  color: theme.primaryColor,\n                ),\n              ),\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n\n// CustomTrackShape to customize track height\nclass CustomTrackShape extends SliderTrackShape {\n  final double trackHeight;\n\n  const CustomTrackShape({required this.trackHeight});\n\n  @override\n  Rect getPreferredRect({\n    required RenderBox parentBox,\n    Offset offset = Offset.zero,\n    required SliderThemeData sliderTheme,\n    bool isEnabled = false,\n    bool isDiscrete = false,\n  }) {\n    final double trackHeight = sliderTheme.trackHeight ?? this.trackHeight;\n\n    final double trackLength = parentBox.size.width;\n\n    final Rect trackRect = Rect.fromLTWH(\n      offset.dx,\n      offset.dy + (parentBox.size.height - trackHeight) / 2,\n      trackLength,\n      trackHeight,\n    );\n\n    return trackRect;\n  }\n\n  @override\n  void paint(\n    PaintingContext context,\n    Offset offset, {\n    required RenderBox parentBox,\n    required SliderThemeData sliderTheme,\n    required Animation<double> enableAnimation,\n    required Offset thumbCenter,\n    bool isEnabled = false,\n    bool isDiscrete = false,\n    TextDirection? textDirection,\n    Offset? secondaryOffset,\n  }) {\n    final Paint activePaint = Paint()..color = sliderTheme.activeTrackColor!;\n    final Paint inactivePaint = Paint()\n      ..color = sliderTheme.inactiveTrackColor!;\n\n    final double trackHeight = sliderTheme.trackHeight ?? this.trackHeight;\n    final double trackRadius = trackHeight / 2;\n    final double trackLength = parentBox.size.width;\n\n    final RRect activeTrackRRect = RRect.fromRectAndRadius(\n      Rect.fromLTWH(\n        offset.dx,\n        thumbCenter.dy - trackRadius,\n        thumbCenter.dx - offset.dx,\n        trackHeight,\n      ),\n      Radius.circular(trackRadius),\n    );\n\n    final RRect inactiveTrackRRect = RRect.fromRectAndRadius(\n      Rect.fromLTWH(\n        thumbCenter.dx,\n        thumbCenter.dy - (trackHeight / 2),\n        trackLength - thumbCenter.dx,\n        trackHeight,\n      ),\n      Radius.circular(trackHeight / 2),\n    );\n\n    context.canvas.drawRRect(activeTrackRRect, activePaint);\n    context.canvas.drawRRect(inactiveTrackRRect, inactivePaint);\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "mini_settings", "file_path": "presentation/settings/widgets/mini_settings/mini_settings_drawer.dart", "file_name": "mini_settings_drawer.dart", "line": 31, "line_from": 31, "line_to": 176, "snippet": "  Widget build(BuildContext context) {\n    final SettingsPresenter settingPresenter = locate();\n    final ThemeData themeData = Theme.of(context);\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      PageType pageType = PageType.settings;\n      if (isAyahPage) {\n        pageType = PageType.ayah;\n      } else if (isTafseerPage || showOnlyFontSettings) {\n        pageType = PageType.tafseer;\n      }\n      settingPresenter.initializeMiniSettings(pageType: pageType);\n    });\n\n    return Container(\n      margin: EdgeInsets.only(\n        top: MediaQuery.of(context).padding.top,\n      ),\n      height: double.infinity,\n      width: QuranScreen.width * 0.75,\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: ClipRRect(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.start,\n          children: [\n            const MiniSettingsTopBar(),\n            gapH5,\n            Expanded(\n              child: SingleChildScrollView(\n                child: Column(\n                  children: showOnlyFontSettings\n                      ? [\n                          FontSettingsCard(\n                            settingPresenter: settingPresenter,\n                            showTextReview: false,\n                            showTafseerFontSlider: showTafseerFontSlider,\n                          ),\n                        ]\n                      : [\n                          ContentSettingsCard(\n                            settingPresenter: settingPresenter,\n                            isFromSettingsPage: false,\n                          ),\n                          Padding(\n                            padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                            child: BuildDivider(\n                              theme: themeData,\n                            ),\n                          ),\n                          WordByWordSwitch(\n                            settingPresenter: settingPresenter,\n                            theme: themeData,\n                          ),\n                          Padding(\n                            padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                            child: BuildDivider(\n                              theme: themeData,\n                            ),\n                          ),\n                          FontSettingsCard(\n                            settingPresenter: settingPresenter,\n                            showTextReview: false,\n                          ),\n                        ],\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass MiniSettingsTopBar extends StatelessWidget {\n  const MiniSettingsTopBar({\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData themeData = Theme.of(context);\n    return Container(\n      padding: EdgeInsets.only(\n        left: twelvePx,\n        right: twelvePx,\n        top: twentyOnePx,\n      ),\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n          GestureDetector(\n            onTap: () => context.navigatorPop(),\n            child: Padding(\n              padding: paddingH6,\n              child: Icon(\n                Icons.arrow_forward_ios_rounded,\n                size: sixteenPx,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          gapW8,\n          Align(\n            alignment: Alignment.centerLeft,\n            child: Text(\n              context.l10n.quickTools,\n              style: themeData.textTheme.headlineSmall?.copyWith(\n                fontWeight: FontWeight.bold,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          const Spacer(),\n          GestureDetector(\n            onTap: () async {\n              await context.navigatorPush<void>(const SettingsPage());\n            },\n            child: SvgPicture.asset(\n              SvgPath.icSettings,\n              height: twentyOnePx,\n              colorFilter: buildColorFilter(isDarkMode(context)\n                  ? context.color.subtitleColor\n                  : context.color.primaryColor),\n            ),\n          ),\n          gapW10,\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word_language_selection_bottom_sheet", "file_path": "presentation/settings/widgets/word_by_word_language_selection_bottom_sheet/word_by_word_downloaded_items.dart", "file_name": "word_by_word_downloaded_items.dart", "line": 12, "line_from": 12, "line_to": 58, "snippet": "  final void Function({required String name})? onLanguageSelected;\n  final void Function({required String name})? onLanguageDelete;\n  final ThemeData theme;\n  const WordByWordDownloadedItems({\n    super.key,\n    required this.title,\n    required this.theme,\n    this.selectedLanguage,\n    this.downloadedLanguages,\n    this.onLanguageSelected,\n    this.onLanguageDelete,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Padding(\n          padding: EdgeInsets.symmetric(horizontal: sixteenPx),\n          child: SectionHeader(\n            theme: theme,\n            title:\n                '$title (${downloadedLanguages!.length.toLocalizedString(context)})',\n          ),\n        ),\n        ListView.builder(\n          shrinkWrap: true,\n          physics: const NeverScrollableScrollPhysics(),\n          itemCount: downloadedLanguages!.length,\n          padding: EdgeInsets.zero,\n          itemBuilder: (context, index) {\n            final String name = downloadedLanguages![index];\n\n            return WordByWordDownloadedSingleItem(\n              name: name,\n              isSelected: name == selectedLanguage,\n              onSelect: (String name) => onLanguageSelected?.call(name: name),\n              onDelete: (String name) => onLanguageDelete?.call(name: name),\n              theme: theme,\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "word_by_word_language_selection_bottom_sheet", "file_path": "presentation/settings/widgets/word_by_word_language_selection_bottom_sheet/word_by_word_available_items.dart", "file_name": "word_by_word_available_items.dart", "line": 12, "line_from": 12, "line_to": 68, "snippet": "  final void Function({required String name})? onLanguageDownload;\n  final void Function({required String name})? onLanguageDelete;\n  final ThemeData theme;\n  final bool? isDownloading;\n  final String? activeDownloadId;\n  final int? downloadProgress;\n\n  const WordByWordAvailableItems({\n    super.key,\n    required this.title,\n    required this.items,\n    required this.theme,\n    this.selectedLanguage,\n    this.onLanguageDownload,\n    this.onLanguageDelete,\n    this.isDownloading,\n    this.activeDownloadId,\n    this.downloadProgress,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Padding(\n          padding: EdgeInsets.symmetric(horizontal: sixteenPx),\n          child: SectionHeader(\n            theme: theme,\n            title: '$title (${items.length.toLocalizedString(context)})',\n          ),\n        ),\n        ListView.builder(\n          shrinkWrap: true,\n          physics: const NeverScrollableScrollPhysics(),\n          itemCount: items.length,\n          padding: EdgeInsets.zero,\n          itemBuilder: (context, index) {\n            final WbwDbFileModel file = items[index];\n            final String name = file.name;\n            final String size = file.size;\n\n            return WordByWordAvailableSingleItem(\n              name: name,\n              onDownload: (String name) => onLanguageDownload?.call(name: name),\n              theme: theme,\n              isDownloading: isDownloading!,\n              size: size,\n              activeDownloadId: activeDownloadId,\n              downloadProgress: downloadProgress!,\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "notice", "file_path": "presentation/home/ui/notice/notice_dialog.dart", "file_name": "notice_dialog.dart", "line": 421, "line_from": 421, "line_to": 433, "snippet": "    required void Function(PromotionalMessageEntity) onClose,\n  }) async {\n    final bool? isClosed = await showAnimatedDialog<bool>(\n      context: context,\n      barrierDismissible: true,\n      builder: (context) => NoticeDialog(\n        payload: notice,\n      ),\n      animationType: DialogTransitionType.fadeScale,\n      curve: Curves.fastOutSlowIn,\n    );\n    if (isClosed ?? false) onClose(notice);\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "announcement", "file_path": "presentation/home/ui/announcement/carousel_item.dart", "file_name": "carousel_item.dart", "line": 24, "line_from": 24, "line_to": 69, "snippet": "  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: GestureDetector(\n        onTap: onTap,\n        child: _CarouselContent(\n          ayah: ayah,\n          surahName: surahName,\n          theme: theme,\n          context: context,\n        ),\n      ),\n    );\n  }\n}\n\nclass _CarouselContent extends StatelessWidget {\n  const _CarouselContent({\n    required this.ayah,\n    required this.surahName,\n    required this.theme,\n    required this.context,\n  });\n\n  final DailyAyah ayah;\n  final String surahName;\n  final ThemeData theme;\n  final BuildContext context;\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: QuranScreen.width - 70,\n      child: Text(\n        \"${ayah.text} \\n\\n [$surahName ${ayah.surahId.toLocalizedString(context)}:${ayah.ayahId.toLocalizedString(context)}]\",\n        overflow: TextOverflow.ellipsis,\n        maxLines: 7,\n        textAlign: TextAlign.center,\n        style: context.quranText.aText!.copyWith(\n          // color: context.color.whiteColor.withAlpha((0.7 * 255).toInt()),\n\n          height: 1.7,\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/home/presenter/home_presenter.dart", "file_name": "home_presenter.dart", "line": 125, "line_from": 125, "line_to": 135, "snippet": "    required void Function(UpdateInfoEntity) onForceUpdate,\n  }) async {\n    await Future<void>.delayed(4.inSeconds);\n    await parseDataFromEitherWithUserMessage(\n      task: () async => _determineIfNeedForceUpdate.execute(),\n      onDataLoaded: (updateInfo) {\n        final bool needForceUpdate = updateInfo.askToUpdate;\n        if (needForceUpdate) onForceUpdate(updateInfo);\n      },\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/home/presenter/home_presenter.dart", "file_name": "home_presenter.dart", "line": 320, "line_from": 320, "line_to": 334, "snippet": "    required void Function(String promotionUrl) onInternet,\n    required VoidCallback onNoInternet,\n  }) async {\n    final bool isNetworkAvailable = await checkInternetConnection();\n    if (!isNetworkAvailable) {\n      onNoInternet();\n      return;\n    }\n    const String appStoreUrl =\n        \"https://apps.apple.com/us/developer/md-saiful-islam-saif/id1238182913\";\n    const String playStoreUrl =\n        \"https://play.google.com/store/apps/dev?id=5689317609893757784\";\n    final String promotionUrl = Platform.isIOS ? appStoreUrl : playStoreUrl;\n    onInternet(promotionUrl);\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/home/presenter/home_presenter.dart", "file_name": "home_presenter.dart", "line": 367, "line_from": 367, "line_to": 375, "snippet": "    await Future<void>.delayed(5.inSeconds);\n    await _askReviewIfNecessary.execute(askForReview: askForReview);\n  }\n\n  @override\n  void onClose() {\n    _fetchAnnouncementsSub?.cancel();\n    super.onClose();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/home/widgets/home_page_fancy_background.dart", "file_name": "home_page_fancy_background.dart", "line": 12, "line_from": 12, "line_to": 48, "snippet": "  Widget build(BuildContext context) {\n    // used vector for improved rendering performance\n    return SvgPicture.asset(\n      SvgPath.imgBgHome,\n      height: 55.percentHeight,\n      width: 100.percentWidth,\n      colorFilter: buildColorFilterToChangeColor(\n          context.theme.bannerTheme.backgroundColor!.withOpacityInt(0.8)),\n    );\n  }\n}\n\nclass StartPageFancyBackgroundColor extends StatelessWidget {\n  const StartPageFancyBackgroundColor({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ClipPath(\n      clipper: OvalBottomBorderClipper(),\n      child: Container(\n        height: 55.percentHeight,\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            stops: const [0.0, 0.42, 1.0],\n            colors: [\n              context.color.gdTop,\n              context.color.gdMiddle,\n              context.color.gdBottom,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/home/widgets/page_list_widget.dart", "file_name": "page_list_widget.dart", "line": 24, "line_from": 24, "line_to": 119, "snippet": "  Widget build(BuildContext context) {\n    return ListView.builder(\n      padding: EdgeInsets.zero,\n      physics: const NeverScrollableScrollPhysics(),\n      shrinkWrap: true,\n      itemCount: pages.length,\n      itemBuilder: (context, index) {\n        final PageEntity page = pages[index];\n\n        return _buildPageListItem(\n          theme: theme,\n          pageNumber: page.id,\n          context: context,\n          surahName: getTranslatedSurahName(\n              surahNumber: page.startSurahNo, context: context),\n          pageInitialText: page.arabicInitial,\n          onTapPageItem: () async =>\n              await homePresenter.goToSurahDetailsPageWithSpecificAyah(\n            context: context,\n            surahIndex: page.startSurahNo - 1,\n            ayahIndex: page.startAyatNo - 1,\n            isNeedToJump: false,\n            showPageIndicator: true,\n          ),\n        );\n      },\n    );\n  }\n}\n\nOnTapWidget _buildPageListItem({\n  required ThemeData theme,\n  required int pageNumber,\n  required BuildContext context,\n  required String surahName,\n  required String pageInitialText,\n  required VoidCallback onTapPageItem,\n}) {\n  return OnTapWidget(\n    theme: theme,\n    onTap: onTapPageItem,\n    child: Container(\n      margin: EdgeInsets.symmetric(horizontal: twentyPx, vertical: sixteenPx),\n      child: Row(\n        children: [\n          ShowSurahNumberWidget(\n            formatSurahNumber: pageNumber.toLocalizedString(context),\n            theme: theme,\n          ),\n          gapW18,\n          SizedBox(\n            width: 35.percentWidth,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.start,\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(\n                  '${context.l10n.page} ${pageNumber.toLocalizedString(context)}',\n                  overflow: TextOverflow.ellipsis,\n                  style: theme.textTheme.titleLarge?.copyWith(\n                    fontWeight: FontWeight.w600,\n                  ),\n                ),\n                gapH4,\n                Text(\n                  surahName,\n                  overflow: TextOverflow.ellipsis,\n                  style: theme.textTheme.bodySmall!.copyWith(\n                    color: context.color.subtitleColor,\n                  ),\n                ),\n              ],\n            ),\n          ),\n          gapW15,\n          Flexible(\n            child: Align(\n              alignment: Alignment.centerRight,\n              child: Text(\n                pageInitialText,\n                overflow: TextOverflow.clip,\n                maxLines: 1,\n                textDirection: TextDirection.rtl,\n                style: context.quranText.arabicAyah!.copyWith(\n                  fontFamily: FontFamily.alQalamQuranMajeed,\n                  fontSize: nineteenPx,\n                  letterSpacing: 0,\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n    ),\n  );\n}"}, {"structure_type": "function", "name": "show", "docstring": "", "module": "ui", "file_path": "presentation/grammar/ui/grammar_bottom_sheet.dart", "file_name": "grammar_bottom_sheet.dart", "line": 31, "line_from": 31, "line_to": 220, "snippet": "  static Future<void> show({\n    required BuildContext context,\n    required List<WordByWordEntity> wordList,\n    required int selectedWordIndex,\n  }) async {\n    final GrammarPresenter grammarPresenter = locate<GrammarPresenter>();\n    final bool success = await grammarPresenter.loadCorpusDataAndPrepare(\n      suraId: wordList[selectedWordIndex].surah!,\n      ayahId: wordList[selectedWordIndex].ayah!,\n    );\n\n    if (!success || !context.mounted) return;\n\n    final GrammarBottomSheet grammarBottomSheet = GrammarBottomSheet(\n      key: const Key(\"GrammarBottomSheet\"),\n      wordList: wordList,\n      selectedWordIndex: selectedWordIndex,\n    );\n    await grammarPresenter.jumpToPage(selectedWordIndex);\n    if (context.mounted) {\n      await context.showBottomSheet<void>(grammarBottomSheet, context);\n    }\n  }\n\n  @override\n  State<GrammarBottomSheet> createState() => _GrammarBottomSheetState();\n}\n\nclass _GrammarBottomSheetState extends State<GrammarBottomSheet> {\n  late int currentWordIndex;\n\n  String _getTranslation(\n      WordByWordEntity word, GrammarPresenter grammarPresenter, int wordIndex) {\n    final WordByWordPresenter wordByWordPresenter =\n        locate<WordByWordPresenter>();\n    final String selectedLanguage =\n        wordByWordPresenter.currentUiState.selectedLanguage;\n\n    switch (selectedLanguage) {\n      case 'English':\n        return word.en ?? '';\n      case 'Bangla':\n        return word.bn ?? '';\n      default:\n        return CacheData\n                .wordByWordCache[selectedLanguage]?[word.surah ?? 0]\n                    ?[word.ayah ?? 0]?[wordIndex]\n                .translation ??\n            word.en ??\n            '';\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    currentWordIndex = widget.selectedWordIndex;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final GrammarPresenter grammarPresenter = locate<GrammarPresenter>();\n\n    return PresentableWidgetBuilder(\n      presenter: grammarPresenter,\n      builder: () {\n        final List<CorpusTableData> corpusData =\n            grammarPresenter.currentUiState.corpusData;\n\n        return Container(\n          decoration: decorateBottomSheet(context),\n          alignment: Alignment.topCenter,\n          height: QuranScreen.width * 1.1,\n          child: Column(\n            key: const Key('grammar_bottom_sheet'),\n            mainAxisSize: MainAxisSize.min,\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n              gapH20,\n              TitleSectionWidget(\n                pageController: grammarPresenter.pageController,\n                wordList: widget.wordList,\n                selectedWordIndex: currentWordIndex,\n              ),\n              gapH15,\n              Flexible(\n                child: PageView.builder(\n                  itemCount: corpusData.length,\n                  reverse: true,\n                  controller: grammarPresenter.pageController,\n                  onPageChanged: (int index) {\n                    setState(() {\n                      currentWordIndex = index;\n                    });\n                  },\n                  itemBuilder: (context, index) {\n                    final CorpusTableData word = corpusData[index];\n                    return Wrap(\n                      alignment: WrapAlignment.center,\n                      children: [\n                        Padding(\n                          padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                          child: Column(\n                            crossAxisAlignment: CrossAxisAlignment.center,\n                            children: [\n                              ArabicWordWidget(\n                                key: const Key(\"ArabicWordWidget\"),\n                                theme: theme,\n                                word: word,\n                              ),\n                              gapH20,\n                              WordPartsOfSpeechWidget(\n                                key: const Key(\"WordPartsOfSpeechWidget\"),\n                                theme: theme,\n                                pos1: word.pos1,\n                                pos2: word.pos2,\n                                pos3: word.pos3,\n                                pos4: word.pos4,\n                                pos5: word.pos5,\n                              ),\n                              gapH10,\n                              Text(\n                                key: const Key(\"TranslationText\"),\n                                _getTranslation(widget.wordList[index],\n                                    grammarPresenter, index),\n                                style: theme.textTheme.titleMedium!.copyWith(\n                                  fontWeight: FontWeight.w400,\n                                ),\n                              ),\n                              gapH20,\n                              if (word.rootAr != null) ...[\n                                ShowRootWordWidget(\n                                  key: const Key(\"ShowRootWordWidget\"),\n                                  title: context.l10n.rootWord,\n                                  subtitle: word.rootAr,\n                                  theme: theme,\n                                ),\n                                gapH6,\n                              ],\n                              if (word.lemma != null) ...[\n                                ShowRootWordWidget(\n                                  key: const Key(\"ShowLemmaDerivativeWidget\"),\n                                  title: context.l10n.lemmaDerivative,\n                                  subtitle: word.lemma!,\n                                  theme: theme,\n                                ),\n                                gapH10,\n                              ],\n                            ],\n                          ),\n                        ),\n                      ],\n                    );\n                  },\n                ),\n              ),\n              Padding(\n                padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                child: TwoWayActionButton(\n                  theme: theme,\n                  svgPictureForCancelButton: SvgImage(\n                    SvgPath.icMaximize,\n                    width: twentyPx,\n                    height: twentyPx,\n                    color: context.color.primaryColor,\n                  ),\n                  svgPictureForOkButton: SvgImage(\n                    SvgPath.icPlayCircle,\n                    width: twentyPx,\n                    height: twentyPx,\n                    color: context.color.primaryColor,\n                  ),\n                  submitButtonBgColor: context.color.secondaryButtonColor,\n                  submitButtonTextColor: context.color.primaryColor,\n                  cancelButtonTextColor: context.color.primaryColor,\n                  submitButtonTitle: context.l10n.playAudio,\n                  cancelButtonTitle: 'Click for More',\n                  onSubmitButtonTap: () async => await grammarPresenter.handleSubmitButtonTap(context, widget.wordList),\n                  onCancelButtonTap: () async => await grammarPresenter.handleClickForMore(context),\n                ),\n              ),\n              gapH30,\n            ],\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/grammar/widgets/verse_navigation.dart", "file_name": "verse_navigation.dart", "line": 32, "line_from": 32, "line_to": 134, "snippet": "  Widget build(BuildContext context) {\n    return Row(\n      mainAxisSize: MainAxisSize.min,\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        _NavigationButton(\n          onPressed: isFirstAyah ? null : onPreviousPressed,\n          text: 'Previous $previousVerse',\n          iconPath: SvgPath.icLeftArrow,\n          isNext: false,\n          theme: theme,\n          isDisabled: isFirstAyah,\n        ),\n        gapW12,\n        _NavigationButton(\n          onPressed: isLastAyah ? null : onNextPressed,\n          text: 'Next $nextVerse',\n          iconPath: SvgPath.icRightArrow,\n          isNext: true,\n          theme: theme,\n          isDisabled: isLastAyah,\n        ),\n      ],\n    );\n  }\n}\n\nclass _NavigationButton extends StatelessWidget {\n  const _NavigationButton({\n    required this.onPressed,\n    required this.text,\n    required this.iconPath,\n    required this.isNext,\n    required this.theme,\n    required this.isDisabled,\n  });\n\n  final VoidCallback? onPressed;\n  final String text;\n  final String iconPath;\n  final bool isNext;\n  final ThemeData theme;\n  final bool isDisabled;\n\n  @override\n  Widget build(BuildContext context) {\n    return OnTapWidget(\n      onTap: isDisabled ? null : onPressed,\n      theme: theme,\n      borderRadius: BorderRadius.circular(thirtySevenPx),\n      child: Container(\n        alignment: Alignment.center,\n        constraints: BoxConstraints(\n          minWidth: 41.percentWidth,\n        ),\n        decoration: BoxDecoration(\n          color: isDisabled\n              ? context.color.secondaryButtonColor.withOpacityInt(0.5)\n              : context.color.secondaryButtonColor,\n          borderRadius: BorderRadius.circular(thirtySevenPx),\n        ),\n        padding: EdgeInsets.symmetric(horizontal: fourteenPx, vertical: tenPx),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            if (!isNext)\n              SvgImage(\n                iconPath,\n                width: twentyPx,\n                height: twentyPx,\n                color: isDisabled\n                    ? context.color.subtitleColor\n                    : context.color.blackColor,\n              ),\n            if (!isNext) gapW8,\n            Flexible(\n              child: Text(\n                text,\n                maxLines: 1,\n                style: theme.textTheme.bodyMedium!.copyWith(\n                  fontWeight: FontWeight.normal,\n                  overflow: TextOverflow.ellipsis,\n                  color: isDisabled ? context.color.subtitleColor : null,\n                ),\n              ),\n            ),\n            if (isNext) gapW8,\n            if (isNext)\n              SvgImage(\n                iconPath,\n                width: twentyPx,\n                height: twentyPx,\n                color: isDisabled\n                    ? context.color.subtitleColor\n                    : context.color.blackColor,\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "conflicts", "docstring": "", "module": "presenter", "file_path": "presentation/memorization/presenter/memorization_presenter.dart", "file_name": "memorization_presenter.dart", "line": 425, "line_from": 425, "line_to": 459, "snippet": "    // Create a unique notification ID based on plan name to avoid conflicts\n    final int notificationId = currentState.planName.hashCode.abs() % 100000;\n\n    final NotificationContent content = NotificationContent(\n      id: notificationId,\n      channelKey: memorizationNotificationChannelKey,\n      title: 'Memorization Reminder',\n      body:\n          'Time to practice your Quran memorization: ${currentState.planName}',\n      category: NotificationCategory.Reminder,\n      backgroundColor: QuranColor.primaryColorLight,\n      color: QuranColor.primaryColorLight,\n      notificationLayout: NotificationLayout.Default,\n      payload: {\n        'type': 'memorization_plan',\n        'plan_name': currentState.planName\n      },\n    );\n\n    final NotificationCalendar schedule = NotificationCalendar(\n      hour: time.hour,\n      minute: time.minute,\n      second: 0,\n      millisecond: 0,\n      timeZone: timeZone,\n      repeats: true,\n      allowWhileIdle: true,\n      preciseAlarm: true,\n    );\n\n    await _awesomeNotifications.createNotification(\n      content: content,\n      schedule: schedule,\n    );\n  }"}, {"structure_type": "function", "name": "progress;", "docstring": "", "module": "widgets", "file_path": "presentation/memorization/widgets/memorization_plan_card.dart", "file_name": "memorization_plan_card.dart", "line": 29, "line_from": 29, "line_to": 164, "snippet": "  final Future<double> progress;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: EdgeInsets.symmetric(horizontal: twentyPx, vertical: sixPx),\n      child: OnTapWidget(\n        onTap: onTap,\n        theme: theme,\n        child: Container(\n          decoration: BoxDecoration(\n            borderRadius: radius15,\n            border: Border.all(color: context.color.borderColor, width: 1),\n          ),\n          child: Padding(\n            padding: padding15,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                MemorizationPlanTopRow(\n                  planName: plan.planName,\n                  theme: theme,\n                  memorizationPresenter: memorizationPresenter,\n                  plan: plan,\n                ),\n                gapH20,\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    Expanded(\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          DaysLeftText(\n                            daysLeft: plan.estimatedDays,\n                            theme: theme,\n                          ),\n                          gapH20,\n                          PlanInfoRow(\n                            iconPath: SvgPath.icStar,\n                            text: getCurrentLanguage(context) ==\n                                    LanguageType.bangla.code\n                                ? '${plan.startSurahId.toLocalizedString(context)}:${plan.startAyahId.toLocalizedString(context)} ${context.l10n.from} ${plan.endSurahId.toLocalizedString(context)}:${plan.endAyahId.toLocalizedString(context)}'\n                                : '${context.l10n.from} ${plan.startSurahId.toLocalizedString(context)}:${plan.startAyahId.toLocalizedString(context)} - ${plan.endSurahId.toLocalizedString(context)}:${plan.endAyahId.toLocalizedString(context)}',\n                            theme: theme,\n                          ),\n                          gapH8,\n                          FutureBuilder<String>(\n                              future: memorizationPresenter.getCurrentProgress(\n                                  plan.planName, context),\n                              builder: (context, snapshot) {\n                                return PlanInfoRow(\n                                  iconPath: SvgPath.icGraduate,\n                                  text: snapshot.data ?? context.l10n.loading,\n                                  theme: theme,\n                                );\n                              }),\n                          gapH8,\n                          PlanInfoRow(\n                            iconPath: plan.hasNotification\n                                ? SvgPath.icVolumeHigh\n                                : SvgPath.icVolumeSlash,\n                            text: plan.hasNotification &&\n                                    plan.notificationTime != null\n                                ? '${DateFormat('h:mm a').format(plan.notificationTime!)} ${context.l10n.daily}'\n                                : context.l10n.turnedOff,\n                            theme: theme,\n                          ),\n                          gapH8,\n                          PlanInfoRow(\n                            iconPath: SvgPath.icClock,\n                            text:\n                                '${context.l10n.endsIn} ${DateFormat('MMM dd, yyyy').format(plan.createdAt.add(Duration(days: plan.estimatedDays)))}',\n                            theme: theme,\n                          ),\n                        ],\n                      ),\n                    ),\n                    SizedBox(\n                      width: 26.percentWidth,\n                      child: FutureBuilder<double>(\n                        key: Key(plan.planName),\n                        future: progress,\n                        builder: (context, snapshot) {\n                          return ProgressCircle(\n                            theme: theme,\n                            progress: snapshot.data ?? 0.0,\n                            text: context.l10n.completed,\n                          );\n                        },\n                      ),\n                    )\n                  ],\n                )\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass DaysLeftText extends StatelessWidget {\n  const DaysLeftText({\n    super.key,\n    required this.daysLeft,\n    required this.theme,\n  });\n\n  final int daysLeft;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    return RichText(\n      text: TextSpan(\n        children: [\n          TextSpan(\n            text: '${daysLeft.toLocalizedString(context)} ',\n            style: theme.textTheme.headlineLarge!.copyWith(\n              fontWeight: FontWeight.bold,\n            ),\n          ),\n          TextSpan(\n            text: context.l10n.daysLeft,\n            style: theme.textTheme.labelSmall!.copyWith(\n              color: context.color.subtitleColor,\n              fontWeight: FontWeight.w400,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/memorization/widgets/memorzation_search_widget.dart", "file_name": "memorzation_search_widget.dart", "line": 15, "line_from": 15, "line_to": 66, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return Container(\n      height: isMobile ? 40.px : 25.px,\n      margin: EdgeInsets.symmetric(horizontal: isMobile ? twentyPx : tenPx),\n      padding: EdgeInsets.symmetric(vertical: 0.px),\n      alignment: Alignment.centerLeft,\n      child: TextFormField(\n        //contextMenuBuilder: fixedLightContextMenu,\n\n        textAlignVertical: TextAlignVertical.center,\n        onTapOutside: (event) => FocusScope.of(context).unfocus(),\n        textAlign: TextAlign.left,\n        controller: textEditingController,\n\n        decoration: InputDecoration(\n          contentPadding: padding4,\n          filled: true,\n          hintText: hintText,\n          fillColor: context.color.primaryColor.withOpacityInt(0.12),\n          hintStyle: theme.textTheme.bodySmall!.copyWith(\n            color: context.color.primaryColor,\n          ),\n          enabledBorder: _determineFormFieldRadius(),\n          border: _determineFormFieldRadius(),\n          disabledBorder: _determineFormFieldRadius(),\n          focusedBorder: _determineFormFieldRadius(),\n          prefixIcon: Padding(\n            padding: isMobile ? padding12 : padding8,\n            child: SvgPicture.asset(\n              SvgPath.icSearch,\n              // height: twentyPx,\n              // width: twentyPx,\n              colorFilter: buildColorFilterToChangeColor(\n                context.color.primaryColor,\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nOutlineInputBorder _determineFormFieldRadius() => _borderRadius();\n\nOutlineInputBorder _borderRadius() {\n  return OutlineInputBorder(\n    borderRadius: isMobile ? radius8 : radius4,\n    borderSide: BorderSide.none,\n  );\n}"}, {"structure_type": "function", "name": "onInit", "docstring": "", "module": "presenter", "file_path": "presentation/translation/presenter/translation_presenter.dart", "file_name": "translation_presenter.dart", "line": 70, "line_from": 70, "line_to": 696, "snippet": "  Future<void> onInit() async {\n    await initializeData();\n    super.onInit();\n  }\n\n  @override\n  void dispose() {\n    searchController.clear();\n    _fetchAndSetAvailableTranslations();\n    searchController.dispose();\n    super.dispose();\n  }\n\n  void clearSearch() {\n    searchController.clear();\n    _fetchAndSetAvailableTranslations();\n  }\n\n  Future<void> initializeData() async {\n    uiState.value = uiState.value.copyWith(isLoading: true);\n\n    try {\n      await _loadTranslationData();\n\n      await _fetchAndSetAvailableTranslations();\n\n      await _fetchAndSetSelectedTranslations();\n\n      // Set the totalAvailableToDownloadItemsCount based on the stored count\n\n      final int availableItemsCount = await _fetchAvailableItemsCountUseCase.execute();\n\n      uiState.value = uiState.value.copyWith(totalAvailableToDownloadItemsCount: availableItemsCount);\n    } catch (e) {\n      uiState.value = uiState.value.copyWith(userMessage: \"Initialization failed: ${e.toString()}\", isLoading: false);\n    }\n  }\n\n  CancelToken _addCancelToken(TTDbFileModel file) {\n    final CancelToken cancelToken = CancelToken();\n    _cancelTokens[file.fileName] = cancelToken;\n    return cancelToken;\n  }\n\n  void cancelDownload() {\n    _cancelTokens[currentUiState.activeDownloadId]?.cancel();\n  }\n\n  Future<void> _fetchAndSetSelectedTranslations() async {\n    final Set<String> selectedTranslationFileNames = await _getSelectedTranslationsUseCase.execute();\n    List<TTDbFileModel> selectedItems = [];\n\n    if (selectedTranslationFileNames.isNotEmpty) {\n      for (String fileName in selectedTranslationFileNames) {\n        TTDbFileModel? fileModel = currentUiState.jsonData.trans.values\n            .expand((models) => models)\n            .firstWhereOrNull((model) => model.fileName == fileName);\n\n        if (fileModel != null) {\n          \n          selectedItems.add(fileModel);\n          await _loadTranslation(fileModel);\n        }\n      }\n    }\n\n    uiState.value = uiState.value.copyWith(selectedItems: selectedItems);\n    await updateSelectedTranslationsCache();\n  }\n\n  Future<void> _loadTranslation(TTDbFileModel file) async {\n    final bool isDefaultTranslation = ['bn_bayaan', 'en_sahih'].contains(file.fileName);\n    if (isDefaultTranslation) {\n      await _getDefaultTranslationUseCase.execute(file);\n    } else {\n      await _getNonDefaultTranslationUseCase.execute(\n        file: file,\n        cancelToken: _addCancelToken(file),\n      );\n    }\n  }\n\n  bool isTranslationSelectedForSearch(TTDbFileModel translation) {\n    return currentUiState.selectedSearchTranslations.any((item) => item.fileName == translation.fileName);\n  }\n\n  Future<void> toggleSearchTranslationSelection(\n      {required TTDbFileModel translation, required BuildContext context}) async {\n    final List<TTDbFileModel> currentSelections = List<TTDbFileModel>.from(currentUiState.selectedSearchTranslations);\n\n    if (isTranslationSelectedForSearch(translation)) {\n      currentSelections.removeWhere((item) => item.fileName == translation.fileName);\n    } else {\n      if (currentSelections.length >= 5) {\n        await showMessage(message: \"Maximum 5 translations can be selected for search\");\n        return;\n      }\n      currentSelections.add(translation);\n    }\n\n    uiState.value = currentUiState.copyWith(\n      selectedSearchTranslations: currentSelections,\n    );\n\n    locate<SearchPresenter>().updateSelectedTranslations(currentSelections);\n  }\n\n  void updateSelected(List<TTDbFileModel> translations) {\n    uiState.value = currentUiState.copyWith(selectedSearchTranslations: translations);\n  }\n\n  Future<void> updateSelectedTranslationsCache() async {\n    final Set<String> selectedTranslations = currentUiState.selectedItems.map((e) => e.fileName).toSet();\n    await _saveSelectedTranslationsUseCase.execute(selectedTranslations);\n  }\n\n  void onSearchQueryChanged(String query) {\n    uiState.value = uiState.value.copyWith(searchQuery: query);\n\n    if (query.isEmpty) {\n      // Reset to original full lists\n      _fetchAndSetAvailableTranslations();\n    } else {\n      // Perform filtering based on the query\n      String lowerCaseQuery = query.toLowerCase();\n\n      // Filter available items\n      List<TTDbFileModel> filteredAvailable = uiState.value.allAvailableItems\n          .where((item) =>\n              item.name.toLowerCase().contains(lowerCaseQuery) || item.language.toLowerCase().contains(lowerCaseQuery))\n          .toList();\n\n      // Filter downloadable items\n      List<MapEntry<String, List<TTDbFileModel>>> filteredDownloadable =\n          uiState.value.allDownloadableItems.map((entry) {\n        List<TTDbFileModel> filteredList = entry.value\n            .where((model) =>\n                model.name.toLowerCase().contains(lowerCaseQuery) ||\n                model.language.toLowerCase().contains(lowerCaseQuery))\n            .toList();\n        return MapEntry(entry.key, filteredList);\n      }).toList();\n\n      uiState.value = uiState.value.copyWith(\n        availableItems: filteredAvailable,\n        downloadableItems: filteredDownloadable,\n      );\n    }\n  }\n\n  Future<void> _loadTranslationData() async {\n    final Either<String, TTJsonModel> result = await _getTranslationAndTafseerUseCase.execute();\n    result.fold(\n        (failure) => uiState.value = uiState.value.copyWith(\n              userMessage: failure,\n              isLoading: false,\n            ), (jsonData) {\n      List<double> totalSize = [];\n      for (MapEntry<String, List<TTDbFileModel>> entry in jsonData.trans.entries) {\n        double sizes = 0.0;\n        for (TTDbFileModel model in entry.value) {\n          sizes += double.parse(model.size);\n        }\n        totalSize.add(double.parse(sizes.toStringAsFixed(2)));\n      }\n      return uiState.value = uiState.value.copyWith(\n        jsonData: jsonData,\n        isLoading: false,\n        totalSizes: totalSize,\n      );\n    });\n  }\n\n  TTJsonModel get jsonData => currentUiState.jsonData;\n\n  bool isAlreadyDownloaded(TTDbFileModel model) {\n    return currentUiState.availableItems.any((item) => item.fileName == model.fileName);\n  }\n\n  Future<void> _fetchAndSetAvailableTranslations() async {\n    final List<String> currentAvailableTranslations = await _getDownloadedTranslationsUseCase.execute();\n    final Set<String> availableTranslationsSet = currentAvailableTranslations.toSet();\n\n    if (uiState.value.jsonData.trans.isNotEmpty) {\n      _updateAvailableAndDownloadableItems(availableTranslationsSet);\n    } else {\n      uiState.value = uiState.value.copyWith(userMessage: \"No translation data available.\", isLoading: false);\n    }\n  }\n\n  bool isShowDeleteButton(TTDbFileModel file) {\n    return !['bn_bayaan', 'en_sahih'].contains(file.fileName);\n  }\n\n  Future<void> deleteItem(TTDbFileModel file, BuildContext context) async {\n    try {\n      await _deleteTranslationDatabaseUseCase.execute(fileName: file.fileName);\n      await removeTranslationFromAvailableList(file);\n\n      // Remove from available items\n      final List<TTDbFileModel> newAvailableItems = List<TTDbFileModel>.from(currentUiState.availableItems)\n        ..remove(file);\n\n      // Remove from selected items\n      final List<TTDbFileModel> newSelectedItems =\n          currentUiState.selectedItems.where((element) => element.fileName != file.fileName).toList();\n\n      // Remove from search selections\n      final List<TTDbFileModel> newSearchSelections =\n          currentUiState.selectedSearchTranslations.where((element) => element.fileName != file.fileName).toList();\n\n      // Clear from cache if needed\n      CacheData.translationList.remove(file.fileName);\n\n      _updateAvailableAndDownloadableItems((await _getDownloadedTranslationsUseCase.execute()).toSet());\n\n      uiState.value = currentUiState.copyWith(\n        availableItems: newAvailableItems,\n        selectedItems: newSelectedItems,\n        selectedSearchTranslations: newSearchSelections,\n        totalAvailableToDownloadItemsCount: currentUiState.totalAvailableToDownloadItemsCount + 1,\n      );\n\n      // Update search presenter if needed\n      locate<SearchPresenter>().updateSelectedTranslations(newSearchSelections);\n\n      // Save the updated count and cache\n      await _saveAvailableItemsCountUseCase.execute(uiState.value.totalAvailableToDownloadItemsCount);\n      await updateSelectedTranslationsCache();\n\n      // If no translation is selected after deletion, automatically select the default translation based on language\n      if (newSelectedItems.isEmpty) {\n        final settingsPresenter = locate<SettingsPresenter>();\n        final String currentLanguage = settingsPresenter.getCurrentLanguage();\n\n        // Check if the language is Bangla by checking language code or display name\n        final bool isBangla = currentLanguage.toLowerCase().startsWith(LanguageType.bangla.code) ||\n            currentLanguage == '\u09ac\u09be\u0982\u09b2\u09be (Bangla)' ||\n            currentLanguage == '\u09ac\u09be\u0982\u09b2\u09be';\n\n        final String defaultTranslationFileName = isBangla ? 'bn_bayaan' : 'en_sahih';\n\n        debugPrint(\n            'After deletion, no translations selected. Setting default: $defaultTranslationFileName for language: $currentLanguage, isBangla=$isBangla');\n\n        // Find the default translation model\n        final TTDbFileModel? defaultTranslation = jsonData.trans.values\n            .expand((models) => models)\n            .firstWhereOrNull((model) => model.fileName == defaultTranslationFileName);\n\n        if (defaultTranslation != null) {\n          // Load and select the default translation\n          await loadTranslationByFileModel(defaultTranslation);\n        }\n      }\n\n      // Show success message\n      showMessage(message: \"Deleted successfully\");\n    } catch (e) {\n      logErrorStatic(\"Error deleting translation: $e\", \"TranslationPresenter\");\n      showMessage(message: \"Failed to delete\");\n    }\n  }\n\n  void _updateAvailableAndDownloadableItems(Set<String> availableTranslationsSet) {\n    final List<TTDbFileModel> downloadedModels = uiState.value.jsonData.trans.values\n        .expand((models) => models)\n        .where((model) => availableTranslationsSet.contains(model.fileName))\n        .toList();\n\n    final List<MapEntry<String, List<TTDbFileModel>>> downloadableItems =\n        _getDownloadableTranslations(uiState.value.jsonData.trans, downloadedModels);\n\n    // Update both the filtered and original lists\n    uiState.value = uiState.value.copyWith(\n      availableItems: downloadedModels,\n      allAvailableItems: downloadedModels, // Original list\n      downloadableItems: downloadableItems,\n      allDownloadableItems: downloadableItems, // Original list\n      isLoading: false,\n    );\n  }\n\n  List<MapEntry<String, List<TTDbFileModel>>> _getDownloadableTranslations(\n      Map<String, List<TTDbFileModel>> allTranslations, List<TTDbFileModel> downloadedModels) {\n    final List<TTDbFileModel> allItems = allTranslations.values.expand((models) => models).toList();\n    final Set<String> downloadedFileNames = downloadedModels.map((item) => item.fileName).toSet();\n    final List<TTDbFileModel> downloadableItems =\n        allItems.where((model) => !downloadedFileNames.contains(model.fileName)).toList();\n\n    return allTranslations.entries\n        .map((entry) => MapEntry(entry.key, entry.value.where((model) => downloadableItems.contains(model)).toList()))\n        .toList();\n  }\n\n  bool isFileDownloading(String fileId) {\n    return currentUiState.isDownloading && currentUiState.activeDownloadId == fileId;\n  }\n\n  bool isTranslationSelected(TTDbFileModel file) {\n    return currentUiState.selectedItems.contains(file);\n  }\n\n  /// Initiates download for a single translation or all translations by language.\n  ///\n  /// - If a [file] is provided, downloads that specific translation.\n  /// - If a [languageKey] is provided, downloads all translations for that language.\n  Future<void> initiateDownload({TTDbFileModel? file, String? languageKey, required BuildContext context}) async {\n    if (currentUiState.isDownloading) {\n      if (file != null && currentUiState.activeDownloadId == file.fileName) {\n        cancelDownload();\n        return addUserMessage(context.l10n.downloadCancelled);\n      } else {\n        return addUserMessage(context.l10n.downloadInProgress);\n      }\n    } else if (file != null) {\n      return _downloadAndLoadTranslation(file, context);\n    } else if (languageKey != null) {\n      return _downloadTranslationsByLanguage(languageKey, context);\n    } else {\n      logErrorStatic(\"initiateDownload called without required parameters\", \"TranslationPresenter\");\n    }\n  }\n\n  Future<void> _downloadAndLoadTranslation(TTDbFileModel file, BuildContext context) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet && context.mounted) {\n      showMessage(message: context.l10n.noInternetConnection);\n      return;\n    }\n\n    try {\n      uiState.value = uiState.value.copyWith(\n        isDownloading: true,\n        activeDownloadId: file.fileName,\n      );\n\n      final connectivitySubscription = await monitorNetworkConnectivity(\n        context,\n        onConnectionLost: () {\n          addUserMessage(context.l10n.noInternetConnection);\n        },\n        onConnectionRestored: () {\n          addUserMessage(context.l10n.internetConnectionRestored);\n        },\n      );\n\n      final String dbPath = await getDatabaseFilePath(file.fileName);\n      final File dbFile = File(dbPath);\n\n      await _getNonDefaultTranslationUseCase\n          .execute(\n              file: file,\n              cancelToken: _addCancelToken(file),\n              onProgress: (percentage) {\n                uiState.value = uiState.value.copyWith(downloadProgress: percentage);\n              })\n          .whenComplete(() async {\n        await connectivitySubscription.cancel();\n        if (!_cancelTokens[file.fileName]!.isCancelled) {\n          final bool isValid = await validateDownloadedFile(\n            file: dbFile,\n            fileName: file.fileName,\n            expectedSizeMB: file.size,\n            context: context,\n            onError: (message) => showMessage(message: message),\n          );\n\n          if (isValid) {\n            await addTranslationToAvailableList(file.fileName);\n            // Decrement the available items count\n            uiState.value = uiState.value\n                .copyWith(totalAvailableToDownloadItemsCount: uiState.value.totalAvailableToDownloadItemsCount - 1);\n            // Save the updated count\n            await _saveAvailableItemsCountUseCase.execute(uiState.value.totalAvailableToDownloadItemsCount);\n            // Call the update method to ensure the UI state is refreshed\n            final List<String> currentAvailableTranslations = await _getDownloadedTranslationsUseCase.execute();\n            _updateAvailableAndDownloadableItems(currentAvailableTranslations.toSet());\n\n            // Show success message\n            showMessage(message: context.l10n.downloadedSuccess);\n          }\n        }\n      });\n    } catch (e) {\n      logErrorStatic(\"Error loading translation: $e\", \"TranslationPresenter\");\n      showMessage(message: \"Failed to download\");\n    } finally {\n      uiState.value = uiState.value.copyWith(isDownloading: false, activeDownloadId: null, downloadProgress: 0);\n    }\n  }\n\n  Future<void> _downloadTranslationsByLanguage(String languageKey, BuildContext context) async {\n    List<TTDbFileModel> modelsToDownload = currentUiState.jsonData.trans[languageKey] ?? [];\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet && context.mounted) {\n      showMessage(message: context.l10n.noInternetConnection);\n      return;\n    }\n\n    uiState.value = uiState.value.copyWith(isAllFilesDownloading: true);\n    for (var model in modelsToDownload) {\n      if (!isAlreadyDownloaded(model) && context.mounted) {\n        await _downloadAndLoadTranslation(model, context);\n      }\n    }\n    uiState.value = uiState.value.copyWith(isAllFilesDownloading: false);\n  }\n\n  String getTranslationText(String fileName, int surahID, int ayahIndex, BuildContext context) {\n    return CacheData.translationList[fileName]?[surahID]?[ayahIndex] ?? context.l10n.translationNotAvailable;\n  }\n\n  TextSpan getTranslationTextSpan({\n    required String fileName,\n    required int surahID,\n    required int ayahIndex,\n    required BuildContext context,\n  }) {\n    final String translationText =\n        CacheData.translationList[fileName]?[surahID]?[ayahIndex] ?? context.l10n.translationNotAvailable;\n    return TextSpan(text: translationText);\n  }\n\n  bool isSelected(TTDbFileModel file) {\n    return currentUiState.selectedItems.contains(file);\n  }\n\n  // Method to get translations not yet downloaded for a given language\n  List<TTDbFileModel> getUndownloadedTranslationsForLanguage(String languageKey) {\n    // Assuming `jsonData` contains all available translations\n    // and `currentUiState` knows about all downloaded ones\n    List<TTDbFileModel> allTranslationsForLanguage = currentUiState.jsonData.trans[languageKey] ?? [];\n    return allTranslationsForLanguage.where((model) => !isAlreadyDownloaded(model)).toList();\n  }\n\n  Future<void> toggleSelection({required TTDbFileModel file, int? surahID, required BuildContext context}) async {\n    // Toggle selection status\n    bool isSelected = currentUiState.selectedItems.contains(file);\n    List<TTDbFileModel> updatedList = List<TTDbFileModel>.from(currentUiState.selectedItems);\n\n    if (isSelected) {\n      updatedList.remove(file);\n      CacheData.translationList.remove(file.fileName);\n    } else if (updatedList.length < 5) {\n      updatedList.add(file);\n      await handleTranslationSelection(file);\n    } else {\n      addUserMessage(context.l10n.selectUpTo5Translation);\n      return;\n    }\n\n    // Update UI state\n    uiState.value = uiState.value.copyWith(selectedItems: updatedList);\n    await updateSelectedTranslationsCache(); // Update the cache with the new selection\n  }\n\n  Future<void> handleTranslationSelection(TTDbFileModel file) async {\n    // Process translation selection based on whether it's a default translation\n    final bool isDefaultTranslation = ['bn_bayaan', 'en_sahih'].contains(file.fileName);\n    if (isDefaultTranslation) {\n      await _getDefaultTranslationUseCase.execute(file);\n    } else {\n      await _selectTranslation(file: file); // Use your existing repository method\n    }\n  }\n\n  Future<void> _selectTranslation({required TTDbFileModel file}) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    final Either<String, void> result = await _selectTranslationUseCase.execute(file: file);\n    result.fold(\n      (failure) => uiState.value = uiState.value.copyWith(userMessage: failure),\n      (_) => uiState.value = uiState.value.copyWith(userMessage: context.l10n.selectedSuccessfully),\n    );\n  }\n\n  Future<void> addTranslationToAvailableList(String newItem) async {\n    final List<String> currentAvailableTranslations = await _getDownloadedTranslationsUseCase.execute();\n    final Set<String> availableTranslationsSet = currentAvailableTranslations.toSet()..add(newItem);\n    await _saveAvailableTranslationItemsUseCase.execute(\n        availableTranslations: availableTranslationsSet, newItem: newItem);\n    _updateAvailableAndDownloadableItems(availableTranslationsSet);\n  }\n\n  Future<void> removeTranslationFromAvailableList(TTDbFileModel file) async {\n    final List<String> currentAvailableTranslations = await _getDownloadedTranslationsUseCase.execute();\n\n    final Set<String> availableTranslationsSet = currentAvailableTranslations.toSet()..remove(file.fileName);\n\n    await _deleteAvailableTranslationUseCase.execute(file: file);\n    _updateAvailableAndDownloadableItems(availableTranslationsSet);\n  }\n\n  bool isDefaultTranslation(String fileName) {\n    return !['bn_bayaan', 'en_sahih'].contains(fileName);\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async => showMessage(message: message);\n  @override\n  Future<void> toggleLoading({required bool loading}) async =>\n      uiState.value = uiState.value.copyWith(isLoading: loading);\n\n  String getTranslationNameByFileName({required String fileName}) {\n    return jsonData.trans.values.expand((models) => models).firstWhere((model) => model.fileName == fileName).name;\n  }\n\n  // Track currently loading translations to prevent duplicate loads\n  final Set<String> _currentlyLoadingTranslations = {};\n\n  Future<void> setSelectedTranslations(List<String> fileNames) async {\n    debugPrint(\n        'Setting selected translations from: ${currentUiState.selectedItems.map((e) => e.fileName).join(\", \")} to: ${fileNames.join(\", \")}');\n\n    // Clear translations in cache that won't be in the new selection\n    final Set<String> currentSelectedFileNames = currentUiState.selectedItems.map((e) => e.fileName).toSet();\n    final Set<String> newSelectedFileNames = fileNames.toSet();\n\n    // Remove translations from cache that are no longer selected\n    for (String fileName in currentSelectedFileNames) {\n      if (!newSelectedFileNames.contains(fileName)) {\n        debugPrint('Removing translation from cache: $fileName');\n        CacheData.translationList.remove(fileName);\n      }\n    }\n\n    List<TTDbFileModel> selectedItems = [];\n\n    for (String fileName in fileNames) {\n      TTDbFileModel? fileModel =\n          jsonData.trans.values.expand((models) => models).firstWhereOrNull((model) => model.fileName == fileName);\n\n      if (fileModel != null) {\n        selectedItems.add(fileModel);\n        if (!CacheData.translationList.containsKey(fileName)) {\n          await _loadTranslation(fileModel);\n        }\n      }\n    }\n\n    uiState.value = uiState.value.copyWith(selectedItems: selectedItems);\n    await _saveSelectedTranslationsUseCase.execute(fileNames.toSet());\n    await updateSelectedTranslationsCache();\n    debugPrint('Selected translations explicitly set to: ${fileNames.join(\", \")}');\n  }\n\n  Future<void> loadTranslationByFileModel(TTDbFileModel fileModel) async {\n    _currentlyLoadingTranslations.add(fileModel.fileName);\n\n    try {\n      debugPrint('Loading translation file model: ${fileModel.fileName} (${fileModel.language})');\n\n      // First clear any existing translation with the same language\n      var updatedList = List<TTDbFileModel>.from(currentUiState.selectedItems);\n\n      // If the file is already in the list, no need to reload it\n      if (updatedList.any((item) => item.fileName == fileModel.fileName)) {\n        debugPrint('Translation ${fileModel.fileName} is already in selected list, skipping load');\n        return;\n      }\n\n      // Remove any existing translation for the same language\n      updatedList.removeWhere((item) => item.language == fileModel.language);\n\n      if (['bn_bayaan', 'en_sahih'].contains(fileModel.fileName)) {\n        // Handle default translation\n        debugPrint('Loading default translation: ${fileModel.fileName}');\n        await _getDefaultTranslationUseCase.execute(fileModel);\n        updatedList.add(fileModel);\n        await _saveSelectedTranslationsUseCase.execute({fileModel.fileName});\n      } else {\n        // For non-default translations, ensure it's downloaded first\n        if (!isAlreadyDownloaded(fileModel)) {\n          // Show loading state\n          uiState.value =\n              uiState.value.copyWith(isDownloading: true, activeDownloadId: fileModel.fileName, downloadProgress: 0);\n\n          try {\n            // Download the translation\n            await _getNonDefaultTranslationUseCase.execute(\n                file: fileModel,\n                cancelToken: _addCancelToken(fileModel),\n                onProgress: (percentage) {\n                  uiState.value = uiState.value.copyWith(downloadProgress: percentage);\n                });\n\n            // Add to available translations after successful download\n            await addTranslationToAvailableList(fileModel.fileName);\n          } finally {\n            uiState.value = uiState.value.copyWith(isDownloading: false, activeDownloadId: null, downloadProgress: 0);\n          }\n        }\n\n        // Now load the translation\n        await _getNonDefaultTranslationUseCase.execute(\n          file: fileModel,\n          cancelToken: _addCancelToken(fileModel),\n        );\n        updatedList.add(fileModel);\n        await _saveSelectedTranslationsUseCase.execute(\n          updatedList.map((e) => e.fileName).toSet(),\n        );\n      }\n\n      uiState.value = uiState.value.copyWith(selectedItems: updatedList);\n      debugPrint(\n          'Translation loaded successfully: ${fileModel.fileName}, Selected items: ${updatedList.map((e) => e.fileName).join(', ')}');\n    } catch (e) {\n      logErrorStatic(\"Error loading translation: $e\", \"TranslationPresenter\");\n      showMessage(message: \"Failed to load translation. Please try again.\");\n    } finally {\n      // Always remove from currently loading set, even if there's an error\n      _currentlyLoadingTranslations.remove(fileModel.fileName);\n    }\n  }\n\n  Future<void> clearSelectedTranslations() async {\n    // Clear the selected items\n    uiState.value = uiState.value.copyWith(selectedItems: []);\n\n    // Clear the cache\n    CacheData.translationList.clear();\n\n    // Update the cache in storage\n    await updateSelectedTranslationsCache();\n  }\n}"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "services", "file_path": "presentation/notification/services/notification_service_utilities.dart", "file_name": "notification_service_utilities.dart", "line": 20, "line_from": 20, "line_to": 50, "snippet": "      await Future<void>.delayed(manualDelayDuration, run);\n    });\n  }\n\n  static Duration _determineManualDelayDuration(int addedDayCount) =>\n      addedDayCount == 0 ? 3.inSeconds : Duration(seconds: Random().nextInt(3) + addedDayCount);\n\n  static int get notificationScheduleDayCount => Random(DateTime.now().millisecondsSinceEpoch).nextInt(65) + 31;\n\n  static NotificationContent buildNotificationContent({\n    required int notificationId,\n    required String channelKey,\n    required Map<String, String?> payload,\n  }) {\n    final String notificationTitle = payload[\"title\"] ?? \"\";\n    final String notificationBody = payload[\"body\"] ?? \"\";\n    final bool invalidNotification = notificationTitle.isEmpty || notificationBody.isEmpty;\n    if (invalidNotification) throw InvalidNotificationException();\n\n    return NotificationContent(\n      id: notificationId,\n      channelKey: channelKey,\n      title: notificationTitle,\n      body: notificationBody,\n      category: NotificationCategory.Recommendation,\n      backgroundColor: QuranColor.primaryColorLight,\n      notificationLayout: NotificationLayout.BigText,\n      payload: payload,\n      \n    );\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/daily_ayah/presenter/daily_ayah_presenter.dart", "file_name": "daily_ayah_presenter.dart", "line": 91, "line_from": 91, "line_to": 99, "snippet": "    return Future<void>.delayed(const Duration(milliseconds: 120), () {\n      uiState.value = currentUiState.copyWith(errorMessage: \"\");\n    });\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/last_read/presenter/last_read_presenter.dart", "file_name": "last_read_presenter.dart", "line": 87, "line_from": 87, "line_to": 115, "snippet": "    await Future<void>.delayed(1.inSeconds);\n    await getLastReadList();\n  }\n\n  Future<void> deleteSelectedLastReads(BuildContext context) async {\n    if (currentUiState.isSelected.isEmpty) {\n      addUserMessage(context.l10n.selectAnItem);\n      return;\n    }\n    await RemoveDialog.show(\n      onRemove: () async {\n        final List<int> selectedItem =\n            Set<int>.from(currentUiState.isSelected).toList();\n        final List<LastReadEntity> result =\n            await _deleteLastReadUseCase.execute(deletedItem: selectedItem);\n\n        uiState.value = uiState.value.copyWith(\n          isSelected: {},\n          lastReadList: result,\n          checkBox: result.isNotEmpty,\n        );\n        if (context.mounted && result.isEmpty) {\n          context.navigatorPop();\n        }\n      },\n      context: context,\n      title: context.l10n.lastRead,\n    );\n  }"}, {"structure_type": "function", "name": "Future.microtask", "docstring": "", "module": "presenter", "file_path": "presentation/search/presenter/search_presenter.dart", "file_name": "search_presenter.dart", "line": 576, "line_from": 576, "line_to": 592, "snippet": "    final Widget resultPage = await Future.microtask(\n      () => SearchResultPage(\n        query: currentUiState.searchQuery,\n        searchPresenter: this,\n      ),\n    );\n    Get.to(() => resultPage);\n  }\n\n  void clearSearchAndError() {\n    uiState.value = currentUiState.copyWith(\n      userMessage: null,\n      showSearchFieldError: false,\n      showDatabaseError: false,\n    );\n    queryController.clear();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "common", "file_path": "presentation/common/custom_bottom_sheet_container.dart", "file_name": "custom_bottom_sheet_container.dart", "line": 29, "line_from": 29, "line_to": 114, "snippet": "  Widget build(BuildContext context) {\n    return CustomStatusBarColor(\n      statusBarColor: statusBarColor ?? Colors.transparent,\n      navigationBarColor: context.color.backgroundColor,\n      statusBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      navigationBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      child: Container(\n        width: double.infinity,\n        constraints: constraints,\n        decoration: decorateBottomSheet(context),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            if (bottomSheetTitle != null) ...[\n              BottomSheetHeader(\n                title: bottomSheetTitle!,\n                theme: theme,\n              ),\n              gapH5,\n            ],\n            Padding(\n              padding: showPadding\n                  ? EdgeInsets.only(\n                      bottom: twentyPx,\n                      left: twentyPx,\n                      right: twentyPx,\n                    )\n                  : EdgeInsets.zero,\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  showPadding ? const SizedBox.shrink() : gapH10,\n                  ...children,\n                  gapH10,\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass BottomSheetHeader extends StatelessWidget {\n  BottomSheetHeader({\n    super.key,\n    required this.title,\n    required this.theme,\n  });\n\n  final String title;\n  final ThemeData theme;\n  late final SettingsPresenter settingsPresenter = locate<SettingsPresenter>();\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      width: double.infinity,\n      decoration: BoxDecoration(\n        color: context.color.inputColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n      child: Padding(\n        padding: EdgeInsets.symmetric(\n          vertical: seventeenPx,\n          horizontal: twentyPx,\n        ),\n        child: Text(\n          title,\n          overflow: TextOverflow.ellipsis,\n          maxLines: 1,\n          style: theme.textTheme.headlineSmall?.copyWith(\n              color: context.color.primaryColor,\n              fontFamily: settingsPresenter.getAppFontFamily()),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "widgets", "file_path": "presentation/common/widgets/custom_fade_scrollbar.dart", "file_name": "custom_fade_scrollbar.dart", "line": 6, "line_from": 6, "line_to": 136, "snippet": "  final Widget child;\n  final Color? scrollbarColor;\n  final double scrollbarWidth;\n  final double scrollbarRadius;\n  final Duration fadeOutDuration;\n  final Duration fadeInDuration;\n  final Duration idleDuration;\n\n  const CustomFadeScrollbar({\n    super.key,\n    required this.child,\n    this.scrollbarColor,\n    this.scrollbarWidth = 8.0,\n    this.scrollbarRadius = 4.0,\n    this.fadeOutDuration = const Duration(milliseconds: 300),\n    this.fadeInDuration = const Duration(milliseconds: 150),\n    this.idleDuration = const Duration(milliseconds: 600),\n  });\n\n  @override\n  State<CustomFadeScrollbar> createState() => _CustomFadeScrollbarState();\n}\n\nclass _CustomFadeScrollbarState extends State<CustomFadeScrollbar> with SingleTickerProviderStateMixin {\n  late AnimationController _fadeController;\n  late Animation<double> _fadeAnimation;\n  Timer? _fadeoutTimer;\n  ScrollController? _scrollController;\n  bool _isDragging = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _fadeController = AnimationController(\n      vsync: this,\n      duration: widget.fadeOutDuration,\n    );\n    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(\n        parent: _fadeController,\n        curve: Curves.easeInOut,\n      ),\n    );\n\n    // Start with scrollbar hidden\n    _fadeController.reverse();\n  }\n\n  @override\n  void dispose() {\n    _fadeoutTimer?.cancel();\n    _fadeController.dispose();\n    _scrollController?.dispose();\n    super.dispose();\n  }\n\n  bool _handleScrollNotification(ScrollNotification notification) {\n    final ScrollMetrics metrics = notification.metrics;\n    if (metrics.maxScrollExtent <= metrics.minScrollExtent) {\n      return false;\n    }\n\n    if (notification is ScrollStartNotification || notification is ScrollUpdateNotification) {\n      _showScrollbar();\n    } else if (notification is ScrollEndNotification) {\n      _hideScrollbarAfterIdle();\n    }\n    return false;\n  }\n\n  void _showScrollbar() {\n    _fadeoutTimer?.cancel();\n    _fadeController.duration = widget.fadeInDuration;\n    _fadeController.forward();\n  }\n\n  void _hideScrollbarAfterIdle() {\n    _fadeoutTimer?.cancel();\n    _fadeoutTimer = Timer(widget.idleDuration, () {\n      if (mounted && !_isDragging) {\n        _fadeController.duration = widget.fadeOutDuration;\n        _fadeController.reverse();\n      }\n    });\n  }\n\n  void _onPointerDown(PointerDownEvent event) {\n    _isDragging = true;\n    _showScrollbar();\n  }\n\n  void _onPointerUp(PointerUpEvent event) {\n    _isDragging = false;\n    _hideScrollbarAfterIdle();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return NotificationListener<ScrollNotification>(\n      onNotification: _handleScrollNotification,\n      child: Stack(\n        children: [\n          widget.child,\n          Positioned.fill(\n            child: IgnorePointer(\n              ignoring: false,\n              child: Listener(\n                onPointerDown: _onPointerDown,\n                onPointerUp: _onPointerUp,\n                child: FadeTransition(\n                  opacity: _fadeAnimation,\n                  child: Container(\n                    alignment: Alignment.centerRight,\n                    child: Container(\n                      width: widget.scrollbarWidth,\n                      margin: const EdgeInsets.only(right: 2.0),\n                      decoration: BoxDecoration(\n                        color: widget.scrollbarColor ?? Theme.of(context).colorScheme.onSurface.withOpacityInt(0.4),\n                        borderRadius: BorderRadius.circular(widget.scrollbarRadius),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "class", "name": "AudioPresenter extends BasePresenter<AudioUIState>", "docstring": "", "module": "audio", "file_path": "presentation/audio/audio_presenter.dart", "file_name": "audio_presenter.dart", "line": 38, "line_from": 38, "line_to": 1585, "snippet": "class AudioPresenter extends BasePresenter<AudioUIState> {\n  final IsSurahAudioAvailableUseCase _isSurahAudioAvailableUseCase;\n  final PlayVerseWithDelayUseCase _playVerseWithDelayUseCase;\n  final DownloadAndSaveAudioLocationUseCase _downloadAndSaveAudioLocationUseCase;\n  final PlaySurahAudioUseCase _playSurahAudioUseCase;\n  final GetAudioPathUseCase _getAudioPathUseCase;\n  final AddToPlaylistUseCase _addToPlaylistUseCase;\n  final FetchAudioFilesAndVerseTimingsUseCase _fetchAudioFilesAndVerseTimingsUseCase;\n  final SeekAudioUseCase _seekAudioUseCase;\n  final ClearPlaylistUseCase _clearPlaylistUseCase;\n  final CreateAudioFilePathUseCase _createAudioFilePathUseCase;\n  final StopAudioUseCase _stopAudioUseCase;\n  final PausePlaybackUseCase _pausePlaybackUseCase;\n  final ResumePlaybackUseCase _resumePlaybackUseCase;\n  late final ReciterPresenter reciterPresenter = locate<ReciterPresenter>();\n  final TextEditingController surahNameSearchController = TextEditingController();\n  final TextEditingController ayahNumberSearchController = TextEditingController();\n  StreamSubscription<int>? _pageChangeSubscription;\n\n  // Action stream for UI interactions\n  final StreamController<AudioAction> _actionStreamController = StreamController<AudioAction>.broadcast();\n  Stream<AudioAction> get actionStream => _actionStreamController.stream;\n\n  // Internal tracking of current page index\n  int? _currentPageIndex;\n\n  // Add debounce timer at class level\n  Timer? _debounceTimer;\n\n  AudioPresenter(\n    this._isSurahAudioAvailableUseCase,\n    this._downloadAndSaveAudioLocationUseCase,\n    this._playVerseWithDelayUseCase,\n    this._playSurahAudioUseCase,\n    this._getAudioPathUseCase,\n    this._addToPlaylistUseCase,\n    this._seekAudioUseCase,\n    this._clearPlaylistUseCase,\n    this._createAudioFilePathUseCase,\n    this._stopAudioUseCase,\n    this._pausePlaybackUseCase,\n    this._resumePlaybackUseCase,\n    this._fetchAudioFilesAndVerseTimingsUseCase,\n  );\n\n  final Obs<AudioUIState> uiState = Obs(AudioUIState.empty());\n  AudioUIState get currentUiState => uiState.value;\n\n  @override\n  Future<void> onInit() async {\n    await initializeData();\n    await initializeSearch();\n    super.onInit();\n  }\n\n  @override\n  void dispose() {\n    _debounceTimer?.cancel();\n    _pageChangeSubscription?.cancel();\n    _actionStreamController.close();\n    uiState.close();\n    AudioPlayerService.instance.dispose();\n    surahNameSearchController.removeListener(_onSurahSearchChanged);\n    ayahNumberSearchController.removeListener(_onAyahSearchChanged);\n    surahNameSearchController.dispose();\n    ayahNumberSearchController.dispose();\n    super.dispose();\n  }\n\n  Future<void> initializeData() async {\n    initializeAudioListeners();\n    initializePositionListener();\n  }\n\n  Future<void> selectSurahOrAyah(int id, SelectionType type, {bool isSurah = true}) async {\n    final String? surahName = isSurah ? CacheData.surahsCache[id].nameEn : null;\n\n    if (type == SelectionType.end && !isValidEndSurahAyahSelection(id, isSurah)) {\n      addUserMessage(\"End Ayah must be after Start Ayah.\");\n      return;\n    }\n    updateUIStateForSurahAyahSelection(id, type, isSurah, surahName);\n  }\n\n  // Helper method to safely reset audio player state without triggering playback\n  Future<void> safelyResetAudioPlayerState() async {\n    try {\n      // First stop any current playback\n      if (currentUiState.isPlaying) {\n        await _stopAudioUseCase.execute();\n      }\n\n      // Give time for the player to fully stop\n      await Future.delayed(const Duration(milliseconds: 500));\n\n      // Reset UI state without reinitializing the audio player\n      uiState.value = uiState.value.copyWith(\n        isPlaying: false,\n        isPaused: true,\n        isLoading: false,\n        currentPlayTime: Duration.zero,\n        currentlyPlayingSurahIndex: null,\n        currentlyPlayingAyahIndex: null,\n        lastProcessedAyahIndex: null,\n        isSingleAyahPlayback: false,\n        currentSurahIdsInPlaylist: [],\n      );\n    } catch (e) {\n      addUserMessage(\"Error resetting audio state. Please try again.\");\n      uiState.value = uiState.value.copyWith(isLoading: false);\n    }\n  }\n\n  void onAudioPlayOnlineStream({bool isFromMemorization = false}) async {\n    try {\n      final BuildContext context = QuranMajeed.globalContext;\n      final bool hasInternet = await checkInternetConnection();\n\n      // Toggle online streaming state\n      final bool newStreamingState = !(currentUiState.isOnlinePlayingStream ?? false);\n      uiState.value = currentUiState.copyWith(isOnlinePlayingStream: newStreamingState);\n\n      if (newStreamingState && !hasInternet) {\n        //\n      } else {\n        showMessage(\n            message: newStreamingState ? context.l10n.usingOnlineStreaming : context.l10n.usingDownloadedAudioFiles);\n      }\n\n      await safelyResetAudioPlayerState();\n      showMessage(message: context.l10n.pressPlayStartAudNewSet);\n    } catch (e) {\n      addUserMessage(\"An error occurred while changing streaming mode.\");\n      uiState.value = uiState.value.copyWith(isLoading: false);\n    }\n  }\n\n  void updateUIStateForSurahAyahSelection(int id, SelectionType type, bool isSurah, String? surahName) {\n    if (type == SelectionType.start) {\n      if (isSurah) {\n        uiState.value = currentUiState.copyWith(\n          selectedSurahIndex: id,\n          ayahNumbers: CacheData.surahsCache[id].totalAyah,\n          filteredAyahs: List<int>.generate(CacheData.surahsCache[id].totalAyah, (index) => index + 1),\n          selectedStartSurahId: id + 1,\n          selectedEndSurahId: id + 1,\n          selectedEndAyahId: CacheData.surahsCache[id].totalAyah,\n          selectedStartSurahName: surahName,\n          selectedEndSurahName: surahName,\n        );\n      } else {\n        uiState.value = currentUiState.copyWith(\n          selectedStartAyahId: id + 1,\n          selectedSurahIndex: currentUiState.selectedSurahIndex,\n          selectedAyahIndex: id,\n        );\n      }\n    } else {\n      if (isSurah) {\n        uiState.value = currentUiState.copyWith(\n          selectedEndSurahId: id + 1,\n          ayahNumbers: CacheData.surahsCache[id].totalAyah,\n          filteredAyahs: List<int>.generate(CacheData.surahsCache[id].totalAyah, (index) => index + 1),\n          selectedSurahIndex: id,\n          selectedEndSurahName: surahName,\n          selectedEndAyahId: CacheData.surahsCache[id].totalAyah,\n        );\n      } else {\n        uiState.value = currentUiState.copyWith(\n          selectedEndAyahId: id + 1,\n          selectedSurahIndex: currentUiState.selectedSurahIndex,\n          selectedAyahIndex: id,\n        );\n      }\n    }\n  }\n\n  Future<void> initializeSearch() async {\n    while (CacheData.surahsCache.isEmpty) {\n      await Future.delayed(const Duration(milliseconds: 100));\n    }\n\n    surahNameSearchController.addListener(_onSurahSearchChanged);\n    ayahNumberSearchController.addListener(_onAyahSearchChanged);\n\n    uiState.value = uiState.value.copyWith(\n      filteredSurahs: List.from(CacheData.surahsCache),\n      filteredAyahs: List<int>.generate(uiState.value.ayahNumbers!, (index) => index + 1),\n    );\n  }\n\n  void onSurahSearchChanged(String query) {\n    surahNameSearchController.text = query;\n  }\n\n  void onAyahSearchChanged(String query) {\n    ayahNumberSearchController.text = query;\n  }\n\n  void _onSurahSearchChanged() {\n    Debounce.debounce('surah_search', const Duration(milliseconds: 300), () {\n      final query = surahNameSearchController.text.trim().toLowerCase();\n      if (query.isEmpty) {\n        uiState.value = uiState.value.copyWith(\n          surahSearchQuery: '',\n          filteredSurahs: List.from(CacheData.surahsCache),\n        );\n      } else {\n        final filtered = CacheData.surahsCache.where((surah) {\n          return surah.nameEn.toLowerCase().contains(query) ||\n              surah.nameBn.toLowerCase().contains(query) ||\n              surah.name.toLowerCase().contains(query);\n        }).toList();\n        uiState.value = uiState.value.copyWith(\n          surahSearchQuery: query,\n          filteredSurahs: filtered,\n        );\n      }\n    });\n  }\n\n  void _onAyahSearchChanged() {\n    Debounce.debounce('ayah_search', const Duration(milliseconds: 300), () {\n      final query = ayahNumberSearchController.text.trim();\n\n      if (query.isEmpty) {\n        uiState.value = uiState.value.copyWith(\n          ayahSearchQuery: '',\n          filteredAyahs: List<int>.generate(\n            uiState.value.ayahNumbers!,\n            (index) => index + 1,\n          ),\n        );\n      } else {\n        final filtered = List<int>.generate(\n          uiState.value.ayahNumbers!,\n          (index) => index + 1,\n        ).where((ayah) => ayah.toString().contains(query)).toList();\n\n        uiState.value = uiState.value.copyWith(\n          ayahSearchQuery: query,\n          filteredAyahs: filtered,\n        );\n      }\n    });\n  }\n\n  bool isValidEndSurahAyahSelection(int id, bool isSurah) {\n    if (isSurah) {\n      return id >= (currentUiState.selectedStartSurahId ?? 1) - 1;\n    } else {\n      if (currentUiState.selectedEndSurahId == currentUiState.selectedStartSurahId) {\n        return id >= (currentUiState.selectedStartAyahId ?? 1) - 1;\n      }\n      return true;\n    }\n  }\n\n  void onSelectSurah(int surahIndex) {\n    if (currentUiState.selectedStartSurahId != surahIndex) {\n      uiState.value = currentUiState.copyWith(\n          selectedStartAyahId: 1,\n          filteredAyahs: List<int>.generate(CacheData.surahsCache[surahIndex].totalAyah, (index) => index + 1));\n    }\n  }\n\n  void updateAyahRepeatNumber(int ayahRepeatNumber) {\n    uiState.value = uiState.value.copyWith(\n      ayahRepeatNumber: ayahRepeatNumber,\n    );\n  }\n\n  void updateAyahDelayNumber(int ayahDelayNumber) {\n    uiState.value = uiState.value.copyWith(ayahDelayNumber: ayahDelayNumber);\n  }\n\n  Future<void> handleSeek(double seekPercent) async {\n    if (seekPercent < 0 || seekPercent > 1 || currentUiState.totalDuration == null) {\n      return;\n    }\n\n    uiState.value = uiState.value.copyWith(seekingBarTapped: true);\n\n    final Duration seekToDuration = Duration(\n      milliseconds: (currentUiState.totalDuration!.inMilliseconds * seekPercent).round(),\n    );\n\n    try {\n      await _seekAudioUseCase.execute(seekDuration: seekToDuration);\n      await _updateCurrentSurahAndAyahAfterSeek(seekToDuration);\n    } catch (e) {\n      uiState.value = uiState.value.copyWith(seekingBarTapped: false);\n    }\n  }\n\n  Future<void> _updateCurrentSurahAndAyahAfterSeek(Duration position) async {\n    if (position.inMilliseconds < 0) return;\n\n    final int currentMillis = position.inMilliseconds;\n    final int? currentIndex = AudioPlayerService.instance.currentIndex;\n    final List<int>? currentSurahIdsInPlaylist = currentUiState.currentSurahIdsInPlaylist;\n    final AudioFile? audioFileId = (currentSurahIdsInPlaylist != null && currentIndex != null)\n        ? CacheData.audioFiles[currentSurahIdsInPlaylist[currentIndex]]\n        : null;\n\n    if (audioFileId != null && currentUiState.verseTimings != null) {\n      final List<VerseTiming> timings = currentUiState.verseTimings!;\n      if (timings.isEmpty) {\n        uiState.value = uiState.value.copyWith(seekingBarTapped: false);\n        return;\n      }\n\n      final VerseTiming currentVerse = timings.lastWhereOrNull(\n            (vt) => vt.time <= currentMillis,\n          ) ??\n          timings.first;\n\n      final int ayahIndex = (currentVerse.ayah - 1).clamp(0, timings.length - 1);\n\n      uiState.value = uiState.value.copyWith(\n        currentlyPlayingSurahIndex: currentVerse.surahId,\n        currentlyPlayingAyahIndex: ayahIndex,\n        currentPlayTime: position,\n      );\n\n      if (ayahIndex >= 0) {\n        jumpToCurrentAyah(ayahIndex + 1);\n      }\n    }\n\n    uiState.value = uiState.value.copyWith(seekingBarTapped: false);\n  }\n\n  Future<void> onSelectSurahButtonClicked(\n      BuildContext context, String bottomSheetTitle, SelectionType selectionType) async {\n    uiState.value = uiState.value.copyWith(\n      selectedAyahIndex: selectionType == SelectionType.start\n          ? (currentUiState.selectedStartAyahId ?? 1) - 1\n          : (currentUiState.selectedEndAyahId ?? 1) - 1,\n    );\n\n    int? scrollToSurahIndex;\n\n    if (selectionType == SelectionType.end) {\n      scrollToSurahIndex = uiState.value.selectedStartSurahId! - 1;\n    }\n\n    await SelectSurahAyahBottomSheet.show(\n      context: context,\n      presenter: SurahAyahPresenter.audio(this),\n      bottomSheetTitle: bottomSheetTitle,\n      isDoneButtonEnabled: true,\n      isJumpToAyahBottomSheet: false,\n      onSurahSelected: (surahId) => selectSurahOrAyah(surahId, selectionType, isSurah: true),\n      onAyahSelected: (ayahId) => selectSurahOrAyah(ayahId, selectionType, isSurah: false),\n      onSubmit: () => context.navigatorPop<void>(),\n      selectedSurahIndex: scrollToSurahIndex ?? 0,\n      selectedAyahIndex: uiState.value.selectedAyahIndex,\n    );\n  }\n\n  void displayAudioPlayerUI() {\n    // Validate that surah and ayah selections are set\n    if (currentUiState.selectedStartSurahId == null ||\n        currentUiState.selectedEndSurahId == null ||\n        currentUiState.selectedStartAyahId == null ||\n        currentUiState.selectedEndAyahId == null) {\n      addUserMessage(\"Unable to play audio. Please try again.\");\n      return;\n    }\n\n    // Check if online streaming is enabled\n    final bool isOnlineStream = currentUiState.isOnlinePlayingStream ?? false;\n\n    // Immediately show the appropriate player UI based on online/offline mode\n    uiState.value = uiState.value.copyWith(\n      isLoading: true,\n      // Always show player controls immediately, regardless of streaming mode\n      showPlayerControls: true,\n      // Keep track of streaming mode for the UI to know which widget to display\n      isOnlinePlayingStream: isOnlineStream,\n    );\n\n    // Initialize the player without delay to start audio processing immediately\n    _initializeAndPlayAudio();\n  }\n\n  // Extracted method to handle audio initialization and playback\n  Future<void> _initializeAndPlayAudio() async {\n    try {\n      // First, ensure AudioPlayerService is properly initialized and reset\n      try {\n        await AudioPlayerService.reinitialize();\n\n        // Clear any existing playlist\n        await clearPlaylist();\n      } catch (e) {\n        // Continue even if reinitialization fails\n        addUserMessage(\"Warning: Audio player reset incomplete. Continuing anyway.\");\n      }\n\n      // Then prepare and play audio with explicit autoPlay flag\n      await onSurahSelected(\n        startSurah: currentUiState.selectedStartSurahId!,\n        endSurah: currentUiState.selectedEndSurahId!,\n        autoPlay: true, // Explicitly set autoPlay to true when user presses Play Audio\n      );\n    } catch (e) {\n      uiState.value = uiState.value.copyWith(\n        isLoading: false,\n        isPlaying: false,\n        showPlayerControls: false,\n      );\n      addUserMessage(\"Error initializing audio player. Please try again.\");\n    }\n  }\n\n  String getSelectedReciterName() => reciterPresenter.currentUiState.selectedReciter.name;\n\n  void updateSurahAndAyahSelection() {\n    // Get the current page index (surah index) and convert to 1-indexed surah ID\n    final int surahId = (_currentPageIndex ?? 0) + 1;\n\n    // Get the surah name from the cache\n    final String surahName = CacheData.surahsCache[surahId - 1].nameEn;\n\n    // Get the total number of ayahs in this surah\n    final int totalAyahs = CacheData.surahsCache[surahId - 1].totalAyah;\n\n    // First update the selection state through the helper method\n    updateUIStateForSurahAyahSelection(surahId - 1, SelectionType.start, true, surahName);\n\n    // Then explicitly set all the required fields to ensure both start and end surah\n    // are set to the current surah, with start ayah as 1 and end ayah as total ayahs\n    uiState.value = uiState.value.copyWith(\n      // Start surah information\n      selectedStartSurahName: surahName,\n      selectedStartSurahId: surahId,\n      selectedStartAyahId: 1,\n\n      // End surah information (same as start surah)\n      selectedEndSurahName: surahName,\n      selectedEndSurahId: surahId,\n      selectedEndAyahId: totalAyahs,\n\n      // Current selection indicators\n      selectedSurahIndex: surahId - 1,\n      selectedAyahIndex: 0,\n\n      // Set the ayah numbers for this surah\n      ayahNumbers: totalAyahs,\n      filteredAyahs: List<int>.generate(totalAyahs, (index) => index + 1),\n    );\n  }\n\n  Future<void> onClickAudioButton(BuildContext context, bool isFromAyahDetail) async {\n    // Make sure we have a valid current page index\n    if (_currentPageIndex == null) {\n      addUserMessage(\"Unable to determine current page. Please try again.\");\n      return;\n    }\n\n    // Update the surah and ayah selection based on current page\n    updateSurahAndAyahSelection();\n\n    // Show the audio play bottom sheet\n    await AudioPlayBottomSheet.show(\n      context: context,\n      isFromAyahDetail: isFromAyahDetail,\n    );\n  }\n\n  Future<void> resumePlayback() async {\n    await _resumePlaybackUseCase.execute();\n    uiState.value = uiState.value.copyWith(isPlaying: true, isPaused: false);\n  }\n\n  void initializeAudioListeners() {\n    AudioPlayerService.instance.durationStream.listen((duration) {\n      uiState.value = uiState.value.copyWith(totalDuration: duration);\n    }).onError((error, _) {\n      // Error handling\n    });\n\n    AudioPlayerService.instance.playerStateStream.listen((playbackState) {\n      // Check for completion condition\n      if (playbackState.processingState == ProcessingState.completed) {\n        // Audio playback has completed, close the player UI\n        uiState.value = uiState.value.copyWith(\n          isPlaying: false,\n          isLoading: false,\n          showPlayerControls: false,\n          currentlyPlayingSurahIndex: null,\n          currentlyPlayingAyahIndex: null,\n          currentPlayTime: Duration.zero,\n          lastProcessedAyahIndex: null,\n        );\n        return;\n      }\n\n      // Normal state update\n      uiState.value = uiState.value.copyWith(\n        isPlaying: playbackState.playing,\n        isLoading: playbackState.processingState == ProcessingState.buffering ||\n            playbackState.processingState == ProcessingState.loading,\n      );\n    }).onError((error, _) {\n      // Handle error in player state stream\n      addUserMessage(\"Error playing audio. Please try again.\");\n      uiState.value = uiState.value.copyWith(\n        isPlaying: false,\n        isLoading: false,\n        showPlayerControls: false,\n      );\n    });\n\n    listenToCurrentIndex();\n  }\n\n  void setPageChangeSubscription(Stream<int> pageIndexStream) {\n    _pageChangeSubscription?.cancel();\n    _pageChangeSubscription = pageIndexStream.distinct().listen((newPageIndex) {\n      _currentPageIndex = newPageIndex;\n      if (newPageIndex + 1 == currentUiState.currentlyPlayingSurahIndex) {\n        _scrollToCurrentAyah();\n      }\n    });\n  }\n\n  void emitBottomBarHeightAction(double height) {\n    _actionStreamController.add(AudioAction(\n      type: AudioActionType.setBottomBarHeight,\n      height: height,\n    ));\n  }\n\n  void listenToCurrentIndex() {\n    AudioPlayerService.instance.currentIndexStream.listen((currentIndex) {\n      if (currentIndex != null && currentUiState.isPlaying) {\n        scrollToPage(currentIndex: currentIndex);\n      }\n    });\n  }\n\n  void scrollToPage({int currentIndex = 0}) {\n    final List<int>? currentSurahIdsInPlaylist = currentUiState.currentSurahIdsInPlaylist;\n\n    if (currentSurahIdsInPlaylist != null && currentIndex < currentSurahIdsInPlaylist.length) {\n      final int surahId = currentSurahIdsInPlaylist[currentIndex];\n      final int pageIndex = surahId - 1;\n      _actionStreamController.add(AudioAction(\n        type: AudioActionType.jumpToPage,\n        pageIndex: pageIndex,\n      ));\n    }\n  }\n\n  void initializePositionListener() {\n    AudioPlayerService.instance.positionStream.listen((position) async {\n      uiState.value = uiState.value.copyWith(currentPlayTime: position);\n      if (currentUiState.isPlaying) {\n        await _updateCurrentSurahAndAyah(position);\n        await _stopPlayingWhenEndOfPlaylist(position);\n      }\n    });\n  }\n\n  Future<void> _stopPlayingWhenEndOfPlaylist(Duration position) async {\n    final List<VerseTiming>? verseTimings = currentUiState.verseTimings;\n    if (verseTimings == null || verseTimings.isEmpty) return;\n\n    // Handle single ayah playback mode\n    if (currentUiState.isSingleAyahPlayback) {\n      // Find the timing for the current ayah\n      final int ayahId = currentUiState.selectedEndAyahId!;\n      final int surahId = currentUiState.selectedEndSurahId!;\n\n      // Find the current ayah's timing\n      final VerseTiming? currentAyahTiming =\n          verseTimings.firstWhereOrNull((timing) => timing.surahId == surahId && timing.ayah == ayahId);\n\n      if (currentAyahTiming != null) {\n        // Find the next ayah's timing to determine when to stop\n        final VerseTiming? nextAyahTiming = verseTimings.firstWhereOrNull(\n            (timing) => (timing.surahId == surahId && timing.ayah > ayahId) || (timing.surahId > surahId));\n\n        final int endTime = nextAyahTiming?.time ?? currentUiState.totalDuration!.inMilliseconds;\n\n        // If we're at the end of this ayah (position is very close to the next ayah's start time or end of audio)\n        if (position.inMilliseconds >= endTime) {\n          // Stop the audio playback\n          await _stopAudioUseCase.execute();\n          uiState.value = uiState.value.copyWith(\n            currentlyPlayingSurahIndex: null,\n            currentlyPlayingAyahIndex: null,\n            currentPlayTime: Duration.zero,\n            isPlaying: false,\n            showPlayerControls: false,\n            lastProcessedAyahIndex: null,\n          );\n          return; // Exit early\n        }\n      }\n    }\n\n    // Original logic for full surah playback\n    final VerseTiming lastTiming = verseTimings.last;\n    final int lastTime = lastTiming.time;\n    if (currentUiState.specialCase &&\n        position.inMilliseconds >= lastTime &&\n        currentUiState.currentlyPlayingSurahIndex == currentUiState.selectedEndSurahId) {\n      await _stopAudioUseCase.execute();\n      uiState.value = uiState.value.copyWith(\n        currentlyPlayingSurahIndex: null,\n        currentlyPlayingAyahIndex: null,\n        currentPlayTime: Duration.zero,\n        isPlaying: false,\n        showPlayerControls: false,\n        lastProcessedAyahIndex: null,\n      );\n    } else if (currentUiState.currentlyPlayingSurahIndex == currentUiState.selectedEndSurahId &&\n        currentUiState.currentlyPlayingAyahIndex == currentUiState.selectedEndAyahId &&\n        !currentUiState.specialCase) {\n      if (position.inMilliseconds >= currentUiState.totalDuration!.inMilliseconds) {\n        await _stopAudioUseCase.execute();\n        uiState.value = uiState.value.copyWith(\n          currentlyPlayingSurahIndex: null,\n          currentlyPlayingAyahIndex: null,\n          currentPlayTime: Duration.zero,\n          isPlaying: false,\n          showPlayerControls: false,\n          lastProcessedAyahIndex: null,\n        );\n      }\n    }\n  }\n\n  Future<void> _scrollToCurrentAyah() async {\n    if (!currentUiState.seekingBarTapped && _currentPageIndex != null) {\n      final int pageIndex = _currentPageIndex!;\n      if (currentUiState.currentlyPlayingSurahIndex == pageIndex + 1) {\n        final int currentAyah = currentUiState.currentlyPlayingAyahIndex ?? (currentUiState.selectedStartAyahId ?? 1);\n        final int totalAyahs = CacheData.surahsCache[pageIndex].totalAyah; // Get total ayahs for the surah\n        final int ayahIndex = currentAyah - 1;\n\n        // Check if the current ayah is within bounds and not the last one\n        if (ayahIndex < totalAyahs - 1) {\n          // Only scroll if not at the last ayah\n          _actionStreamController.add(AudioAction(\n            type: AudioActionType.scrollToAyah,\n            pageIndex: pageIndex,\n            ayahIndex: ayahIndex,\n          ));\n        }\n      }\n    }\n  }\n\n  void jumpToCurrentAyah(int ayah) {\n    if (_currentPageIndex != null) {\n      _actionStreamController.add(AudioAction(\n        type: AudioActionType.jumpToAyah,\n        pageIndex: _currentPageIndex!,\n        ayahIndex: ayah - 1,\n      ));\n    }\n    uiState.value = uiState.value.copyWith(seekingBarTapped: false);\n  }\n\n  Future<void> _updateCurrentSurahAndAyah(Duration position) async {\n    final int currentMillis = position.inMilliseconds;\n    final int? currentIndex = AudioPlayerService.instance.currentIndex;\n    final List<int>? currentSurahIdsInPlaylist = currentUiState.currentSurahIdsInPlaylist;\n\n    if (currentSurahIdsInPlaylist == null || currentIndex == null) return;\n\n    final int currentSurahId = currentSurahIdsInPlaylist[currentIndex];\n    final List<VerseTiming> verseTimings =\n        currentUiState.verseTimings!.where((vt) => vt.surahId == currentSurahId).toList();\n\n    if (verseTimings.isEmpty) return;\n\n    // Use firstWhereOrNull to prevent \"No element\" error\n    final VerseTiming? currentAyahTiming = verseTimings.firstWhereOrNull(\n      (vt) => vt.ayah == currentUiState.currentlyPlayingAyahIndex,\n    );\n\n    if (currentAyahTiming == null) {\n      return;\n    }\n\n    if (currentMillis < currentAyahTiming.time) {\n      return;\n    }\n\n    final VerseTiming currentVerse = _findCurrentVerse(verseTimings, currentMillis);\n    final int surahId = currentVerse.surahId;\n    final int ayahNumber = currentVerse.ayah;\n    final VerseTiming? nextVerse = _findNextVerse(verseTimings, ayahNumber);\n    final int currentAyahEndTime = nextVerse?.time ?? currentUiState.totalDuration!.inMilliseconds;\n\n    // Increase tolerance for end detection\n    final bool isAtAyahEnd = currentMillis >= currentAyahEndTime - 150;\n\n    if (isAtAyahEnd) {\n      final bool isRepeating = await _handleAyahRepetition(verseTimings, ayahNumber);\n      if (!isRepeating) {\n        int newAyahIndex = ayahNumber + 1;\n        final int totalAyahs = CacheData.surahsCache[currentSurahId - 1].totalAyah;\n\n        // Ensure newAyahIndex is within bounds\n        if (newAyahIndex > totalAyahs) {\n          if (currentIndex < currentSurahIdsInPlaylist.length - 1) {\n            // Next surah will be handled by currentIndexStream\n            return;\n          } else {\n            // End of playlist; do not update ayah index beyond totalAyahs\n            newAyahIndex = ayahNumber;\n          }\n        }\n\n        uiState.value = uiState.value.copyWith(\n          repeatCount: 0,\n          currentlyPlayingAyahIndex: newAyahIndex,\n          isRepeating: false,\n        );\n        await _handleAyahDelay(surahId, newAyahIndex, position);\n        // Scroll to new ayah\n        await _scrollToCurrentAyah();\n      }\n    } else {\n      if (ayahNumber != currentUiState.currentlyPlayingAyahIndex) {\n        uiState.value = uiState.value.copyWith(\n          currentlyPlayingSurahIndex: surahId,\n          currentlyPlayingAyahIndex: ayahNumber,\n          currentPlayTime: position,\n        );\n        await _scrollToCurrentAyah();\n      } else {\n        uiState.value = uiState.value.copyWith(\n          currentPlayTime: position,\n        );\n      }\n    }\n  }\n\n  bool isEndOfCurrentAyah(int currentMillis, List<VerseTiming> verseTimings, int ayahIndex) {\n    final VerseTiming? currentAyahTiming = verseTimings.firstWhereOrNull((vt) => vt.ayah == ayahIndex);\n    if (currentAyahTiming == null) return false;\n\n    final VerseTiming? nextAyahTiming = verseTimings.firstWhereOrNull((vt) => vt.ayah == ayahIndex + 1);\n    final int endTimeOfCurrentAyah = nextAyahTiming?.time ?? currentUiState.totalDuration!.inMilliseconds;\n\n    return currentMillis >= endTimeOfCurrentAyah;\n  }\n\n  Duration getDurationOfAyah(List<VerseTiming> verseTimings, int ayahIndex) {\n    final VerseTiming ayah = verseTimings.firstWhere((element) => element.ayah == ayahIndex);\n    return Duration(milliseconds: ayah.time);\n  }\n\n  Future<void> loadVerseTimings({required int reciterId, required List<int> surahIds}) async {\n    List<VerseTiming> verseTimings =\n        surahIds.expand((surahId) => CacheData.verseTimings['$reciterId-$surahId'] ?? <VerseTiming>[]).toList();\n    final List<VerseTiming> filteredTimings = _filterAndAdjustVerseTimings(verseTimings);\n    uiState.value = uiState.value.copyWith(verseTimings: filteredTimings);\n  }\n\n  List<VerseTiming> _filterAndAdjustVerseTimings(List<VerseTiming> timings) {\n    if (timings.isEmpty) return [];\n\n    final int startSurahId = currentUiState.selectedStartSurahId!;\n    final int startAyahId = currentUiState.selectedStartAyahId!;\n    final int endSurahId = currentUiState.selectedEndSurahId!;\n    int endAyahId = currentUiState.selectedEndAyahId!;\n    final int endSurahTotalAyah = CacheData.surahsCache[endSurahId - 1].totalAyah;\n\n    // Always include the next ayah's timing for proper duration calculation,\n    // but we'll handle stopping at the right time in _stopPlayingWhenEndOfPlaylist\n    if (endAyahId < endSurahTotalAyah) {\n      endAyahId += 1;\n    }\n\n    final List<VerseTiming> filteredTimings = timings.where((timing) {\n      final int surahId = timing.surahId;\n      final int ayahId = timing.ayah;\n\n      return (surahId == startSurahId && ayahId >= startAyahId && (surahId != endSurahId || ayahId <= endAyahId)) ||\n          (surahId > startSurahId && surahId < endSurahId) ||\n          (surahId == endSurahId && ayahId <= endAyahId);\n    }).toList();\n\n    if (filteredTimings.isEmpty) return [];\n\n    final bool hasEndTiming = filteredTimings.any((timing) => timing.ayah == endAyahId && timing.surahId == endSurahId);\n\n    if (hasEndTiming && endAyahId != endSurahTotalAyah) {\n      uiState.value = uiState.value.copyWith(specialCase: true);\n      return [\n        ...filteredTimings.where((timing) => timing.ayah != endAyahId || timing.surahId != endSurahId),\n        filteredTimings.firstWhere((timing) => timing.ayah == endAyahId && timing.surahId == endSurahId)\n      ];\n    } else {\n      uiState.value = uiState.value.copyWith(specialCase: false);\n      return filteredTimings;\n    }\n  }\n\n  Future<void> playAudioFromAyah({required int ayahNumber}) async {\n    final List<VerseTiming> timings = currentUiState.verseTimings!;\n    if (timings.isEmpty) return;\n\n    final VerseTiming targetTiming = timings.firstWhereOrNull((timing) => timing.ayah == ayahNumber) ?? timings.first;\n\n    final int seekPosition = targetTiming.time;\n    await _seekAudioUseCase.execute(seekDuration: Duration(milliseconds: seekPosition));\n\n    uiState.value = uiState.value.copyWith(\n      currentlyPlayingAyahIndex: ayahNumber,\n      isSingleAyahPlayback: currentUiState.isSingleAyahPlayback,\n    );\n\n    await _playSurahAudioUseCase.execute();\n  }\n\n  Future<void> repeatAyahs(int times, int delayInSeconds, List<VerseTiming> verseTimings) async {\n    for (final VerseTiming timing in verseTimings) {\n      Duration startOfAyah = Duration(milliseconds: timing.time);\n      Duration endOfAyah = getDurationOfAyah(verseTimings, timing.ayah);\n      Duration ayahDuration = endOfAyah - startOfAyah;\n\n      for (int i = 0; i < times; i++) {\n        await AudioPlayerService.instance.seek(startOfAyah);\n        await AudioPlayerService.instance.play();\n        await Future.delayed(ayahDuration);\n        await AudioPlayerService.instance.pause();\n        await AudioPlayerService.instance.seek(startOfAyah);\n        if (delayInSeconds > 0) {\n          await Future.delayed(Duration(seconds: delayInSeconds));\n        }\n      }\n      uiState.value = uiState.value.copyWith(lastProcessedAyahIndex: timing.ayah);\n    }\n  }\n\n  Duration getStartOfAyah(List<VerseTiming> verseTimings, int ayahIndex) {\n    final VerseTiming ayah = verseTimings.firstWhere((element) => element.ayah == ayahIndex);\n    return Duration(milliseconds: ayah.time);\n  }\n\n  Future<void> playSingleAyah({required int surahId, required int ayahId, bool isFromMemorization = false}) async {\n    try {\n      uiState.value = uiState.value.copyWith(\n        selectedStartSurahId: surahId,\n        selectedEndSurahId: surahId,\n        selectedStartAyahId: ayahId,\n        selectedEndAyahId: ayahId,\n        isSingleAyahPlayback: true,\n      );\n\n      // First set up the audio with autoPlay set to true\n      await onSurahSelected(\n        startSurah: surahId,\n        endSurah: surahId,\n        isFromMemorization: isFromMemorization,\n        autoPlay: true, // Set autoPlay to true to trigger playback automatically\n      );\n\n      // After initialization, make sure we're at the specific ayah\n      await Future.delayed(const Duration(milliseconds: 300));\n\n      // If we have verse timings available, seek to the specific ayah's position\n      if (currentUiState.verseTimings != null && currentUiState.verseTimings!.isNotEmpty) {\n        final VerseTiming? ayahTiming = currentUiState.verseTimings!.firstWhereOrNull(\n          (timing) => timing.surahId == surahId && timing.ayah == ayahId,\n        );\n\n        if (ayahTiming != null) {\n          await _seekAudioUseCase.execute(seekDuration: Duration(milliseconds: ayahTiming.time));\n\n          uiState.value = uiState.value.copyWith(\n            currentlyPlayingSurahIndex: surahId,\n            currentlyPlayingAyahIndex: ayahId,\n          );\n\n          // Jump to the ayah in the UI\n\n          jumpToCurrentAyah(ayahId);\n        }\n      }\n    } catch (e) {\n      addUserMessage(\"Error playing ayah. Please try again.\");\n      uiState.value = uiState.value.copyWith(\n        isLoading: false,\n        isPlaying: false,\n      );\n    }\n  }\n\n  Future<void> playAudio({required bool isFromMemorization}) async {\n    try {\n      final playlistLength = currentUiState.currentSurahIdsInPlaylist?.length ?? 0;\n      if (playlistLength == 0) {\n        addUserMessage(\"No audio sources available. Please try again or switch to online streaming.\");\n        uiState.value = uiState.value.copyWith(isLoading: false);\n        return;\n      }\n\n      // Check if we're in online streaming mode\n      final bool isStreamingEnabled = currentUiState.isOnlinePlayingStream ?? false;\n\n      // ALWAYS show player controls immediately when in online streaming mode\n      // This is a redundant safety check to ensure they're shown\n      uiState.value = uiState.value.copyWith(\n        // Always show player controls for online streaming mode\n        showPlayerControls: isStreamingEnabled || currentUiState.showPlayerControls,\n        isLoading: true,\n        isPlaying: false,\n        isDownloading: false, // Ensure download flag is reset when starting playback\n      );\n\n      Duration startTimestamp = Duration.zero;\n\n      if (currentUiState.selectedStartSurahId != null && currentUiState.selectedStartAyahId != null) {\n        await loadVerseTimings(\n          reciterId: currentUiState.selectedReciter.id,\n          surahIds: currentUiState.currentSurahIdsInPlaylist!,\n        );\n\n        startTimestamp = await getAyahStartTimestamp(\n          currentUiState.selectedStartSurahId!,\n          currentUiState.selectedStartAyahId!,\n        );\n\n        // Only handle jumping to specific ayah within the current page\n        if (!isFromMemorization && currentUiState.selectedStartAyahId != null) {\n          // Wait a moment for any page change to complete\n          await Future.delayed(const Duration(milliseconds: 300));\n          jumpToCurrentAyah(currentUiState.selectedStartAyahId!);\n        }\n\n        await AudioPlayerService.instance.seek(startTimestamp);\n      }\n\n      await AudioPlayerService.instance.play();\n\n      // By this point, if we get here, playback is actually happening\n      // so we can safely show the player controls\n      uiState.value = uiState.value.copyWith(\n        isPlaying: true,\n        isLoading: false,\n        repeatCount: 0,\n        currentlyPlayingSurahIndex: currentUiState.selectedStartSurahId,\n        currentlyPlayingAyahIndex: currentUiState.selectedStartAyahId,\n        isSingleAyahPlayback: currentUiState.isSingleAyahPlayback,\n        showPlayerControls: true, // Ensure player controls are shown when audio is playing\n      );\n    } catch (e) {\n      addUserMessage(\"Failed to start playback. Please try again.\");\n      uiState.value = uiState.value.copyWith(\n        isPlaying: false,\n        isLoading: false,\n        showPlayerControls: false, // Hide player controls on error\n      );\n    }\n  }\n\n  Future<Duration> getAyahStartTimestamp(int surahId, int ayahId) async {\n    // If this is the first ayah, return Duration.zero to play from the beginning\n    if (ayahId == 1) {\n      return Duration.zero;\n    }\n\n    final List<VerseTiming> verseTimings = currentUiState.verseTimings!;\n    final VerseTiming ayahTiming = verseTimings.firstWhere(\n      (timing) => timing.surahId == surahId && timing.ayah == ayahId,\n      orElse: () => verseTimings.first,\n    );\n    return Duration(milliseconds: ayahTiming.time);\n  }\n\n  Future<void> togglePlayPause() async {\n    if (currentUiState.isPlaying) {\n      await pauseAudio();\n    } else {\n      await resumePlayback();\n    }\n  }\n\n  Future<String> fetchSurahAudioPath(int surah, Reciter reciter) async {\n    final Either<String, String> audioPath = await _getAudioPathUseCase.execute(surah: surah, reciter: reciter);\n    return audioPath.fold((l) => \"\", (r) => r);\n  }\n\n  Future<void> clearPlaylist() async {\n    try {\n      await _clearPlaylistUseCase.execute();\n      uiState.value = uiState.value.copyWith(currentSurahIdsInPlaylist: []);\n    } catch (e) {\n      uiState.value = uiState.value.copyWith(currentSurahIdsInPlaylist: []);\n    }\n  }\n\n  Future<void> onSurahSelected({\n    required int startSurah,\n    required int endSurah,\n    bool isFromMemorization = false,\n    bool autoPlay = false,\n  }) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    try {\n      final bool isStreamingEnabled = currentUiState.isOnlinePlayingStream ?? false;\n\n      // Check if we need to jump to a different page first, before any audio setup\n      // This ensures the jump happens immediately\n      final bool isDifferentSurah = _currentPageIndex != null && _currentPageIndex! + 1 != startSurah;\n\n      if (isDifferentSurah && !isFromMemorization) {\n        // Force an immediate jump to the surah page\n        final int pageToJump = startSurah - 1;\n        _actionStreamController.add(AudioAction(\n          type: AudioActionType.jumpToPage,\n          pageIndex: pageToJump,\n        ));\n      }\n\n      await AudioPlayerService.reinitialize();\n\n      // For online streaming mode, ALWAYS maintain player visibility throughout the process\n      final bool shouldShowPlayerControls = isStreamingEnabled || currentUiState.showPlayerControls;\n\n      // Set the currently playing surah early so other methods can use it\n      uiState.value = uiState.value.copyWith(\n        currentSurahIdsInPlaylist: [],\n        // Store the selected start surah so we can navigate to it\n        selectedStartSurahId: startSurah,\n        isSingleAyahPlayback: false,\n        // For online streaming, ALWAYS show player controls immediately\n        showPlayerControls: shouldShowPlayerControls,\n      );\n\n      List<int> totalSurahs = List<int>.generate(endSurah - startSurah + 1, (index) => startSurah + index);\n      final Reciter selectedReciter = currentUiState.selectedReciter;\n      // Initialize surahsToDownload at the top level so it's accessible throughout the method\n      List<int> surahsToDownload = [];\n      bool downloadSuccess = false;\n\n      await fetchAudioFilesAndVerseTimings(totalSurahs, selectedReciter);\n\n      if (!isStreamingEnabled) {\n        try {\n          surahsToDownload = await _getSurahsToDownload(startSurah, endSurah, selectedReciter);\n          if (surahsToDownload.isNotEmpty) {\n            final bool hasInternet = await checkInternetConnection();\n            if (!hasInternet) {\n              showMessage(message: context.l10n.noInternetConnection);\n              uiState.value = uiState.value.copyWith(\n                isLoading: false,\n                showPlayerControls: false, // Ensure player controls remain hidden\n              );\n              return;\n            }\n\n            // Explicitly make sure player controls are hidden when starting download\n            uiState.value = uiState.value.copyWith(\n                isDownloading: true,\n                downloadCancelToken: CancelToken(),\n                currentDownloadingSurahIndex: surahsToDownload.first,\n                showPlayerControls: false);\n\n            try {\n              await _downloadSurahs(surahsToDownload, selectedReciter);\n              // Mark that download was successful and completed\n              downloadSuccess = true;\n            } catch (e) {\n              if (_isCancelled()) {\n                uiState.value = uiState.value.copyWith(\n                  isDownloading: false,\n                  downloadCancelToken: null,\n                  showPlayerControls: false, // Ensure player controls remain hidden on cancel\n                );\n              } else {\n                // Handle other errors by resetting download state\n                uiState.value = uiState.value.copyWith(\n                  isDownloading: false,\n                  downloadCancelToken: null,\n                  showPlayerControls: false, // Ensure player controls remain hidden on error\n                );\n              }\n              return; // Return early ONLY on download error or cancel\n            }\n          } else {\n            // No downloads needed, already have files locally\n            // Show player controls for offline playback when files are already downloaded\n            uiState.value = uiState.value.copyWith(showPlayerControls: true);\n          }\n        } catch (e) {\n          // Reset download state in case of errors\n          uiState.value = uiState.value.copyWith(\n            isDownloading: false,\n            downloadCancelToken: null,\n            showPlayerControls: false, // Ensure player controls remain hidden on error\n          );\n          return; // Return early on error\n        }\n      }\n\n      await addToPlaylist(totalSurahs, selectedReciter);\n\n      // Only start playing if autoPlay is true\n      if (autoPlay) {\n        await playAudio(isFromMemorization: isFromMemorization);\n      } else {\n        // Just update UI to show it's ready to play\n        // For online streaming, ALWAYS maintain player controls visibility\n        final bool shouldKeepPlayerControls = isStreamingEnabled || surahsToDownload.isEmpty || downloadSuccess;\n\n        uiState.value = uiState.value.copyWith(\n          isLoading: false,\n          showPlayerControls: shouldKeepPlayerControls,\n        );\n      }\n    } catch (e) {\n      // Even in case of an error, keep the player controls visible for online streaming\n      final bool isStreamingEnabled = currentUiState.isOnlinePlayingStream ?? false;\n      uiState.value = uiState.value.copyWith(\n        isLoading: false,\n        isDownloading: false,\n        isPlaying: false,\n        // Only hide controls if NOT in streaming mode\n        showPlayerControls: isStreamingEnabled,\n      );\n    }\n  }\n\n  Future<List<int>> _getSurahsToDownload(int startSurah, int endSurah, Reciter reciter) async {\n    List<int> surahsToDownload = [];\n\n    final surahRange = List<int>.generate(endSurah - startSurah + 1, (index) => startSurah + index);\n\n    await Future.wait(surahRange.map((surah) async {\n      final Either<String, bool> result =\n          await _isSurahAudioAvailableUseCase.execute(surahNumber: surah, reciter: reciter);\n\n      result.fold((l) => addUserMessage(l), (r) {\n        if (!r) surahsToDownload.add(surah);\n      });\n    }));\n\n    return surahsToDownload;\n  }\n\n  Future<void> fetchAudioFilesAndVerseTimings(List<int> totalSurahs, Reciter reciter) async {\n    await _fetchAudioFilesAndVerseTimingsUseCase.execute(totalSurahs, reciter);\n  }\n\n  Future<void> _downloadSurahs(List<int> surahsToDownload, Reciter reciter) async {\n    try {\n      // Pre-initialize UI state once before starting downloads to reduce delay\n      uiState.value = uiState.value.copyWith(isDownloading: true, downloadProgress: 0, showPlayerControls: false);\n\n      // Start downloads immediately without delay\n      for (final surah in surahsToDownload) {\n        if (_isCancelled()) break;\n\n        // Update UI for current surah download\n        uiState.value = uiState.value.copyWith(currentDownloadingSurahIndex: surah, downloadProgress: 0);\n        emitBottomBarHeightAction(kBottomNavigationBarHeight + 22.percentWidth);\n\n        try {\n          // Use microtask to ensure UI updates before download starts\n          await Future.microtask(() async {\n            await _downloadAndSaveAudioLocationUseCase.execute(\n              surahID: surah,\n              reciter: reciter,\n              onProgress: (percentage) => uiState.value = uiState.value.copyWith(downloadProgress: percentage),\n              cancelToken: currentUiState.downloadCancelToken!,\n            );\n          });\n\n          emitBottomBarHeightAction(kBottomNavigationBarHeight + 5.percentWidth);\n          if (!_isCancelled()) {\n            await reciterPresenter.updateDownloadCountsAndReciters(reciter, surah);\n          }\n        } catch (e) {\n          if (!_isCancelled()) rethrow;\n        }\n      }\n    } finally {\n      // Handle the UI state updates based on whether the download was canceled or completed\n      if (_isCancelled()) {\n        // If download was canceled, make sure player controls remain hidden\n        uiState.value =\n            uiState.value.copyWith(isDownloading: false, downloadCancelToken: null, showPlayerControls: false);\n      } else if (currentUiState.isDownloading) {\n        // Only if download wasn't canceled and completed successfully, show player controls\n        uiState.value =\n            uiState.value.copyWith(isDownloading: false, downloadCancelToken: null, showPlayerControls: true);\n      }\n    }\n  }\n\n  Future<void> onReciterChanged(Reciter reciter) async {\n    uiState.value = uiState.value.copyWith(\n      isPlaying: false,\n      currentlyPlayingSurahIndex: null,\n      currentlyPlayingAyahIndex: null,\n      currentPlayTime: Duration.zero,\n      selectedReciter: reciter,\n    );\n  }\n\n  Future<void> seekToPreviousAyah() async {\n    final List<VerseTiming> timings = currentUiState.verseTimings!;\n    final int currentAyah = currentUiState.currentlyPlayingAyahIndex ?? 1;\n\n    final int? previousAyah = timings.map((vt) => vt.ayah).toList().lastWhereOrNull((ayah) => ayah < currentAyah);\n\n    if (previousAyah != null) {\n      if (currentUiState.isSingleAyahPlayback) {\n        uiState.value = uiState.value.copyWith(isSingleAyahPlayback: false);\n      }\n      await playAudioFromAyah(ayahNumber: previousAyah);\n      await _scrollToCurrentAyah();\n    }\n  }\n\n  Future<void> seekToNextAyah() async {\n    final List<VerseTiming> timings = currentUiState.verseTimings!;\n    final int currentAyah = currentUiState.currentlyPlayingAyahIndex ?? 1;\n\n    final int? nextAyah = timings.map((vt) => vt.ayah).toList().firstWhereOrNull((ayah) => ayah > currentAyah);\n\n    if (nextAyah != null) {\n      if (currentUiState.isSingleAyahPlayback) {\n        uiState.value = uiState.value.copyWith(isSingleAyahPlayback: false);\n      }\n      await playAudioFromAyah(ayahNumber: nextAyah);\n      await _scrollToCurrentAyah();\n    }\n  }\n\n  Future<void> addToPlaylist(List<int> totalSurahs, Reciter reciter) async {\n    final bool isStreamingEnabled = currentUiState.isOnlinePlayingStream ?? false;\n    final BuildContext context = QuranMajeed.globalContext;\n\n    if (isStreamingEnabled) {\n      final bool hasInternet = await checkInternetConnection();\n      if (!hasInternet) {\n        showMessage(message: context.l10n.noInternetConnection);\n        return;\n      }\n\n      for (final surah in totalSurahs) {\n        try {\n          final AudioFile? audioFile = CacheData.audioFiles[surah];\n          if (audioFile == null) {\n            continue;\n          }\n          final String streamingUrl = audioFile.audioLink;\n          if (streamingUrl.isEmpty) {\n            continue;\n          }\n\n          await _addToPlaylistUseCase.execute(\n            audioPath: streamingUrl,\n            title: CacheData.surahsCache[surah - 1].nameEn,\n            isOnlineStream: true,\n          );\n\n          uiState.value = uiState.value.copyWith(\n            currentSurahIdsInPlaylist: [...?currentUiState.currentSurahIdsInPlaylist, surah],\n          );\n        } catch (e) {\n          addUserMessage(\"Error adding surah $surah to playlist.\");\n        }\n      }\n\n      final playlistLength = currentUiState.currentSurahIdsInPlaylist?.length ?? 0;\n      if (playlistLength == 0) {\n        addUserMessage(context.l10n.failPrepStreamAudTryAgain);\n      }\n    } else {\n      final String directoryPath = await getApplicationDirectoryPath();\n\n      for (final surah in totalSurahs) {\n        try {\n          final Either<String, String> result =\n              await _createAudioFilePathUseCase.execute(surah: surah, reciter: reciter);\n          final String location = result.fold((l) => \"\", (r) => r);\n          final String fileSaveLocation = \"$directoryPath/$location\";\n\n          if (await doesFileExist(fileSaveLocation)) {\n            await _addToPlaylistUseCase.execute(\n              audioPath: fileSaveLocation,\n              title: CacheData.surahsCache[surah - 1].nameEn,\n            );\n\n            uiState.value = uiState.value.copyWith(\n              currentSurahIdsInPlaylist: [...?currentUiState.currentSurahIdsInPlaylist, surah],\n            );\n          }\n        } catch (e) {\n          // Continue\n        }\n      }\n\n      final playlistLength = currentUiState.currentSurahIdsInPlaylist?.length ?? 0;\n      if (playlistLength == 0) {\n        addUserMessage(context.l10n.failPrepAudFilesTryAgain);\n      }\n    }\n  }\n\n  bool _isCancelled() => currentUiState.downloadCancelToken?.isCancelled ?? false;\n\n  Future<void> onSelectVerseForDelayedPlay(int audioFileId, String verseKey, Duration delay) async {\n    await _playVerseWithDelayUseCase.execute(audioFileId, verseKey, delay);\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async => showMessage(message: message);\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async =>\n      uiState.value = uiState.value.copyWith(isLoading: loading);\n\n  Future<void> updatePlaybackSpeed(double speed) async {\n    uiState.value = uiState.value.copyWith(playbackSpeed: speed);\n    await AudioPlayerService.instance.setSpeed(speed);\n  }\n\n  List<double> get availablePlaybackSpeeds => [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0];\n\n  Future<void> incrementPlaybackSpeed() async {\n    final currentSpeed = currentUiState.playbackSpeed;\n    final speeds = availablePlaybackSpeeds;\n    final currentIndex = speeds.indexOf(currentSpeed);\n    if (currentIndex < speeds.length - 1) {\n      await updatePlaybackSpeed(speeds[currentIndex + 1]);\n    }\n  }\n\n  Future<void> decrementPlaybackSpeed() async {\n    final currentSpeed = currentUiState.playbackSpeed;\n    final speeds = availablePlaybackSpeeds;\n    final currentIndex = speeds.indexOf(currentSpeed);\n    if (currentIndex > 0) {\n      await updatePlaybackSpeed(speeds[currentIndex - 1]);\n    }\n  }\n\n  VerseTiming _findCurrentVerse(List<VerseTiming> verseTimings, int currentMillis) {\n    return verseTimings.lastWhere(\n      (vt) => vt.time <= currentMillis,\n      orElse: () => verseTimings.first,\n    );\n  }\n\n  VerseTiming? _findNextVerse(List<VerseTiming> verseTimings, int currentAyahNumber) {\n    return verseTimings.firstWhereOrNull(\n      (vt) => vt.ayah == currentAyahNumber + 1,\n    );\n  }\n\n  Future<bool> _handleAyahRepetition(List<VerseTiming> verseTimings, int currentAyahNumber) async {\n    final int repeatCount = currentUiState.repeatCount;\n    final int ayahRepeatNumber = currentUiState.ayahRepeatNumber;\n\n    if (repeatCount < ayahRepeatNumber) {\n      final VerseTiming currentVerse = verseTimings.firstWhere((vt) => vt.ayah == currentAyahNumber);\n      await AudioPlayerService.instance.seek(Duration(milliseconds: currentVerse.time));\n      uiState.value = uiState.value.copyWith(\n        repeatCount: repeatCount + 1,\n        currentPlayTime: Duration(milliseconds: currentVerse.time),\n        isRepeating: true,\n      );\n      return true; // Still repeating\n    } else {\n      return false; // Repetitions complete\n    }\n  }\n\n  Future<void> _handleAyahDelay(int surahId, int ayahNumber, Duration position) async {\n    if (currentUiState.ayahDelayNumber > 0) {\n      uiState.value = uiState.value.copyWith(\n        currentlyPlayingSurahIndex: surahId,\n        currentlyPlayingAyahIndex: ayahNumber,\n        currentPlayTime: position,\n        repeatCount: 0,\n        isRepeating: false,\n      );\n      await _scrollToCurrentAyah();\n\n      await pauseAudio();\n\n      // Check if we've reached the end of the playlist before applying delay\n      bool isEndOfPlaylist = false;\n\n      // Check if we're at the end surah and ayah\n      if (surahId == currentUiState.selectedEndSurahId && ayahNumber >= currentUiState.selectedEndAyahId!) {\n        isEndOfPlaylist = true;\n      }\n\n      if (!isEndOfPlaylist) {\n        await Future.delayed(Duration(seconds: currentUiState.ayahDelayNumber));\n\n        // Check if still paused (user didn't manually stop during delay)\n        if (currentUiState.isPaused) {\n          await resumePlayback();\n        }\n      } else {\n        // If at end of playlist, don't auto-resume\n        await stopAudio();\n      }\n    } else {\n      uiState.value = uiState.value.copyWith(\n        currentlyPlayingSurahIndex: surahId,\n        currentlyPlayingAyahIndex: ayahNumber,\n        currentPlayTime: position,\n        repeatCount: 0,\n        isRepeating: false,\n        isPaused: false,\n      );\n      await _scrollToCurrentAyah();\n    }\n  }\n\n  void handleDelayIncrement() {\n    int currentDelay = currentUiState.ayahDelayNumber;\n    if (currentDelay < 10) {\n      updateAyahDelayNumber(currentDelay + 1);\n    } else {\n      updateAyahDelayNumber(0);\n    }\n  }\n\n  void handleRepeatIncrement() {\n    int currentRepeat = currentUiState.ayahRepeatNumber;\n    if (currentRepeat == -1) {\n      updateAyahRepeatNumber(0);\n    } else if (currentRepeat == 3) {\n      updateAyahRepeatNumber(-1);\n    } else {\n      updateAyahRepeatNumber(currentRepeat + 1);\n    }\n  }\n\n  String? getRepeatBadgeText() {\n    if (currentUiState.ayahRepeatNumber > 0 || currentUiState.ayahRepeatNumber == -1) {\n      return currentUiState.ayahRepeatNumber == -1 ? '\u221e' : '${currentUiState.ayahRepeatNumber}';\n    }\n    return null;\n  }\n\n  String? getDelayBadgeText() {\n    return currentUiState.ayahDelayNumber > 0 ? '${currentUiState.ayahDelayNumber}s' : null;\n  }\n\n  double getCurrentProgress() {\n    if (currentUiState.currentPlayTime == null || currentUiState.totalDuration == null) {\n      return 0.0;\n    }\n    return currentUiState.currentPlayTime!.inMilliseconds / currentUiState.totalDuration!.inMilliseconds;\n  }\n\n  Future<void> cancelDownload() async {\n    final cancelToken = currentUiState.downloadCancelToken;\n    if (cancelToken != null && !cancelToken.isCancelled) {\n      // IMMEDIATELY hide player controls - this must happen synchronously before any async operations\n      uiState.value = uiState.value.copyWith(showPlayerControls: false);\n\n      // Then cancel the token\n      cancelToken.cancel(\"Download canceled by user\");\n\n      // Update all the other state properties\n      uiState.value = uiState.value.copyWith(\n        isDownloading: false,\n        downloadCancelToken: null,\n        downloadProgress: 0,\n        currentDownloadingSurahIndex: null,\n        showDownloadCard: false,\n        // Redundant but ensures it's still false after the previous update\n        showPlayerControls: false,\n      );\n\n      try {\n        await stopAudio();\n        await Future.delayed(const Duration(milliseconds: 500));\n        await AudioPlayerService.reinitialize();\n\n        // Ensure one more time that player controls are still hidden after cleanup\n        uiState.value = uiState.value.copyWith(showPlayerControls: false);\n      } catch (e) {\n        // Continue with UI updates, but still ensure player controls are hidden\n        uiState.value = uiState.value.copyWith(showPlayerControls: false);\n      }\n\n      emitBottomBarHeightAction(kBottomNavigationBarHeight + 5.percentWidth);\n    }\n  }\n\n  Future<void> pauseAudio() async {\n    await _pausePlaybackUseCase.execute();\n    uiState.value = uiState.value.copyWith(isPlaying: false, isPaused: true);\n    emitBottomBarHeightAction(kBottomNavigationBarHeight + 5.percentWidth);\n  }\n\n  Future<void> stopAudio() async {\n    await _stopAudioUseCase.execute();\n\n    uiState.value = uiState.value.copyWith(\n      isPaused: true,\n      showPlayerControls: false,\n      isPlaying: false,\n      isLoading: false,\n      currentPlayTime: Duration.zero,\n      currentlyPlayingSurahIndex: null,\n      currentlyPlayingAyahIndex: null,\n      lastProcessedAyahIndex: null,\n      isSingleAyahPlayback: false,\n      currentSurahIdsInPlaylist: [],\n    );\n\n    emitBottomBarHeightAction(kBottomNavigationBarHeight + 5.percentWidth);\n  }\n\n  String getSuranNameFromId(int surahId) => CacheData.surahsCache[surahId - 1].nameEn;\n}\n\n// Define AudioAction for stream events\nenum AudioActionType { scrollToAyah, jumpToPage, jumpToAyah, setBottomBarHeight }\n\nclass AudioAction {\n  final AudioActionType type;\n  final int? pageIndex;\n  final int? ayahIndex;\n  final double? height;\n\n  AudioAction({\n    required this.type,\n    this.pageIndex,\n    this.ayahIndex,\n    this.height,\n  });\n}\n"}, {"structure_type": "function", "name": "_onSearchQueryChanged", "docstring": "", "module": "presenter", "file_path": "presentation/audio/reciter/presenter/reciter_presenter.dart", "file_name": "reciter_presenter.dart", "line": 57, "line_from": 57, "line_to": 511, "snippet": "  void _onSearchQueryChanged() {\n    Debounce.debounce(\"surahSearching\", 300.inMilliseconds, () async {\n      final query = surahNameSearchController.text.trim().toLowerCase();\n      uiState.value = uiState.value.copyWith(searchQuery: query);\n    });\n  }\n\n  void _onReciterSearchQueryChanged() {\n    final query = reciterSearchController.text.trim().toLowerCase();\n    Debounce.debounce(\"reciterSearching\", 300.inMilliseconds, () async {\n      try {\n        final List<Reciter> allReciters =\n            await _getRecitersFromDatabaseUseCase.call();\n\n        List<Reciter> filteredReciters = List.from(allReciters);\n\n        if (query.isNotEmpty) {\n          filteredReciters = allReciters\n              .where((reciter) => reciter.name.toLowerCase().contains(query))\n              .toList();\n        }\n\n        // Remove the currently selected reciter from the filtered list\n        filteredReciters\n            .removeWhere((r) => r.id == currentUiState.selectedReciter.id);\n        filteredReciters.sort((a, b) => a.name.compareTo(b.name));\n\n        // Force UI update by creating a new state\n        if (!uiState.value.isLoading) {\n          uiState.value = currentUiState.copyWith(\n            availableRecitersForDownload: filteredReciters,\n            searchQuery: query,\n          );\n        }\n      } catch (e) {\n        addUserMessage(\"Error filtering reciters: $e\");\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    surahNameSearchController.removeListener(_onSearchQueryChanged);\n    reciterSearchController.removeListener(_onReciterSearchQueryChanged);\n    surahNameSearchController.dispose();\n    reciterSearchController.dispose();\n    super.dispose();\n  }\n\n  List<int> get filteredSurahIndices {\n    if (currentUiState.searchQuery.isEmpty) {\n      return List.generate(CacheData.surahsCache.length, (i) => i);\n    } else {\n      return CacheData.surahsCache\n          .asMap()\n          .entries\n          .where((entry) =>\n              entry.value.nameEn\n                  .toLowerCase()\n                  .contains(currentUiState.searchQuery) ||\n              entry.value.nameBn\n                  .toLowerCase()\n                  .contains(currentUiState.searchQuery) ||\n              entry.value.serial\n                  .toString()\n                  .toLowerCase()\n                  .contains(currentUiState.searchQuery))\n          .map((entry) => entry.key)\n          .toList();\n    }\n  }\n\n  ReciterUiState get currentUiState => uiState.value;\n  final Map<int, bool> _isProcessingSurah = {}; // Map to track Surah processing\n  Future<void> downloadSurahAudio(\n      {required int surahIndex,\n      required Reciter reciter,\n      required BuildContext context}) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet && context.mounted) {\n      await showMessage(message: context.l10n.noInternetConnection);\n      return;\n    }\n\n    if (_isProcessingSurah[surahIndex] ?? false) {\n      cancelDownload();\n      _isProcessingSurah[surahIndex] = false;\n      if (context.mounted) addUserMessage(context.l10n.downloadCancelled);\n\n      updateUiState(\n          isDownloading: false,\n          currentDownloadingSurahIndex: null,\n          downloadProgress: 0,\n          downloadCancelToken: null,\n          activeDownloadId: null);\n      _cancelTokens.remove(currentUiState.activeDownloadId);\n      return;\n    }\n\n    if (_isProcessingSurah.containsValue(true) && context.mounted) {\n      addUserMessage(context.l10n.downloadInProgress);\n      return;\n    }\n\n    _isProcessingSurah[surahIndex] = true;\n\n    try {\n      _initializeDownloadProcess();\n      await fetchAudioFilesAndVerseTimings([surahIndex], reciter);\n      updateUiState(\n          isDownloading: true,\n          currentDownloadingSurahIndex: surahIndex,\n          currentDownloadingReciterId: reciter.id,\n          downloadCancelToken: CancelToken(),\n          downloadProgress: 0);\n\n      final connectivitySubscription = await monitorNetworkConnectivity(\n        context,\n        onConnectionLost: () {\n          addUserMessage(context.l10n.noInternetConnection);\n        },\n        onConnectionRestored: () {\n          addUserMessage(context.l10n.internetConnectionRestored);\n        },\n      );\n\n      final result = await _downloadAndSaveAudioLocationUseCase.execute(\n        surahID: surahIndex,\n        reciter: reciter,\n        onProgress: updateDownloadProgress,\n        cancelToken: currentUiState.downloadCancelToken!,\n      );\n\n      // Cancel connectivity subscription\n      await connectivitySubscription.cancel();\n\n      await result.fold(\n        (failure) => processDownloadFailure(),\n        (_) async {\n          if (!currentUiState.downloadCancelToken!.isCancelled) {\n            await processDownloadSuccess(reciter, context);\n            await loadDownloadCounts();\n          }\n        },\n      );\n    } catch (e) {\n      addUserMessage(\"Failed to download surah: $e\");\n    } finally {\n      _isProcessingSurah[surahIndex] = false;\n      _cancelTokens.remove(currentUiState.activeDownloadId);\n      updateUiState(\n          isDownloading: false,\n          currentDownloadingSurahIndex: null,\n          downloadProgress: 0,\n          currentDownloadingReciterId: null,\n          downloadCancelToken: null,\n          activeDownloadId: null);\n    }\n  }\n\n  Future<void> deleteAudioFilesBySurahAndReciter(\n      {required int surahNumber, required Reciter reciter}) async {\n    final result = await _deleteAudioBySurahAndReciter.execute(\n      surahNumber: surahNumber,\n      reciter: reciter,\n    );\n    await result.fold(\n      (failure) async => await addUserMessage(failure),\n      (_) async {\n        await addUserMessage('Audio deleted successfully');\n        await updateDownloadCountsAndReciters(reciter, surahNumber,\n            isDelete: true);\n      },\n    );\n  }\n\n  void updateDownloadProgress(int percentage) {\n    updateUiState(downloadProgress: percentage);\n  }\n\n  Future<void> processDownloadFailure() async {\n    addUserMessage('Failed to download surah');\n    updateUiState(isDownloading: false);\n  }\n\n  Future<void> processDownloadSuccess(\n      Reciter reciter, BuildContext context) async {\n    if (context.mounted) addUserMessage(context.l10n.surahDownloaded);\n    await updateDownloadCountsAndReciters(\n        reciter, currentUiState.currentDownloadingSurahIndex!);\n    updateUiState(isDownloading: false, downloadProgress: 0);\n  }\n\n  void _initializeDownloadProcess() {\n    final String downloadId = DateTime.now().millisecondsSinceEpoch.toString();\n    final CancelToken cancelToken = CancelToken();\n    _cancelTokens[downloadId] = cancelToken;\n    uiState.value = currentUiState.copyWith(\n      downloadCancelToken: cancelToken,\n      activeDownloadId: downloadId,\n    );\n  }\n\n  void cancelDownload() {\n    if (currentUiState.isDownloading! &&\n        currentUiState.downloadCancelToken != null) {\n      currentUiState.downloadCancelToken!.cancel();\n      if (currentUiState.activeDownloadId != null) {\n        _cancelTokens.remove(currentUiState.activeDownloadId);\n      }\n      uiState.value = uiState.value.copyWith(\n        isDownloading: false,\n        downloadProgress: 0,\n        currentDownloadingSurahIndex: null,\n        currentDownloadingReciterId: null,\n        downloadCancelToken: null,\n        activeDownloadId: null,\n      );\n    }\n  }\n\n  Future<void> fetchAudioFilesAndVerseTimings(\n      List<int> totalSurahs, Reciter reciter) async {\n    await _fetchAudioFilesAndVerseTimingsUseCase.execute(totalSurahs, reciter);\n  }\n\n  Future<void> updateDownloadCountsAndReciters(Reciter reciter, int surahId,\n      {bool isDelete = false}) async {\n    Map<int, int> currentCounts =\n        Map<int, int>.from(currentUiState.downloadedSurahCounts ?? {});\n    List<int> surahIds = await _getSurahIdsForReciterUseCase.call(reciter);\n\n    if (isDelete) {\n      surahIds.remove(surahId);\n    } else if (!surahIds.contains(surahId)) {\n      surahIds.add(surahId);\n    }\n\n    int newCount = surahIds.length;\n    currentCounts[reciter.id] = newCount;\n    await _saveDownloadCountUseCase.saveDownloadCount(reciter.id, newCount);\n    await _saveReciterWithSurahIdUseCase.call(surahId, reciter,\n        isDelete: isDelete);\n\n    await loadReciterSurahIds();\n\n    updateUiState(downloadedSurahCounts: currentCounts);\n  }\n\n  String getImagePath(String reciterName) {\n    return 'assets/images/non_svg/img_qari/$reciterName.png';\n  }\n\n  void updateUiState({\n    bool? isDownloading,\n    int? currentDownloadingSurahIndex,\n    int? downloadProgress,\n    Map<int, int>? downloadedSurahCounts,\n    int? currentDownloadingReciterId,\n    CancelToken? downloadCancelToken,\n    String? activeDownloadId,\n  }) {\n    uiState.value = uiState.value.copyWith(\n      isDownloading: isDownloading,\n      currentDownloadingSurahIndex: currentDownloadingSurahIndex,\n      downloadProgress: downloadProgress,\n      downloadedSurahCounts: downloadedSurahCounts,\n      currentDownloadingReciterId: currentDownloadingReciterId,\n      downloadCancelToken: downloadCancelToken,\n      activeDownloadId: activeDownloadId,\n    );\n  }\n\n  int getCurrentDownloadCount(Reciter reciter) =>\n      uiState.value.downloadedSurahCounts?[reciter.id] ?? 0;\n\n  Future<void> downloadAllSurahs(\n      {required Reciter reciter, required BuildContext context}) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet) {\n      if (context.mounted) addUserMessage(context.l10n.noInternetConnection);\n      return;\n    }\n\n    updateUiState(isDownloading: true);\n    int totalSurahs = 114;\n    List<String> errors = [];\n    _initializeDownloadProcess();\n\n    for (int surahIndex = 1; surahIndex <= totalSurahs; surahIndex++) {\n      if (currentUiState.downloadCancelToken!.isCancelled) break;\n      await fetchAudioFilesAndVerseTimings([surahIndex], reciter);\n      updateUiState(currentDownloadingSurahIndex: surahIndex);\n\n      final result = await _downloadAndSaveAudioLocationUseCase.execute(\n        surahID: surahIndex,\n        reciter: reciter,\n        onProgress: (percentage) =>\n            updateOverallProgress(surahIndex, percentage, totalSurahs),\n        cancelToken: currentUiState.downloadCancelToken!,\n      );\n\n      result.fold(\n        (failure) => errors.add(\"Surah $surahIndex: $failure\"),\n        (_) async => await updateDownloadCountsAndReciters(\n            reciter, currentUiState.currentDownloadingSurahIndex!),\n      );\n    }\n\n    if (errors.isNotEmpty) {\n      addUserMessage(\"Errors occurred during download: ${errors.join(', ')}\");\n    } else if (context.mounted) {\n      addUserMessage(context.l10n.surahDownloaded);\n    }\n\n    updateUiState(\n        isDownloading: false,\n        downloadProgress: 0,\n        currentDownloadingSurahIndex: 0);\n  }\n\n  void updateOverallProgress(int surahIndex, int percentage, int totalSurahs) {\n    int progress = ((surahIndex / totalSurahs) * 100).toInt() +\n        (percentage ~/ totalSurahs);\n    updateUiState(downloadProgress: progress);\n  }\n\n  void toggleCheckBoxVisibility() {\n    final bool newState = !currentUiState.checkBoxVisible!;\n    uiState.value = currentUiState.copyWith(\n      checkBoxVisible: newState,\n      isSelected: newState ? currentUiState.isSelected : {},\n    );\n  }\n\n  void selectSurah(int index) {\n    if (currentUiState.checkBoxVisible!) {\n      final isSelectedSet =\n          Set<int>.from(currentUiState.isSelected as Set<int>);\n      isSelectedSet.contains(index)\n          ? isSelectedSet.remove(index)\n          : isSelectedSet.add(index);\n      uiState.value = currentUiState.copyWith(isSelected: isSelectedSet);\n      // isSelectedSet.isEmpty ? showDownlaod.value = false : showDownlaod.value = true;\n    }\n  }\n\n  Future<void> loadDownloadCounts() async {\n    try {\n      Map<int, int> downloadCounts = {};\n      List<Reciter> allReciters =\n          await _getRecitersFromDatabaseUseCase.call(); // Get all reciters\n      for (Reciter reciter in allReciters) {\n        List<int> surahIds = await _getSurahIdsForReciterUseCase.call(reciter);\n        downloadCounts[reciter.id] = surahIds.length;\n      }\n      uiState.value =\n          currentUiState.copyWith(downloadedSurahCounts: downloadCounts);\n    } catch (e) {\n      addUserMessage(\"Failed to load download counts: $e\");\n    }\n  }\n\n  Future<void> selectReciter(\n      {required Reciter reciter, required BuildContext context}) async {\n    List<Reciter> availableReciters =\n        List.from(currentUiState.availableRecitersForDownload ?? []);\n\n    availableReciters.removeWhere((r) => r.id == reciter.id);\n    availableReciters.insert(0, currentUiState.selectedReciter);\n    availableReciters.sort((a, b) => a.name.compareTo(b.name));\n\n    uiState.value = currentUiState.copyWith(\n      availableRecitersForDownload: availableReciters,\n      selectedReciterId: reciter.id,\n      selectedReciter: reciter,\n    );\n\n    await saveSelectedReciter(reciter);\n    await audioPresenter.onReciterChanged(reciter);\n\n    // Show toast message after reciter selection\n    await addUserMessage(context.l10n.selectedSuccessfully);\n  }\n\n  @override\n  Future<void> addUserMessage(String message) {\n    return showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }\n\n  @override\n  Future<void> onInit() async {\n    await toggleLoading(loading: true);\n    await getSelectedReciter();\n    await getReciters();\n    await loadDownloadCounts();\n    await loadReciterSurahIds();\n    await toggleLoading(loading: false);\n\n    super.onInit();\n  }\n\n  Future<void> loadReciterSurahIds() async {\n    try {\n      final reciters =\n          await _getRecitersFromDatabaseUseCase.call(); // Get all reciters\n      final Map<int, List<int>> reciterSurahIds = {\n        for (var reciter in reciters)\n          reciter.id: await _getSurahIdsForReciterUseCase.call(reciter)\n      };\n      uiState.value = uiState.value.copyWith(reciterSurahIds: reciterSurahIds);\n    } catch (e) {\n      addUserMessage(\"Failed to load Reciter Surah IDs: $e\");\n    }\n  }\n\n  Future<void> getReciters() async {\n    final List<Reciter> reciters = await _getRecitersFromDatabaseUseCase.call();\n\n    final List<Reciter> availableReciters = List.from(reciters);\n    availableReciters\n        .removeWhere((r) => r.id == currentUiState.selectedReciter.id);\n    availableReciters.sort((a, b) => a.name.compareTo(b.name));\n    uiState.value = currentUiState.copyWith(\n        availableRecitersForDownload: availableReciters);\n  }\n\n  Future<void> saveSelectedReciter(Reciter reciter) async {\n    await _manageSelectedReciterUseCase.saveSelectedReciter(reciter);\n  }\n\n  Future<void> getSelectedReciter() async {\n    final Reciter reciter =\n        await _manageSelectedReciterUseCase.getSelectedReciter();\n    uiState.value = currentUiState.copyWith(\n      defaultReciter: reciter,\n      selectedReciter: reciter,\n      selectedReciterId: reciter.id,\n    );\n    await audioPresenter.onReciterChanged(reciter);\n  }\n\n  Future<void> saveReciterWithSurahId(int surahId, Reciter reciter) async {\n    await _saveReciterWithSurahIdUseCase.call(surahId, reciter);\n    uiState.value = currentUiState.copyWith(reciterSurahIds: {\n      ...?currentUiState.reciterSurahIds,\n      reciter.id: [surahId]\n    });\n  }\n}"}, {"structure_type": "function", "name": "_updateState", "docstring": "", "module": "presenter", "file_path": "presentation/profile/presenter/profile_presenter.dart", "file_name": "profile_presenter.dart", "line": 47, "line_from": 47, "line_to": 463, "snippet": "  void _updateState(ProfileUiState newState) => uiState.value = newState;\n  // --- End State Management ---\n\n  // Flags to prevent concurrent refreshes\n  bool _isRefreshingActivity = false;\n\n  // Animation controllers for charts\n  final Map<ActivityTimeRange, AnimationController> _animationControllers = {};\n\n  ProfilePresenter({\n    required GetWeeklyActivityUseCase getWeeklyActivityUseCase,\n    required GetMonthlyActivityUseCase getMonthlyActivityUseCase,\n    required GetYearlyActivityUseCase getYearlyActivityUseCase,\n    required GetActivityStatsUseCase getActivityStatsUseCase,\n  })  : _getWeeklyActivityUseCase = getWeeklyActivityUseCase,\n        _getMonthlyActivityUseCase = getMonthlyActivityUseCase,\n        _getYearlyActivityUseCase = getYearlyActivityUseCase,\n        _getActivityStatsUseCase = getActivityStatsUseCase;\n\n  @override\n  void onInit() {\n    super.onInit();\n    loadProfileData(); // Load initial data\n    _listenForUsageDataChanges(); // Start listening for updates\n  }\n\n  @override\n  void onClose() {\n    _usageDataChangeSubscription?.cancel(); // Cancel subscription on close\n\n    // Dispose animation controllers\n    for (final controller in _animationControllers.values) {\n      controller.dispose();\n    }\n\n    super.onClose();\n  }\n\n  void navigateToActivityDetails(BuildContext context) {\n    // If data isn't already loaded, load it first\n    if (currentUiState.monthlyActivity.isEmpty || currentUiState.yearlyActivity.isEmpty) {\n      // Show a loading indicator\n      _updateState(currentUiState.copyWith(isActivityLoading: true));\n\n      // Load all activity data\n      Future.wait([\n        _loadWeeklyActivityData(),\n        _loadMonthlyActivityData(),\n        _loadYearlyActivityData(),\n      ]).then((_) {\n        // Hide loading indicator\n        _updateState(currentUiState.copyWith(isActivityLoading: false));\n\n        // Now navigate with the loaded data\n        _showDetailedActivityPage(context);\n      });\n    } else {\n      // Data is already loaded, navigate directly\n      _showDetailedActivityPage(context);\n    }\n  }\n\n  /// Creates and initializes animation controllers for various charts\n  void initAnimationController(ActivityTimeRange timeRange, TickerProvider vsync) {\n    if (_animationControllers.containsKey(timeRange)) {\n      return;\n    }\n\n    final controller = AnimationController(\n      duration: const Duration(milliseconds: 800),\n      vsync: vsync,\n    );\n\n    _animationControllers[timeRange] = controller;\n    controller.forward();\n  }\n\n  /// Restarts animations for the currently active time range\n  void restartAnimation(ActivityTimeRange timeRange) {\n    final controller = _animationControllers[timeRange];\n    if (controller != null) {\n      controller.reset();\n      controller.forward();\n    }\n  }\n\n  /// Listens to the [AppLifecycleTracker.onUsageDataChanged] stream and\n  /// triggers a refresh of the activity data, debouncing events to prevent\n  /// excessive updates.\n  void _listenForUsageDataChanges() {\n    _usageDataChangeSubscription = _appLifecycleTracker.onUsageDataChanged\n        .debounceTime(const Duration(milliseconds: 1000)) // Debounce for 1 second\n        .listen((_) {\n      if (!_isRefreshingActivity) {\n        // Prevent concurrent refreshes\n        refreshActivityData(); // Call refresh method\n      }\n    }, onError: (Object e, StackTrace stackTrace) {\n      logErrorStatic('ProfilePresenter', 'Error in usage data change stream: $e');\n    });\n  }\n\n  /// Loads all necessary data for the profile page, including user details,\n  /// stats, and the initial activity data.\n  Future<void> loadProfileData() async {\n    await toggleLoading(loading: true);\n\n    // Simulated user data - would come from a repository in production\n    String userName = 'Ahmad Saleh';\n    String userEmail = 'ahmad.saleh@example.com';\n    String avatarUrl = '';\n    double dailyReadingProgress = 0.65;\n    int totalReads = 365;\n    int totalBookmarks = 28;\n    int totalNotes = 17;\n    int badgesEarned = 8;\n    double nextBadgeProgress = 0.75;\n\n    // Set initial time range to weekly (default view)\n    final activeTimeRange = currentUiState.activeTimeRange;\n\n    // Fetch Initial Activity Data based on active time range\n    await _loadActivityDataForTimeRange(activeTimeRange);\n\n    // Fetch usage stats for active time range\n    final Either<String, UsageStatsEntity> statsResult = await _getActivityStatsUseCase.execute(\n      timeRange: _mapActivityTimeRangeToTimeRange(activeTimeRange),\n    );\n\n    UsageStatsEntity? usageStats;\n\n    statsResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading usage stats: $error');\n      },\n      (UsageStatsEntity stats) {\n        usageStats = stats;\n      },\n    );\n\n    // Update UI state with all fetched data\n    _updateState(currentUiState.copyWith(\n      userName: userName,\n      userEmail: userEmail,\n      avatarUrl: avatarUrl,\n      dailyReadingProgress: dailyReadingProgress,\n      totalReads: totalReads,\n      totalBookmarks: totalBookmarks,\n      totalNotes: totalNotes,\n      badgesEarned: badgesEarned,\n      nextBadgeProgress: nextBadgeProgress,\n      usageStats: usageStats,\n      isLoading: false,\n      userMessage: () => null, // Clear any previous message\n    ));\n  }\n\n  /// Maps the UI time range enum to the domain time range enum\n  TimeRange _mapActivityTimeRangeToTimeRange(ActivityTimeRange uiTimeRange) {\n    switch (uiTimeRange) {\n      case ActivityTimeRange.weekly:\n        return TimeRange.last7Days;\n      case ActivityTimeRange.monthly:\n        return TimeRange.currentMonth;\n      case ActivityTimeRange.yearly:\n        return TimeRange.currentYear;\n    }\n  }\n\n  /// Loads activity data for the specified time range\n  Future<void> _loadActivityDataForTimeRange(ActivityTimeRange timeRange) async {\n    switch (timeRange) {\n      case ActivityTimeRange.weekly:\n        await _loadWeeklyActivityData();\n        break;\n      case ActivityTimeRange.monthly:\n        await _loadMonthlyActivityData();\n        break;\n      case ActivityTimeRange.yearly:\n        await _loadYearlyActivityData();\n        break;\n    }\n  }\n\n  /// Loads weekly activity data\n  Future<void> _loadWeeklyActivityData() async {\n    final Either<String, List<WeeklyActivityEntity>> activityResult = await _getWeeklyActivityUseCase.execute();\n\n    List<ActivityData> activityData = [];\n\n    activityResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading weekly activity: $error');\n        activityData = []; // Keep activity data empty on failure\n      },\n      (List<WeeklyActivityEntity> entities) {\n        activityData = _mapWeeklyActivityToPresentationModel(entities: entities);\n      },\n    );\n\n    // Update just the weekly activity part of the state\n    _updateState(currentUiState.copyWith(\n      weeklyActivity: activityData,\n    ));\n  }\n\n  /// Loads monthly activity data\n  Future<void> _loadMonthlyActivityData() async {\n    final Either<String, List<MonthlyActivityEntity>> activityResult = await _getMonthlyActivityUseCase.execute();\n\n    List<MonthlyActivityData> activityData = [];\n\n    activityResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading monthly activity: $error');\n        activityData = []; // Keep activity data empty on failure\n      },\n      (List<MonthlyActivityEntity> entities) {\n        activityData = _mapMonthlyActivityToPresentationModel(entities: entities);\n      },\n    );\n\n    // Update just the monthly activity part of the state\n    _updateState(currentUiState.copyWith(\n      monthlyActivity: activityData,\n    ));\n  }\n\n  /// Loads yearly activity data\n  Future<void> _loadYearlyActivityData() async {\n    final Either<String, List<YearlyActivityEntity>> activityResult = await _getYearlyActivityUseCase.execute();\n\n    List<YearlyActivityData> activityData = [];\n\n    activityResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading yearly activity: $error');\n        activityData = []; // Keep activity data empty on failure\n      },\n      (List<YearlyActivityEntity> entities) {\n        activityData = _mapYearlyActivityToPresentationModel(entities: entities);\n      },\n    );\n\n    // Update just the yearly activity part of the state\n    _updateState(currentUiState.copyWith(\n      yearlyActivity: activityData,\n    ));\n  }\n\n  /// Maps a list of [WeeklyActivityEntity] (domain) to a list of [ActivityData] (presentation).\n  List<ActivityData> _mapWeeklyActivityToPresentationModel({required List<WeeklyActivityEntity> entities}) {\n    // Assumes 'entities' is the sorted list of 7 days from the use case.\n    final DateTime todayDateOnly = DateUtils.dateOnly(DateTime.now());\n\n    return entities.map((entity) {\n      final bool isTodayFlag = DateUtils.dateOnly(entity.date) == todayDateOnly;\n      return ActivityData(\n        day: entity.date.day, // Day of month for display\n        date: entity.date, // Full date object\n        minutes: entity.minutes,\n        isToday: isTodayFlag,\n        // 'isActive' is derived in ActivityData constructor\n      );\n    }).toList();\n  }\n\n  /// Maps a list of [MonthlyActivityEntity] (domain) to a list of [MonthlyActivityData] (presentation).\n  List<MonthlyActivityData> _mapMonthlyActivityToPresentationModel({required List<MonthlyActivityEntity> entities}) {\n    final DateTime todayDateOnly = DateUtils.dateOnly(DateTime.now());\n\n    return entities.map((entity) {\n      final bool isTodayFlag = DateUtils.dateOnly(entity.date) == todayDateOnly;\n      return MonthlyActivityData(\n        day: entity.date.day,\n        date: entity.date,\n        minutes: entity.minutes,\n        isToday: isTodayFlag,\n      );\n    }).toList();\n  }\n\n  /// Maps a list of [YearlyActivityEntity] (domain) to a list of [YearlyActivityData] (presentation).\n  List<YearlyActivityData> _mapYearlyActivityToPresentationModel({required List<YearlyActivityEntity> entities}) {\n    return entities.map((entity) {\n      return YearlyActivityData(\n        date: entity.date,\n        minutes: entity.minutes,\n      );\n    }).toList();\n  }\n\n  /// Refreshes all activity data\n  Future<void> refreshActivityData() async {\n    if (_isRefreshingActivity) return;\n    _isRefreshingActivity = true;\n\n    // Show loading indicator for activity data\n    _updateState(currentUiState.copyWith(\n      isActivityLoading: true,\n    ));\n\n    // Load data for all time ranges regardless of the currently active range\n    // This ensures all data is available when viewing detailed activity\n    await Future.wait([\n      _loadWeeklyActivityData(),\n      _loadMonthlyActivityData(),\n      _loadYearlyActivityData(),\n    ]);\n\n    // Update usage stats for the current time range\n    final timeRange = _mapActivityTimeRangeToTimeRange(currentUiState.activeTimeRange);\n    final Either<String, UsageStatsEntity> statsResult = await _getActivityStatsUseCase.execute(\n      timeRange: timeRange,\n    );\n\n    UsageStatsEntity? usageStats;\n    statsResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading usage stats: $error');\n      },\n      (UsageStatsEntity stats) {\n        usageStats = stats;\n      },\n    );\n\n    // Update UI state with refreshed data\n    _updateState(currentUiState.copyWith(\n      usageStats: usageStats,\n      isActivityLoading: false,\n    ));\n\n    _isRefreshingActivity = false;\n  }\n\n  /// Shows the detailed activity page with current activity data\n  void _showDetailedActivityPage(BuildContext context) {\n    context.navigatorPush(\n      DetailedActivityPage(\n        weeklyActivity: currentUiState.weeklyActivity,\n        monthlyActivity: currentUiState.monthlyActivity,\n        yearlyActivity: currentUiState.yearlyActivity,\n        onAnimationInit: initAnimationController,\n        isLoading: currentUiState.isActivityLoading,\n      ),\n    );\n  }\n\n  /// Changes the active time range and loads the corresponding data\n  Future<void> changeTimeRange(ActivityTimeRange newTimeRange) async {\n    if (newTimeRange == currentUiState.activeTimeRange) return;\n\n    // Update state with new time range first (for UI feedback)\n    _updateState(currentUiState.copyWith(\n      activeTimeRange: newTimeRange,\n      // Optional: Set a loading state for the specific chart\n      // isActivityLoading: true,\n    ));\n\n    // Load data for the new time range\n    await _loadActivityDataForTimeRange(newTimeRange);\n\n    // Update stats for the new time range\n    final statsResult = await _getActivityStatsUseCase.execute(\n      timeRange: _mapActivityTimeRangeToTimeRange(newTimeRange),\n    );\n\n    statsResult.fold(\n      (String error) async {\n        await addUserMessage(error);\n        logErrorStatic('ProfilePresenter', 'Error loading usage stats: $error');\n      },\n      (UsageStatsEntity stats) {\n        _updateState(currentUiState.copyWith(\n          usageStats: stats,\n        ));\n      } as Future<Null> Function(dynamic r),\n    );\n\n    // Restart animation for the active chart\n    restartAnimation(newTimeRange);\n  }\n\n  /// Records test usage data via the [AppLifecycleTracker].\n  /// The UI will update automatically via the stream listener.\n  void recordTestUsage({required Duration duration}) {\n    _appLifecycleTracker.recordTestUsage(duration: duration);\n    // No manual refresh needed here. Listener handles UI update.\n    addUserMessage(\"Recorded ${duration.inMinutes} minutes. Chart will update shortly.\");\n  }\n\n  /// Handles the tap action for the \"Set Daily Reminder\" button.\n  void navigateToSetReminder(BuildContext context) {\n    addUserMessage(\"Set Reminder feature coming soon!\");\n    // Example: Navigator.pushNamed(context, '/set-reminder');\n  }\n\n  // --- BasePresenter Overrides ---\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    // This controls the overall page loading state\n    _updateState(currentUiState.copyWith(isLoading: loading));\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async {\n    _updateState(currentUiState.copyWith(\n      userMessage: () => message,\n    ));\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/profile/widgets/lifetime_activity_card.dart", "file_name": "lifetime_activity_card.dart", "line": 22, "line_from": 22, "line_to": 112, "snippet": "  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(\n          'Lifetime Activity',\n          style: theme.textTheme.titleLarge?.copyWith(\n            fontWeight: FontWeight.bold,\n            color: context.color.primaryColor,\n          ),\n        ),\n        gapH10,\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          spacing: tenPx,\n          children: [\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icQuran,\n              value: totalReads,\n              label: 'Readings',\n            ),\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icBookmark,\n              value: totalBookmarks,\n              label: context.l10n.bookmark,\n            ),\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icSettings,\n              value: totalNotes,\n              label: context.l10n.pin,\n            ),\n            _StatItem(\n              theme: theme,\n              icon: SvgPath.icSettings,\n              value: totalNotes,\n              label: context.l10n.note,\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n\nclass _StatItem extends StatelessWidget {\n  const _StatItem({\n    required this.theme,\n    required this.icon,\n    required this.value,\n    required this.label,\n  });\n\n  final ThemeData theme;\n  final String icon;\n  final int value;\n  final String label;\n\n  @override\n  Widget build(BuildContext context) {\n    return Expanded(\n      child: Container(\n        height: 75.px,\n        decoration: BoxDecoration(\n          color: context.color.tabBarShade,\n          borderRadius: radius12,\n        ),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(\n              '${value.toLocalizedString(context)}+',\n              style: theme.textTheme.titleMedium?.copyWith(\n                fontWeight: FontWeight.w600,\n              ),\n            ),\n            gapH4,\n            Text(\n              label,\n              style: theme.textTheme.bodySmall?.copyWith(\n                color: context.color.subtitleColor,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "paint", "docstring": "", "module": "widgets", "file_path": "presentation/profile/widgets/chart_animations.dart", "file_name": "chart_animations.dart", "line": 27, "line_from": 27, "line_to": 124, "snippet": "  void paint(Canvas canvas, Size size) {\n    final width = size.width;\n    final height = size.height;\n\n    if (values.isEmpty) return;\n\n    // Calculate spacing between bars\n    final totalBarsWidth = barWidth * values.length;\n    final spacing = (width - totalBarsWidth) / (values.length + 1);\n\n    // Draw each bar with ripple animation\n    for (int i = 0; i < values.length; i++) {\n      final normalizedValue = values[i] / maxValue;\n      final barHeight = normalizedValue * height * animationValue;\n\n      // Calculate bar position\n      final left = spacing + (spacing + barWidth) * i;\n      final top = height - barHeight;\n      final rect = RRect.fromRectAndRadius(\n        Rect.fromLTWH(left, top, barWidth, barHeight),\n        Radius.circular(cornerRadius),\n      );\n\n      // Create gradient for each bar\n      final gradient = LinearGradient(\n        begin: Alignment.topCenter,\n        end: Alignment.bottomCenter,\n        colors: [\n          colors[i % colors.length].withOpacityInt(0.8),\n          colors[i % colors.length],\n        ],\n      );\n\n      // Paint bar with gradient\n      final paint = Paint()\n        ..shader = gradient.createShader(rect.outerRect)\n        ..style = PaintingStyle.fill;\n\n      canvas.drawRRect(rect, paint);\n\n      // Add glow effect (optional)\n      if (animationValue > 0.7) {\n        final glowPaint = Paint()\n          ..color = colors[i % colors.length].withOpacityInt(0.2)\n          ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8);\n\n        canvas.drawRRect(rect, glowPaint);\n      }\n\n      // Add ripple effect on top of bar (wave animation)\n      if (animationValue > 0.9 && values[i] > 0) {\n        const double waveHeight = 3.0;\n        const double waveFrequency = 10.0;\n        final double wavePhase = animationValue * 10.0;\n\n        final wavePaint = Paint()\n          ..color = Colors.white.withOpacityInt(0.3)\n          ..style = PaintingStyle.stroke\n          ..strokeWidth = 1.5;\n\n        final wavePath = Path();\n        double startX = left;\n        wavePath.moveTo(startX, top + waveHeight * sin(startX / waveFrequency + wavePhase));\n\n        for (double x = startX; x <= left + barWidth; x += 2) {\n          final y = top + waveHeight * sin(x / waveFrequency + wavePhase);\n          wavePath.lineTo(x, y);\n        }\n\n        canvas.drawPath(wavePath, wavePaint);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant AnimatedBarChartPainter oldDelegate) {\n    return oldDelegate.animationValue != animationValue;\n  }\n}\n\n/// Custom line chart with animation effects\nclass AnimatedLineChart extends StatefulWidget {\n  final List<FlSpot> spots;\n  final Color lineColor;\n  final Color gradientColor;\n  final bool animate;\n\n  const AnimatedLineChart({\n    super.key,\n    required this.spots,\n    required this.lineColor,\n    required this.gradientColor,\n    this.animate = true,\n  });\n\n  @override\n  State<AnimatedLineChart> createState() => _AnimatedLineChartState();\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "widgets", "file_path": "presentation/profile/widgets/chart_animations.dart", "file_name": "chart_animations.dart", "line": 131, "line_from": 131, "line_to": 326, "snippet": "  void initState() {\n    super.initState();\n    _animationController = AnimationController(\n      vsync: this,\n      duration: const Duration(milliseconds: 1500),\n    );\n\n    _animation = CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.elasticOut,\n    );\n\n    if (widget.animate) {\n      _animationController.forward();\n    } else {\n      _animationController.value = 1.0;\n    }\n  }\n\n  @override\n  void dispose() {\n    _animationController.dispose();\n    super.dispose();\n  }\n\n  void reset() {\n    _animationController.reset();\n    _animationController.forward();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _animation,\n      builder: (context, child) {\n        final animatedSpots = _getAnimatedSpots();\n\n        return LineChart(\n          LineChartData(\n            gridData: const FlGridData(show: false),\n            titlesData: FlTitlesData(\n              topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),\n              rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),\n              bottomTitles: AxisTitles(\n                sideTitles: SideTitles(\n                  showTitles: true,\n                  getTitlesWidget: (value, meta) {\n                    // Show every 5th point or important x values\n                    if (value % 5 != 0 && value != 1) {\n                      return const SizedBox();\n                    }\n                    return Padding(\n                      padding: const EdgeInsets.only(top: 8.0),\n                      child: Text(\n                        value.toInt().toString(),\n                        style: Theme.of(context).textTheme.bodySmall,\n                      ),\n                    );\n                  },\n                ),\n              ),\n              leftTitles: AxisTitles(\n                sideTitles: SideTitles(\n                  showTitles: true,\n                  reservedSize: 30,\n                  getTitlesWidget: (value, meta) {\n                    if (value == 0) return const SizedBox();\n                    return Padding(\n                      padding: const EdgeInsets.only(right: 8.0),\n                      child: Text(\n                        value.toInt().toString(),\n                        style: Theme.of(context).textTheme.bodySmall,\n                      ),\n                    );\n                  },\n                ),\n              ),\n            ),\n            borderData: FlBorderData(show: false),\n            lineBarsData: [\n              LineChartBarData(\n                spots: animatedSpots,\n                isCurved: true,\n                curveSmoothness: 0.3,\n                color: widget.lineColor,\n                barWidth: 3,\n                isStrokeCapRound: true,\n                dotData: FlDotData(\n                  show: true,\n                  getDotPainter: (spot, percent, barData, index) {\n                    // Determine if this is today's spot based on index\n                    final bool isToday = index == (animatedSpots.length - 1);\n                    return FlDotCirclePainter(\n                      radius: isToday ? 5 * _animation.value : 3 * _animation.value, // Larger radius for today\n                      color: widget.lineColor, // Primary color for dots\n                      strokeWidth: 1,\n                      strokeColor: Theme.of(context).cardColor, // Use card background for stroke\n                    );\n                  },\n                ),\n                belowBarData: BarAreaData(\n                  show: true,\n                  color: widget.gradientColor,\n                  gradient: LinearGradient(\n                    colors: [\n                      widget.gradientColor.withOpacityInt(0.3), // Start a bit stronger\n                      widget.gradientColor.withOpacityInt(0.05), // End very transparent\n                    ],\n                    begin: Alignment.topCenter,\n                    end: Alignment.bottomCenter,\n                  ),\n                ),\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n\n  List<FlSpot> _getAnimatedSpots() {\n    if (widget.spots.isEmpty) return [];\n\n    // Animate the growth of the line\n    final animationValue = _animation.value;\n\n    // Animate both y values and line progress\n    return widget.spots.asMap().entries.map((entry) {\n      final index = entry.key;\n      final spot = entry.value;\n\n      // Determine if this spot should be shown based on animation progress\n      if (index / widget.spots.length > animationValue) {\n        return FlSpot(spot.x, 0); // Not yet visible\n      }\n\n      // Animate the y value\n      return FlSpot(spot.x, spot.y * animationValue);\n    }).toList();\n  }\n}\n\n/// Heat map cell for yearly activity visualization\nclass HeatMapCell extends StatelessWidget {\n  final double value;\n  final double maxValue;\n  final Color baseColor;\n  final bool isAnimated;\n  final bool isHighlighted;\n\n  const HeatMapCell({\n    super.key,\n    required this.value,\n    required this.maxValue,\n    required this.baseColor,\n    this.isAnimated = true,\n    this.isHighlighted = false,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final intensity = value > 0 ? (value / maxValue).clamp(0.1, 1.0) : 0.0;\n\n    return TweenAnimationBuilder<double>(\n      tween: Tween<double>(begin: 0, end: intensity),\n      duration: Duration(milliseconds: isAnimated ? 800 : 0),\n      curve: Curves.easeInOut,\n      builder: (context, value, child) {\n        // Calculate color based on intensity\n        final color = intensity > 0 ? Color.lerp(baseColor.withOpacityInt(0.2), baseColor, value)! : Colors.transparent;\n\n        return Container(\n          margin: const EdgeInsets.all(1),\n          decoration: BoxDecoration(\n            color: color,\n            borderRadius: BorderRadius.circular(2),\n            boxShadow: isHighlighted\n                ? [\n                    BoxShadow(\n                      color: baseColor.withOpacityInt(0.4),\n                      blurRadius: 4,\n                      spreadRadius: 1,\n                    ),\n                  ]\n                : null,\n          ),\n          child: AnimatedScale(\n            scale: isHighlighted ? 1.1 : 1.0,\n            duration: const Duration(milliseconds: 200),\n            child: const SizedBox.square(dimension: 10),\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "duplicates", "docstring": "", "module": "activity_details", "file_path": "presentation/profile/widgets/activity_details/monthly_activity_chart_view.dart", "file_name": "monthly_activity_chart_view.dart", "line": 46, "line_from": 46, "line_to": 237, "snippet": "    // Create fixed y-axis labels to avoid duplicates\n    final List<double> yLabels = [0]; // Always show 0\n    if (maxYValue <= 60) {\n      // If max is less than an hour, show minutes\n      final double interval = (maxYValue / 3).ceil().toDouble();\n      yLabels.addAll([interval, 2 * interval, 3 * interval]);\n    } else {\n      // If max includes hours, ensure proper hour spacing\n      final int maxHours = (maxYValue / 60).ceil();\n      final double hourInterval = (maxHours / 3).ceil().toDouble();\n      yLabels.addAll([hourInterval * 60, 2 * hourInterval * 60, 3 * hourInterval * 60]);\n    }\n\n    return Card(\n      elevation: 0,\n      shape: RoundedRectangleBorder(\n        borderRadius: radius12,\n        side: BorderSide(color: widget.theme.dividerColor.withOpacityInt(0.5)),\n      ),\n      clipBehavior: Clip.antiAlias,\n      color: context.color.iconBgColor,\n      child: Padding(\n        padding: padding15,\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Title section\n            Text(\n              'Monthly Activity (${DateFormat('MMMM yyyy').format(DateTime.now())})',\n              style: widget.theme.textTheme.titleMedium?.copyWith(\n                fontWeight: FontWeight.bold,\n                color: widget.theme.textTheme.bodyLarge?.color,\n              ),\n            ),\n            gapH16,\n\n            // Bar chart for days\n            SizedBox(\n              height: 180,\n              child: BarChart(\n                BarChartData(\n                  alignment: BarChartAlignment.spaceAround,\n                  maxY: maxYValue,\n                  gridData: const FlGridData(show: false),\n                  titlesData: FlTitlesData(\n                    topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),\n                    rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),\n                    bottomTitles: AxisTitles(\n                      sideTitles: SideTitles(\n                        showTitles: true,\n                        getTitlesWidget: (value, meta) {\n                          final day = value.toInt();\n                          // Only show every 5th day or 1st day to avoid crowding\n                          if (day % 5 != 0 && day != 1 && day != data.length) {\n                            return const SizedBox();\n                          }\n                          return Padding(\n                            padding: const EdgeInsets.only(top: 8.0),\n                            child: Text(\n                              day.toString(),\n                              style: widget.theme.textTheme.bodySmall?.copyWith(\n                                color: context.color.subtitleColor,\n                                fontSize: 10,\n                              ),\n                            ),\n                          );\n                        },\n                        reservedSize: 28,\n                      ),\n                    ),\n                    leftTitles: AxisTitles(\n                      sideTitles: SideTitles(\n                        showTitles: true,\n                        reservedSize: 40,\n                        // Use our explicit label values\n                        interval: 1,\n                        getTitlesWidget: (value, meta) {\n                          // Check if this value is in our yLabels (with small tolerance)\n                          bool isLabelValue = false;\n                          double labelToUse = 0;\n\n                          for (final labelValue in yLabels) {\n                            if ((value - labelValue).abs() < 1.0) {\n                              isLabelValue = true;\n                              labelToUse = labelValue;\n                              break;\n                            }\n                          }\n\n                          if (!isLabelValue) {\n                            return const SizedBox.shrink();\n                          }\n\n                          // Format the label based on its value\n                          final String label;\n                          if (labelToUse >= 60) {\n                            final int hours = (labelToUse / 60).floor();\n                            label = '${hours}h';\n                          } else {\n                            label = '${labelToUse.toInt()}m';\n                          }\n\n                          return Padding(\n                            padding: const EdgeInsets.only(right: 8.0),\n                            child: Text(\n                              label,\n                              style: widget.theme.textTheme.bodySmall?.copyWith(\n                                color: context.color.subtitleColor,\n                              ),\n                            ),\n                          );\n                        },\n                      ),\n                    ),\n                  ),\n                  borderData: FlBorderData(show: false),\n                  barGroups: List.generate(data.length, (i) {\n                    final dayData = data[i];\n                    final bool isToday = dayData.isToday;\n                    return BarChartGroupData(\n                      x: dayData.day,\n                      barRods: [\n                        BarChartRodData(\n                          toY: dayData.minutes,\n                          color: isToday ? primaryColor : primaryColor.withOpacityInt(0.5),\n                          width: 8, // Thinner bars due to more data points\n                          borderRadius: const BorderRadius.only(\n                            topLeft: Radius.circular(4),\n                            topRight: Radius.circular(4),\n                          ),\n                          backDrawRodData: BackgroundBarChartRodData(\n                            show: true,\n                            toY: maxYValue,\n                            color: context.color.chartShade.withOpacityInt(0.6),\n                          ),\n                        ),\n                      ],\n                    );\n                  }),\n                  barTouchData: BarTouchData(\n                    touchTooltipData: BarTouchTooltipData(\n                      tooltipRoundedRadius: 8,\n                      tooltipBorder: BorderSide(\n                        color: context.color.borderColor,\n                        width: 1,\n                      ),\n                      getTooltipItem: (group, groupIndex, rod, rodIndex) {\n                        final day = group.x;\n                        final minutesTotal = rod.toY.round();\n                        final hours = minutesTotal ~/ 60;\n                        final minutes = minutesTotal % 60;\n\n                        // Format the day to show the date (e.g., Aug 15)\n                        final DateTime date = DateTime(now.year, now.month, day);\n                        final String dayText = DateFormat('MMM d').format(date);\n\n                        String timeText = '';\n                        if (hours > 0) {\n                          timeText += '$hours h ';\n                        }\n                        timeText += '$minutes min';\n\n                        return BarTooltipItem(\n                          '$dayText\\n',\n                          widget.theme.textTheme.bodySmall!.copyWith(\n                            fontWeight: FontWeight.bold,\n                            color: widget.theme.textTheme.bodyLarge?.color,\n                          ),\n                          children: [\n                            TextSpan(\n                              text: timeText,\n                              style: TextStyle(\n                                color: primaryColor,\n                                fontWeight: FontWeight.bold,\n                              ),\n                            ),\n                          ],\n                        );\n                      },\n                      getTooltipColor: (group) {\n                        return widget.theme.cardColor;\n                      },\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "activity_dashboard", "file_path": "presentation/profile/widgets/activity_dashboard/weekly_activity_chart.dart", "file_name": "weekly_activity_chart.dart", "line": 19, "line_from": 19, "line_to": 152, "snippet": "  Widget build(BuildContext context) {\n    assert(activityData.length <= 7,\n        \"WeeklyActivityChart requires at most 7 days of data.\");\n\n    final List<ActivityData> data = activityData.isEmpty\n        ? List.generate(\n            7,\n            (index) => ActivityData(\n              day: DateTime.now().subtract(Duration(days: 6 - index)).day,\n              date: DateTime.now().subtract(Duration(days: 6 - index)),\n              minutes: 0,\n              isToday: index == 6,\n            ),\n          )\n        : activityData;\n\n    final double maxMinutesInWeek = data.isNotEmpty\n        ? data\n            .map((d) => d.minutes)\n            .fold(0.0, (prev, current) => max(prev, current))\n        : 0.0;\n\n    final double effectiveMaxMinutes =\n        (maxMinutesInWeek <= 0) ? 30.0 : maxMinutesInWeek;\n\n    final Color primaryChartColor = context.color.primaryColor;\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        SizedBox(\n          height: 160,\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            crossAxisAlignment: CrossAxisAlignment.end,\n            children: List.generate(\n              data.length,\n              (index) => _ActivityBar(\n                theme: theme,\n                data: data[index],\n                maxMinutesInWeek: effectiveMaxMinutes,\n                barColor: primaryChartColor,\n                inactiveBarColor: primaryChartColor.withOpacityInt(0.2),\n              ),\n            ),\n          ),\n        ),\n        gapH12,\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceAround,\n          children: List.generate(\n            data.length,\n            (index) => _DayLabel(\n              day: data[index].day,\n              isToday: data[index].isToday,\n              isActive: data[index].isActive,\n              theme: theme,\n              activeColor: primaryChartColor,\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass _ActivityBar extends StatelessWidget {\n  const _ActivityBar({\n    required this.theme,\n    required this.data,\n    required this.maxMinutesInWeek,\n    required this.barColor,\n    required this.inactiveBarColor,\n  });\n\n  final ThemeData theme;\n  final ActivityData data;\n  final double maxMinutesInWeek;\n  final Color barColor;\n  final Color inactiveBarColor;\n\n  @override\n  Widget build(BuildContext context) {\n    const double maxBarHeight = 125.0;\n    const double minBarHeight = 5.0;\n    const double barWidth = 30.0;\n\n    final double ratio =\n        maxMinutesInWeek > 0 ? data.minutes / maxMinutesInWeek : 0.0;\n\n    final double barHeight = data.isActive\n        ? (ratio * maxBarHeight).clamp(minBarHeight, maxBarHeight)\n        : minBarHeight;\n\n    final Color inactiveColor = context.color.primaryColor20;\n\n    final Color currentBarColor = data.isActive ? barColor : inactiveColor;\n\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.end,\n      children: [\n        SizedBox(\n          height: sixteenPx,\n          child: (data.isActive && data.minutes >= 1)\n              ? Text(\n                  \"${data.minutes.toInt().toLocalizedString(context)}m\",\n                  style: theme.textTheme.bodySmall?.copyWith(\n                    color: barColor,\n                    fontWeight: FontWeight.w500,\n                    fontSize: tenPx,\n                  ),\n                )\n              : null,\n        ),\n        gapH4,\n        TweenAnimationBuilder<double>(\n          tween: Tween<double>(begin: 0, end: barHeight),\n          duration: const Duration(milliseconds: 800),\n          curve: Curves.elasticOut,\n          builder: (context, height, child) {\n            return Container(\n              width: barWidth,\n              height: height.clamp(minBarHeight, maxBarHeight),\n              decoration: BoxDecoration(\n                color: currentBarColor,\n                borderRadius: radius8,\n              ),\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"}, {"structure_type": "function", "name": "[];", "docstring": "", "module": "presenter", "file_path": "presentation/tafseer/presenter/tafseer_presenter.dart", "file_name": "tafseer_presenter.dart", "line": 911, "line_from": 911, "line_to": 939, "snippet": "    List<Future<void>> futures = [];\n    for (TTDbFileModel model in modelsToDownload) {\n      if (!isAlreadyDownloaded(model) && context.mounted) {\n        futures.add(_loadTafseer(model, context));\n      }\n    }\n    await Future.wait(futures);\n    uiState.value = uiState.value.copyWith(isAllFilesDownloading: false);\n  }\n\n  List<MapEntry<String, List<TTDbFileModel>>> _getDownloadableTafseers(\n      Map<String, List<TTDbFileModel>> allTafseers,\n      List<TTDbFileModel> downloadedModels) {\n    final List<TTDbFileModel> allItems =\n        allTafseers.values.expand((models) => models).toList();\n    final Set<String> downloadedFileNames =\n        downloadedModels.map((model) => model.fileName).toSet();\n    final List<TTDbFileModel> downloadableItems = allItems\n        .where((model) => !downloadedFileNames.contains(model.fileName))\n        .toList();\n\n    return allTafseers.entries\n        .map((entry) => MapEntry(\n            entry.key,\n            entry.value\n                .where((model) => downloadableItems.contains(model))\n                .toList()))\n        .toList();\n  }"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "widgets", "file_path": "presentation/tafseer/widgets/custom_speed_dial.dart", "file_name": "custom_speed_dial.dart", "line": 41, "line_from": 41, "line_to": 224, "snippet": "  void initState() {\n    super.initState();\n    presenter = CustomSpeedDialPresenter(vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _isDisposed = true;\n    presenter.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isDisposed) return const SizedBox();\n\n    final TafseerPresenter tafseerPresenter = locate<TafseerPresenter>();\n    final NotePresenter notePresenter = locate<NotePresenter>();\n\n    return PresentableWidgetBuilder<CustomSpeedDialPresenter>(\n      presenter: presenter,\n      builder: () {\n        final isOpened = presenter.state.isOpened;\n        final slideAnimations = presenter.slideAnimations;\n\n        return StreamBuilder<void>(\n          stream: notePresenter.noteUpdateStream,\n          builder: (context, _) {\n            return FutureBuilder<bool>(\n              future: tafseerPresenter.hasExistingNote(\n                  widget.surahID, widget.ayahID),\n              builder: (context, snapshot) {\n                final bool hasNote = snapshot.data ?? false;\n\n                return Column(\n                  mainAxisAlignment: MainAxisAlignment.end,\n                  crossAxisAlignment: CrossAxisAlignment.end,\n                  children: [\n                    SpeedDialItem(\n                      isOpened: isOpened,\n                      theme: Theme.of(context),\n                      svgIconPath:\n                          hasNote ? SvgPath.icEdit : SvgPath.icNoteFavorite,\n                      backgroundColor: QuranColor.axolotlColor,\n                      label: hasNote\n                          ? context.l10n.editNote\n                          : context.l10n.createNote,\n                      onTap: () {\n                        widget.onTapCreateNote();\n                        presenter.closeSpeedDial();\n                      },\n                      slideAnimation: slideAnimations[0],\n                    ),\n                    SpeedDialItem(\n                      isOpened: isOpened,\n                      theme: Theme.of(context),\n                      svgIconPath: SvgPath.icCopyFill,\n                      backgroundColor: QuranColor.tigerEyeColor,\n                      label: context.l10n.copyTafseer,\n                      onTap: () {\n                        widget.onTapCopy();\n                        presenter.closeSpeedDial();\n                      },\n                      slideAnimation: slideAnimations[1],\n                    ),\n                    SpeedDialItem(\n                      isOpened: isOpened,\n                      theme: Theme.of(context),\n                      svgIconPath: SvgPath.icShare2,\n                      backgroundColor: QuranColor.cornflowerBlueColor,\n                      label: context.l10n.share,\n                      onTap: () {\n                        widget.onTapShare();\n                        presenter.closeSpeedDial();\n                      },\n                      slideAnimation: slideAnimations[2],\n                    ),\n                    FloatingActionButton(\n                      elevation: 2,\n                      shape: RoundedRectangleBorder(borderRadius: radius20),\n                      backgroundColor: context.color.primaryButtonColor,\n                      onPressed: presenter.toggleSpeedDial,\n                      child: AnimatedRotation(\n                        turns: isOpened ? 0.5 : 0,\n                        duration: const Duration(milliseconds: 300),\n                        child: SvgImage(\n                          isOpened ? SvgPath.icClose : SvgPath.icDashboard,\n                          width: twentyFourPx,\n                          height: twentyFourPx,\n                          color: context.color.primaryButtonTextColor,\n                        ),\n                      ),\n                    ),\n                  ],\n                );\n              },\n            );\n          },\n        );\n      },\n    );\n  }\n}\n\nclass SpeedDialItem extends StatelessWidget {\n  const SpeedDialItem({\n    super.key,\n    required this.isOpened,\n    required this.theme,\n    required this.svgIconPath,\n    required this.backgroundColor,\n    required this.label,\n    required this.onTap,\n    required this.slideAnimation,\n  });\n\n  final bool isOpened;\n  final ThemeData theme;\n  final String svgIconPath;\n  final Color backgroundColor;\n  final String label;\n  final VoidCallback onTap;\n  final Animation<Offset> slideAnimation;\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedOpacity(\n      opacity: isOpened ? 1.0 : 0.0,\n      duration: const Duration(milliseconds: 300),\n      child: isOpened\n          ? SlideTransition(\n              position: slideAnimation,\n              child: OnTapWidget(\n                onTap: onTap,\n                theme: theme,\n                child: Transform.translate(\n                  offset: Offset(0, isOpened ? 0 : 20),\n                  child: Container(\n                    margin: EdgeInsets.only(bottom: tenPx),\n                    child: Row(\n                      mainAxisAlignment: MainAxisAlignment.end,\n                      mainAxisSize: MainAxisSize.min,\n                      children: [\n                        Material(\n                          color: context.color.primaryColor10,\n                          elevation: 2,\n                          borderRadius: radius20,\n                          child: Padding(\n                            padding: EdgeInsets.symmetric(\n                                horizontal: sixteenPx, vertical: eightPx),\n                            child: Text(\n                              label,\n                              style: context.quranText.buttonText!.copyWith(\n                                color: context.color.primaryColor,\n                                fontWeight: FontWeight.normal,\n                              ),\n                            ),\n                          ),\n                        ),\n                        gapW8,\n                        FloatingActionButton(\n                          heroTag: label,\n                          elevation: 2,\n                          mini: true,\n                          splashColor: Colors.transparent,\n                          backgroundColor: backgroundColor,\n                          onPressed: onTap,\n                          child: SvgImage(\n                            svgIconPath,\n                            width: twentyPx,\n                            height: twentyPx,\n                            color: context.color.primaryButtonTextColor,\n                          ),\n                        ),\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            )\n          : const SizedBox(),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/tafseer/widgets/view_tafseer_details.dart", "file_name": "view_tafseer_details.dart", "line": 32, "line_from": 32, "line_to": 137, "snippet": "  Widget build(BuildContext context) {\n    return FutureBuilder<String>(\n      future: tafseerPresenter.getTafsirTextFuture(surahID, ayahID, index),\n      builder: (context, snapshot) {\n        return SingleChildScrollView(\n          physics: const ClampingScrollPhysics(),\n          key: Key('tafseer_details_$index'),\n          child: Container(\n            padding: EdgeInsets.only(\n                left: twentyPx,\n                right: twentyPx,\n                top: thirtyPx,\n                bottom: 30.percentWidth),\n            width: double.infinity,\n            child: Column(\n              key: const Key('tafseer_details_column'),\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                if (snapshot.hasData) ...[\n                  HtmlFormattedText(\n                    tafsirText: snapshot.data!,\n                    theme: theme,\n                    ayahPresenter: ayahPresenter,\n                  ),\n                ] else if (snapshot.hasError) ...[\n                  Text('Error: ${snapshot.error}'),\n                ] else ...[\n                  const Center(child: Text('Loading...')),\n                ],\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass OptimizedHtmlContent extends StatelessWidget {\n  const OptimizedHtmlContent({\n    super.key,\n    required this.tafsirText,\n    required this.theme,\n    required this.tafseerFontSize,\n    required this.arabicFontSize,\n    required this.tafseerArabicFontFamily,\n  });\n\n  final String tafsirText;\n  final ThemeData theme;\n  final double tafseerFontSize;\n  final double arabicFontSize;\n  final ArabicFonts tafseerArabicFontFamily;\n\n  @override\n  Widget build(BuildContext context) {\n    return Html(\n      key: ValueKey(\n          'html_content_${tafseerFontSize}_${arabicFontSize}_${tafseerArabicFontFamily.name}'),\n      data: tafsirText.replaceAll(RegExp(r'\\r?\\n'), '<br/>'),\n      shrinkWrap: true,\n      extensions: [\n        TagExtension(\n          tagsToExtend: {\"longer\"},\n          builder: (ExtensionContext extensionContext) {\n            return Padding(\n              padding: EdgeInsets.only(top: sixteenPx, bottom: sixteenPx),\n              child: SizedBox(\n                width: double.infinity,\n                child: Text(\n                  extensionContext.element!.innerHtml.replaceAll('<br>', \"\\n\"),\n                  textDirection: TextDirection.rtl,\n                  style: TextStyle(\n                    fontSize: arabicFontSize,\n                    fontFamily: tafseerArabicFontFamily.name,\n                    letterSpacing: 0,\n                  ),\n                ),\n              ),\n            );\n          },\n        ),\n      ],\n      style: {\n        \"body\": Style(\n          margin: Margins.zero,\n          textAlign: TextAlign.left,\n          padding: HtmlPaddings.zero,\n          fontFamily: FontFamily.kalpurush,\n          fontSize: FontSize(tafseerFontSize),\n          letterSpacing: 0,\n          lineHeight: const LineHeight(1.5),\n          color: theme.textTheme.bodyMedium!.color,\n        ),\n        \"span\": Style(\n          direction: TextDirection.rtl,\n          lineHeight: const LineHeight(2),\n          letterSpacing: 0,\n          wordSpacing: 2,\n          fontFamily: tafseerArabicFontFamily.name,\n          fontSize: FontSize(arabicFontSize),\n        ),\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/main_page/ui/main_page.dart", "file_name": "main_page.dart", "line": 32, "line_from": 32, "line_to": 181, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    QuranScreen.setUp(context);\n    _mainPagePresenter.updateContext(context);\n    // _tafseerPresenter.updateContext(context);\n    return PopScope(\n      onPopInvokedWithResult: (bool isInvoked, dynamic result) async {\n        final bool isDrawerOpen =\n            _mainPagePresenter.mainScaffoldKey.currentState?.isDrawerOpen ??\n                false;\n        final int currentIndex = _mainPagePresenter.currentUiState.currentIndex;\n\n        if (isDrawerOpen) {\n          _mainPagePresenter.closeDrawer();\n          return;\n        }\n        if (currentIndex != 0) {\n          await _mainPagePresenter.setNavBarIndex(0);\n          return;\n        }\n\n        _mainPagePresenter.showExitDialog(context);\n      },\n      canPop: false,\n      child: PresentableWidgetBuilder(\n        presenter: _mainPagePresenter,\n        builder: () {\n          final MainPageUiState uiState = _mainPagePresenter.currentUiState;\n          return CustomStatusBarColor(\n            statusBarColor: isDarkMode(context)\n                ? theme.colorScheme.secondary\n                : (uiState.currentIndex == 0\n                    ? theme.primaryColor\n                    : context.color.gradientTop),\n            statusBarIconColor: isDarkMode(context)\n                ? Brightness.light\n                : (uiState.currentIndex == 0\n                    ? Brightness.light\n                    : Brightness.dark),\n            navigationBarIconColor:\n                isDarkMode(context) ? Brightness.light : Brightness.dark,\n            navigationBarColor: context.color.bottomNavBgColor,\n            child: Scaffold(\n              key: _mainPagePresenter.mainScaffoldKey,\n              resizeToAvoidBottomInset: false,\n              body: _pages[uiState.currentIndex],\n              drawer: const MainPageDrawer(),\n              bottomNavigationBar: MainNavigationBar(\n                selectedIndex: uiState.currentIndex,\n                onDestinationSelected: (index) {\n                  _mainPagePresenter.changeTabIndex(index);\n                },\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass MainNavigationBar extends StatelessWidget {\n  const MainNavigationBar({\n    super.key,\n    required this.selectedIndex,\n    required this.onDestinationSelected,\n  });\n\n  final int selectedIndex;\n  final ValueChanged<int> onDestinationSelected;\n\n  @override\n  Widget build(BuildContext context) {\n    return Theme(\n      key: const Key('main_navigation_bar_theme'),\n      data: Theme.of(context).copyWith(\n        navigationBarTheme: NavigationBarThemeData(\n          elevation: 0,\n          backgroundColor: context.color.backgroundColor,\n          labelTextStyle: WidgetStateProperty.resolveWith((states) {\n            if (states.contains(WidgetState.selected)) {\n              return TextStyle(\n                fontSize: twelvePx,\n                fontWeight: FontWeight.w600,\n                color: context.color.primaryColor,\n              );\n            }\n            return TextStyle(\n              fontSize: twelvePx,\n              fontWeight: FontWeight.normal,\n              color: context.color.navInactive,\n            );\n          }),\n          indicatorColor: context.color.navBgAc,\n        ),\n      ),\n      child: Container(\n        key: const Key('main_navigation_bar_container'),\n        padding: EdgeInsets.symmetric(horizontal: tenPx),\n        decoration: BoxDecoration(\n          color: context.color.backgroundColor,\n          border: Border(\n            top: BorderSide(\n              color: context.color.borderColor,\n            ),\n          ),\n        ),\n        child: NavigationBar(\n          key: const Key('main_navigation_bar'),\n          backgroundColor: context.color.backgroundColor,\n          selectedIndex: selectedIndex,\n          onDestinationSelected: onDestinationSelected,\n          overlayColor: WidgetStateProperty.all(Colors.transparent),\n          destinations: const [\n            NavDestinationItem(\n              key: Key('home_nav_destination_item'),\n              outlineIcon: SvgPath.icHomeActive,\n              fillIcon: SvgPath.icHomeInactive,\n              label: 'Home',\n            ),\n            NavDestinationItem(\n              key: Key('subject_wise_nav_destination_item'),\n              outlineIcon: SvgPath.icSubjectWiseActive,\n              fillIcon: SvgPath.icSubjectWiseInactive,\n              label: 'Topics',\n            ),\n            NavDestinationItem(\n              key: Key('collection_nav_destination_item'),\n              outlineIcon: SvgPath.icCollectionActive,\n              fillIcon: SvgPath.icCollectionInactive,\n              label: 'Collection',\n            ),\n            NavDestinationItem(\n              key: Key('memorize_nav_destination_item'),\n              outlineIcon: SvgPath.icMemorizeActive,\n              fillIcon: SvgPath.icMemorizeInactive,\n              label: 'Memorize',\n            ),\n            NavDestinationItem(\n              key: Key('profile_nav_destination_item'),\n              outlineIcon: SvgPath.icSettingsFill,\n              fillIcon: SvgPath.icSettingsDeactive,\n              label: 'Profile',\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "class", "name": "NoticeDialogButton extends StatelessWidget", "docstring": "", "module": "drawer", "file_path": "presentation/main_page/widgets/drawer/notice_dialog_button.dart", "file_name": "notice_dialog_button.dart", "line": 11, "line_from": 11, "line_to": 99, "snippet": "class NoticeDialogButton extends StatelessWidget {\n  const NoticeDialogButton({\n    super.key,\n    required this.title,\n    required this.icon,\n    required this.color,\n    this.opacity,\n    this.trailing = true,\n    required this.onPressed,\n    required this.actionType,\n    required this.theme,\n  });\n\n  final String title;\n  final String icon;\n  final Color color;\n  final double? opacity;\n  final VoidCallback onPressed;\n  final ButtonActionType actionType;\n  final bool trailing;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: EdgeInsets.only(bottom: twelvePx),\n      child: OnTapWidget(\n        theme: theme,\n        onTap: onPressed,\n        child: Container(\n          width: QuranScreen.width,\n          padding: EdgeInsets.only(\n              left: eightPx, right: twelvePx, top: twelvePx, bottom: twelvePx),\n          decoration: BoxDecoration(\n            color: theme.primaryColor.withOpacityInt(0.07),\n            borderRadius: radius6,\n          ),\n          child: Row(\n            mainAxisAlignment: trailing\n                ? MainAxisAlignment.spaceBetween\n                : MainAxisAlignment.center,\n            children: [\n              Row(\n                children: [\n                  gapW5,\n                  SizedBox(\n                    width: thirtyPx,\n                    height: thirtyPx,\n                    child: SvgPicture.asset(icon),\n                  ),\n                  gapW15,\n                  SizedBox(\n                    width: trailing ? 55.percentWidth : null,\n                    child: Text(\n                      title,\n                      overflow: TextOverflow.ellipsis,\n                      style: theme.textTheme.titleMedium!.copyWith(\n                        fontWeight: FontWeight.w500,\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n              if (trailing)\n                if (actionType == ButtonActionType.copy)\n                  SvgPicture.asset(\n                    SvgPath.icCopy,\n                    width: eighteenPx,\n                    height: eighteenPx,\n                    colorFilter: buildColorFilter(context.color.subtitleColor),\n                  )\n                else\n                  SvgPicture.asset(\n                    SvgPath.icSend,\n                    width: sixteenPx,\n                    height: sixteenPx,\n                    colorFilter: buildColorFilter(context.color.subtitleColor),\n                  ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum ButtonActionType { copy, send }\n"}, {"structure_type": "function", "name": "_handlePopScope", "docstring": "", "module": "ui", "file_path": "presentation/ayah_detail/ui/ayah_details_page.dart", "file_name": "ayah_details_page.dart", "line": 40, "line_from": 40, "line_to": 278, "snippet": "  Future<void> _handlePopScope() async {\n    await _ayahPresenter.stopAudio();\n    _ayahPresenter.stopAutoScroll();\n    await _ayahPresenter.fetchAndSaveLastAyah();\n  }\n\n  Future<void> _initializePage() async {\n    await _ayahPresenter.initializeAyahDetailsPage(\n      initialPageIndex: initialPageIndex,\n      initialAyahIndex: initialAyahIndex,\n      showPageIndicator: showPageIndicator,\n    );\n    _audioPresenter.setPageChangeSubscription(\n      _ayahPresenter.uiState.stream.map((state) => state.currentPageIndex),\n    );\n\n    // Add preloading logic here after initialization\n    _preloadAyahData();\n  }\n\n  // New method to preload ayah data safely\n  void _preloadAyahData() {\n    // Start a microtask to ensure this runs after initialization\n    Future.microtask(() {\n      final int surahId = initialPageIndex + 1; // Convert to 1-indexed\n      final int currentAyah = initialAyahIndex + 1;\n      final int totalAyahs = CacheData.surahsCache[initialPageIndex].totalAyah;\n\n      // Determine range to preload\n      final int pageSize = _ayahPresenter.pageSize;\n      final int endAyah = (currentAyah + pageSize - 1) > totalAyahs\n          ? totalAyahs\n          : (currentAyah + pageSize - 1);\n\n      // Preload the range\n      _ayahPresenter.getWordsForAyahRange(surahId, currentAyah, endAyah);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n\n    SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(\n      statusBarColor: context.color.gradientTop,\n      statusBarIconBrightness:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      systemNavigationBarIconBrightness:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n    ));\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(\n      value: SystemUiOverlayStyle(\n        statusBarColor: context.color.gradientTop,\n        statusBarIconBrightness:\n            isDarkMode(context) ? Brightness.light : Brightness.dark,\n      ),\n      child: Stack(\n        children: [\n          PopScope(\n            onPopInvokedWithResult: (bool isPopInvoked, dynamic result) =>\n                _handlePopScope(),\n            child: PresentableWidgetBuilder(\n              presenter: _ayahPresenter,\n              onInit: () {\n                // Use post-frame callback to ensure initialization happens after the first build\n                WidgetsBinding.instance.addPostFrameCallback((_) {\n                  _initializePage();\n                });\n              },\n              builder: () {\n                final AyahViewUiState uiState = _ayahPresenter.uiState.value;\n                final AudioUIState audioUIState = _audioPresenter.uiState.value;\n\n                return Scaffold(\n                  backgroundColor: context.color.gradientTop,\n                  key: scaffoldKey,\n                  endDrawer: const MiniSettingsDrawer(isAyahPage: true),\n                  extendBody: true,\n                  endDrawerEnableOpenDragGesture: false,\n                  body: SafeArea(\n                    child: FancyScaffold(\n                      floatingWidgetController:\n                          _ayahPresenter.floatingWidgetController,\n                      isAudioPlaying: audioUIState.showPlayerControls ||\n                          _ayahPresenter\n                              .currentUiState.autoScrollOptionTurnedOn,\n                      appBar: AyahDetailsPageAppBar(\n                        key: const Key(_ayahDetailsPageAppBarKey),\n                        ayahPresenter: _ayahPresenter,\n                        scaffoldKey: scaffoldKey,\n                        theme: theme,\n                      ),\n                      body: Column(\n                        children: [\n                          Expanded(\n                            child: AyahPageScrollView(\n                              key: const Key(_ayahPageScrollViewKey),\n                              ayahPresenter: _ayahPresenter,\n                              uiState: uiState,\n                              showPageIndicator: showPageIndicator,\n                            ),\n                          ),\n                        ],\n                      ),\n                      bottomNavigationBarHeight:\n                          uiState.bottomNavigationBarHeight,\n                      bottomNavigationBar: _BottomNavigationWidget(\n                        audioUIState: audioUIState,\n                        uiState: uiState,\n                        audioPresenter: _audioPresenter,\n                        ayahPresenter: _ayahPresenter,\n                        theme: theme,\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n          StreamBuilder<AudioAction>(\n            stream: _audioPresenter.actionStream,\n            builder: (context, snapshot) {\n              if (snapshot.hasData) {\n                final AudioAction action = snapshot.data!;\n                switch (action.type) {\n                  case AudioActionType.scrollToAyah:\n                    final scrollController = ScrollControllerManager()\n                        .getScrollController(action.pageIndex!);\n                    if (scrollController.isAttached) {\n                      WidgetsBinding.instance.addPostFrameCallback((_) {\n                        scrollController.scrollTo(\n                          index: action.ayahIndex!,\n                          duration: const Duration(milliseconds: 100),\n                          curve: Curves.easeInOut,\n                        );\n                      });\n                    }\n                    break;\n                  case AudioActionType.jumpToPage:\n                    WidgetsBinding.instance.addPostFrameCallback((_) {\n                      _ayahPresenter.pageController\n                          .jumpToPage(action.pageIndex!);\n                    });\n                    break;\n                  case AudioActionType.jumpToAyah:\n                    final scrollController = ScrollControllerManager()\n                        .getScrollController(action.pageIndex!);\n                    if (scrollController.isAttached) {\n                      WidgetsBinding.instance.addPostFrameCallback((_) {\n                        scrollController.jumpTo(index: action.ayahIndex!);\n                      });\n                    }\n                    break;\n                  case AudioActionType.setBottomBarHeight:\n                    WidgetsBinding.instance.addPostFrameCallback((_) {\n                      _ayahPresenter\n                          .setBottomNavigationBarHeight(action.height!);\n                    });\n                    break;\n                }\n              }\n              return const SizedBox.shrink();\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass _BottomNavigationWidget extends StatelessWidget {\n  const _BottomNavigationWidget({\n    required this.audioUIState,\n    required this.uiState,\n    required this.audioPresenter,\n    required this.ayahPresenter,\n    required this.theme,\n  });\n\n  final AudioUIState audioUIState;\n  final AyahViewUiState uiState;\n  final AudioPresenter audioPresenter;\n  final AyahPresenter ayahPresenter;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    if (audioUIState.isDownloading) {\n      // return AudioDownloadState(\n      //   qariName: audioPresenter.getSelectedReciterName(),\n      //   downloadRange:\n      //       '${audioUIState.selectedStartSurahName} - ${audioUIState.selectedEndSurahName}',\n      //   downloadProgress: audioUIState.downloadProgress,\n      //   onCancelPressed: () async => await audioPresenter.cancelDownload(),\n      //   bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n      //   theme: theme,\n      // );\n      return AudioDownloadStatusBar(\n        qariName: audioPresenter.getSelectedReciterName(),\n        downloadRange:\n            '${audioUIState.selectedStartSurahName} - ${audioUIState.selectedEndSurahName}',\n        downloadProgress: audioUIState.downloadProgress,\n        onCancelPressed: () async => await audioPresenter.cancelDownload(),\n        bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n        theme: theme,\n      );\n    }\n\n    if (audioUIState.showPlayerControls) {\n      return AudioPlayerWidget(\n        theme: theme,\n        progress: audioUIState.currentPlayTime != null &&\n                audioUIState.totalDuration != null\n            ? audioUIState.currentPlayTime!.inMilliseconds /\n                audioUIState.totalDuration!.inMilliseconds\n            : 0.0,\n        audioPresenter: audioPresenter,\n        isFromAyahDetail: true,\n        bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n      );\n    }\n\n    if (uiState.autoScrollOptionTurnedOn) {\n      return AutoScrollControlWidget(\n        theme: theme,\n        ayahPresenter: ayahPresenter,\n        bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n      );\n    }\n\n    return SimpleNavigationButtons(\n      ayahPresenter: ayahPresenter,\n      audioPresenter: audioPresenter,\n      theme: theme,\n      bottomNavigationBarHeight: uiState.bottomNavigationBarHeight,\n    );\n  }\n}"}, {"structure_type": "function", "name": "{};", "docstring": "", "module": "presenter", "file_path": "presentation/ayah_detail/presenter/ayah_presenter.dart", "file_name": "ayah_presenter.dart", "line": 82, "line_from": 82, "line_to": 1198, "snippet": "  final Map<int, Future<List<WordByWordEntity>>> _wordCache = {};\n  final Map<String, Future<List<WordByWordEntity>>> _paginatedWordCache = {};\n  final int _pageSize = 10; // Number of ayahs to load per page\n  Timer? _autoScrollTimer;\n  StreamSubscription<Either<String, SettingsStateEntity>>? _settingsChangeSub;\n  double _currentScrollSpeed = defaultScrollSpeed;\n  static const double defaultScrollSpeed =\n      0.1; // Reduced by factor of 10 from original 1.0\n  String selectedText = '';\n  ItemScrollController? _currentScrollController;\n  int? _initialAyahIndexForPage;\n\n  // Public getter for the page size\n  int get pageSize => _pageSize;\n\n  AyahPresenter(\n    this._saveLastReadUseCase,\n    this._listenSettingsChangesUseCase,\n    this._getAllBookmarkFoldersUseCase,\n    this._getWordsForSurah,\n    this._preloadAdjacentSurahs,\n    this._getAllBookmarkEntries,\n    this._getWordsForSurahAyah,\n  );\n\n  AyahViewUiState get currentUiState => uiState.value;\n\n  void setInitialAyahIndexForPage(int pageIndex, int? ayahIndex) {\n    if (pageIndex == currentUiState.currentPageIndex) {\n      _initialAyahIndexForPage = ayahIndex;\n    }\n  }\n\n  int? getInitialAyahIndexForPage(int pageIndex) {\n    if (pageIndex == currentUiState.currentPageIndex) {\n      final index = _initialAyahIndexForPage;\n      _initialAyahIndexForPage = null; // Clear after first use\n      return index;\n    }\n    return null;\n  }\n\n  Future<void> onClickAudioPlayerButton({\n    required int surahID,\n    required int ayahID,\n    bool isFromMemorization = false,\n  }) async {\n    if (!isFromMemorization) floatingWidgetController.showAppBar();\n    await _audioPresenter.playSingleAyah(\n      surahId: surahID,\n      ayahId: ayahID,\n      isFromMemorization: isFromMemorization,\n    );\n  }\n\n  void setBottomNavigationBarHeight(double height) {\n    uiState.value = currentUiState.copyWith(bottomNavigationBarHeight: height);\n  }\n\n  void updateCurrentPageIndex(int index) {\n    uiState.value = currentUiState.copyWith(\n      currentPageIndex: index,\n      selectedSurahIndex: index,\n    );\n  }\n\n  Future<void> stopAudio() async {\n    if (_audioPresenter.currentUiState.isDownloading) {\n      _audioPresenter.cancelDownload();\n    }\n    await _audioPresenter.stopAudio();\n  }\n\n  Future<void> jumpToDesiredLocation({\n    required int initialPageIndex,\n    required int initialAyahIndex,\n    required bool isNeedToJump,\n  }) async {\n    if (!isNeedToJump) return;\n\n    // Jump to correct page immediately\n    if (pageController.hasClients) {\n      pageController.jumpToPage(initialPageIndex);\n    } else {\n      // If controller not ready, use a minimal delay and retry once\n      await Future.delayed(50.milliseconds);\n      if (pageController.hasClients) {\n        pageController.jumpToPage(initialPageIndex);\n      }\n    }\n\n    // Try to jump to specific ayah immediately\n    final ItemScrollController scrollController =\n        getScrollController(initialPageIndex);\n\n    // Function to attempt scrolling with decreasing animation duration\n    Future<void> attemptScroll([int retryCount = 0]) async {\n      if (scrollController.isAttached) {\n        try {\n          // Use jumpTo for immediate navigation without animation\n          scrollController.jumpTo(index: initialAyahIndex);\n          return;\n        } catch (e) {\n          // If jump fails, try with minimal animation\n          if (retryCount == 0) {\n            try {\n              scrollController.scrollTo(\n                  index: initialAyahIndex, duration: 50.milliseconds);\n              return;\n            } catch (e2) {\n              logErrorStatic('Failed to scroll to ayah: $e2', 'AyahPresenter');\n            }\n          }\n        }\n      } else if (retryCount == 0) {\n        // Only retry once with minimal delay\n        await Future.delayed(50.milliseconds);\n        if (scrollController.isAttached) {\n          return attemptScroll(1);\n        }\n      }\n\n      logErrorStatic(\n          'Failed to jump to ayah, controller not ready', 'AyahPresenter');\n    }\n\n    // Execute the scroll attempt\n    await attemptScroll();\n  }\n\n  Future<void> initializeSearch() async {\n    surahNameSearchController.addListener(_onSurahSearchChanged);\n    ayahNumberSearchController.addListener(_onAyahSearchChanged);\n\n    // Initialize with cached surahs\n    uiState.value = uiState.value.copyWith(\n      filteredSurahs: List<SurahEntity>.from(CacheData.surahsCache),\n      filteredAyahs: List<int>.generate(\n          uiState.value.ayahNumbers, (int index) => index + 1),\n    );\n  }\n\n  void onSurahSearchChanged(String query) {\n    surahNameSearchController.text = query;\n  }\n\n  void onAyahSearchChanged(String query) {\n    ayahNumberSearchController.text = query;\n  }\n\n  /// Handle Surah Search Input Changes\n  void _onSurahSearchChanged() {\n    Debounce.debounce('surah_search', const Duration(milliseconds: 300), () {\n      final String query = surahNameSearchController.text.trim().toLowerCase();\n      if (query.isEmpty) {\n        // Show all Surahs if search query is empty\n        uiState.value = uiState.value.copyWith(\n          surahSearchQuery: '',\n          filteredSurahs: List<SurahEntity>.from(CacheData.surahsCache),\n        );\n      } else {\n        // Filter Surahs based on the query\n        final List<SurahEntity> filtered =\n            CacheData.surahsCache.where((SurahEntity surah) {\n          return surah.nameEn.toLowerCase().contains(query) ||\n              surah.nameBn.toLowerCase().contains(query) ||\n              surah.serial.toString().contains(query);\n        }).toList();\n        uiState.value = uiState.value.copyWith(\n          surahSearchQuery: query,\n          filteredSurahs: filtered,\n        );\n      }\n    });\n  }\n\n  /// Handle Ayah Search Input Changes\n  void _onAyahSearchChanged() {\n    Debounce.debounce('ayah_search', const Duration(milliseconds: 300), () {\n      final String query = ayahNumberSearchController.text.trim();\n\n      if (query.isEmpty) {\n        // Show all Ayahs if search query is empty\n        uiState.value = uiState.value.copyWith(\n          ayahSearchQuery: '',\n          filteredAyahs: List<int>.generate(\n            uiState.value.ayahNumbers,\n            (int index) => index + 1,\n          ),\n        );\n      } else {\n        // Filter Ayahs that contain the query string\n        final List<int> filtered = List<int>.generate(\n          uiState.value.ayahNumbers,\n          (int index) => index + 1,\n        ).where((int ayah) => ayah.toString().contains(query)).toList();\n\n        uiState.value = uiState.value.copyWith(\n          ayahSearchQuery: query,\n          filteredAyahs: filtered,\n        );\n      }\n    });\n  }\n\n  @override\n  Future<void> onInit() async {\n    super.onInit();\n    await fetchSettingState();\n    await loadAllBookmarkedAyahs();\n    await loadAllPinnedAyahs();\n    await initializeSearch();\n  }\n\n  @override\n  void dispose() {\n    _autoScrollTimer?.cancel();\n    surahNameSearchController.removeListener(_onSurahSearchChanged);\n    ayahNumberSearchController.removeListener(_onAyahSearchChanged);\n    surahNameSearchController.dispose();\n    ayahNumberSearchController.dispose();\n    _pageController?.dispose();\n    _pageController = null;\n    super.dispose();\n  }\n\n  Future<void> loadAllBookmarkedAyahs() async {\n    await parseDataFromEitherWithUserMessage(\n      task: () async => await _getAllBookmarkEntries.execute(),\n      onDataLoaded: (bookmarks) async {\n        final Map<int, Map<int, Map<String, bool>>> newIsBookmarkMap =\n            await compute(\n          _processBookmarks,\n          _BookmarkProcessInput(bookmarks: bookmarks),\n        );\n        uiState.value =\n            currentUiState.copyWith(isBookmarkMap: newIsBookmarkMap);\n      },\n    );\n  }\n\n  /// Map containing Surah numbers (keys) and their corresponding Sajdah ayah numbers (values)\n  /// This map is immutable and contains all the Sajdah ayahs in the Quran\n  static const Map<int, List<int>> _sajdahAyahMap = {\n    7: [206], // Al-A'raf\n    13: [15], // Ar-Ra'd\n    16: [50], // An-Nahl\n    17: [109], // Al-Isra\n    19: [58], // Maryam\n    22: [18, 77], // Al-Hajj (contains two Sajdah)\n    25: [60], // Al-Furqan\n    27: [26], // An-Naml\n    32: [15], // As-Sajdah\n    38: [24], // Sad\n    41: [38], // Fussilat\n    53: [62], // An-Najm\n    84: [21], // Al-Inshiqaq\n    96: [19], // Al-Alaq\n  };\n\n  /// Checks if a given Surah and Ayah combination contains a Sajdah\n  ///\n  /// [surahNumber] The number of the Surah (1-114)\n  /// [ayahNumber] The number of the Ayah within the Surah\n  /// Returns true if the specified Ayah contains a Sajdah, false otherwise\n  bool isSajdahAyah(int surahNumber, int ayahNumber) =>\n      _sajdahAyahMap[surahNumber]?.contains(ayahNumber) ?? false;\n\n  static Map<int, Map<int, Map<String, bool>>> _processBookmarks(\n      _BookmarkProcessInput input) {\n    final Map<int, Map<int, Map<String, bool>>> bookmarkMap = {};\n    final Map<int, Map<int, int>> bookmarkCounts = {};\n\n    // First pass - count bookmarks per ayah and initialize maps\n    for (final bookmark in input.bookmarks) {\n      bookmarkMap.putIfAbsent(bookmark.surahID, () => {});\n      bookmarkMap[bookmark.surahID]!.putIfAbsent(bookmark.ayahID,\n          () => {'isBookmarked': true, 'isMultiBookmarked': false});\n\n      bookmarkCounts.putIfAbsent(bookmark.surahID, () => {});\n      bookmarkCounts[bookmark.surahID]!\n          .update(bookmark.ayahID, (count) => count + 1, ifAbsent: () => 1);\n    }\n\n    // Second pass - mark multi-bookmarked ayahs\n    for (final surahId in bookmarkCounts.keys) {\n      for (final ayahId in bookmarkCounts[surahId]!.keys) {\n        if (bookmarkCounts[surahId]![ayahId]! > 1) {\n          bookmarkMap[surahId]![ayahId]!['isMultiBookmarked'] = true;\n        }\n      }\n    }\n\n    return bookmarkMap;\n  }\n\n  Future<void> onTapAyahCard({\n    required BuildContext context,\n    required int surahID,\n    required int ayahNumber,\n  }) async {\n    await stopAudio();\n\n    final TafseerPage tafseerPage = await Future.microtask(\n      () => TafseerPage(\n        surahID: surahID,\n        ayahID: ayahNumber,\n      ),\n    );\n\n    if (context.mounted) {\n      await context.navigatorPush<void>(tafseerPage);\n    }\n  }\n\n  Future<void> onAyahMoreClicked({\n    required BuildContext context,\n    required SurahEntity surah,\n    required int ayahNumber,\n  }) async {\n    await onClickMoreButton(\n      context: context,\n      surahID: surah.serial,\n      ayahID: ayahNumber,\n      isDirectButtonVisible: false,\n      isAddCollectionButtonVisible: true,\n      isPlayButtonVisible: true,\n      isCopyAyahButtonVisible: true,\n    );\n  }\n\n  Future<void> toggleWordByWord({required bool showWordByWord}) async {\n    uiState.value = currentUiState.copyWith(\n      showWordByWord: showWordByWord,\n      showArabic: !showWordByWord,\n    );\n    await _updateSettings();\n  }\n\n  Future<void> _updateSettings() async {\n    final SettingsStateEntity currentSettings =\n        await locate<SettingsRepository>().getSettingsState();\n    final updatedSettings = currentSettings.copyWith(\n      showWordByWord: currentUiState.showWordByWord,\n      showArabic: currentUiState.showArabic,\n    );\n    await locate<SettingsRepository>()\n        .updateSettings(settingsState: updatedSettings);\n  }\n\n  void _updateSettingsState(SettingsStateEntity settingState) {\n    uiState.value = uiState.value.copyWith(\n      arabicFontScript: settingState.arabicFontScript,\n      arabicFontSize: settingState.arabicFontSize,\n      localFontSize: settingState.localFontSize,\n      showArabic: settingState.showArabic,\n      arabicFont: settingState.arabicFont,\n      showWordByWord: settingState.showWordByWord,\n      showTranslation: settingState.showTranslation,\n      tafseerFontSize: settingState.tafseerFontSize,\n      showTajweed: settingState.showTajweed,\n    );\n  }\n\n  Future<void> fetchSettingState() async {\n    final SettingsStateEntity settingsState =\n        await locate<SettingsRepository>().getSettingsState();\n    _updateSettingsState(settingsState);\n    await handleStreamEvents(\n      stream: _listenSettingsChangesUseCase.execute(),\n      onData: _updateSettingsState,\n      subscription: _settingsChangeSub,\n    );\n  }\n\n  Future<void> goToAyahPageWithSurahAndAyahID({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n    bool isNeedToPop = true,\n    bool showPageIndicator = false,\n  }) async {\n    if (isNeedToPop) {\n      context.navigatorPop();\n    }\n    final AyahDetailsPage ayahPage =\n        await Future.microtask(() => AyahDetailsPage(\n              initialPageIndex: surahID - 1,\n              initialAyahIndex: ayahID - 1,\n              showPageIndicator: showPageIndicator,\n            ));\n\n    if (context.mounted) {\n      await context.navigatorPush<void>(ayahPage);\n    } else if (QuranMajeed.globalContext.mounted) {\n      await QuranMajeed.globalContext.navigatorPush<void>(ayahPage);\n    }\n  }\n\n  Future<void> fetchAndSaveLastAyah() async {\n    if (currentUiState.isDisposedAfter3Second) {\n      await catchFutureOrVoid(() async {\n        final int pageIndex = currentUiState.currentPageIndex;\n        final int index =\n            getItemPositionsListener(pageIndex).itemPositions.value.first.index;\n\n        final LastReadEntity lastRead = LastReadEntity(\n            ayahIndex: index + 1,\n            surahIndex: pageIndex,\n            surahName: CacheData.surahsCache[pageIndex].nameEn);\n        await _saveLastReadUseCase.execute(lastRead: lastRead);\n        uiState.value = currentUiState.copyWith(isDisposedAfter3Second: false);\n      });\n    }\n  }\n\n  Future<void> fetchBookmarkFolders() async {\n    await parseDataFromEitherWithUserMessage(\n      task: () async => await _getAllBookmarkFoldersUseCase.execute(),\n      onDataLoaded: (folderList) =>\n          uiState.value = uiState.value.copyWith(bookmarkFolders: folderList),\n    );\n  }\n\n  Future<List<WordByWordEntity>> getWordsForSurah(int surahNumber) async {\n    if (!_wordCache.containsKey(surahNumber)) {\n      _wordCache[surahNumber] =\n          _getWordsForSurah.execute(surahNumber).then((result) {\n        return result.fold(\n          (String error) => <WordByWordEntity>[],\n          (List<WordByWordEntity> words) async {\n            // Preload adjacent surahs in the background\n            UiHelper.doOnPageLoaded(() async {\n              await _preloadAdjacentSurahs.execute(surahNumber);\n            });\n\n            uiState.value = currentUiState.copyWith(\n              wordByWordListForSurah: {\n                ...currentUiState.wordByWordListForSurah,\n                surahNumber: words,\n              },\n            );\n            return words;\n          },\n        );\n      });\n    }\n    return _wordCache[surahNumber]!;\n  }\n\n  // New method to get words for a range of ayahs within a surah\n  Future<List<WordByWordEntity>> getWordsForAyahRange(\n      int surahNumber, int startAyah, int endAyah) async {\n    // Set Arabic loading state to true when fetch starts\n    uiState.value = currentUiState.copyWith(isArabicLoading: true);\n\n    final String cacheKey = '${surahNumber}_${startAyah}_$endAyah';\n    if (!_paginatedWordCache.containsKey(cacheKey)) {\n      _paginatedWordCache[cacheKey] =\n          _getPagedWordsForAyahRange(surahNumber, startAyah, endAyah);\n\n      // Manage cache size to avoid memory issues\n      _manageCache();\n    }\n\n    try {\n      final List<WordByWordEntity> words = await _paginatedWordCache[cacheKey]!;\n\n      // Set Arabic loading state to false when data is fetched successfully\n      uiState.value = currentUiState.copyWith(isArabicLoading: false);\n\n      return words;\n    } catch (e) {\n      // Set Arabic loading state to false even if there's an error\n      uiState.value = currentUiState.copyWith(isArabicLoading: false);\n\n      // Log error and rethrow\n      logError('Error fetching words for ayah range: $e');\n      rethrow;\n    }\n  }\n\n  // Helper method to fetch paged words\n  Future<List<WordByWordEntity>> _getPagedWordsForAyahRange(\n      int surahNumber, int startAyah, int endAyah) async {\n    // Check if we already have the full surah loaded\n    if (_wordCache.containsKey(surahNumber)) {\n      final fullSurahWords = await _wordCache[surahNumber]!;\n      // Filter words for the requested ayahs\n      return fullSurahWords\n          .where((word) =>\n              word.ayah != null &&\n              word.ayah! >= startAyah &&\n              word.ayah! <= endAyah)\n          .toList();\n    }\n\n    // Build lists of surah numbers and ayah numbers for the repository call\n    final List<int> surahNumbers = [];\n    final List<int> ayahNumbers = [];\n\n    for (int ayah = startAyah; ayah <= endAyah; ayah++) {\n      surahNumbers.add(surahNumber);\n      ayahNumbers.add(ayah);\n    }\n\n    // Otherwise fetch just the requested ayahs using the multiple ayahs method\n    final List<WordByWordEntity> words = [];\n    for (int ayah = startAyah; ayah <= endAyah; ayah++) {\n      final result = await _getWordsForSurahAyah.execute(surahNumber, ayah);\n      result.fold(\n        (String error) => {},\n        (List<WordByWordEntity> ayahWords) {\n          words.addAll(ayahWords);\n        },\n      );\n    }\n\n    return words;\n  }\n\n  // Manage cache size to prevent memory issues\n  void _manageCache() {\n    if (_paginatedWordCache.length > 20) {\n      // Keep only 20 pages in memory\n      final keysToRemove = _paginatedWordCache.keys\n          .take(_paginatedWordCache.length - 20)\n          .toList();\n      for (final key in keysToRemove) {\n        _paginatedWordCache.remove(key);\n      }\n    }\n  }\n\n  // Preload the next page of ayahs to improve perceived performance\n  Future<void> preloadNextAyahPage(int surahNumber, int currentAyah) async {\n    final nextPageStart = currentAyah + _pageSize;\n    final totalAyahs = CacheData.surahsCache[surahNumber - 1].totalAyah;\n\n    if (nextPageStart < totalAyahs) {\n      final nextPageEnd = (nextPageStart + _pageSize - 1) > totalAyahs\n          ? totalAyahs\n          : (nextPageStart + _pageSize - 1);\n\n      // Load next page in background\n      getWordsForAyahRange(surahNumber, nextPageStart, nextPageEnd);\n    }\n  }\n\n  Color getAyahBackgroundColor(\n    BuildContext context,\n    ThemeData theme,\n    int index,\n    bool isFromSpecificPage,\n    bool isFromTafseerPage,\n  ) {\n    if (isFromTafseerPage) {\n      return theme.scaffoldBackgroundColor;\n    }\n\n    final bool isOddIndex = index.isOdd;\n    final Color baseColor = theme.scaffoldBackgroundColor;\n    final Color altColor = isDarkMode(context)\n        ? theme.cardColor\n        : theme.cardColor.withOpacityInt(0.5);\n\n    return (isFromSpecificPage == isOddIndex) ? baseColor : altColor;\n  }\n\n  Future<List<WordByWordEntity>> getWordsForSpecificAyah(\n      int surahNumber, int ayahNumber) async {\n    final Either<String, List<WordByWordEntity>> result =\n        await _getWordsForSurahAyah.execute(surahNumber, ayahNumber);\n    return result.fold(\n      (error) => [],\n      (words) {\n        return words;\n      },\n    );\n  }\n\n  Future<String> getArabicForSpecificAyahUseCase(\n      int surahID, int ayahID) async {\n    // Get word-by-word data for this ayah\n    final wordsResult = await _getWordsForSurahAyah.execute(surahID, ayahID);\n    final List<WordByWordEntity> words =\n        wordsResult.fold((error) => [], (wordsList) => wordsList);\n    AyahArabicTextHelper.cacheWordData(words);\n\n    return currentUiState.arabicFontScript == ArabicFontScript.uthmani\n        ? AyahArabicTextHelper.getArabicTextForAyah(\n            surahID, ayahID, ArabicFontScript.uthmani)\n        : AyahArabicTextHelper.getArabicTextForAyah(\n            surahID, ayahID, ArabicFontScript.indoPak);\n  }\n\n  Future<void> updateAyahDataWithBookmark({\n    required int surahID,\n    required int ayahID,\n    required bool isBookmarked,\n    required bool isMultiBookmarked,\n  }) async {\n    final updatedIsBookmarkMap = Map<int, Map<int, Map<String, bool>>>.from(\n        currentUiState.isBookmarkMap);\n\n    if (updatedIsBookmarkMap[surahID] == null) {\n      updatedIsBookmarkMap[surahID] = {};\n    }\n\n    updatedIsBookmarkMap[surahID]![ayahID] = {\n      'isBookmarked': isBookmarked,\n      'isMultiBookmarked': isMultiBookmarked,\n    };\n\n    uiState.value =\n        currentUiState.copyWith(isBookmarkMap: updatedIsBookmarkMap);\n  }\n\n  /// Refreshes the bookmark map after sync to ensure bookmark icons are displayed properly\n  Future<void> refreshBookmarkMap() async {\n    try {\n      final bookmarksResult = await _getAllBookmarkEntries.execute();\n      bookmarksResult.fold(\n        (error) => logErrorStatic(\n            'Failed to refresh bookmarks: $error', 'AyahPresenter'),\n        (bookmarks) {\n          final bookmarkMap =\n              _processBookmarks(_BookmarkProcessInput(bookmarks: bookmarks));\n          uiState.value = currentUiState.copyWith(isBookmarkMap: bookmarkMap);\n        },\n      );\n    } catch (e) {\n      logErrorStatic('Error refreshing bookmark map: $e', 'AyahPresenter');\n    }\n  }\n\n  /// Loads all pinned ayahs into the isPinMap\n  Future<void> loadAllPinnedAyahs() async {\n    try {\n      // Get the UserDataRepository using the service locator\n      final UserDataRepository userDataRepository =\n          locate<UserDataRepository>();\n\n      // Get all pins from the repository\n      final List<PinEntity> pins = await userDataRepository.getAllPins();\n\n      // Process pins into the isPinMap\n      final Map<int, Map<int, bool>> newIsPinMap = {};\n\n      for (final pin in pins) {\n        newIsPinMap.putIfAbsent(pin.surahId, () => {});\n        newIsPinMap[pin.surahId]![pin.ayahNumber] = true;\n      }\n\n      // Update the UI state with the new pin map\n      uiState.value = currentUiState.copyWith(isPinMap: newIsPinMap);\n    } catch (e) {\n      logErrorStatic('Error loading pinned ayahs: $e', 'AyahPresenter');\n    }\n  }\n\n  /// Refreshes the pin map after sync to ensure pin icons are displayed properly\n  Future<void> refreshPinMap() async {\n    try {\n      await loadAllPinnedAyahs();\n    } catch (e) {\n      logErrorStatic('Error refreshing pin map: $e', 'AyahPresenter');\n    }\n  }\n\n  Future<void> updateAyahDataWithPin({\n    required int surahID,\n    required int ayahID,\n    required bool isPinned,\n  }) async {\n    final updatedIsPinMap =\n        Map<int, Map<int, bool>>.from(currentUiState.isPinMap);\n\n    if (updatedIsPinMap[surahID] == null) {\n      updatedIsPinMap[surahID] = {};\n    }\n\n    updatedIsPinMap[surahID]![ayahID] = isPinned;\n\n    uiState.value = currentUiState.copyWith(isPinMap: updatedIsPinMap);\n  }\n\n  (bool, bool) checkAyahBookmarkStatus(int surahID, int ayahID) {\n    final surahBookmarks = currentUiState.isBookmarkMap[surahID];\n    if (surahBookmarks == null) return (false, false);\n\n    final ayahBookmark = surahBookmarks[ayahID];\n    if (ayahBookmark == null) return (false, false);\n\n    return (\n      ayahBookmark['isBookmarked'] ?? false,\n      ayahBookmark['isMultiBookmarked'] ?? false,\n    );\n  }\n\n  Future<void> navigateToPageIndex(int index) async {\n    uiState.value = currentUiState.copyWith(\n      currentPageIndex: index,\n      selectedSurahIndex: index,\n      selectedAyahIndex: 0,\n    );\n    if (!pageController.hasClients) {\n      await Future.delayed(300.milliseconds);\n    }\n\n    if (pageController.hasClients) {\n      await pageController.animateToPage(\n        index,\n        duration: 300.milliseconds,\n        curve: Curves.easeInOut,\n      );\n    }\n  }\n\n  Future<void> initializeAyahDetailsPage({\n    required int initialPageIndex,\n    required int initialAyahIndex,\n    required bool showPageIndicator,\n  }) async {\n    // Dispose existing controller if it exists\n    _pageController?.dispose();\n    // Create a new controller with the correct initial page\n    _pageController = PageController(initialPage: initialPageIndex);\n\n    // Use post-frame callback for all UI state updates to prevent setState during build\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      // Initialize UI state with loading indicators\n      uiState.value = currentUiState.copyWith(\n        currentPageIndex: initialPageIndex,\n        selectedSurahIndex: initialPageIndex,\n        selectedAyahIndex: initialAyahIndex,\n        showPageIndicator: showPageIndicator,\n        isArabicLoading:\n            true, // Make sure Arabic loading is set to true initially\n      );\n\n      // Set the initial ayah index for the page\n      setInitialAyahIndexForPage(initialPageIndex, initialAyahIndex);\n\n      // Start navigation to the specific ayah immediately\n      jumpToDesiredLocation(\n        initialPageIndex: initialPageIndex,\n        initialAyahIndex: initialAyahIndex,\n        isNeedToJump: true,\n      );\n    });\n\n    // Continue with other initialization tasks in parallel\n    UiHelper.doOnPageLoaded(() async {\n      // Pre-fetch the words for this surah to ensure data is ready\n      await getWordsForSurah(initialPageIndex + 1);\n      _audioPresenter.initializePositionListener();\n      await _setIsDisposedAfter3Second();\n    });\n  }\n\n  String formatHijbNumber(String hijb) {\n    final List<String> hijbFractioned = hijb.split('.');\n    final String hijbFirstPart = hijbFractioned.first;\n    final String hijbLastPart = hijbFractioned.last;\n    String? formattedHijbNumber;\n    switch (hijbLastPart) {\n      case '25':\n        formattedHijbNumber = '$hijbFirstPart\u00bc';\n        break;\n      case '5':\n        formattedHijbNumber = '$hijbFirstPart\u00bd';\n        break;\n      case '75':\n        formattedHijbNumber = '$hijbFirstPart\u00be';\n        break;\n      default:\n        formattedHijbNumber = hijb;\n    }\n    return formattedHijbNumber;\n  }\n\n  Future<void> _setIsDisposedAfter3Second() async {\n    await Future<void>.delayed(3.seconds);\n    uiState.value = currentUiState.copyWith(isDisposedAfter3Second: true);\n  }\n\n  ItemScrollController getScrollController(int pageIndex) {\n    return ScrollControllerManager().getScrollController(pageIndex);\n  }\n\n  ItemPositionsListener getItemPositionsListener(int pageIndex) {\n    return ScrollControllerManager().getItemPositionsListener(pageIndex);\n  }\n\n  Future<void> onMushafViewModeTap(BuildContext context) async {\n    await SelectMushafBottomSheet.show(\n      context: context,\n      isOnMushafPage: false,\n    );\n  }\n\n  void updateWordByWordData(int ayahNumber) {\n    uiState.value = currentUiState.copyWith(\n        wordByWordList: currentUiState.wordByWordListForSurah[ayahNumber]);\n  }\n\n  Future<void> onClickMoreButton({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n    required bool isDirectButtonVisible,\n    required bool isAddCollectionButtonVisible,\n    required bool isPlayButtonVisible,\n    required bool isCopyAyahButtonVisible,\n  }) async {\n    await MoreOptionBottomSheet.show(\n      context: context,\n      surahID: surahID,\n      ayahID: ayahID,\n      isTafseerButtonVisible: true,\n      isDirectButtonVisible: false,\n      idAddCollectionButtonVisible: true,\n      isFromAyahPage: true,\n      isPlayButtonVisible: isPlayButtonVisible,\n      isCopyAyahButtonVisible: isCopyAyahButtonVisible,\n    );\n  }\n\n  Future<void> onSurahListTap({\n    required BuildContext context,\n    required String title,\n    required bool isDoneButtonEnabled,\n    required bool isJumpToAyahBottomSheet,\n    required Function(int surahId) onSurahSelected,\n    required Function(int ayahId) onAyahSelected,\n    required Function() onSubmit,\n  }) async {\n    final int currentSurahIndex = pageController.page!.round();\n    final int currentAyahNumbers =\n        CacheData.surahsCache[currentSurahIndex].totalAyah;\n\n    uiState.value = currentUiState.copyWith(\n      selectedSurahIndex: currentSurahIndex,\n      ayahNumbers: currentAyahNumbers,\n      filteredAyahs:\n          List<int>.generate(currentAyahNumbers, (index) => index + 1),\n    );\n\n    await SelectSurahAyahBottomSheet.show(\n      context: context,\n      bottomSheetTitle: title, // or context.l10n.jumpToAyah\n      presenter: SurahAyahPresenter.ayah(locate<AyahPresenter>()),\n      isDoneButtonEnabled: isDoneButtonEnabled,\n      isJumpToAyahBottomSheet: isJumpToAyahBottomSheet,\n      onSurahSelected: onSurahSelected,\n      onAyahSelected: onAyahSelected,\n      onJumpToTafseer: () async => await goToTafseerPage(\n        context: context,\n        surahID: currentUiState.selectedSurahIndex + 1,\n        ayahID: currentUiState.selectedAyahIndex + 1,\n      ),\n      onSubmit: onSubmit,\n      selectedSurahIndex: currentUiState.selectedSurahIndex, // ADD THIS\n      selectedAyahIndex: currentUiState.selectedAyahIndex, // ADD THIS\n    );\n  }\n\n  void onSelectSurah(int surahIndex) {\n    final int ayahNumbers = CacheData.surahsCache[surahIndex].totalAyah;\n    _audioPresenter.onSelectSurah(surahIndex);\n    uiState.value = currentUiState.copyWith(\n      selectedSurahIndex: surahIndex,\n      ayahNumbers: ayahNumbers,\n      filteredAyahs: List<int>.generate(ayahNumbers, (index) => index + 1),\n      selectedAyahIndex: 0,\n    );\n  }\n\n  Future<void> goToTafseerPage({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n  }) async {\n    await getWordsForSurah(currentUiState.selectedSurahIndex + 1);\n    if (context.mounted) {\n      await onTapAyahCard(\n        context: context,\n        surahID:\n            CacheData.surahsCache[currentUiState.selectedSurahIndex].serial,\n        ayahNumber: currentUiState.selectedAyahIndex + 1,\n      );\n    }\n  }\n\n  void onSelectAyah(int ayahIndex) {\n    uiState.value = currentUiState.copyWith(\n      selectedAyahIndex: ayahIndex,\n    );\n  }\n\n  @override\n  Future<void> addUserMessage(String message) {\n    return showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }\n\n  void toggleAutoScroll() {\n    if (currentUiState.autoScrollOptionTurnedOn) {\n      stopAutoScroll();\n    } else {\n      startAutoScroll();\n    }\n    uiState.value = currentUiState.copyWith(\n      autoScroll: !currentUiState.autoScrollOptionTurnedOn,\n      isAutoScrolling: !currentUiState.autoScrollOptionTurnedOn,\n    );\n    setBottomNavigationBarHeight(kBottomNavigationBarHeight + 5.percentWidth);\n  }\n\n  void startAutoScroll() {\n    final int currentPageIndex = currentUiState.currentPageIndex;\n    final ItemScrollController scrollController =\n        getScrollController(currentPageIndex);\n\n    if (!scrollController.isAttached) return;\n\n    _autoScrollTimer?.cancel();\n\n    // Perform initial scroll immediately\n    _performScroll(currentPageIndex, scrollController);\n\n    // Then continue with periodic scrolling\n    const scrollInterval = Duration(seconds: 2);\n    _autoScrollTimer = Timer.periodic(scrollInterval, (timer) {\n      if (!currentUiState.autoScrollOptionTurnedOn ||\n          !currentUiState.isAutoScrolling) {\n        timer.cancel();\n        return;\n      }\n\n      setBottomNavigationBarHeight(kBottomNavigationBarHeight + 5.percentWidth);\n      _performScroll(currentPageIndex, scrollController);\n    });\n  }\n\n  void _performScroll(\n      int currentPageIndex, ItemScrollController scrollController) {\n    _currentScrollController = scrollController;\n    final positions =\n        getItemPositionsListener(currentPageIndex).itemPositions.value;\n    if (positions.isEmpty) return;\n\n    final firstPosition = positions.first;\n    final lastIndex = positions.last.index;\n    final maxIndex = CacheData.surahsCache[currentPageIndex].totalAyah - 1;\n\n    if (lastIndex >= maxIndex) {\n      stopAutoScroll();\n      return;\n    }\n\n    final scrollSpeed = _currentScrollSpeed / 20;\n    scrollController.scrollTo(\n      index: firstPosition.index,\n      duration: const Duration(seconds: 2),\n      curve: Curves.linear,\n      alignment: firstPosition.itemLeadingEdge - scrollSpeed,\n    );\n  }\n\n  void stopAutoScroll() {\n    _autoScrollTimer?.cancel();\n    _autoScrollTimer = null;\n\n    if (_currentScrollController != null) {\n      final positions =\n          getItemPositionsListener(currentUiState.currentPageIndex)\n              .itemPositions\n              .value;\n      if (positions.isNotEmpty) {\n        _currentScrollController!.jumpTo(\n          index: positions.first.index,\n          alignment: positions.first.itemLeadingEdge,\n        );\n      }\n    }\n    _currentScrollController = null;\n\n    uiState.value = currentUiState.copyWith(\n      autoScroll: false,\n      isAutoScrolling: false,\n    );\n  }\n\n  void changeAutoScrollSpeed(double speed) {\n    if (speed >= 1.0 && speed <= 10.0) {\n      uiState.value = currentUiState.copyWith(autoScrollSpeed: speed);\n      // Reduce speed by factor of 5 to make scrolling faster than before\n      _currentScrollSpeed = speed / 5;\n    }\n  }\n\n  void pauseAutoScroll() {\n    _autoScrollTimer?.cancel();\n    _autoScrollTimer = null;\n    uiState.value = currentUiState.copyWith(isAutoScrolling: false);\n  }\n\n  void resumeAutoScroll() {\n    uiState.value = currentUiState.copyWith(\n      isAutoScrolling: true,\n      autoScroll: true,\n    );\n    startAutoScroll();\n  }\n\n  Future<void> onClickAdvanceCopy(BuildContext context, ThemeData theme) async {\n    await AdvanceCopyBottomSheet.show(\n      context: context,\n      theme: theme,\n      surahId: currentUiState.currentPageIndex + 1,\n      surahName: getTranslatedSurahName(\n          surahNumber: currentUiState.currentPageIndex + 1, context: context),\n      totalAyahs:\n          CacheData.surahsCache[currentUiState.currentPageIndex].totalAyah,\n    );\n  }\n\n  Future<void> onClickShareButton({\n    required int surahID,\n    required int ayahID,\n  }) async {\n    await ShareAyahBottomSheet.show(\n      context: QuranMajeed.globalContext,\n      surahID: surahID,\n      ayahID: ayahID,\n    );\n  }\n\n  Future<String> _makeShareableString({\n    required int surahID,\n    required int ayahID,\n    required BuildContext context,\n  }) async {\n    final String arabicAyah =\n        await getArabicForSpecificAyahUseCase(surahID, ayahID);\n    return await convertAyahToSharableString(\n      surahID: surahID,\n      ayahID: ayahID,\n      arabicAyah: arabicAyah,\n      shareWithArabicText: true,\n      shareWithTranslation: true,\n      surahName: CacheData.surahsCache[surahID - 1].nameEn,\n      translatorName: translationPresenter.currentUiState.selectedItems\n          .map((e) => e.name)\n          .toList(),\n      translation: translationPresenter.currentUiState.selectedItems\n          .map((e) => translationPresenter.getTranslationText(\n              e.fileName, surahID, ayahID, context))\n          .toList(),\n    );\n  }\n\n  Future<void> copySingleAyahText({\n    required int surahID,\n    required int ayahID,\n    required BuildContext context,\n  }) async {\n    final String shareableString = await _makeShareableString(\n        surahID: surahID, ayahID: ayahID, context: context);\n    copyText(text: shareableString);\n    addUserMessage(context.l10n.ayahCopiedToClipboard);\n  }\n\n  Future<void> shareSingleAyahText({\n    required int surahID,\n    required int ayahID,\n    required BuildContext context,\n  }) async {\n    final String shareableString = await _makeShareableString(\n        surahID: surahID, ayahID: ayahID, context: context);\n    await shareText(text: shareableString);\n  }\n\n  Future<void> onClickMultipleAyahShareButton(BuildContext context) async {\n    await MultipleAyahShareBottomSheet.show(\n      context: context,\n    );\n  }\n\n  Future<void> onClickShareImageButton(BuildContext context) async {\n    await ShareImageBottomSheet.show(\n      context: context,\n    );\n  }\n\n  void scrollUpBy100Pixels() {\n    if (!currentUiState.isAutoScrolling) return;\n\n    final offset = getScrollController(currentUiState.currentPageIndex)\n        .scrollController\n        ?.offset;\n\n    getScrollController(currentUiState.currentPageIndex)\n        .scrollController\n        ?.animateTo(\n          offset! - 100,\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeInOut,\n        );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "collection", "file_path": "presentation/ayah_detail/widgets/collection/collection_bottomsheet_persistent_footer.dart", "file_name": "collection_bottomsheet_persistent_footer.dart", "line": 26, "line_from": 26, "line_to": 129, "snippet": "  final void Function(int, {required bool isBookmarked}) onBookmarkToggled;\n  final CollectionType collectionType;\n  final VoidCallback onNewCreateBottomSheetClosed;\n  final ThemeData theme;\n\n  @override\n  Widget build(BuildContext context) {\n    final pinPresenter = locate<PinPresenter>();\n\n    return Container(\n      // height: 14.percentWidth,\n      padding: padding20,\n      color: theme.scaffoldBackgroundColor,\n      child: TwoWayActionButton(\n        key: const Key(\"TwoWayActionButton\"),\n        theme: theme,\n        cancelButtonBgColor: isDarkMode(context)\n            ? context.color.primaryButtonColor\n            : context.color.secondaryButtonColor,\n        cancelButtonTextColor: isDarkMode(context)\n            ? context.color.primaryButtonTextColor\n            : context.color.secondaryButtonTextColor,\n        onCancelButtonTap: () {\n          presenter.onClickNewCreate(\n            context: context,\n            surahID: surahID,\n            ayahID: ayahID,\n            collectionType: collectionType,\n          );\n          onNewCreateBottomSheetClosed();\n        },\n        onSubmitButtonTap: () async {\n          if (collectionType == CollectionType.pin) {\n            // Handle pin update\n            final selectedPinName = pinPresenter.currentUiState.selectedPinName;\n            if (selectedPinName.isEmpty) {\n              context.navigatorPop<void>();\n              return;\n            }\n\n            // Find the selected pin\n            final selectedPin = pinPresenter.currentUiState.pins.firstWhere(\n              (pin) => pin.name == selectedPinName,\n            );\n\n            // Only show toast if the pin's ayah or surah has actually changed\n            final bool hasChanges = selectedPin.surahId != surahID ||\n                selectedPin.ayahNumber != ayahID;\n\n            // Update the existing pin with new ayah\n            await pinPresenter.updatePin(\n              oldPin: selectedPin,\n              newName: selectedPin.name,\n              newColor: selectedPin.color,\n              newSurahId: surahID,\n              newAyahNumber: ayahID,\n              context: context,\n              onUpdated: () async {\n                // Update the UI state to show the pin icon for the new ayah\n                final ayahPresenter = locate<AyahPresenter>();\n\n                // Only update the old position if it changed\n                if (hasChanges) {\n                  // Mark the old position as no longer pinned\n                  await ayahPresenter.updateAyahDataWithPin(\n                    surahID: selectedPin.surahId,\n                    ayahID: selectedPin.ayahNumber,\n                    isPinned: false,\n                  );\n                }\n\n                // Mark the new position as pinned\n                await ayahPresenter.updateAyahDataWithPin(\n                  surahID: surahID,\n                  ayahID: ayahID,\n                  isPinned: true,\n                );\n\n                ayahPresenter.uiState.refresh();\n\n                context.navigatorPop<void>();\n                // Only show toast if there were actual changes\n                if (hasChanges) {\n                  pinPresenter.addUserMessage(context.l10n.pinUpdSuccess);\n                }\n              },\n            );\n          } else {\n            // Handle bookmark update\n            await presenter.doneButtonHandlerWithToast(\n              context: context,\n              surahID: surahID,\n              ayahID: ayahID,\n              onBookmarkToggled: onBookmarkToggled,\n              showToastAlways: true,\n            );\n          }\n        },\n        cancelButtonTitle: context.l10n.createNew,\n        submitButtonTitle: context.l10n.done,\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "collection", "file_path": "presentation/ayah_detail/widgets/collection/collection_bottom_sheet.dart", "file_name": "collection_bottom_sheet.dart", "line": 29, "line_from": 29, "line_to": 66, "snippet": "  final void Function(int, {required bool isBookmarked}) onBookmarkAdded;\n  final String? title;\n  final CollectionType collectionType;\n  @override\n  State<CollectionBottomSheet> createState() => _CollectionBottomSheetState();\n\n  static Future<void> show({\n    required int surahID,\n    required int ayahID,\n    required String? title,\n    required Future<void> Function(int, {required bool isBookmarked})\n        onBookmarkToggled,\n    required CollectionType collectionType,\n    required BuildContext context,\n  }) async {\n    try {\n      if (!context.mounted) return;\n\n      await showModalBottomSheet<void>(\n        context: context,\n        isScrollControlled: true,\n        enableDrag: false,\n        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.zero),\n        backgroundColor: Colors.transparent,\n        builder: (_) => CollectionBottomSheet(\n          surahID: surahID,\n          ayahID: ayahID,\n          title: title,\n          onBookmarkAdded: onBookmarkToggled,\n          collectionType: collectionType,\n        ),\n      );\n    } catch (e, stack) {\n      log(\"BottomSheet Error: $e\", error: e, stackTrace: stack);\n    }\n    // dislocate<MoreMenuPresenter>();\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/surah_list_column.dart", "file_name": "surah_list_column.dart", "line": 25, "line_from": 25, "line_to": 89, "snippet": "  final void Function(int surahId)? onSurahSelected;\n  final ThemeData theme;\n  final int selectedSurahIndex;\n  final List<SurahEntity> filteredSurahs;\n  final Function(String) onSearchChanged;\n  final TextEditingController surahSearchController;\n  final int? initialSurahIndex;\n  @override\n  State<SurahListColumn> createState() => _SurahListColumnState();\n}\n\nclass _SurahListColumnState extends State<SurahListColumn> {\n  final ItemScrollController _scrollController = ItemScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    UiHelper.doOnPageLoaded(() {\n      // Prioritize scrollToSurahIndex if provided, otherwise use initialSurahIndex\n      if (widget.initialSurahIndex != null && _scrollController.isAttached) {\n        _scrollController.jumpTo(index: widget.initialSurahIndex!);\n      } else if (widget.initialSurahIndex != null &&\n          _scrollController.isAttached) {\n        _scrollController.jumpTo(index: widget.initialSurahIndex!);\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return BuildExpandedColumn(\n      flex: 2,\n      searchTextField: UserInputField(\n        borderRadius: BorderRadius.circular(fiftyPx),\n        textEditingController: widget.surahSearchController,\n        hintText: context.l10n.searchSurah,\n        onChanged: widget.onSearchChanged,\n      ),\n      listViewBuilder: () {\n        if (widget.filteredSurahs.isEmpty) {\n          return CustomizableFeedbackWidget(\n            theme: widget.theme,\n            svgPath: SvgPath.icSearchBox,\n            message: context.l10n.noResultFound,\n          );\n        }\n\n        return ScrollablePositionedList.builder(\n          itemScrollController: _scrollController,\n          itemCount: widget.filteredSurahs.length,\n          itemBuilder: (context, index) {\n            final surah = widget.filteredSurahs[index];\n            return SurahListItem(\n              surah: surah,\n              theme: widget.theme,\n              index: surah.serial - 1,\n              onSelect: () => widget.onSurahSelected?.call(surah.serial - 1),\n              selectedSurahIndex: widget.selectedSurahIndex,\n            );\n          },\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "onFontChanged", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/arabic_ayah_text_widget.dart", "file_name": "arabic_ayah_text_widget.dart", "line": 19, "line_from": 19, "line_to": 326, "snippet": "  static void onFontChanged(String fontFamily, double fontSize) {\n    // If the font has changed, clear the entire cache\n    if (_lastFontFamily != fontFamily || _lastFontSize != fontSize) {\n      _cache.clear();\n      _processedAyahs.clear();\n      _lastFontFamily = fontFamily;\n      _lastFontSize = fontSize;\n\n      // Also clear the TajweedEntity cache to ensure consistency\n      TajweedEntity.clearCache();\n    }\n  }\n\n  static TextSpan getProcessedText({\n    required String text,\n    required TextStyle baseStyle,\n    required int surahNumber,\n    required int ayahNumber,\n    required bool showTajweed,\n  }) {\n    if (text.isEmpty) {\n      // Return a simple text span if the text is empty to avoid processing issues\n      return TextSpan(text: '', style: baseStyle);\n    }\n\n    // Check if font has changed and update tracking\n    final fontFamily = baseStyle.fontFamily ?? '';\n    final fontSize = baseStyle.fontSize ?? 0.0;\n\n    if (_lastFontFamily != fontFamily || _lastFontSize != fontSize) {\n      onFontChanged(fontFamily, fontSize);\n    }\n\n    final String ayahKey = '${surahNumber}_$ayahNumber';\n    // Enhanced cache key including more font properties and theme color\n    final String key =\n        '${surahNumber}_${ayahNumber}_${text.length}_${fontSize}_${fontFamily}_${baseStyle.fontWeight?.index}_${baseStyle.fontStyle?.index}_${baseStyle.color?.toARGB32()}_$showTajweed';\n\n    // Skip cache for previously problematic ayahs\n    if (_processedAyahs.containsKey(ayahKey) && _processedAyahs[ayahKey] == false) {\n      _cache.remove(key);\n    }\n\n    if (!_cache.containsKey(key)) {\n      try {\n        final result = TajweedEntity.processTajweedText(\n          text: text,\n          baseStyle: baseStyle,\n          surahNumber: surahNumber,\n          ayahNumber: ayahNumber,\n          showTajweed: showTajweed,\n        );\n\n        // Extract the original text without tajweed markup for comparison\n        final String strippedOriginal = text.replaceAllMapped(\n            RegExp(r'\\[(.*?)\\]\\((.*?)\\)|\\((.*?)\\)\\[(.*?)\\]', dotAll: true, multiLine: true), (Match match) {\n          if (match.group(1) != null) return match.group(1)!;\n          return match.group(4)!;\n        });\n\n        // Verify the processed text has expected content\n        if (_isProcessedTextValid(result, strippedOriginal)) {\n          _cache[key] = result;\n          _processedAyahs[ayahKey] = true; // Mark as successfully processed\n        } else {\n          // If verification fails, mark as problematic\n          _processedAyahs[ayahKey] = false;\n\n          // Process without cache and return the result\n          return TajweedEntity.processTajweedText(\n            text: text,\n            baseStyle: baseStyle,\n            surahNumber: surahNumber,\n            ayahNumber: ayahNumber,\n            showTajweed: showTajweed,\n          );\n        }\n\n        // Manage cache size\n        if (_cache.length > 200) {\n          final keysToRemove = _cache.keys.take(50).toList();\n          for (final cacheKey in keysToRemove) {\n            _cache.remove(cacheKey);\n          }\n        }\n      } catch (e) {\n        // Fallback to simple text span if processing fails\n        _processedAyahs[ayahKey] = false; // Mark as problematic\n        return TextSpan(text: text, style: baseStyle);\n      }\n    }\n\n    // Double-check the cached result for completeness\n    final cachedResult = _cache[key]!;\n\n    // Extract the original text without tajweed markup for verification\n    final String strippedOriginal = text.replaceAllMapped(\n        RegExp(r'\\[(.*?)\\]\\((.*?)\\)|\\((.*?)\\)\\[(.*?)\\]', dotAll: true, multiLine: true), (Match match) {\n      if (match.group(1) != null) return match.group(1)!;\n      return match.group(4)!;\n    });\n\n    if (!_isProcessedTextValid(cachedResult, strippedOriginal)) {\n      _processedAyahs[ayahKey] = false; // Mark as problematic\n      _cache.remove(key);\n\n      // Regenerate without caching\n      return TajweedEntity.processTajweedText(\n        text: text,\n        baseStyle: baseStyle,\n        surahNumber: surahNumber,\n        ayahNumber: ayahNumber,\n        showTajweed: showTajweed,\n      );\n    }\n\n    return cachedResult;\n  }\n\n  // Helper method to extract all text from a TextSpan tree\n  static String _extractTextFromSpan(TextSpan span) {\n    String result = span.text ?? '';\n\n    if (span.children != null) {\n      for (var child in span.children!) {\n        if (child is TextSpan) {\n          result += _extractTextFromSpan(child);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // Helper method to verify processed text contains all expected content\n  static bool _isProcessedTextValid(TextSpan processedSpan, String originalText) {\n    if (processedSpan.children == null || processedSpan.children!.isEmpty) {\n      return processedSpan.text == originalText;\n    }\n\n    // Extract all text from the TextSpan tree\n    final String extractedText = _extractTextFromSpan(processedSpan);\n\n    // Remove whitespace for comparison\n    final String normalizedOriginal = originalText.replaceAll(RegExp(r'\\s+'), '');\n    final String normalizedProcessed = extractedText.replaceAll(RegExp(r'\\s+'), '');\n\n    // Check for length equality and some content matching at the beginning and end\n    if (normalizedOriginal.length != normalizedProcessed.length) {\n      return false;\n    }\n\n    // Add extra checks for the start and end of the text\n    // This ensures the processed text maintains the same structure\n    final int checkLength = normalizedOriginal.length > 10 ? 5 : normalizedOriginal.length ~/ 2;\n\n    if (checkLength > 0) {\n      if (!normalizedProcessed.startsWith(normalizedOriginal.substring(0, checkLength))) {\n        return false;\n      }\n\n      if (!normalizedProcessed.endsWith(normalizedOriginal.substring(normalizedOriginal.length - checkLength))) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Clear the cache\n  static void clearCache() {\n    _cache.clear();\n    _processedAyahs.clear();\n    _lastFontFamily = '';\n    _lastFontSize = 0;\n    // Also clear the TajweedEntity cache\n    TajweedEntity.clearCache();\n  }\n}\n\nclass ArabicAyahTextWidget extends StatelessWidget {\n  const ArabicAyahTextWidget({\n    super.key,\n    required this.ayahNumber,\n    this.wordData,\n    required this.arabicFontScript,\n    required this.arabicFontName,\n    required this.arabicFontSize,\n    required this.theme,\n    this.singleAyah,\n    this.highlightedAyah,\n    this.isArabicSearch = false,\n    this.surahID,\n    required this.showTajweed,\n    this.selectedWordIndex,\n  });\n\n  final int ayahNumber;\n  final List<WordByWordEntity>? wordData;\n  final ArabicFontScript arabicFontScript;\n  final String arabicFontName;\n  final double arabicFontSize;\n  final AyahEntity? singleAyah;\n  final ThemeData theme;\n  final TextSpan? highlightedAyah;\n  final bool isArabicSearch;\n  final int? surahID;\n  final bool showTajweed;\n  final int? selectedWordIndex;\n\n  // Static method to clear all caches when font settings change\n  static void onFontSettingsChanged(String fontFamily, double fontSize) {\n    _TajweedTextCache.clearCache();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: double.infinity,\n      child: _buildWordByWordText(context),\n    );\n  }\n\n  Widget _buildWordByWordText(BuildContext context) {\n    // In search results, if we have a highlighted span, use that directly\n    if (isArabicSearch && highlightedAyah != null) {\n      // For search results, we need to use the highlightedAyah directly\n      // but still apply the proper font and styling\n      final TextStyle baseStyle = context.quranText.arabicAyah!.copyWith(\n        fontFamily: arabicFontName,\n        fontSize: arabicFontSize,\n      );\n\n      // The highlighted ayah already has tajweed tags stripped\n      // in the SearchPresenter.getHighlightedAyah method\n      return RichText(\n        textDirection: TextDirection.rtl,\n        text: TextSpan(\n          children: highlightedAyah!.children,\n          style: baseStyle.merge(highlightedAyah!.style),\n          text: highlightedAyah!.text,\n        ),\n      );\n    }\n\n    if (wordData == null) return const SizedBox.shrink();\n\n    return Wrap(\n      key: Key(\"ayah_$ayahNumber\"),\n      direction: Axis.horizontal,\n      alignment: WrapAlignment.start,\n      textDirection: TextDirection.rtl,\n      children: List.generate(wordData!.length, (index) {\n        final word = wordData![index];\n        final String arabicText = arabicFontScript == ArabicFontScript.uthmani ? word.uthmani! : word.indopak!;\n        final TextStyle baseStyle = context.quranText.arabicAyah!.copyWith(\n          fontFamily: arabicFontName,\n          fontSize: arabicFontSize,\n          letterSpacing: 0,\n          height: 1.3,\n        );\n        final bool isSelected = index == selectedWordIndex;\n        final TextStyle wordStyle = isSelected ? baseStyle.copyWith(color: theme.colorScheme.primary) : baseStyle;\n\n        return Padding(\n          padding: const EdgeInsets.only(left: 2.0, bottom: 8.0),\n          child: OnTapWidget(\n            theme: theme,\n            onTap: () => _showGrammarBottomSheet(context, word),\n            child: Container(\n              padding: EdgeInsets.symmetric(horizontal: twoPx),\n              decoration: BoxDecoration(\n                color: isSelected ? theme.colorScheme.primary.withOpacityInt(0.2) : null,\n                borderRadius: BorderRadius.circular(fourPx),\n              ),\n              child: showTajweed\n                  ? RichText(\n                      textDirection: TextDirection.rtl,\n                      text: _TajweedTextCache.getProcessedText(\n                        text: arabicText,\n                        baseStyle: wordStyle,\n                        surahNumber: surahID ?? 1,\n                        ayahNumber: ayahNumber,\n                        showTajweed: showTajweed,\n                      ),\n                    )\n                  : Text(\n                      TajweedEntity.stripTajweedTags(arabicText),\n                      textDirection: TextDirection.rtl,\n                      style: wordStyle,\n                    ),\n            ),\n          ),\n        );\n      }),\n    );\n  }\n\n  void _showGrammarBottomSheet(BuildContext context, WordByWordEntity selectedWord) {\n    if (wordData != null) {\n      GrammarBottomSheet.show(\n        context: context,\n        wordList: wordData!,\n        selectedWordIndex: wordData!.indexOf(selectedWord),\n      );\n    }\n  }\n}"}, {"structure_type": "function", "name": "issues", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/ayah_content_widget.dart", "file_name": "ayah_content_widget.dart", "line": 95, "line_from": 95, "line_to": 166, "snippet": "        // We use Future.microtask to avoid blocking the UI thread and prevent initialization issues\n        Future.microtask(() {\n          ayahPresenter.preloadNextAyahPage(\n              pageIndex + 1, currentAyahIndex + 1);\n        });\n      }\n    }\n  }\n\n  Widget _buildAyahItem(BuildContext context, SurahEntity surah,\n      ThemeData theme, List<WordByWordEntity> wordData, int ayahIndex) {\n    final int ayahNumber = ayahIndex + 1;\n    final List<WordByWordEntity> ayahWords =\n        wordData.where((word) => word.ayah == ayahNumber).toList();\n\n    final bool isFirstAyah = ayahIndex == 0;\n    final bool isNewPage = CacheData.uniquePageIDwithSurahAndAyahID\n        .containsKey('${surah.serial}:$ayahNumber');\n    final WordByWordEntity? firstWordOfPageAyah =\n        ayahWords.isNotEmpty ? ayahWords.first : null;\n    final bool shouldShowBismillah =\n        isFirstAyah && surah.serial != 1 && surah.serial != 9;\n\n    return Column(\n      children: [\n        if (isFirstAyah) ...[\n          SurahHeader(surah: surah, theme: theme),\n          gapH16,\n        ],\n        if (shouldShowBismillah) ...[\n          ShowBismillahWidget(theme: theme),\n          gapH12,\n        ],\n        if (showPageIndicator && isNewPage) ...[\n          CenteredPageIndicator(\n            theme: theme,\n            pageNumber: firstWordOfPageAyah?.page ?? 0,\n            juzNumber: firstWordOfPageAyah?.juz ?? 0,\n            hijbNumber: firstWordOfPageAyah?.hijb != null\n                ? ayahPresenter.formatHijbNumber(firstWordOfPageAyah!.hijb!)\n                : '',\n          ),\n          gapH8,\n        ],\n        AyahContainer(\n          theme: theme,\n          isFromSpecificPage: true,\n          onTapAyahCard: () async {\n            await ayahPresenter.onTapAyahCard(\n              context: context,\n              surahID: surah.serial,\n              ayahNumber: ayahNumber,\n            );\n          },\n          ayahPresenter: ayahPresenter,\n          index: ayahIndex,\n          surahID: pageIndex + 1,\n          ayahNumber: ayahNumber,\n          ayahTopRowTitle: ayahNumber.toLocalizedString(context),\n          wordData: ayahWords,\n          onClickMore: () {\n            ayahPresenter.onAyahMoreClicked(\n              context: context,\n              surah: surah,\n              ayahNumber: ayahNumber,\n            );\n          },\n        ),\n        if (ayahIndex == surah.totalAyah - 1) SizedBox(height: 22.percentWidth),\n      ],\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "ayah_details", "file_path": "presentation/ayah_detail/widgets/ayah_details/build_ayah_list_column.dart", "file_name": "build_ayah_list_column.dart", "line": 22, "line_from": 22, "line_to": 80, "snippet": "  final void Function(int ayahID)? onAyahSelected;\n  final ThemeData theme;\n  final int selectedAyahIndex;\n  final List<int> filteredAyahs;\n  final Function(String) onSearchChanged;\n  final TextEditingController ayahSearchController;\n  final int ayahNumbers;\n  final int? initialAyahIndex;\n\n  @override\n  State<BuildAyahListColumn> createState() => _BuildAyahListColumnState();\n}\n\nclass _BuildAyahListColumnState extends State<BuildAyahListColumn> {\n  final ItemScrollController _scrollController = ItemScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.initialAyahIndex != null) {\n      UiHelper.doOnPageLoaded(() {\n        if (_scrollController.isAttached) {\n          _scrollController.jumpTo(index: widget.initialAyahIndex!);\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return BuildExpandedColumn(\n        flex: 1,\n        searchTextField: UserInputField(\n          textEditingController: widget.ayahSearchController,\n          borderRadius: BorderRadius.circular(50),\n          hintText: context.l10n.ayah,\n          onChanged: widget.onSearchChanged,\n          inputFormatters: [\n            FilteringTextInputFormatter.digitsOnly,\n            LengthLimitingTextInputFormatter(3),\n          ],\n        ),\n        listViewBuilder: () {\n          return ScrollablePositionedList.builder(\n            itemScrollController: _scrollController,\n            itemCount: widget.filteredAyahs.length,\n            itemBuilder: (context, index) {\n              final ayahID = widget.filteredAyahs[index];\n              return AyahNumberListItem(\n                index: ayahID - 1,\n                theme: widget.theme,\n                selectedAyahIndex: widget.selectedAyahIndex,\n                onSelect: () => widget.onAyahSelected!(ayahID - 1),\n              );\n            },\n          );\n        });\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "bottom_sheet", "file_path": "presentation/ayah_detail/widgets/bottom_sheet/more_option_bottom_sheet.dart", "file_name": "more_option_bottom_sheet.dart", "line": 60, "line_from": 60, "line_to": 95, "snippet": "    void Function(BookmarkEntity)? onBookmarkRemoved,\n    bool isDirectButtonVisible = false,\n    bool idAddCollectionButtonVisible = true,\n    bool isPlayButtonVisible = true,\n    bool isCopyAyahButtonVisible = true,\n    bool isFromMemorization = false,\n    bool isFromDailyAyah = false,\n    bool isFromSearch = false,\n    bool isFromSubjectWise = false,\n    bool isTafseerButtonVisible = false,\n    bool isFromAyahPage = false,\n    bool isFromDua = false,\n  }) async {\n    final MoreOptionBottomSheet moreOptionBottomSheet = MoreOptionBottomSheet(\n      surahID: surahID,\n      ayahID: ayahID,\n      bookmark: bookmark,\n      dua: dua,\n      onBookmarkRemoved: onBookmarkRemoved,\n      isDirectButtonVisible: isDirectButtonVisible,\n      idAddCollectionButtonVisible: idAddCollectionButtonVisible,\n      isPlayButtonVisible: isPlayButtonVisible,\n      isCopyAyahButtonVisible: isCopyAyahButtonVisible,\n      isFromMemorization: isFromMemorization,\n      isFromDailyAyah: isFromDailyAyah,\n      isFromSearch: isFromSearch,\n      isFromSubjectWise: isFromSubjectWise,\n      isTafseerButtonVisible: isTafseerButtonVisible,\n      isFromAyahPage: isFromAyahPage,\n      isFromDua: isFromDua,\n      key: const Key(\"MoreOptionBottomSheet\"),\n    );\n\n    if (!context.mounted) return;\n    await context.showBottomSheet(moreOptionBottomSheet, context);\n  }"}, {"structure_type": "function", "name": "onInit", "docstring": "", "module": "presenter", "file_path": "presentation/word_by_word/presenter/word_by_word_presenter.dart", "file_name": "word_by_word_presenter.dart", "line": 47, "line_from": 47, "line_to": 322, "snippet": "  Future<void> onInit() async {\n    super.onInit();\n    await _loadInitialData();\n  }\n\n  Future<void> _loadInitialData() async {\n    await toggleLoading(loading: true);\n    await _loadDownloadedLanguages();\n    await _loadAvailableLanguages();\n    await _loadSelectedLanguage();\n    await toggleLoading(loading: false);\n  }\n\n  Future<void> _loadAvailableLanguages() async {\n    final result = await _getAvailableWbwLanguagesUseCase.execute();\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (wbwJsonModel) async {\n        final input = _LanguageProcessInput(\n          allLanguages: wbwJsonModel.wordbyword,\n          downloadedLanguages: currentUiState.downloadedLanguages,\n        );\n\n        final List<WbwDbFileModel> availableLanguages = await compute(\n          _processAvailableLanguages,\n          input,\n        );\n\n        uiState.value = currentUiState.copyWith(\n          availableLanguages: availableLanguages,\n          allLanguages: wbwJsonModel.wordbyword,\n        );\n      },\n    );\n  }\n\n  static List<WbwDbFileModel> _processAvailableLanguages(_LanguageProcessInput input) {\n    return input.allLanguages.where((language) => !input.downloadedLanguages.contains(language.name)).toList();\n  }\n\n  Future<void> _loadDownloadedLanguages() async {\n    final result = await _getDownloadedWbwLanguagesUseCase.execute();\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (downloadedLanguages) {\n        uiState.value = currentUiState.copyWith(\n          downloadedLanguages: downloadedLanguages,\n        );\n      },\n    );\n  }\n\n  String getFileSize(String fileName, BuildContext context) {\n    if (fileName == 'Bangla' || fileName == 'English') {\n      return context.l10n.defaultLang;\n    }\n    final WbwDbFileModel file = currentUiState.allLanguages.firstWhere((element) => element.name == fileName);\n    return '${context.l10n.fileSize}: ${file.size.toLocalizedNumber(context)} ${context.l10n.mb}';\n  }\n\n  Future<void> _loadSelectedLanguage() async {\n    final result = await _getSelectedWbwLanguageUseCase.execute();\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (selectedLanguage) {\n        uiState.value = currentUiState.copyWith(\n          selectedLanguage: selectedLanguage,\n        );\n      },\n    );\n  }\n\n  Future<void> downloadLanguage({required WbwDbFileModel wbwFile, required BuildContext context}) async {\n    final bool hasInternet = await checkInternetConnection();\n    if (!hasInternet && context.mounted) {\n      showMessage(message: context.l10n.noInternetConnection);\n      return;\n    }\n\n    if (currentUiState.isDownloading) {\n      if (currentUiState.activeDownloadId == wbwFile.name && context.mounted) {\n        cancelDownload(context);\n        return addUserMessage(context.l10n.downloadCancelled);\n      } else {\n        if (context.mounted) {\n          return addUserMessage(context.l10n.downloadInProgress);\n        }\n      }\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isDownloading: true,\n      activeDownloadId: wbwFile.name,\n      downloadProgress: 0,\n    );\n\n    final Either<String, void> result = await _downloadWbwLanguageUseCase.execute(\n      wbwFile: wbwFile,\n      onProgress: (progress) {\n        uiState.value = currentUiState.copyWith(downloadProgress: progress);\n      },\n      cancelToken: _addCancelToken(wbwFile),\n    );\n\n    result.fold(\n      (failure) {\n        if (failure == \"Download cancelled\") {\n          if (context.mounted) addUserMessage(context.l10n.downloadCancelled);\n        } else {\n          if (context.mounted) addUserMessage(context.l10n.downloadFailed);\n        }\n        uiState.value = currentUiState.copyWith(\n          isDownloading: false,\n          activeDownloadId: null,\n          downloadProgress: 0,\n        );\n      },\n      (_) async {\n        await _loadDownloadedLanguages();\n        await _loadAvailableLanguages();\n        if (context.mounted) {\n          addUserMessage(context.l10n.downloadedSuccessfully);\n        }\n        uiState.value = currentUiState.copyWith(\n          isDownloading: false,\n          activeDownloadId: null,\n          downloadProgress: 0,\n        );\n      },\n    );\n  }\n\n  Future<void> loadWordByWordByFileModel(WbwDbFileModel fileModel, BuildContext context) async {\n    if (['Bangla', 'English'].contains(fileModel.name)) {\n      // Handle default language\n      await setSelectedLanguage(fileName: fileModel.name);\n    } else {\n      // Handle non-default language\n      final bool hasInternet = await checkInternetConnection();\n      if (!hasInternet) {\n        if (context.mounted) {\n          showMessage(message: context.l10n.noInternetConnection);\n        }\n        return;\n      }\n\n      uiState.value = currentUiState.copyWith(\n        isDownloading: true,\n        activeDownloadId: fileModel.name,\n        downloadProgress: 0,\n      );\n\n      final result = await _downloadWbwLanguageUseCase.execute(\n        wbwFile: fileModel,\n        cancelToken: _addCancelToken(fileModel),\n        onProgress: (progress) {\n          uiState.value = currentUiState.copyWith(downloadProgress: progress);\n        },\n      );\n\n      result.fold(\n        (error) => addUserMessage(error),\n        (_) async {\n          await _loadDownloadedLanguages();\n          await setSelectedLanguage(fileName: fileModel.name);\n        },\n      );\n    }\n\n    await _loadAvailableLanguages();\n    uiState.value = currentUiState.copyWith(\n      isDownloading: false,\n      activeDownloadId: null,\n      downloadProgress: 0,\n    );\n  }\n\n  CancelToken _addCancelToken(WbwDbFileModel file) {\n    final CancelToken cancelToken = CancelToken();\n    _cancelTokens[file.name] = cancelToken;\n    return cancelToken;\n  }\n\n  void cancelDownload(BuildContext context) {\n    if (currentUiState.isDownloading) {\n      _cancelTokens[currentUiState.activeDownloadId]?.cancel();\n\n      uiState.value = currentUiState.copyWith(\n        isDownloading: false,\n        activeDownloadId: null,\n        downloadProgress: 0,\n      );\n      addUserMessage(context.l10n.downloadCancelled);\n    }\n  }\n\n  Future<void> deleteLanguage({required String fileName, required BuildContext context}) async {\n    if (['Bangla', 'English'].contains(fileName)) {\n      addUserMessage(context.l10n.cannotDeleteDefaultLanguages);\n      return;\n    }\n\n    await RemoveDialog.show(\n      title: context.l10n.language,\n      context: context,\n      onRemove: () async {\n        final bool isCurrentlySelected = currentUiState.selectedLanguage == fileName;\n        final Either<String, WbwJsonModel> availableLanguagesResult = await _getAvailableWbwLanguagesUseCase.execute();\n        final WbwDbFileModel? wbwFile = availableLanguagesResult.fold(\n          (failure) {\n            addUserMessage(failure);\n            return null;\n          },\n          (wbwJsonModel) {\n            return wbwJsonModel.wordbyword.firstWhere((element) => element.name == fileName);\n          },\n        );\n        final deletedFile = await _deleteWbwLanguageUseCase.execute(file: wbwFile!);\n        deletedFile.fold(\n          (failure) => addUserMessage(failure),\n          (_) async {\n            await _loadDownloadedLanguages();\n            await _loadAvailableLanguages();\n            if (isCurrentlySelected) {\n              await setSelectedLanguage(fileName: currentUiState.downloadedLanguages.first);\n            }\n            if (context.mounted) {\n              addUserMessage(context.l10n.deletedSuccessfully);\n            }\n          },\n        );\n      },\n    );\n  }\n\n  Future<void> setSelectedLanguage({required String fileName}) async {\n    final WbwDbFileModel file = currentUiState.allLanguages.firstWhere((element) => element.fileName == fileName);\n    final result = await _setSelectedWbwLanguageUseCase.execute(file: file);\n    result.fold(\n      (failure) => addUserMessage(failure),\n      (_) async {\n        await _loadSelectedLanguage();\n      },\n    );\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async {\n    uiState.value = currentUiState.copyWith(userMessage: message);\n    showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async =>\n      uiState.value = currentUiState.copyWith(isLoading: loading);\n\n  bool isLanguageDownloaded(String fileName) {\n    // Convert fileName to language name if needed\n    String languageName = fileName;\n\n    // Map filename to language name\n    final Map<String, String> fileToName = {\n      'wbw_bn': 'Bangla',\n      'wbw_en': 'English',\n      'wbw_de': 'German',\n      'wbw_hi': 'Hindi',\n      'wbw_indo': 'Indonesian',\n      'wbw_ru': 'Russian',\n      'wbw_tr': 'Turkish',\n      'wbw_ur': 'Urdu',\n    };\n    languageName = fileToName[fileName] ?? fileName;\n\n    return currentUiState.downloadedLanguages.contains(languageName);\n  }\n}"}, {"structure_type": "function", "name": "conflicts", "docstring": "", "module": "ui", "file_path": "presentation/mushaf/ui/mushaf_page.dart", "file_name": "mushaf_page.dart", "line": 40, "line_from": 40, "line_to": 58, "snippet": "    // Set the mushaf type in the next frame to avoid build conflicts\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      presenter.setSelectedMushafType(type: widget.mushafType);\n      // Update appbar title after initialization\n      presenter.updateAppbarTitle(context);\n\n      // Start preloading pages in the background\n      presenter.preloadMushafPages();\n    });\n\n    // Register for app lifecycle events to manage memory\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/mushaf/ui/text_mushaf_page.dart", "file_name": "text_mushaf_page.dart", "line": 17, "line_from": 17, "line_to": 227, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: PresentableWidgetBuilder(\n          presenter: presenter,\n          builder: () {\n            final String title = presenter.currentUiState.appbarTitle ??\n                (presenter.currentUiState.appbarTitleKey == 'textMushafTitle'\n                    ? context.l10n.textMushafTitle\n                    : presenter.currentUiState.appbarTitleKey ?? context.l10n.textMushafTitle);\n            return Text(title);\n          },\n        ),\n        elevation: 1,\n      ),\n      body: PresentableWidgetBuilder(\n        presenter: presenter,\n        builder: () {\n          final TextMushafUiState state = presenter.currentUiState;\n\n          // Show a full-screen loading indicator when initializing or downloading\n          if (state.isDownloading || (state.isLoading && state.textLayout.isEmpty)) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  const CircularProgressIndicator(),\n                  const SizedBox(height: 16),\n                  if (state.isDownloading)\n                    Padding(\n                      padding: const EdgeInsets.symmetric(horizontal: 24.0),\n                      child: LinearProgressIndicator(\n                        value: state.downloadProgress,\n                      ),\n                    ),\n                  const SizedBox(height: 8),\n                  Text(\n                    state.isDownloading\n                        ? '${context.l10n.downloading} ${(state.downloadProgress * 100).round()}%'\n                        : context.l10n.loading,\n                    style: theme.textTheme.bodyMedium,\n                  ),\n                ],\n              ),\n            );\n          }\n\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),\n                child: Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    const SizedBox(width: 50),\n                    Text(\n                      (state.currentJuzNumber != null ? '${context.l10n.juz} ${state.currentJuzNumber}' : '') +\n                          (state.currentHizbNumber != null ? ' \u2022 ${context.l10n.hizb} ${state.currentHizbNumber}' : ''),\n                      style: theme.textTheme.titleSmall,\n                      textAlign: TextAlign.center,\n                    ),\n                    const SizedBox(width: 50),\n                  ],\n                ),\n              ),\n              Expanded(\n                child: PageView.builder(\n                  controller: presenter.pageController,\n                  itemCount: state.totalPages,\n                  itemBuilder: (BuildContext context, int pageIndex) {\n                    if (state.currentPage != pageIndex + 1) {\n                      return Container(color: theme.scaffoldBackgroundColor);\n                    }\n\n                    if (state.textLayout.isEmpty && state.isLoading) {\n                      return const Center(child: CircularProgressIndicator());\n                    }\n                    if (state.textLayout.isEmpty && !state.isLoading) {\n                      return Center(child: Text(\"No layout data for page ${pageIndex + 1}\"));\n                    }\n\n                    return ListView.builder(\n                      key: ValueKey('text_page_${pageIndex + 1}'),\n                      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),\n                      itemCount: state.textLayout.length,\n                      itemBuilder: (context, lineIndex) {\n                        final TextLayoutEntity lineLayout = state.textLayout[lineIndex];\n                        final List<TextWordEntity>? words = state.textWordsByLine[lineLayout.line];\n                        return _TextLineWidget(\n                          key: ValueKey('line_${pageIndex + 1}_${lineLayout.line}'),\n                          lineLayout: lineLayout,\n                          words: words,\n                          theme: theme,\n                        );\n                      },\n                    );\n                  },\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.all(8.0),\n                child: Text(\n                  context.l10n.pageCount(state.currentPage, state.totalPages),\n                  style: theme.textTheme.bodySmall,\n                ),\n              ),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _TextLineWidget extends StatelessWidget {\n  final TextLayoutEntity lineLayout;\n  final List<TextWordEntity>? words;\n  final ThemeData theme;\n\n  const _TextLineWidget({\n    super.key,\n    required this.lineLayout,\n    required this.words,\n    required this.theme,\n  });\n\n  static const String _basmallahText = '\u0628\u0650\u0633\u0652\u0645\u0650 \u0671\u0644\u0644\u064e\u0651\u0647\u0650 \u0671\u0644\u0631\u064e\u0651\u062d\u0652\u0645\u064e\u0640\u0670\u0646\u0650 \u0671\u0644\u0631\u064e\u0651\u062d\u0650\u064a\u0645\u0650';\n\n  String _getSurahName(int? surahNumber, BuildContext context) {\n    if (surahNumber == null || surahNumber < 1 || surahNumber > 114) {\n      return context.l10n.surah;\n    }\n    try {\n      final String surahNameArabic = CacheData.surahsCache[surahNumber - 1].name;\n      return surahNameArabic;\n    } catch (e) {\n      return context.l10n.surah;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final TextStyle arabicTextStyle = theme.textTheme.bodyLarge!.copyWith(\n      fontFamily: 'KFGQPC Uthmanic Script',\n      fontSize: 20,\n      height: 2.0,\n      letterSpacing: 0,\n      color: theme.textTheme.bodyLarge?.color,\n    );\n    final TextStyle surahNameStyle = theme.textTheme.headlineMedium!.copyWith(\n      fontFamily: 'KFGQPC Uthmanic Script',\n      fontSize: 28,\n      fontWeight: FontWeight.bold,\n      height: 1.8,\n      color: theme.colorScheme.primary,\n    );\n    final TextStyle basmallahStyle = arabicTextStyle.copyWith(\n      fontWeight: FontWeight.w500,\n      fontSize: arabicTextStyle.fontSize! * 1.05,\n    );\n\n    Widget lineContent;\n\n    switch (lineLayout.type) {\n      case 'ayah':\n        if (words == null || words!.isEmpty) {\n          lineContent = SizedBox(height: arabicTextStyle.fontSize! * (arabicTextStyle.height ?? 1.5) * 1.2);\n        } else {\n          lineContent = Wrap(\n            alignment: lineLayout.isCentered ? WrapAlignment.center : WrapAlignment.start,\n            textDirection: TextDirection.rtl,\n            runSpacing: 6.0,\n            spacing: 3.0,\n            children: words!.map((word) {\n              final String displayText = (word.uthmani ?? '') + (word.isAyahMarker ? '' : ' ');\n              return Text(\n                displayText,\n                style: arabicTextStyle,\n              );\n            }).toList(),\n          );\n        }\n        break;\n      case 'surah_name':\n        lineContent = Text(\n          _getSurahName(lineLayout.rangeStart, context),\n          style: surahNameStyle,\n          textAlign: lineLayout.isCentered ? TextAlign.center : TextAlign.start,\n        );\n        break;\n      case 'basmallah':\n        lineContent = Text(\n          _basmallahText,\n          style: basmallahStyle,\n          textAlign: lineLayout.isCentered ? TextAlign.center : TextAlign.start,\n        );\n        break;\n      default:\n        lineContent = SizedBox(height: arabicTextStyle.fontSize! * (arabicTextStyle.height ?? 1.5));\n    }\n\n    return Container(\n      width: double.infinity,\n      padding: const EdgeInsets.symmetric(vertical: 6.0),\n      alignment: lineLayout.isCentered ? Alignment.center : Alignment.centerRight,\n      child: lineContent,\n    );\n  }\n}"}, {"structure_type": "function", "name": "updates", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 45, "line_from": 45, "line_to": 57, "snippet": "    // Check if userMessage is already the same to avoid redundant updates\n    if (currentUiState.userMessage != message) {\n      uiState.value = currentUiState.copyWith(userMessage: message);\n      await showMessage(message: message);\n    }\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    if (currentUiState.isLoading != loading) {\n      uiState.value = currentUiState.copyWith(isLoading: loading);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 62, "line_from": 62, "line_to": 117, "snippet": "    void Function(double progress)? onProgressUpdate,\n  }) async {\n    // Check if the database is already available first\n    final bool isAvailable = await isDatabaseAvailable();\n\n    _initCancelToken = CancelToken(); // Create a new token for this attempt\n\n    // If database already exists, skip download and load data directly\n    if (isAvailable) {\n      await loadTextDataForPage(pageNumber: 5);\n      _initCancelToken = null;\n      return;\n    }\n\n    // Explicitly set downloading state before starting\n    uiState.value = currentUiState.copyWith(\n      isDownloading: true,\n      downloadProgress: 0.0,\n    );\n\n    final result = await _initializeTextMushafDatabaseUseCase.execute(\n      onProgress: (received, total) {\n        if (total > 0) {\n          final progress = received / total;\n          onProgressUpdate?.call(progress);\n        }\n      },\n      cancelToken: _initCancelToken,\n    );\n\n    await result.fold(\n      (error) async {\n        logErrorStatic('Text Mushaf DB Initialization failed: $error', _tag);\n        await addUserMessage(error); // Show error to user\n        uiState.value = currentUiState.copyWith(\n          isLoading: false,\n          isDownloading: false,\n          downloadProgress: 0.0,\n        ); // Stop loading\n      },\n      (_) async {\n        uiState.value = currentUiState.copyWith(\n          isDownloading: false,\n          downloadProgress: 1.0,\n        );\n\n        // Final progress update to external callback\n        onProgressUpdate?.call(1.0);\n\n        // Load data for the first page after successful initialization\n        await loadTextDataForPage(pageNumber: 1); // Load page 1\n      },\n    );\n\n    _initCancelToken = null;\n  }"}, {"structure_type": "function", "name": "[];", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/text_mushaf_presenter.dart", "file_name": "text_mushaf_presenter.dart", "line": 258, "line_from": 258, "line_to": 308, "snippet": "    final List<Future<void>> wordFutures = [];\n\n    for (final TextLayoutEntity lineLayout in layoutData) {\n      if (lineLayout.type == 'ayah' && lineLayout.rangeStart > 0 && lineLayout.rangeEnd >= lineLayout.rangeStart) {\n        // Add future to list\n        wordFutures.add(_getWordsForRangeUseCase\n            .execute(\n          params: GetWordsForRangeParams(\n            rangeStart: lineLayout.rangeStart,\n            rangeEnd: lineLayout.rangeEnd,\n          ),\n        )\n            .then((wordsResult) {\n          wordsResult.fold(\n            (wordsError) {\n              logErrorStatic(\n                  'Could not get words for range ${lineLayout.rangeStart}-${lineLayout.rangeEnd} on page $pageNumber, line ${lineLayout.line}: $wordsError',\n                  _tag);\n              wordFetchError = true;\n              wordsByLine[lineLayout.line] = []; // Assign empty list on error\n            },\n            (wordData) {\n              wordsByLine[lineLayout.line] = wordData; // Assign fetched data\n            },\n          );\n        }));\n      } else {\n        // For non-ayah lines, assign empty list immediately\n        wordsByLine[lineLayout.line] = [];\n        logInfoStatic('Skipping word fetch for line ${lineLayout.line}, type: ${lineLayout.type}', _tag);\n      }\n    }\n\n    // Wait for all word fetching futures to complete\n    await Future.wait(wordFutures);\n\n    if (wordFetchError) {\n      await addUserMessage('Some word data could not be loaded.');\n    }\n\n    return wordsByLine;\n  }\n\n  // Called by the PageView listener in the UI\n  void onPageChanged({required int newPage}) {\n    // Basic validation, loadTextDataForPage handles more detailed checks\n    if (newPage >= 1 && newPage <= currentUiState.totalPages && newPage != currentUiState.currentPage) {\n      // Debounce or throttle this if page changes can happen very rapidly\n      loadTextDataForPage(pageNumber: newPage);\n    }\n  }"}, {"structure_type": "function", "name": "rebuilds", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 217, "line_from": 217, "line_to": 245, "snippet": "    // Batch all state updates together to avoid multiple rebuilds\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      uiState.value = currentUiState.copyWith(\n        currentMushafType: newType,\n        currentPage: pageToOpen,\n        mushafDirectory: extractedPath,\n      );\n    });\n\n    await updatePageInfo(pageToOpen);\n  }\n\n  Future<int?> getFirstNonEmptyPage(MushafType type) async {\n    for (int page = 1; page <= _getTotalPages(type); page++) {\n      // Check without cache\n      try {\n        final result = await _getPageInfoUseCase.execute(\n          pageNumber: page,\n          mushafType: type,\n        );\n        if (result.isRight()) {\n          return page;\n        }\n      } catch (_) {\n        // Skip this page if there's an error\n      }\n    }\n    return null;\n  }"}, {"structure_type": "function", "name": "exists", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 428, "line_from": 428, "line_to": 468, "snippet": "            // Use exists() instead of existsSync() to avoid blocking the UI thread\n            if (await file1.exists()) {\n              nuraniFileFormat = 'nurani_quran_%d.png';\n            } else if (await file2.exists()) {\n              nuraniFileFormat = 'page%03d.png';\n            } else {\n              // Default if neither exists\n              nuraniFileFormat = 'nurani_quran_%d.png';\n            }\n          }\n\n          // Use last read page if available or default to page 1\n          final int initialPage = lastReadPage ?? 1;\n\n          uiState.value = currentUiState.copyWith(\n            isLoading: false,\n            isExtracting: false,\n            userMessage: null,\n            totalPages: totalPages,\n            currentMushafType: mushafType,\n            mushafDirectory: extractedPath,\n            nuraniFileFormat: nuraniFileFormat,\n            currentPage: initialPage,\n            appbarTitle: appbarTitle, // Set the appbar title directly here\n          );\n        },\n      );\n\n      // Fix the state update during build issue by handling navigation and state updates separately\n      if (isOnMushafPage) {\n        await updateCurrentMushafType(mushafType);\n      } else {\n        context.navigatorPop();\n        // Navigate first, then update state in the next frame to avoid build conflicts\n        Get.to(() => MushafPage(mushafType: mushafType));\n\n        // Use a post-frame callback to update state after navigation is complete\n        WidgetsBinding.instance.addPostFrameCallback((_) async {\n          await updateCurrentMushafType(mushafType);\n        });\n      }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 545, "line_from": 545, "line_to": 570, "snippet": "    // Use a post-frame callback to avoid updating state during build\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      // Make sure we're using the most up-to-date mushaf type\n      final MushafType currentType = currentUiState.currentMushafType;\n      final String title = getMushafTitle(type: currentType, context: context);\n\n      // Update the UI state with the new title\n      uiState.value = currentUiState.copyWith(appbarTitle: title);\n\n      // Force UI to refresh by calling update\n      update();\n    });\n  }\n\n  String getMushafFileSize({required MushafType type}) {\n    const Map<MushafType, double> fileSizes = {\n      MushafType.hafezi: 120.3,\n      MushafType.newmadani: 123.4,\n      MushafType.nurani: 50.0,\n      MushafType.qaloon: 104.9,\n      MushafType.shemerly: 115.9,\n      MushafType.warsh: 234.1,\n      MushafType.text: 5.2, // Smaller file size for the database\n    };\n    return '${fileSizes[type] ?? 0.0}';\n  }"}, {"structure_type": "function", "name": "system", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 994, "line_from": 994, "line_to": 1023, "snippet": "    // Preload images in batches to avoid overwhelming the system\n    const int batchSize = 3;\n    for (int i = 0; i < paths.length; i += batchSize) {\n      final end = (i + batchSize < paths.length) ? i + batchSize : paths.length;\n      final batch = paths.sublist(i, end);\n\n      await Future.wait(batch.map((path) => _preloadSingleImage(path)));\n\n      // Update preloading progress\n      final progress = end / paths.length;\n      uiState.value = currentUiState.copyWith(\n        preloadProgress: progress,\n      );\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isPreloading: false,\n      preloadProgress: 1.0,\n    );\n  }\n\n  Future<bool> _preloadSingleImage(String path) async {\n    try {\n      final params = PreloadImageParams(path);\n      return await compute(_preloadImageIsolate, params);\n    } catch (e) {\n      logError('Error preloading image: $e');\n      return false;\n    }\n  }"}, {"structure_type": "function", "name": "rebuilds", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 1042, "line_from": 1042, "line_to": 1107, "snippet": "    // Set flag in UI state but don't update preload paths to avoid widget rebuilds\n    uiState.value = currentUiState.copyWith(\n      isPreloading: true,\n      preloadProgress: 0.0,\n    );\n\n    int completed = 0;\n    final int total = paths.length;\n\n    // Preload in batches of 3 to avoid overwhelming the system\n    const int batchSize = 3;\n    for (int i = 0; i < paths.length; i += batchSize) {\n      final end = (i + batchSize < paths.length) ? i + batchSize : paths.length;\n      final batch = paths.sublist(i, end);\n\n      await Future.wait(batch.map((path) => _preloadSingleImage(path)));\n\n      completed += batch.length;\n      final progress = completed / total;\n\n      uiState.value = currentUiState.copyWith(\n        preloadProgress: progress,\n      );\n    }\n\n    uiState.value = currentUiState.copyWith(\n      isPreloading: false,\n      preloadProgress: 1.0,\n    );\n  }\n\n  // Get button title for the bottom sheet based on current state\n  String getButtonTitleForSelectedMushaf(BuildContext context) {\n    final MushafType selectedType = tempSelectedMushafType;\n    final uiState = currentUiState;\n\n    // Handle Text Mushaf download progress separately as a priority\n    if (selectedType == MushafType.text) {\n      // Get TextMushafPresenter to check its download state\n\n      final textUiState = textPresenter.currentUiState;\n\n      if (textUiState.isDownloading) {\n        final int progressPercent = (textUiState.downloadProgress * 100).round();\n        return '${context.l10n.downloading} ${progressPercent.toLocalizedString(context)}%';\n      }\n\n      // If not downloading, check if it's available\n      return textUiState.downloadProgress >= 1.0 ? context.l10n.apply : context.l10n.downloadNow;\n    }\n\n    // For regular mushafs:\n    // First priority: Show extraction status\n    if (uiState.isExtracting && uiState.downloadingMushafName == selectedType.name) {\n      return context.l10n.extracting;\n    }\n\n    // Second priority: Show download progress\n    if (uiState.isDownloading && uiState.downloadingMushafName == selectedType.name) {\n      final int progressPercent = (uiState.downloadProgress * 100).round();\n      return '${context.l10n.downloading} ${progressPercent.toLocalizedString(context)}%';\n    }\n\n    // Default based on downloaded status\n    return uiState.isSelectedMushafDownloaded ? context.l10n.apply : context.l10n.downloadNow;\n  }"}, {"structure_type": "function", "name": "rebuilds", "docstring": "", "module": "presenter", "file_path": "presentation/mushaf/presenter/mushaf_presenter.dart", "file_name": "mushaf_presenter.dart", "line": 1128, "line_from": 1128, "line_to": 1155, "snippet": "    // Only update if the value has changed to avoid unnecessary rebuilds\n    if (currentUiState.isSelectedMushafDownloaded != isDownloaded) {\n      uiState.value = currentUiState.copyWith(\n        isSelectedMushafDownloaded: isDownloaded,\n      );\n    }\n  }\n\n  void onPageChanged(int index) {\n    // This is called by the PageView in MushafPage (for image mushafs)\n    final int newPage = index + 1;\n    if (newPage == currentUiState.currentPage) {\n      return; // Ignore if same page\n    }\n\n    // Save last read page for the *previous* image mushaf page\n    saveLastReadPage();\n\n    // Update state for the new page\n    uiState.value = currentUiState.copyWith(\n      currentPage: newPage,\n      currentSurahName: null, // Clear old info, updatePageInfo will fetch new\n      currentJuzNumber: null,\n    );\n\n    // Update header info (Surah/Juz) for the new page\n    updatePageInfo(newPage);\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "widgets", "file_path": "presentation/mushaf/widgets/mushaf_juz_list_widget.dart", "file_name": "mushaf_juz_list_widget.dart", "line": 20, "line_from": 20, "line_to": 96, "snippet": "  Widget build(BuildContext context) {\n    final MushafPresenter mushafPresenter = locate();\n\n    return ListView.builder(\n      itemCount: 30,\n      shrinkWrap: true,\n      padding: EdgeInsets.only(top: tenPx),\n      itemBuilder: (context, index) {\n        final int juzNumber = index + 1;\n        return JuzSection(\n          juzNumber: juzNumber,\n          theme: theme,\n          mushafPresenter: mushafPresenter,\n        );\n      },\n    );\n  }\n}\n\nclass JuzSection extends StatelessWidget {\n  const JuzSection({\n    super.key,\n    required this.juzNumber,\n    required this.theme,\n    required this.mushafPresenter,\n  });\n\n  final int juzNumber;\n  final ThemeData theme;\n  final MushafPresenter mushafPresenter;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: double.infinity,\n      decoration: BoxDecoration(\n        borderRadius: radius10,\n      ),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          gapH10,\n          InkWell(\n            onTap: () {\n              mushafPresenter.navigateToJuz(juzNumber: juzNumber);\n              context.navigatorPop();\n            },\n            child: Container(\n              width: double.infinity,\n              padding: EdgeInsets.symmetric(\n                horizontal: fifteenPx,\n                vertical: sixPx,\n              ),\n              decoration: BoxDecoration(\n                color: context.color.dropDownColor,\n                borderRadius: radius4,\n              ),\n              child: Text(\n                '${context.l10n.juz} ${juzNumber.toLocalizedString(context)}',\n                style: theme.textTheme.titleMedium!.copyWith(\n                  fontWeight: FontWeight.w600,\n                  color: theme.primaryColor,\n                ),\n              ),\n            ),\n          ),\n          gapH8,\n          JuzSurahList(\n            juzNumber: juzNumber,\n            theme: theme,\n            mushafPresenter: mushafPresenter,\n          ),\n        ],\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "imageFuture;", "docstring": "", "module": "widgets", "file_path": "presentation/mushaf/widgets/mushaf_image_loader.dart", "file_name": "mushaf_image_loader.dart", "line": 62, "line_from": 62, "line_to": 235, "snippet": "  final Future<Uint8List?>? imageFuture;\n  final bool hasError;\n  final bool isInitialized;\n\n  MushafImageUiState({\n    this.imageFuture,\n    this.hasError = false,\n    this.isInitialized = false,\n  });\n\n  static MushafImageUiState empty() => MushafImageUiState();\n\n  MushafImageUiState copyWith({\n    Future<Uint8List?>? imageFuture,\n    bool? hasError,\n    bool? isInitialized,\n  }) {\n    return MushafImageUiState(\n      imageFuture: imageFuture ?? this.imageFuture,\n      hasError: hasError ?? this.hasError,\n      isInitialized: isInitialized ?? this.isInitialized,\n    );\n  }\n}\n\n// Presenter class for MushafImageLoader\nclass MushafImagePresenter extends GetxController {\n  final String filePath;\n  final double viewportWidth;\n  final List<String>? preloadPaths;\n\n  // Static image cache\n  static final Map<String, Uint8List> _imageCache =\n      LinkedHashMap<String, Uint8List>(equals: (a, b) => a == b, hashCode: (k) => k.hashCode);\n  static const int _maxCacheSize = 20;\n\n  // Reactive state\n  final Rx<MushafImageUiState> uiState = Rx<MushafImageUiState>(MushafImageUiState.empty());\n  MushafImageUiState get currentUiState => uiState.value;\n\n  final List<Future<void>> _pendingPreloads = [];\n\n  MushafImagePresenter({\n    required this.filePath,\n    required this.viewportWidth,\n    this.preloadPaths,\n  });\n\n  @override\n  void onClose() {\n    _pendingPreloads.clear();\n    super.onClose();\n  }\n\n  // Add to image cache\n  void _addToCache(String key, Uint8List value) {\n    // Remove oldest entries if cache is getting too large\n    if (_imageCache.length >= _maxCacheSize) {\n      final oldestKey = _imageCache.keys.first;\n      _imageCache.remove(oldestKey);\n    }\n    _imageCache[key] = value;\n  }\n\n  // Initialize image loading\n  void initializeImageLoading(BuildContext context) {\n    if (currentUiState.isInitialized) return;\n\n    _loadImage(context);\n    _preloadImages(context);\n\n    uiState.value = currentUiState.copyWith(isInitialized: true);\n  }\n\n  // Load image\n  void _loadImage(BuildContext context) {\n    // Get device pixel ratio safely\n    final double devicePixelRatio = MediaQuery.of(context).devicePixelRatio;\n    final double targetWidth = viewportWidth * devicePixelRatio;\n\n    // Check if the image is already in cache\n    if (_imageCache.containsKey(filePath)) {\n      uiState.value = currentUiState.copyWith(imageFuture: Future.value(_imageCache[filePath]), hasError: false);\n    } else {\n      uiState.value = currentUiState.copyWith(imageFuture: _loadImageData(filePath, targetWidth), hasError: false);\n    }\n  }\n\n  // Retry loading the image\n  void retryLoadImage(BuildContext context) {\n    _loadImage(context);\n  }\n\n  // Process image data in an isolate\n  Future<Uint8List?> _processImageData(Uint8List bytes, double targetWidth) async {\n    try {\n      return await compute(_processImageInIsolate, ProcessImageParams(bytes, targetWidth.round()));\n    } catch (e) {\n      return bytes; // If processing fails, return the original bytes\n    }\n  }\n\n  // Preload images for faster access\n  void _preloadImages(BuildContext context) {\n    if (preloadPaths == null || preloadPaths!.isEmpty) return;\n\n    // Get device pixel ratio safely\n    final double devicePixelRatio = MediaQuery.of(context).devicePixelRatio;\n    final double targetWidth = viewportWidth * devicePixelRatio;\n\n    // Prioritize loading - load closest pages first\n    final preloadPriority = [...preloadPaths!];\n\n    // Load images in a staggered manner to avoid overwhelming the system\n    for (int i = 0; i < preloadPriority.length; i++) {\n      final path = preloadPriority[i];\n\n      // Skip if already cached\n      if (_imageCache.containsKey(path)) continue;\n\n      // Add a small delay between preloads to avoid UI freezes\n      final preloadFuture = Future.delayed(Duration(milliseconds: i * 50), () async {\n        try {\n          final bytes = await _loadImageData(path, targetWidth);\n          if (bytes != null) {\n            _addToCache(path, bytes);\n          }\n        } catch (e) {\n          // Silently handle preload errors\n          logErrorStatic('Error preloading image $path:', e.toString());\n        }\n      });\n\n      _pendingPreloads.add(preloadFuture);\n    }\n  }\n\n  // Load image data from file\n  Future<Uint8List?> _loadImageData(String path, double targetWidth) async {\n    try {\n      // Check cache first\n      if (_imageCache.containsKey(path)) {\n        return _imageCache[path];\n      }\n\n      // Load file bytes in isolate\n      final params = FileReadParams(path);\n      final rawBytes = await compute(_readFileBytes, params);\n\n      if (rawBytes == null || rawBytes.isEmpty) {\n        return null;\n      }\n\n      // Process image in isolate\n      final processedData = await _processImageData(rawBytes, targetWidth);\n\n      if (processedData != null && processedData.isNotEmpty) {\n        // Cache the processed image\n        _addToCache(path, processedData);\n        return processedData;\n      }\n\n      return rawBytes;\n    } catch (e) {\n      logErrorStatic('Error loading image $path:', e.toString());\n      return null;\n    }\n  }\n\n  // Set error state\n  void setErrorState() {\n    uiState.value = currentUiState.copyWith(hasError: true);\n  }\n}"}, {"structure_type": "function", "name": "changes", "docstring": "", "module": "widgets", "file_path": "presentation/mushaf/widgets/mushaf_page_view.dart", "file_name": "mushaf_page_view.dart", "line": 49, "line_from": 49, "line_to": 99, "snippet": "        // Move page controller logic to post-frame callback to avoid build-time state changes\n        WidgetsBinding.instance.addPostFrameCallback((_) {\n          _syncPageControllerWithState(state);\n        });\n\n        return PageView.builder(\n          controller: pageController,\n          itemCount: totalPages,\n          reverse: true,\n          physics: const PageScrollPhysics(\n            parent: ClampingScrollPhysics(),\n          ),\n          scrollDirection: Axis.horizontal,\n          pageSnapping: true,\n          allowImplicitScrolling:\n              true, // This helps preload adjacent pages in memory\n          padEnds: false,\n          itemBuilder: (context, index) {\n            return _buildPage(context, index, state);\n          },\n          onPageChanged: (index) {\n            onPageChanged?.call(index);\n\n            // Defer state updates to after build phase\n            WidgetsBinding.instance.addPostFrameCallback((_) {\n              if (pageController.positions.isNotEmpty) {\n                mushafPresenter.updatePageInfo(index + 1);\n\n                // Preload surrounding pages when page changes\n                _preloadSurroundingPages(index);\n              }\n            });\n          },\n        );\n      },\n    );\n  }\n\n  // New helper method to handle page controller synchronization\n  void _syncPageControllerWithState(MushafPageUiState state) {\n    if (pageController.hasClients) {\n      final currentPageIndex = pageController.page?.round() ?? 0;\n      if ((currentPageIndex + 1) != state.currentPage) {\n        pageController.jumpToPage(\n          state.currentPage - 1,\n        );\n      }\n      // Always update page info for the current page\n      mushafPresenter.updatePageInfo(state.currentPage);\n    }\n  }"}, {"structure_type": "function", "name": "show", "docstring": "", "module": "pins", "file_path": "presentation/collections/ui/pins/edit_pin_bottomsheet.dart", "file_name": "edit_pin_bottomsheet.dart", "line": 28, "line_from": 28, "line_to": 137, "snippet": "  static Future<void> show({\n    required PinEntity pin,\n    required BuildContext context,\n  }) async {\n    await showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      backgroundColor: Colors.transparent,\n      builder: (context) => EditPinBottomSheet(pin: pin),\n    );\n  }\n\n  @override\n  State<EditPinBottomSheet> createState() => _EditPinBottomSheetState();\n}\n\nclass _EditPinBottomSheetState extends State<EditPinBottomSheet> {\n  late final TextEditingController _pinNameEditingController;\n  late final PinPresenter _pinPresenter = locate<PinPresenter>();\n  late final BookmarkPresenter _bookmarkPresenter = locate<BookmarkPresenter>();\n\n  @override\n  @override\n  void initState() {\n    super.initState();\n    _pinNameEditingController = TextEditingController(text: widget.pin.name);\n  }\n\n  @override\n  void dispose() {\n    _pinNameEditingController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return PresentableWidgetBuilder(\n      presenter: _pinPresenter,\n      onInit: () async {\n        _bookmarkPresenter.toggleColor(\n            color: getColorFromHex(widget.pin.color));\n      },\n      builder: () {\n        return Padding(\n          padding: EdgeInsets.only(\n            bottom: MediaQuery.of(context).viewInsets.bottom,\n          ),\n          child: CustomBottomSheetContainer(\n            key: const Key('EditPinBottomSheet'),\n            theme: theme,\n            bottomSheetTitle: context.l10n.editPin,\n            children: [\n              gapH10,\n              HeaderTitle(\n                key: const Key('EditPinBottomSheetHeader'),\n                title: context.l10n.changeName,\n                theme: theme,\n              ),\n              gapH10,\n              SizedBox(\n                height: fortyFivePx,\n                child: UserInputField(\n                  key: const Key('EditPinBottomSheetUserInputField'),\n                  textEditingController: _pinNameEditingController,\n                  contentPadding: EdgeInsets.only(right: tenPx),\n                  hintText: context.l10n.example,\n                  prefixIconPath: SvgPath.icPin,\n                  prefixIconColor:\n                      _bookmarkPresenter.currentUiState.selectedColor,\n                  inputFormatters: [\n                    FilteringTextInputFormatter.deny(RegexPatterns.denySpace),\n                  ],\n                  borderRadius: radius10,\n                ),\n              ),\n              gapH22,\n              HeaderTitle(\n                  key: const Key('EditPinBottomSheetHeaderTitle'),\n                  title: context.l10n.changeFolderColor,\n                  theme: theme),\n              gapH10,\n              SelectableColorList(),\n              gapH22,\n              TwoWayActionButton(\n                theme: theme,\n                submitButtonTitle: context.l10n.done,\n                cancelButtonTitle: context.l10n.cancel,\n                onCancelButtonTap: () => context.navigatorPop<void>(),\n                onSubmitButtonTap: () async {\n                  await _pinPresenter.updatePin(\n                    oldPin: widget.pin,\n                    newName: _pinNameEditingController.text,\n                    newColor: getHexFromColor(\n                        _bookmarkPresenter.currentUiState.selectedColor),\n                    context: context,\n                    onUpdated: () {\n                      context.navigatorPop<void>();\n                      _pinPresenter.addUserMessage(context.l10n.pinUpdSuccess);\n                    },\n                  );\n                },\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "components", "file_path": "presentation/collections/ui/components/remove_dialog.dart", "file_name": "remove_dialog.dart", "line": 23, "line_from": 23, "line_to": 35, "snippet": "    required Future<void> Function() onRemove,\n  }) async {\n    await showAnimatedDialog<void>(\n      context: context,\n      builder: (_) => RemoveDialog(\n        onRemove: onRemove,\n        title: title,\n      ),\n      animationType: DialogTransitionType.scale,\n      curve: Curves.fastOutSlowIn,\n      barrierDismissible: true,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "components", "file_path": "presentation/collections/ui/components/import_export_bottom_sheet.dart", "file_name": "import_export_bottom_sheet.dart", "line": 68, "line_from": 68, "line_to": 83, "snippet": "    required Future<void> Function() onImportSelected,\n    required Future<void> Function() onExportSelected,\n  }) async {\n    final ImportExportBottomSheet importExportBottomSheet =\n        await Future.microtask(\n      () => ImportExportBottomSheet(\n        key: const Key('ImportExportBottomSheet'),\n        onImportSelected: onImportSelected,\n        onExportSelected: onExportSelected,\n      ),\n    );\n\n    if (context.mounted) {\n      await context.showBottomSheet<void>(importExportBottomSheet, context);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "components", "file_path": "presentation/collections/ui/components/log_out_dialog.dart", "file_name": "log_out_dialog.dart", "line": 24, "line_from": 24, "line_to": 36, "snippet": "    required Future<void> Function() onRemove,\n  }) async {\n    await showAnimatedDialog<void>(\n      context: context,\n      builder: (_) => LogOutDialog(\n        onRemove: onRemove,\n        title: title,\n      ),\n      animationType: DialogTransitionType.scale,\n      curve: Curves.fastOutSlowIn,\n      barrierDismissible: true,\n    );\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "bookmarks", "file_path": "presentation/collections/ui/bookmarks/edit_bookmark_bottomsheet.dart", "file_name": "edit_bookmark_bottomsheet.dart", "line": 33, "line_from": 33, "line_to": 45, "snippet": "    required Future<bool> Function(String, Color) onEditBookmarkFolder,\n  }) async {\n    final EditBookmarkBottomSheet editBookmarkCollection = await Future.microtask(\n      () => EditBookmarkBottomSheet(\n        key: const Key(\"EditBookmarkBottomSheet\"),\n        folder: bookmarkFolder,\n        onEditBookmarkFolder: onEditBookmarkFolder,\n      ),\n    );\n    if (context.mounted) {\n      await context.showBottomSheet<void>(editBookmarkCollection, context);\n    }\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "bookmarks", "file_path": "presentation/collections/ui/bookmarks/more_bookmark_option_bottom_sheet.dart", "file_name": "more_bookmark_option_bottom_sheet.dart", "line": 75, "line_from": 75, "line_to": 92, "snippet": "    required void Function(BookmarkFolderEntity) onRemoveBookmarkFolder,\n    required Future<bool> Function(BookmarkFolderEntity, String, Color) onEditBookmarkFolder,\n    required BookmarkFolderEntity folder,\n    required ThemeData theme,\n  }) async {\n    final MoreBookmarkOptionBottomSheet moreBookmarkOption = await Future.microtask(\n      () => MoreBookmarkOptionBottomSheet(\n        onRemoveBookmarkFolder: (folder) => onRemoveBookmarkFolder(folder),\n        onEditBookmarkFolder: (newName, color) async => onEditBookmarkFolder(folder, newName, color),\n        theme: theme,\n        folder: folder,\n      ),\n    );\n\n    if (context.mounted) {\n      await context.showBottomSheet<void>(moreBookmarkOption, context);\n    }\n  }"}, {"structure_type": "class", "name": "CollectionUiState extends BaseUiState", "docstring": "", "module": "presenter", "file_path": "presentation/collections/presenter/collection_ui_state.dart", "file_name": "collection_ui_state.dart", "line": 4, "line_from": 4, "line_to": 52, "snippet": "class CollectionUiState extends BaseUiState {\n  final bool isAuthenticated;\n  final bool isSyncing;\n  final Color selectedColor;\n\n  const CollectionUiState({\n    required super.isLoading,\n    required super.userMessage,\n    this.isAuthenticated = false,\n    this.isSyncing = false,\n    this.selectedColor = const Color(0xff66BB6A),\n  });\n\n  factory CollectionUiState.empty() => const CollectionUiState(\n        isLoading: false,\n        userMessage: null,\n      );\n\n  @override\n  List<Object?> get props => [\n        isAuthenticated,\n        userMessage,\n        isLoading,\n        isSyncing,\n        selectedColor,\n      ];\n\n  bool get askToSync => !isAuthenticated;\n\n  CollectionUiState copyWith({\n    bool? isAuthenticated,\n    bool? isSyncing,\n    String? userMessage,\n    bool? isLoading,\n    Color? selectedColor,\n  }) {\n    return CollectionUiState(\n      isAuthenticated: isAuthenticated ?? this.isAuthenticated,\n      isSyncing: isSyncing ?? this.isSyncing,\n      isLoading: isLoading ?? this.isLoading,\n      userMessage: userMessage ?? this.userMessage,\n      selectedColor: selectedColor ?? this.selectedColor,\n    );\n  }\n}\n\n\nenum CollectionType { bookmark, pin }"}, {"structure_type": "function", "name": "=", "docstring": "", "module": "presenter", "file_path": "presentation/collections/presenter/collection_presenter.dart", "file_name": "collection_presenter.dart", "line": 84, "line_from": 84, "line_to": 101, "snippet": "      final Future<Either<String, String>> authenticationTask =\n          isAuthenticated ? _signOutUser.execute() : _signInUser.execute();\n\n      await executeMessageOnlyUseCase(() => authenticationTask);\n      await Future<void>.delayed(const Duration(milliseconds: 560));\n\n      await onCheckAuthentication(onAuthenticated: _syncCollections);\n    });\n  }\n\n  Future<void> onCheckAuthentication({\n    required VoidCallback onAuthenticated,\n    VoidCallback? onUnauthenticated,\n  }) async {\n    final bool isAuthenticated = await _checkAuthenticationStatus.execute();\n    uiState.value = currentUiState.copyWith(isAuthenticated: isAuthenticated);\n    isAuthenticated ? onAuthenticated() : onUnauthenticated?.call();\n  }"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "presenter", "file_path": "presentation/collections/presenter/collection_presenter.dart", "file_name": "collection_presenter.dart", "line": 198, "line_from": 198, "line_to": 208, "snippet": "    required void Function(String) onFetched,\n  }) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    await parseDataFromEitherWithUserMessage(\n      task: () async => await _exportCollectionsUseCase.execute(),\n      onDataLoaded: (data) async {\n        onFetched(data);\n        await showMessage(message: context.l10n.urCollsExptdSuccessfully);\n      },\n    );\n  }"}, {"structure_type": "function", "name": "", "docstring": "", "module": "note", "file_path": "presentation/collections/presenter/note/note_presenter.dart", "file_name": "note_presenter.dart", "line": 154, "line_from": 154, "line_to": 184, "snippet": "      (void _) async {\n        // Trigger immediate sync with Firebase after adding\n        await syncCollectionsWithRemote();\n\n        await _loadNotes();\n        _noteUpdateController.add(null);\n        addUserMessage('Note added successfully');\n      },\n    );\n\n    await toggleLoading(loading: false);\n  }\n\n  Future<void> deleteNote({required NoteEntity note}) async {\n    await toggleLoading(loading: true);\n\n    final result = await deleteNoteUseCase(surahId: note.surahId, ayahNumber: note.ayahNumber);\n    result.fold(\n      (String error) => addUserMessage(error),\n      (void _) async {\n        // Trigger immediate sync with Firebase after deletion\n        await syncCollectionsWithRemote();\n\n        await _loadNotes();\n        _noteUpdateController.add(null);\n        addUserMessage('Note deleted successfully');\n      },\n    );\n\n    await toggleLoading(loading: false);\n  }"}, {"structure_type": "function", "name": "", "docstring": "", "module": "note", "file_path": "presentation/collections/presenter/note/note_presenter.dart", "file_name": "note_presenter.dart", "line": 215, "line_from": 215, "line_to": 235, "snippet": "      (void _) async {\n        // Trigger immediate sync with Firebase after update\n        await syncCollectionsWithRemote();\n\n        await _loadNotes();\n        _noteUpdateController.add(null);\n        addUserMessage('Note updated successfully');\n      },\n    );\n\n    await toggleLoading(loading: false);\n  }\n\n  Future<void> updateSortOption(SortOptionEntity option) async {\n    // First save the option\n    await saveNoteSortOptionUseCase.execute(option: option);\n    // Then update UI state\n    uiState.value = currentUiState.copyWith(selectedSort: option);\n    // Refresh the UI to show sorted notes\n    uiState.refresh();\n  }"}, {"structure_type": "function", "name": "onInit", "docstring": "", "module": "bookmark", "file_path": "presentation/collections/presenter/bookmark/bookmark_presenter.dart", "file_name": "bookmark_presenter.dart", "line": 114, "line_from": 114, "line_to": 873, "snippet": "  void onInit() {\n    _fetchAllBookmarkFolders();\n    _loadSavedSortOption();\n    // Set default sort to A to Z\n    final defaultSort = SortOptionEntity.options.firstWhere((option) => option.type == SortOptionType.name);\n    sortBookmarks(defaultSort);\n    super.onInit();\n  }\n\n  Future<void> _loadSavedSortOption() async {\n    final SortOptionEntity? savedOption = await _getSavedSortOptionUseCase.execute();\n    if (savedOption != null) {\n      await _sortBookmarks(savedOption);\n    }\n  }\n\n  Future<void> fetchBookmarks() async {\n    await parseDataFromEitherWithUserMessage(\n      task: _getAllBookmarkFoldersUseCase.execute,\n      onDataLoaded: (folders) {\n        final List<BookmarkFolderEntity> bookmarkFolders = folders.toList(growable: true);\n        _originalBookmarkFolders = bookmarkFolders;\n        _allBookmarkFolders = [..._originalBookmarkFolders];\n\n        uiState.value = currentUiState.copyWith(\n          bookmarkFolders: _allBookmarkFolders,\n          filteredBookmarkFolders: _allBookmarkFolders,\n        );\n\n        if (currentUiState.selectedSort != null) {\n          _sortBookmarks(currentUiState.selectedSort!);\n        }\n      },\n    );\n  }\n\n  Future<void> sortBookmarks(SortOptionEntity option) async {\n    await _sortBookmarks(option);\n    await _saveSortOptionUseCase.execute(option);\n    uiState.refresh();\n  }\n\n  Future<void> _sortBookmarks(SortOptionEntity option) async {\n    await parseDataFromEitherWithUserMessage(\n      task: () => _sortBookmarkUseCase.execute(\n        folders: _originalBookmarkFolders,\n        option: option,\n      ),\n      onDataLoaded: (sortedFolders) {\n        _allBookmarkFolders = sortedFolders;\n        uiState.value = uiState.value.copyWith(\n          selectedSort: option,\n          bookmarkFolders: sortedFolders,\n        );\n        uiState.refresh();\n      },\n    );\n  }\n\n  Future<void> _fetchAllBookmarkFolders() async {\n    await parseDataFromEitherWithUserMessage(\n      task: _getAllBookmarkFoldersUseCase.execute,\n      onDataLoaded: (folders) {\n        final List<BookmarkFolderEntity> sortedFolders = folders.sortedBy((f) => f.createdAt).reversed.toList();\n        uiState.value = currentUiState.copyWith(bookmarkFolders: sortedFolders);\n      },\n    );\n  }\n\n  Future<void> onClickBookmarkPageMoreButton({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n    required String folderName,\n    required BookmarkEntity bookmark,\n    required bool isDirectButtonVisible,\n    required bool idAddCollectionButtonVisible,\n    required Function(int) onRemoveItem,\n  }) async {\n    await MoreOptionBottomSheet.show(\n      context: context,\n      surahID: surahID,\n      ayahID: ayahID,\n      bookmark: bookmark,\n      onBookmarkRemoved: (bookmark) async {\n        await RemoveDialog.show(\n          title: context.l10n.removeBookmark,\n          context: context,\n          onRemove: () async {\n            await Future.delayed(const Duration(milliseconds: 500));\n            if (!context.mounted) return;\n            await removeAyahFromBookmark(\n              bookmark: bookmark,\n              context: context,\n              foldername: folderName,\n              onRemoveItem: onRemoveItem,\n            );\n          },\n        );\n      },\n      isDirectButtonVisible: isDirectButtonVisible,\n      idAddCollectionButtonVisible: idAddCollectionButtonVisible,\n      isTafseerButtonVisible: false,\n      isPlayButtonVisible: false,\n    );\n  }\n\n  Future<void> _updateBookmarkCount({required BookmarkEntity bookmark}) async {\n    final List<BookmarkEntity> bookmarks = currentUiState.bookmarks;\n    final int count = bookmarks.where((element) => element.folderName == bookmark.folderName).length;\n    final List<BookmarkFolderEntity> updatedFolders = currentUiState.bookmarkFolders\n        .map((folder) => folder.name == bookmark.folderName ? folder.copyWith(count: count) : folder)\n        .toList();\n    final List<BookmarkEntity> updatedBookmarks = currentUiState.bookmarks\n        .map((b) => b.folderName == bookmark.folderName ? b.copyWith(folderName: bookmark.folderName) : b)\n        .toList();\n    uiState.value = currentUiState.copyWith(bookmarkFolders: updatedFolders, bookmarks: updatedBookmarks);\n\n    // If the bookmark count is zero, create a placeholder bookmark to preserve the folder\n    if (count == 0) {\n      await _saveEmptyFolderPlaceholder(bookmark.folderName, bookmark.color);\n    }\n  }\n\n  // Creates a special placeholder bookmark entry to keep empty folders alive\n  Future<void> _saveEmptyFolderPlaceholder(String folderName, Color color) async {\n    // Save the placeholder to ensure the folder continues to exist\n    await _saveBookmarksToAyahUseCase.execute(\n      surahID: -1,\n      ayahID: -1,\n      savingFolders: [\n        BookmarkFolderEntity(\n          id: DateTime.now().microsecond,\n          name: folderName,\n          color: color,\n          count: 0,\n          createdAt: DateTime.now(),\n          updatedAt: DateTime.now(),\n        )\n      ],\n    );\n\n    // Ensure changes are synced\n    await syncCollectionsWithRemote();\n\n    // Refresh the bookmarks UI\n    await fetchBookmarks();\n  }\n\n  Future<void> deleteBookmarkFolder({\n    required BookmarkFolderEntity folder,\n  }) async {\n    await parseDataFromEitherWithUserMessage(\n      task: () => _deleteBookmarkFolderUseCase.execute(folder: folder),\n      onDataLoaded: (message) async {\n        final List<BookmarkFolderEntity> bookmarks = currentUiState.bookmarkFolders.toList(growable: true)\n          ..remove(folder);\n\n        if (_searchQuery.isNotEmpty) {\n          clearSearch();\n        }\n\n        uiState.value = currentUiState.copyWith(bookmarkFolders: bookmarks);\n\n        // The repository now handles sync with Firebase, so we don't need to trigger it here\n        // We'll refetch bookmarks after a short delay to ensure deletion is complete\n        await Future.delayed(const Duration(milliseconds: 800));\n        await fetchBookmarks();\n        await addUserMessage(message);\n      },\n    );\n  }\n\n  String _lastBookmarkQuery = \"\";\n\n  Future<void> searchBookmarks({required String query}) async {\n    final String trimmedQuery = query.trim();\n    _searchQuery = trimmedQuery;\n\n    if (trimmedQuery.isEmpty) {\n      await fetchBookmarks();\n      return;\n    }\n\n    if (trimmedQuery == _lastBookmarkQuery) return;\n\n    await parseDataFromEitherWithUserMessage(\n      task: () => _searchBookmarkUseCase.execute(\n        query: trimmedQuery,\n        allFolders: _allBookmarkFolders,\n      ),\n      onDataLoaded: (bookmarks) {\n        uiState.value = currentUiState.copyWith(\n          filteredBookmarkFolders: bookmarks,\n        );\n      },\n    );\n    _lastBookmarkQuery = trimmedQuery;\n  }\n\n  Future<void> restoreSearchState() async {\n    if (_searchQuery.isNotEmpty) {\n      await searchBookmarks(query: _searchQuery);\n    }\n  }\n\n  Future<void> clearSearch() async {\n    _searchQuery = '';\n    _lastBookmarkQuery = '';\n    bookmarkSearchController.clear();\n    await searchBookmarks(query: '');\n  }\n\n  Future<void> fetchAyahListByBookmarkFolder({\n    required String folderName,\n  }) async {\n    uiState.value = uiState.value.copyWith(isLoading: true);\n    final AyahPresenter ayahPresenter = locate<AyahPresenter>();\n    final Either<String, List<BookmarkEntity>> result = await _getAyahListByBookmarkFolderUseCase.execute(folderName);\n    await result.fold(\n      (errorMessage) async => addUserMessage(errorMessage),\n      (bookmarks) async {\n        // Filter out placeholder bookmarks (with negative surahID/ayahID)\n        final List<BookmarkEntity> realBookmarks = bookmarks.where((b) => b.surahID > 0 && b.ayahID > 0).toList();\n\n        Map<int, Map<int, List<WordByWordEntity>>> updatedAyahCache = Map.from(uiState.value.ayahcache);\n\n        for (final bookmark in realBookmarks) {\n          final int surahNumber = bookmark.surahID;\n          final int ayahNumber = bookmark.ayahID;\n\n          if (!updatedAyahCache.containsKey(surahNumber)) {\n            updatedAyahCache[surahNumber] = {};\n          }\n\n          if (!updatedAyahCache[surahNumber]!.containsKey(ayahNumber)) {\n            final List<WordByWordEntity> words = await ayahPresenter.getWordsForSpecificAyah(surahNumber, ayahNumber);\n            updatedAyahCache[surahNumber]![ayahNumber] = words;\n          }\n        }\n\n        uiState.value = uiState.value.copyWith(\n          bookmarks: realBookmarks,\n          ayahcache: updatedAyahCache,\n          isLoading: false,\n        );\n      },\n    );\n  }\n\n  Future<void> onBookmarkFolderClicked({\n    required BookmarkFolderEntity folder,\n    required BuildContext context,\n    required TextEditingController editingController,\n  }) async {\n    await disposeKeyboard(\n      context,\n      editingController,\n    );\n    if ((folder.isInvalid || folder.count == 0) && context.mounted) {\n      showMessage(message: context.l10n.noBookmarkAdded);\n      return;\n    }\n\n    await fetchAyahListByBookmarkFolder(folderName: folder.name);\n\n    final BookmarkDetailsPage bookmarkDetailsPage = await Future.microtask(() => BookmarkDetailsPage(\n          folderName: folder.name,\n        ));\n    if (context.mounted) await context.navigatorPush<bool>(bookmarkDetailsPage);\n    focusNode.unfocus();\n    await fetchBookmarks();\n  }\n\n  Future<void> fetchSelectedBookmarks({\n    required int surahID,\n    required int ayahID,\n  }) async {\n    // First, fetch all bookmark folders\n    await fetchBookmarks();\n\n    // Then, fetch the selected bookmarks for this specific ayah\n    await parseDataFromEitherWithUserMessage(\n      task: () async => _getBookmarksBySurahAndAyahUseCase.execute(\n        surahID: surahID,\n        ayahID: ayahID,\n      ),\n      onDataLoaded: (folders) {\n        final Set<String> bookmarkFolderNames = folders.map((f) => f.name).toSet();\n        uiState.value = currentUiState.copyWith(\n          selectedBookmarkFolderNames: bookmarkFolderNames,\n        );\n      },\n    );\n  }\n\n  bool _hasShownErrorToast = false;\n\n  void validateInput(String value) {\n    final bool isValid = RegExp(r'^[\\p{L}\\p{N}].*', unicode: true).hasMatch(value);\n    uiState.value = uiState.value.copyWith(isInputError: !isValid);\n\n    if (!isValid && !_hasShownErrorToast) {\n      showMessage(message: \"Input must start with a letter or number\");\n      _hasShownErrorToast = true;\n    } else if (isValid) {\n      _hasShownErrorToast = false;\n    }\n  }\n\n  Future<bool> _validateFolderName({\n    required String name,\n  }) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    bool isValid = true;\n    final String purifiedName = name.trim();\n\n    final bool folderExists =\n        _allBookmarkFolders.any((folder) => folder.name.toLowerCase() == purifiedName.toLowerCase());\n\n    if (folderExists) {\n      await addUserMessage(context.l10n.folderAlreadyExists);\n      return false;\n    }\n\n    await parseDataFromEitherWithUserMessage(\n      task: () async => _validateFolderNameUseCase.execute(\n        folderName: purifiedName,\n      ),\n      onDataLoaded: (validated) async => isValid = validated,\n      valueOnError: false,\n    );\n    return isValid;\n  }\n\n  void toggleColor({required Color color}) {\n    uiState.value = currentUiState.copyWith(selectedColor: color);\n  }\n\n  Future<void> addBookmarkToAyah({\n    required int surahID,\n    required int ayahID,\n    Color? color,\n    VoidCallback? onSaved,\n  }) async {\n    final String purifiedName = folderNameEditingController.text.trim();\n    final bool isValid = await _validateFolderName(\n      name: purifiedName,\n    );\n    if (!isValid) return;\n\n    final Color selectedColor = color ?? currentUiState.selectedColor;\n\n    await _createBookmarkAndAddToAyah(\n      name: purifiedName,\n      surahID: surahID,\n      ayahID: ayahID,\n      color: selectedColor,\n    );\n\n    onSaved?.call();\n    _wasBookmarkJustAdded = true;\n    await addUserMessage(QuranMajeed.globalContext.l10n.bookmarkSaved);\n\n    folderNameEditingController.clear();\n  }\n\n  Future<void> goToAyahPageWithSurahAndAyahID({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n  }) async {\n    final AyahDetailsPage ayahPage = await Future.microtask(() => AyahDetailsPage(\n          initialPageIndex: surahID - 1,\n          initialAyahIndex: ayahID - 1,\n        ));\n    if (context.mounted) await context.navigatorPush<void>(ayahPage);\n  }\n\n  Future<void> toggleBookmarkFolderToSelectedByName(String name) async {\n    final Set<String> selectedBookmarkFolderNames = Set.from(currentUiState.selectedBookmarkFolderNames);\n    selectedBookmarkFolderNames.contains(name)\n        ? selectedBookmarkFolderNames.remove(name)\n        : selectedBookmarkFolderNames.add(name);\n    uiState.value = currentUiState.copyWith(\n      selectedBookmarkFolderNames: selectedBookmarkFolderNames,\n    );\n  }\n\n  Future<bool> updateBookmarkFolder({\n    required BookmarkFolderEntity folder,\n    required String newName,\n    required Color newColor,\n  }) async {\n    final bool isValid = folder.name == newName ||\n        await _validateFolderName(\n          name: newName.trim(),\n        );\n    if (!isValid) return false;\n    await executeMessageOnlyUseCase(\n      () async => _updateBookmarkFolderUseCase.execute(\n        folderName: folder.name.trim(),\n        newFolderName: newName.trim(),\n        color: newColor,\n      ),\n      onSuccess: () async {\n        // Trigger immediate sync with Firebase after update\n        await syncCollectionsWithRemote();\n      },\n    );\n    await fetchBookmarks();\n    return true;\n  }\n\n  void closeBookmarkNotification() {\n    uiState.value = currentUiState.copyWith(bookmarkNoticeShown: false);\n  }\n\n  Future<void> saveBookmarksForAyah({\n    required int surahID,\n    required int ayahID,\n    required void Function(int, {required bool isBookmarked}) onSaved,\n    required BuildContext context,\n  }) async {\n    final Set<String> selectedBookmarkFolderNames = currentUiState.selectedBookmarkFolderNames;\n\n    // Always consider it changed, whether adding or removing bookmarks\n    // This ensures the save operation runs even when deselecting all folders\n    uiState.value = uiState.value.copyWith(isBookmarkChanged: true);\n\n    // Capture the localized string early, before any async operations\n    final String bookmarkSavedMessage = context.l10n.bookmarkSaved;\n    final String bookmarkRemovedMessage = context.l10n.removeBookmark;\n\n    final List<BookmarkFolderEntity> bookmarkFolders =\n        currentUiState.bookmarkFolders.filter((f) => selectedBookmarkFolderNames.contains(f.name)).toList();\n\n    // Always execute the save operation, even when all folders are deselected\n    await executeMessageOnlyUseCase(\n      () async => _saveBookmarksToAyahUseCase.execute(\n        surahID: surahID,\n        ayahID: ayahID,\n        savingFolders: bookmarkFolders,\n      ),\n      onSuccess: () async {\n        // Trigger immediate sync with Firebase after saving\n        await syncCollectionsWithRemote();\n\n        onSaved(\n          bookmarkFolders.length,\n          isBookmarked: bookmarkFolders.isNotEmpty,\n        );\n\n        // Show appropriate message based on whether bookmarks were added or removed\n        if (bookmarkFolders.isEmpty) {\n          // All bookmarks were removed\n          addUserMessage(bookmarkRemovedMessage);\n        } else if (!_wasBookmarkJustAdded || selectedBookmarkFolderNames.length > 1) {\n          // Only show toast if bookmark wasn't just added or if additional folders were selected\n          addUserMessage(bookmarkSavedMessage);\n        }\n      },\n      showMessage: false,\n    );\n\n    _wasBookmarkJustAdded = false;\n    await _clearSelection();\n  }\n\n  Future<void> _clearSelection() async {\n    uiState.value = currentUiState.copyWith(\n      selectedBookmarkFolderNames: {},\n    );\n  }\n\n  void toggleSelectionVisibility() {\n    final bool newState = !currentUiState.checkBox;\n    uiState.value = currentUiState.copyWith(\n      checkBox: newState,\n      isSelected: newState ? currentUiState.isSelected : {},\n    );\n  }\n\n  void selectBookmarkItem(int index) {\n    final isSelectedSet = Set<int>.from(currentUiState.isSelected);\n    if (isSelectedSet.contains(index)) {\n      isSelectedSet.remove(index);\n    } else {\n      isSelectedSet.add(index);\n    }\n    uiState.value = currentUiState.copyWith(isSelected: isSelectedSet);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }\n\n  @override\n  Future<void> addUserMessage(String message) async {\n    await showMessage(message: message);\n  }\n\n  Future<void> disposeKeyboard(BuildContext context, TextEditingController controller) async {\n    FocusScope.of(context).unfocus();\n    controller.clear();\n  }\n\n  Future<void> onNewCreateBottomSheetClosed(TabController tabController) async {\n    await fetchBookmarks();\n  }\n\n  Future<void> onClickNewCreate({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n    required CollectionType collectionType,\n  }) async {\n    await CreateNewCollectionBottomSheet.show(\n      context: context,\n      surahID: surahID,\n      ayahID: ayahID,\n      collectionType: collectionType,\n    );\n  }\n\n  Future<void> onClickAddBookmarkButton({\n    required int surahID,\n    required int ayahID,\n  }) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    await CollectionBottomSheet.show(\n      context: context,\n      surahID: surahID,\n      ayahID: ayahID,\n      title: context.l10n.addBookmarks,\n      collectionType: CollectionType.bookmark,\n      onBookmarkToggled: (count, {required bool isBookmarked}) async {\n        await _ayahPresenter.updateAyahDataWithBookmark(\n          surahID: surahID,\n          ayahID: ayahID,\n          isBookmarked: isBookmarked,\n          isMultiBookmarked: count > 1,\n        );\n        _ayahPresenter.uiState.refresh();\n      },\n    );\n  }\n\n  Future<void> onClickAddPinsButton({\n    required int surahID,\n    required int ayahID,\n  }) async {\n    final BuildContext context = QuranMajeed.globalContext;\n    await CollectionBottomSheet.show(\n      context: context,\n      surahID: surahID,\n      ayahID: ayahID,\n      title: context.l10n.addPins,\n      collectionType: CollectionType.pin,\n      onBookmarkToggled: (count, {required bool isBookmarked}) async {\n        await _ayahPresenter.updateAyahDataWithBookmark(\n          surahID: surahID,\n          ayahID: ayahID,\n          isBookmarked: isBookmarked,\n          isMultiBookmarked: count > 1,\n        );\n        _ayahPresenter.uiState.refresh();\n      },\n    );\n  }\n\n  Future<void> doneButtonHandler({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n    required void Function(int, {required bool isBookmarked}) onBookmarkToggled,\n  }) async {\n    await saveBookmarksForAyah(\n      surahID: surahID,\n      ayahID: ayahID,\n      onSaved: onBookmarkToggled,\n      context: context,\n    );\n    if (context.mounted) {\n      context.navigatorPop<void>();\n    }\n  }\n\n  // Add a helper method to sync collections with Firebase\n  Future<void> syncCollectionsWithRemote() async {\n    await _syncBookmarksWithRemoteUseCase.execute();\n  }\n}\n\nextension BookmarkPresenterExtension on BookmarkPresenter {\n  Future<void> handleBookmarkToast({\n    required int surahID,\n    required int ayahID,\n    required BuildContext context,\n    bool showToastAlways = false,\n  }) async {\n    final String purifiedName = folderNameEditingController.text.trim();\n    final bool isValid = await _validateFolderName(\n      name: purifiedName,\n    );\n    if (!isValid) return;\n\n    final Color selectedColor = currentUiState.selectedColor;\n\n    // Immediately update UI state\n    _wasBookmarkJustAdded = true;\n\n    // Update Ayah state to show the bookmark icon immediately\n    final AyahPresenter ayahPresenter = locate<AyahPresenter>();\n    await ayahPresenter.updateAyahDataWithBookmark(\n      surahID: surahID,\n      ayahID: ayahID,\n      isBookmarked: true,\n      isMultiBookmarked: false,\n    );\n    ayahPresenter.uiState.refresh();\n\n    // Show success message\n    if (_wasBookmarkJustAdded || showToastAlways) {\n      await addUserMessage(context.l10n.bookmarkSaved);\n    }\n\n    // Now perform the actual database operations in background\n    _performBookmarkOperationsInBackground(\n      name: purifiedName,\n      surahID: surahID,\n      ayahID: ayahID,\n      color: selectedColor,\n    );\n  }\n\n  // Helper method to perform bookmark operations in background\n  void _performBookmarkOperationsInBackground({\n    required String name,\n    required int surahID,\n    required int ayahID,\n    required Color color,\n  }) {\n    // Fire and forget - process in background\n    Future(() async {\n      await _createBookmarkAndAddToAyah(\n        name: name,\n        surahID: surahID,\n        ayahID: ayahID,\n        color: color,\n      );\n\n      // Refresh bookmark list silently\n      await fetchBookmarks();\n    });\n    folderNameEditingController.clear();\n  }\n\n  // Modify the existing method to include Firebase sync in background\n  Future<void> _createBookmarkAndAddToAyah({\n    required String name,\n    required int surahID,\n    required int ayahID,\n    required Color color,\n  }) async {\n    await _createBookmarkFolderUseCase.execute(\n      name: name,\n      color: color,\n      surahID: surahID,\n      ayahID: ayahID,\n    );\n\n    // Sync with remote in background\n    Future(() async {\n      await syncCollectionsWithRemote();\n    });\n  }\n\n  // Modify the existing removeAyahFromBookmark to update UI immediately\n  Future<void> removeAyahFromBookmark({\n    required BookmarkEntity bookmark,\n    required BuildContext context,\n    required String foldername,\n    required Function(int) onRemoveItem,\n  }) async {\n    final List<BookmarkEntity> ayahList = [...currentUiState.bookmarks];\n    if (ayahList.isEmpty) return;\n\n    final int index = ayahList.indexWhere((currentBookmark) => currentBookmark.id == bookmark.id);\n    if (index <= -1) return;\n\n    // Immediately update UI\n    onRemoveItem(index);\n    await Future.delayed(const Duration(milliseconds: 300));\n\n    ayahList.removeAt(index);\n    uiState.value = currentUiState.copyWith(bookmarks: ayahList);\n\n    // Update Ayah UI state immediately\n    final AyahPresenter ayahPresenter = locate<AyahPresenter>();\n    final bool hasOtherBookmarks = ayahList.any(\n        (b) => b.surahID == bookmark.surahID && b.ayahID == bookmark.ayahID && b.folderName != bookmark.folderName);\n\n    await ayahPresenter.updateAyahDataWithBookmark(\n      surahID: bookmark.surahID,\n      ayahID: bookmark.ayahID,\n      isBookmarked: hasOtherBookmarks,\n      isMultiBookmarked: hasOtherBookmarks,\n    );\n    ayahPresenter.uiState.refresh();\n\n    // Process deletion in background\n    _performBookmarkDeletionInBackground(\n      bookmark: bookmark,\n      foldername: foldername,\n    );\n  }\n\n  // Helper method for background bookmark deletion\n  void _performBookmarkDeletionInBackground({\n    required BookmarkEntity bookmark,\n    required String foldername,\n  }) {\n    Future(() async {\n      await _deleteAyahFromBookmarkFolderUseCase.execute(\n        surahID: bookmark.surahID,\n        ayahID: bookmark.ayahID,\n        folderName: foldername,\n      );\n\n      // Sync with remote in background\n      await syncCollectionsWithRemote();\n\n      await _updateBookmarkCount(bookmark: bookmark);\n      uiState.refresh();\n    });\n  }\n\n  Future<void> doneButtonHandlerWithToast({\n    required BuildContext context,\n    required int surahID,\n    required int ayahID,\n    required void Function(int, {required bool isBookmarked}) onBookmarkToggled,\n    required bool showToastAlways,\n  }) async {\n    await saveBookmarksForAyah(\n      surahID: surahID,\n      ayahID: ayahID,\n      onSaved: onBookmarkToggled,\n      context: context,\n    );\n    // Determine if a toast should be shown based on selection changes.\n\n    // No toast here, handle toast in handleBookmarkToast\n    if (context.mounted) {\n      context.navigatorPop<void>();\n    }\n  }\n}"}, {"structure_type": "function", "name": "Future<void>.delayed", "docstring": "", "module": "presenter", "file_path": "presentation/on_boarding/presenter/on_boarding_presenter.dart", "file_name": "on_boarding_presenter.dart", "line": 242, "line_from": 242, "line_to": 250, "snippet": "    await Future<void>.delayed(112.inMilliseconds);\n    uiState.value = uiState.value.copyWith(userMessage: \"\", isLoading: false);\n  }\n\n  @override\n  Future<void> onReady() async {\n    super.onReady();\n    await syncSelectedLanguageWithSettings();\n  }"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/dua/ui/dua_details_page.dart", "file_name": "dua_details_page.dart", "line": 45, "line_from": 45, "line_to": 211, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n\n    // Sync language with app settings when page is built\n    Future.microtask(() => _duaPresenter.syncLanguageWithAppSettings());\n\n    // Load duas for the selected category if not already loaded\n    if (_duaPresenter.currentUiState.categoryId != category.categoryId) {\n      Future.microtask(\n          () => _duaPresenter.loadDuasByCategory(category.categoryId));\n    }\n\n    return Scaffold(\n      key: scaffoldKey,\n      endDrawer: const DuaMiniSettingsDrawer(),\n      appBar: CustomAppBar(\n        theme: theme,\n        title: context.l10n.duas,\n        actions: [\n          AppbarActionIcon(\n            theme: theme,\n            svgPath: SvgPath.icSettings,\n            onIconTap: () => scaffoldKey.currentState!.openEndDrawer(),\n          ),\n          gapW8\n        ],\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: paddingH16,\n            child: CustomHeaderSectionWidget(\n              title: category.categoryTitle,\n              theme: theme,\n              isDuaPage: true,\n            ),\n          ),\n          Expanded(\n            child: PresentableWidgetBuilder(\n              presenter: _duaPresenter,\n              builder: () {\n                final duas = _duaPresenter.currentUiState.currentDuas;\n\n                // Scroll to the initial dua index if specified\n                if (initialDuaIndex != null) {\n                  // Using post-frame callback to ensure the list is built before scrolling\n                  WidgetsBinding.instance.addPostFrameCallback((_) {\n                    if (_scrollController.isAttached) {\n                      _scrollController.jumpTo(\n                        index: initialDuaIndex!,\n                      );\n                    }\n                  });\n                }\n\n                return ScrollablePositionedList.builder(\n                  itemCount: duas.length,\n                  initialScrollIndex: initialDuaIndex ?? 0,\n                  itemScrollController: _scrollController,\n                  itemPositionsListener: _itemPositionsListener,\n                  itemBuilder: (context, index) {\n                    final dua = duas[index];\n                    final int surahId = dua.surahId ?? 1;\n                    final int ayahId = dua.ayahId?.contains('-') == true\n                        ? int.parse(dua.ayahId!.split('-')[0])\n                        : int.tryParse(dua.ayahId ?? '1') ?? 1;\n                    return DuaDetailsPageAyahContainer(\n                      index: index,\n                      surahID: surahId,\n                      ayahNumber: ayahId,\n                      ayahTopRowTitle: dua.name ?? '',\n                      sectionIcon: SvgPicture.asset(\n                        SvgPath.icAllah,\n                        height: twentyFourPx,\n                        colorFilter: buildColorFilter(theme.primaryColor),\n                      ),\n                      wordData: const [],\n                      onClickMore: () async => await MoreOptionBottomSheet.show(\n                        context: context,\n                        surahID: surahId,\n                        ayahID: ayahId,\n                        dua: dua,\n                        isDirectButtonVisible: true,\n                        isPlayButtonVisible: true,\n                        isCopyAyahButtonVisible: true,\n                        isFromDua: true,\n                      ),\n                      ayahPresenter: _ayahPresenter,\n                      duaReference: dua.reference ?? '',\n                      theme: theme,\n                      dua: dua,\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n/// Custom Mini Settings Drawer specifically for the Dua Details page\n/// Excludes word-by-word and tajweed settings\nclass DuaMiniSettingsDrawer extends StatelessWidget {\n  const DuaMiniSettingsDrawer({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final SettingsPresenter settingPresenter = locate();\n    final ThemeData themeData = Theme.of(context);\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      settingPresenter.initializeMiniSettings(pageType: PageType.dua);\n    });\n\n    return Container(\n      margin: EdgeInsets.only(\n        top: MediaQuery.of(context).padding.top,\n      ),\n      height: double.infinity,\n      width: QuranScreen.width * 0.75,\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: ClipRRect(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.start,\n          children: [\n            _MiniSettingsTopBar(),\n            gapH5,\n            Expanded(\n              child: SingleChildScrollView(\n                child: Column(\n                  children: [\n                    // Custom content settings without tajweed\n                    _DuaContentSettingsCard(\n                      settingPresenter: settingPresenter,\n                    ),\n                    Padding(\n                      padding: EdgeInsets.symmetric(horizontal: twentyPx),\n                      child: BuildDivider(\n                        theme: themeData,\n                      ),\n                    ),\n                    // Include font settings\n                    FontSettingsCard(\n                      settingPresenter: settingPresenter,\n                      showTextReview: false,\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "ui", "file_path": "presentation/dua/ui/dua_details_page.dart", "file_name": "dua_details_page.dart", "line": 216, "line_from": 216, "line_to": 340, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData themeData = Theme.of(context);\n    return Container(\n      padding: EdgeInsets.only(\n        left: twelvePx,\n        right: twelvePx,\n        top: twentyOnePx,\n      ),\n      decoration: BoxDecoration(\n        color: themeData.scaffoldBackgroundColor,\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n        ),\n      ),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n          GestureDetector(\n            onTap: () => context.navigatorPop(),\n            child: Padding(\n              padding: paddingH6,\n              child: Icon(\n                Icons.arrow_forward_ios_rounded,\n                size: sixteenPx,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          gapW8,\n          Align(\n            alignment: Alignment.centerLeft,\n            child: Text(\n              context.l10n.quickTools,\n              style: themeData.textTheme.headlineSmall?.copyWith(\n                fontWeight: FontWeight.bold,\n                color: themeData.primaryColor,\n              ),\n            ),\n          ),\n          const Spacer(),\n          GestureDetector(\n            onTap: () async {\n              await context.navigatorPush<void>(const SettingsPage());\n            },\n            child: SvgPicture.asset(\n              SvgPath.icSettings,\n              height: twentyOnePx,\n              colorFilter: buildColorFilter(isDarkMode(context)\n                  ? context.color.subtitleColor\n                  : context.color.primaryColor),\n            ),\n          ),\n          gapW10,\n        ],\n      ),\n    );\n  }\n}\n\n/// Custom Content Settings Card for Dua page\n/// Excludes tajweed settings\nclass _DuaContentSettingsCard extends StatelessWidget {\n  const _DuaContentSettingsCard({\n    required this.settingPresenter,\n  });\n\n  final SettingsPresenter settingPresenter;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return PresentableWidgetBuilder(\n      presenter: settingPresenter,\n      builder: () {\n        final bool isExpanded = settingPresenter.isSectionExpanded(1);\n\n        return SettingsContainer(\n          child: Column(\n            children: [\n              SettingsCardHeader(\n                title: context.l10n.viewSettings,\n                svgPath: SvgPath.icViews,\n                isExpanded: isExpanded,\n                onTap: () => settingPresenter.toggleSection(1),\n              ),\n              SettingsAnimatedContent(\n                isExpanded: isExpanded,\n                child: Column(\n                  children: [\n                    gapH18,\n                    SwitchSettingItem(\n                      theme: theme,\n                      title: context.l10n.showArabic,\n                      value: settingPresenter\n                              .uiState.value.settingsState?.showArabic ??\n                          true,\n                      onChanged: (value) => settingPresenter.toggleShowArabic(\n                        showArabic: value,\n                        context: context,\n                      ),\n                    ),\n                    gapH8,\n                    SwitchSettingItem(\n                      theme: theme,\n                      title: context.l10n.showTranslation,\n                      value: settingPresenter\n                              .uiState.value.settingsState?.showTranslation ??\n                          true,\n                      onChanged: (bool value) {\n                        settingPresenter.toggleShowTranslation(\n                          showTranslation: value,\n                          context: context,\n                        );\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "addUserMessage", "docstring": "", "module": "presenter", "file_path": "presentation/tajweed/presenter/tajweed_presenter.dart", "file_name": "tajweed_presenter.dart", "line": 12, "line_from": 12, "line_to": 39, "snippet": "  Future<void> addUserMessage(String message) async {\n    uiState.value = currentUiState.copyWith(userMessage: message);\n    showMessage(message: message);\n  }\n\n  @override\n  Future<void> toggleLoading({required bool loading}) async {\n    uiState.value = currentUiState.copyWith(isLoading: loading);\n  }\n}\n\n// Model class for Tajweed stop symbols\nclass TajweedStopSymbol {\n  final String symbolSvgPath; // The Arabic symbol shown in the colored circle\n  final String name; // Name of the stop type (e.g., \"Must Stop\")\n  final String meaning; // The meaning or instruction (optional)\n\n  final int occurrences; // Number of times found in the text\n  final int priority; // Priority level (optional, for sorting)\n\n  TajweedStopSymbol({\n    required this.symbolSvgPath,\n    required this.name,\n    this.meaning = '',\n    required this.occurrences,\n    this.priority = 0,\n  });\n}"}]