[{"structure_type": "function", "name": "setUp", "docstring": "", "module": "config", "file_path": "config/quran_screen.dart", "file_name": "quran_screen.dart", "line": 45, "line_from": 45, "line_to": 283, "snippet": "  static void setUp(BuildContext context) {\n    final Size size = MediaQuery.sizeOf(context);\n    _height = size.height;\n    _width = size.width;\n    _resetIfInvalid();\n  }\n\n  static double? _width;\n  static double? _height;\n\n  static Size get _size => MediaQuery.sizeOf(QuranMajeed.globalContext);\n\n  static double get width {\n    _width ??= _size.width;\n    return _width!;\n  }\n\n  static double get height {\n    _height ??= _size.height;\n    return _height!;\n  }\n\n  static void _resetIfInvalid() {\n    if (_width! < 10 || _height! < 10) {\n      logErrorStatic(\n        'QuranScreen size not initialized. Please initialize QuranScreen and try again.',\n        \"quran_screen\",\n      );\n      _width = null;\n      _height = null;\n    }\n  }\n}\n\nextension QuranScreenWidth on Widget {\n  static double? _onePercentWidth;\n\n  double get onePercentWidth {\n    const double onePercent = 0.01;\n    _onePercentWidth ??= QuranScreen.width * onePercent;\n    return _onePercentWidth!;\n  }\n\n  static double? _twoPercentWidth;\n\n  double get twoPercentWidth {\n    const double twoPercent = 0.02;\n    _twoPercentWidth ??= QuranScreen.width * twoPercent;\n    return _twoPercentWidth!;\n  }\n\n  static double? _fiftyPercentHeight;\n\n  double get fiftyPercentHeight {\n    const double fiftyPercent = 0.50;\n    _fiftyPercentHeight ??= QuranScreen.height * fiftyPercent;\n    return _fiftyPercentHeight!;\n  }\n\n  static double? _threePercentWidth;\n\n  double get threePercentWidth {\n    const double threePercent = 0.03;\n    _threePercentWidth ??= QuranScreen.width * threePercent;\n    return _threePercentWidth!;\n  }\n\n  static double? _fourPercentWidth;\n\n  double get fourPercentWidth {\n    _fourPercentWidth ??= 4.percentWidth;\n    return _fourPercentWidth!;\n  }\n\n  static double? _fivePercentWidth;\n\n  double get fivePercentWidth {\n    _fivePercentWidth ??= 5.percentWidth;\n    return _fivePercentWidth!;\n  }\n\n  static double? _sixPercentWidth;\n\n  double get sixPercentWidth {\n    const double sixPercent = 0.06;\n    _sixPercentWidth ??= QuranScreen.width * sixPercent;\n    return _sixPercentWidth!;\n  }\n\n  static double? _sevenPercentWidth;\n\n  double get sevenPercentWidth {\n    const double sevenPercent = 0.07;\n    _sevenPercentWidth ??= QuranScreen.width * sevenPercent;\n    return _sevenPercentWidth!;\n  }\n\n  static double? _eightPercentWidth;\n\n  double get eightPercentWidth {\n    const double eightPercent = 0.08;\n    _eightPercentWidth ??= QuranScreen.width * eightPercent;\n    return _eightPercentWidth!;\n  }\n\n  static double? _tenPercentWidth;\n\n  double get tenPercentWidth {\n    const double tenPercentWidth = 0.10;\n    _tenPercentWidth ??= QuranScreen.width * tenPercentWidth;\n    return _tenPercentWidth!;\n  }\n\n  static double? _fortyPercentWidth;\n\n  double get fortyPercentWidth {\n    const double fortyPercent = 0.40;\n    _fortyPercentWidth ??= QuranScreen.width * fortyPercent;\n    return _fortyPercentWidth!;\n  }\n\n  static double? _thirtyPercentWidth;\n\n  double get thirtyPercentWidth {\n    const double thirtyPercentWidth = 0.32;\n    _thirtyPercentWidth ??= QuranScreen.width * thirtyPercentWidth;\n    return _thirtyPercentWidth!;\n  }\n\n  static double? _sixtySixPercentWidth;\n\n  double get sixtySixPercentWidth {\n    _sixtySixPercentWidth ??= 66.percentWidth;\n    return _sixtySixPercentWidth!;\n  }\n\n  static double? _fiftyFivePercentWidth;\n\n  double get fiftyFivePercentWidth {\n    _fiftyFivePercentWidth ??= 55.percentWidth;\n    return _fiftyFivePercentWidth!;\n  }\n\n  static double? _seventyPercentWidth;\n\n  double get seventyPercentWidth {\n    const double seventyPercent = 0.70;\n    _seventyPercentWidth ??= QuranScreen.width * seventyPercent;\n    return _seventyPercentWidth!;\n  }\n\n  static double? _tweentyEightPercentWidth;\n\n  double get tweentyEightPercentWidth {\n    const double tweentyEightPercentWidth = 0.28;\n    _tweentyEightPercentWidth ??= QuranScreen.width * tweentyEightPercentWidth;\n    return _tweentyEightPercentWidth!;\n  }\n\n  static double? _twentyPercentWidth;\n\n  double get twentyPercentWidth {\n    const double twentyPercentWidth = 0.20;\n    _twentyPercentWidth ??= QuranScreen.width * twentyPercentWidth;\n    return _twentyPercentWidth!;\n  }\n\n  static double? _twentyFivePercentWidth;\n\n  double get twentyFivePercentWidth {\n    const double twentyFivePercentWidth = 0.25;\n    _twentyFivePercentWidth ??= QuranScreen.width * twentyFivePercentWidth;\n    return _twentyFivePercentWidth!;\n  }\n\n  static double? _twentySixPercentWidth;\n\n  double get twentySixPercentWidth {\n    const double twentySixPercentWidth = 0.26;\n    _twentySixPercentWidth ??= QuranScreen.width * twentySixPercentWidth;\n    return _twentySixPercentWidth!;\n  }\n\n  static double? _twentyThreePercentWidth;\n\n  double get twentyThreePercentWidth {\n    const double twentyThreePercentWidth = 0.23;\n    _twentyThreePercentWidth ??= QuranScreen.width * twentyThreePercentWidth;\n    return _twentyThreePercentWidth!;\n  }\n\n  static double? _fourtyPercentWidth;\n\n  double get fourtyPercentWidth {\n    const double fourtyPercentWidth = 0.40;\n    _fourtyPercentWidth ??= QuranScreen.width * fourtyPercentWidth;\n    return _fourtyPercentWidth!;\n  }\n\n  static double? _twentyPercentHeight;\n\n  double get twentyPercentHeight {\n    const double twentyPercent = 0.20;\n    _twentyPercentHeight ??= QuranScreen.height * twentyPercent;\n    return _twentyPercentHeight!;\n  }\n\n  static double? _tenPercentHeight;\n\n  double get tenPercentHeight {\n    const double tenPercentHeight = 0.10;\n    _tenPercentHeight ??= QuranScreen.height * tenPercentHeight;\n    return _tenPercentHeight!;\n  }\n\n  static double? _twelvePercentHeight;\n\n  double get twelvePercentHeight {\n    const double twentyPercent = 0.12;\n    _twelvePercentHeight ??= QuranScreen.height * twentyPercent;\n    return _twelvePercentHeight!;\n  }\n\n  static double? _fourteenPercentHeight;\n\n  double get fourteenPercentHeight {\n    const double fourteenPercentHeight = 0.14;\n    _fourteenPercentHeight ??= QuranScreen.height * fourteenPercentHeight;\n    return _fourteenPercentHeight!;\n  }\n\n  static double? _tweentyPercentHeight;\n\n  double get tweentyPercentHeight {\n    const double tweentyPercentHeight = 0.20;\n    _tweentyPercentHeight ??= QuranScreen.height * tweentyPercentHeight;\n    return _tweentyPercentHeight!;\n  }\n}"}, {"structure_type": "class", "name": "to implement this in whatever way makes sense", "docstring": "The progress indicator's background color.\n", "module": "external_libs", "file_path": "external_libs/capped_progress_indicator.dart", "file_name": "capped_progress_indicator.dart", "line": 76, "line_from": 76, "line_to": 247, "snippet": "  /// It is up to the subclass to implement this in whatever way makes sense\n  /// for the given use case. See the subclass documentation for details.\n  final Color? backgroundColor;\n\n  /// The progress indicator's color.\n  ///\n  /// This is only used if [CappedProgressIndicator.valueColor] is null.\n  /// If [CappedProgressIndicator.color] is also null, then the ambient\n  /// [ProgressIndicatorThemeData.color] will be used. If that\n  /// is null then the current theme's [ColorScheme.primary] will\n  /// be used by default.\n  final Color? color;\n\n  /// The progress indicator's color as an animated value.\n  ///\n  /// If null, the progress indicator is rendered with [color]. If that is null,\n  /// then it will use the ambient [ProgressIndicatorThemeData.color]. If that\n  /// is also null then it defaults to the current theme's [ColorScheme.primary].\n  final Animation<Color?>? valueColor;\n\n  /// The [SemanticsProperties.label] for this progress indicator.\n  ///\n  /// This value indicates the purpose of the progress bar, and will be\n  /// read out by screen readers to indicate the purpose of this progress\n  /// indicator.\n  final String? semanticsLabel;\n\n  /// The [SemanticsProperties.value] for this progress indicator.\n  ///\n  /// This will be used in conjunction with the [semanticsLabel] by\n  /// screen reading software to identify the widget, and is primarily\n  /// intended for use with determinate progress indicators to announce\n  /// how far along they are.\n  ///\n  /// For determinate progress indicators, this will be defaulted to\n  /// [CappedProgressIndicator.value] expressed as a percentage, i.e. `0.1` will\n  /// become '10%'.\n  final String? semanticsValue;\n\n  Color _getValueColor(BuildContext context) {\n    return valueColor?.value ??\n        color ??\n        ProgressIndicatorTheme.of(context).color ??\n        Theme.of(context).colorScheme.primary;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(PercentProperty('value', value,\n        showName: false, ifNull: '<indeterminate>'));\n  }\n\n  Widget _buildSemanticsWrapper({\n    required BuildContext context,\n    required Widget child,\n  }) {\n    String? expandedSemanticsValue = semanticsValue;\n    if (value != null) {\n      expandedSemanticsValue ??= '${(value! * 100).round()}%';\n    }\n    return Semantics(\n      label: semanticsLabel,\n      value: expandedSemanticsValue,\n      child: child,\n    );\n  }\n}\n\nclass _LinearCappedProgressIndicatorPainter extends CustomPainter {\n  const _LinearCappedProgressIndicatorPainter({\n    required this.backgroundColor,\n    required this.valueColor,\n    this.value,\n    this.cornerRadius,\n    required this.animationValue,\n    required this.textDirection,\n  });\n\n  final Color backgroundColor;\n  final Color valueColor;\n  final double? value;\n  final double? cornerRadius;\n  final double animationValue;\n  final TextDirection textDirection;\n\n  // The indeterminate progress animation displays two lines whose leading (head)\n  // and trailing (tail) endpoints are defined by the following four curves.\n  static const Curve line1Head = Interval(\n    0.0,\n    750.0 / _kIndeterminateLinearDuration,\n    curve: Cubic(0.2, 0.0, 0.8, 1.0),\n  );\n  static const Curve line1Tail = Interval(\n    333.0 / _kIndeterminateLinearDuration,\n    (333.0 + 750.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.4, 0.0, 1.0, 1.0),\n  );\n  static const Curve line2Head = Interval(\n    1000.0 / _kIndeterminateLinearDuration,\n    (1000.0 + 567.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.0, 0.0, 0.65, 1.0),\n  );\n  static const Curve line2Tail = Interval(\n    1267.0 / _kIndeterminateLinearDuration,\n    (1267.0 + 533.0) / _kIndeterminateLinearDuration,\n    curve: Cubic(0.10, 0.0, 0.45, 1.0),\n  );\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Paint paint = Paint()\n      ..color = backgroundColor\n      ..style = PaintingStyle.fill;\n    canvas.drawRRect(\n      RRect.fromRectAndRadius(\n        Offset.zero & size,\n        Radius.circular(cornerRadius ?? size.height / 2),\n      ),\n      paint,\n    );\n\n    paint.color = valueColor;\n\n    void drawBar(double x, double width) {\n      if (width <= 0.0) {\n        return;\n      }\n\n      final double left;\n      switch (textDirection) {\n        case TextDirection.rtl:\n          left = size.width - width - x;\n          break;\n        case TextDirection.ltr:\n          left = x;\n          break;\n      }\n      canvas.drawRRect(\n        RRect.fromRectAndRadius(\n          Offset(left, 0.0) & Size(width, size.height),\n          Radius.circular(cornerRadius ?? size.height / 2),\n        ),\n        paint,\n      );\n    }\n\n    if (value != null) {\n      drawBar(0.0, clampDouble(value!, 0.0, 1.0) * size.width);\n    } else {\n      final double x1 = size.width * line1Tail.transform(animationValue);\n      final double width1 =\n          size.width * line1Head.transform(animationValue) - x1;\n\n      final double x2 = size.width * line2Tail.transform(animationValue);\n      final double width2 =\n          size.width * line2Head.transform(animationValue) - x2;\n\n      drawBar(x1, width1);\n      drawBar(x2, width2);\n    }\n  }\n\n  @override\n  bool shouldRepaint(_LinearCappedProgressIndicatorPainter oldPainter) {\n    return oldPainter.backgroundColor != backgroundColor ||\n        oldPainter.valueColor != valueColor ||\n        oldPainter.value != value ||\n        oldPainter.animationValue != animationValue ||\n        oldPainter.textDirection != textDirection;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "external_libs/fancy_scaffold.dart", "file_name": "fancy_scaffold.dart", "line": 9, "line_from": 9, "line_to": 63, "snippet": "  final void Function(double position)? onSlide;\n  final VoidCallback? onOpened;\n  final VoidCallback? onClosed;\n  final FloatingWidgetState defaultState;\n  final Color backdropColor;\n  final double backdropOpacity;\n  final double? maxHeight;\n  final double minHeight;\n  final bool isPanelVisible;\n  final EdgeInsetsGeometry margin;\n  final EdgeInsetsGeometry padding;\n\n  const FloatingWidgetConfig({\n    this.backdropEnabled = true,\n    this.onSlide,\n    this.onOpened,\n    this.onClosed,\n    this.defaultState = FloatingWidgetState.closed,\n    this.backdropColor = Colors.black,\n    this.backdropOpacity = 0.5,\n    this.maxHeight,\n    this.minHeight = kToolbarHeight * 1.6,\n    this.isPanelVisible = true,\n    this.margin = EdgeInsets.zero,\n    this.padding = const EdgeInsets.all(4),\n  });\n}\n\nclass FancyScaffold extends StatefulWidget {\n  final Widget body;\n  final Widget? appBar;\n  final Widget? bottomNavigationBar;\n  final bool? resizeToAvoidBottomInset;\n  final Color? backgroundColor;\n  final FloatingWidgetController? floatingWidgetController;\n  final FloatingWidgetConfig floatingWidgetConfig;\n  final double? bottomNavigationBarHeight;\n  final bool isAudioPlaying;\n\n  const FancyScaffold({\n    required this.body,\n    this.appBar,\n    this.bottomNavigationBar,\n    this.resizeToAvoidBottomInset,\n    this.backgroundColor,\n    this.floatingWidgetConfig = const FloatingWidgetConfig(),\n    this.floatingWidgetController,\n    this.bottomNavigationBarHeight,\n    this.isAudioPlaying = false,\n    super.key,\n  });\n\n  @override\n  FancyScaffoldState createState() => FancyScaffoldState();\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "external_libs", "file_path": "external_libs/fancy_scaffold.dart", "file_name": "fancy_scaffold.dart", "line": 90, "line_from": 90, "line_to": 373, "snippet": "  void initState() {\n    super.initState();\n    floatingWidgetAnimationController.addListener(_floatingWidgetListener);\n    _floatingWidgetScrollController.addListener(_scrollListener);\n  }\n\n  void hideAppBar() {\n    if (navigationBarAnimationController.value != 0) {\n      navigationBarAnimationController.animateTo(0);\n    }\n  }\n\n  void showAppBar() {\n    if (navigationBarAnimationController.value != 1) {\n      navigationBarAnimationController.animateTo(1);\n    }\n  }\n\n  void _floatingWidgetListener() {\n    if (widget.floatingWidgetConfig.onSlide != null) {\n      widget.floatingWidgetConfig\n          .onSlide!(floatingWidgetAnimationController.value);\n    }\n\n    if (widget.floatingWidgetConfig.onOpened != null &&\n        floatingWidgetAnimationController.value == 1.0) {\n      widget.floatingWidgetConfig.onOpened!();\n    }\n\n    if (widget.floatingWidgetConfig.onClosed != null &&\n        floatingWidgetAnimationController.value == 0.0) {\n      widget.floatingWidgetConfig.onClosed!();\n    }\n\n    if (!navigationBarScrolledDown) {\n      navigationBarAnimationController.value =\n          1 - floatingWidgetAnimationController.value;\n    }\n  }\n\n  void _scrollListener() {\n    if (!_scrollingEnabled) {\n      _floatingWidgetScrollController.jumpTo(0);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    widget.floatingWidgetController?._addState(this);\n    final double systemTopPadding = MediaQuery.of(context).padding.top;\n    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;\n    final double appBarHeight = widget.appBar != null ? kToolbarHeight : 0;\n\n    return CustomStatusBarColor(\n      statusBarColor: context.color.gradientTop,\n      statusBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      navigationBarColor: Theme.of(context).cardColor,\n      navigationBarIconColor:\n          isDarkMode(context) ? Brightness.light : Brightness.dark,\n      child: AnimatedBuilder(\n        animation: floatingWidgetAnimationController,\n        builder: (context, mainChild) {\n          return AnimatedBuilder(\n            animation: navigationBarAnimationController,\n            builder: (context, child) {\n              return Stack(\n                children: [\n                  Positioned.fill(\n                    child: Column(\n                      children: [\n                        Container(\n                            color: context.color.gradientTop,\n                            height: systemTopPadding +\n                                appBarHeight *\n                                    navigationBarAnimationController.value +\n                                2),\n                        Expanded(\n                          child: child!,\n                        ),\n                      ],\n                    ),\n                  ),\n                  if (widget.appBar != null)\n                    Positioned(\n                      top: -kToolbarHeight *\n                              (1 - navigationBarAnimationController.value) +\n                          systemTopPadding +\n                          2,\n                      left: 0,\n                      right: 0,\n                      child: widget.appBar!,\n                    ),\n                  if (widget.bottomNavigationBar != null)\n                    Positioned(\n                      bottom: -(widget.bottomNavigationBarHeight ?? 80) *\n                          (1 - navigationBarAnimationController.value),\n                      left: 0,\n                      right: 0,\n                      child: Container(\n                        width: double.infinity,\n                        color: Colors.transparent,\n                        height: (widget.bottomNavigationBarHeight ?? 73) +\n                            systemBottomPadding,\n                        child: Column(\n                          children: [\n                            Expanded(\n                              child: SingleChildScrollView(\n                                physics: const NeverScrollableScrollPhysics(),\n                                child: widget.bottomNavigationBar,\n                              ),\n                            ),\n                            Container(\n                              color: Theme.of(context).cardColor,\n                            ),\n                          ],\n                        ),\n                      ),\n                    ),\n                ],\n              );\n            },\n            child: Listener(\n              onPointerUp: _handlePointerUp,\n              child: NotificationListener<ScrollUpdateNotification>(\n                onNotification: _handleScrollNotification,\n                child: mainChild!,\n              ),\n            ),\n          );\n        },\n        child: widget.body,\n      ),\n    );\n  }\n\n  void _handlePointerUp(_) {\n    pixelsScrolled = 0;\n    if (navigationBarAnimationController.value > 0.5) {\n      navigationBarAnimationController.animateTo(1);\n      navigationBarScrolledDown = false;\n    } else {\n      navigationBarAnimationController.animateTo(0);\n      navigationBarScrolledDown = false;\n    }\n  }\n\n  bool _handleScrollNotification(ScrollUpdateNotification details) {\n    if (widget.floatingWidgetController?.lockNotificationListener ?? false) {\n      return false;\n    }\n    if (details.metrics.axis == Axis.horizontal) {\n      return false;\n    }\n\n    // Check if audio is playing\n    if (widget.isAudioPlaying) {\n      return false;\n    }\n\n    pixelsScrolled =\n        (pixelsScrolled + (details.scrollDelta ?? 0).abs()).clamp(0, 100) / 100;\n    if ((details.scrollDelta ?? 0) > 0.0 &&\n        details.metrics.axis == Axis.vertical) {\n      navigationBarAnimationController.value -= pixelsScrolled;\n    } else {\n      navigationBarAnimationController.value += pixelsScrolled;\n    }\n    return false;\n  }\n\n  Future<void> _close() {\n    return floatingWidgetAnimationController.fling(velocity: -1.0);\n  }\n\n  Future<void> _open() {\n    return floatingWidgetAnimationController.fling(velocity: 1.0);\n  }\n\n  Future<void> _animatePanelToPosition(\n    double value, {\n    Duration duration = const Duration(milliseconds: 200),\n    Curve curve = Curves.linear,\n  }) {\n    assert(0.0 <= value && value <= 1.0);\n    return floatingWidgetAnimationController.animateTo(value,\n        duration: duration, curve: curve);\n  }\n\n  set _panelPosition(double value) {\n    assert(0.0 <= value && value <= 1.0);\n    floatingWidgetAnimationController.value = value;\n  }\n\n  double get _panelPosition => floatingWidgetAnimationController.value;\n\n  bool get _isPanelAnimating => floatingWidgetAnimationController.isAnimating;\n\n  bool get _isPanelOpen => floatingWidgetAnimationController.value == 1.0;\n\n  bool get _isPanelClosed => floatingWidgetAnimationController.value == 0.0;\n}\n\nclass FloatingWidgetController {\n  FancyScaffoldState? _scaffoldState;\n\n  void _addState(FancyScaffoldState panelState) {\n    _scaffoldState = panelState;\n  }\n\n  GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  bool lockNotificationListener = false;\n\n  bool get isAttached => _scaffoldState != null;\n\n  AnimationController get animationController =>\n      _scaffoldState!.floatingWidgetAnimationController;\n  AnimationController get navbarAnimationController =>\n      _scaffoldState!.navigationBarAnimationController;\n  bool get navbarScrolledDown => _scaffoldState!.navigationBarScrolledDown;\n  set navbarScrolledDown(bool value) {\n    _scaffoldState!.navigationBarScrolledDown = value;\n  }\n\n  void hideAppBar() {\n    assert(isAttached,\n        \"FloatingWidgetController must be attached to a FancyScaffold\");\n    _scaffoldState!.hideAppBar();\n  }\n\n  void showAppBar() {\n    assert(isAttached,\n        \"FloatingWidgetController must be attached to a FancyScaffold\");\n    _scaffoldState!.showAppBar();\n  }\n\n  Future<void> close() {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._close();\n  }\n\n  Future<void> open() {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._open();\n  }\n\n  Future<void> animatePanelToPosition(\n    double value, {\n    Duration duration = const Duration(milliseconds: 200),\n    Curve curve = Curves.linear,\n  }) {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    assert(0.0 <= value && value <= 1.0);\n    return _scaffoldState!\n        ._animatePanelToPosition(value, duration: duration, curve: curve);\n  }\n\n  set panelPosition(double value) {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    assert(0.0 <= value && value <= 1.0);\n    _scaffoldState!._panelPosition = value;\n  }\n\n  double get panelPosition {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._panelPosition;\n  }\n\n  bool get isPanelAnimating {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelAnimating;\n  }\n\n  bool get isPanelOpen {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelOpen;\n  }\n\n  bool get isPanelClosed {\n    assert(isAttached, \"PanelController must be attached to a SlidingUpPanel\");\n    return _scaffoldState!._isPanelClosed;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "external_libs/positioned_scroll_bar.dart", "file_name": "positioned_scroll_bar.dart", "line": 18, "line_from": 18, "line_to": 35, "snippet": "  final void Function({required bool dragging})? onDragging;\n\n  @override\n  Widget build(BuildContext context) {\n    if (!showScrollBar) return listView;\n\n    return DraggableScrollbarPositionedList.arrows(\n      key: const Key('PositionedScrollBar'),\n      backgroundColor: isDarkMode(context)\n          ? context.color.bottomSheetHeader\n          : Theme.of(context).primaryColor,\n      padding: const EdgeInsets.only(right: 2),\n      onDragging: onDragging,\n      controller: controller,\n      child: listView,\n    );\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "external_libs", "file_path": "external_libs/presentable_widget_builder.dart", "file_name": "presentable_widget_builder.dart", "line": 19, "line_from": 19, "line_to": 60, "snippet": "  final Widget Function() builder;\n\n  @override\n  State<PresentableWidgetBuilder<T>> createState() => _PresentableWidgetBuilderState<T>();\n}\n\nclass _PresentableWidgetBuilderState<T extends DisposableInterface> extends State<PresentableWidgetBuilder<T>> {\n  T? _previousState;\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.onInit != null) {\n      widget.onInit!();\n    }\n    if (widget.presenter != null) {\n      Get.put(widget.presenter!);\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.dispose != null) {\n      widget.dispose!();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Obx(() {\n      final currentState = widget.presenter;\n      if (widget.shouldRebuild != null) {\n        if (!widget.shouldRebuild!(_previousState, currentState)) {\n          return widget.builder();\n        }\n      }\n      _previousState = currentState;\n      return widget.builder();\n    });\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "The builder of title.\n\nTypically a [Button] widget that call [toggleFunction] when pressed.", "module": "external_libs", "file_path": "external_libs/expansion_widget.dart", "file_name": "expansion_widget.dart", "line": 26, "line_from": 26, "line_to": 83, "snippet": "  final Widget Function(double animationValue, double easeInValue,\n      bool isExpanded, Function({bool animated}) toggleFunction) titleBuilder;\n\n  /// Function to save expansion state\n  /// Called when expansion state changed\n  final void Function(bool isExpanded)? onSaveState;\n\n  /// function to restore expansion state.\n  /// Return null if there is no state to store;\n  /// in this case, [initiallyExpanded] will be used\n  final bool? Function()? onRestoreState;\n\n  /// The length of time of animation\n  final Duration duration;\n\n  /// Called when the widget expands or collapses.\n  ///\n  /// When the widget starts expanding, this function is called with the value\n  /// true. When the tile starts collapsing, this function is called with\n  /// the value false.\n  final void Function(bool)? onExpansionChanged;\n\n  /// Called when the widget will change expanded state.\n  ///\n  /// When the widget is going to start expanding/collapsing, this function is\n  /// called with the value true/false.\n  ///\n  /// Return false to prevent expanded state to change.\n  /// Return true(default) to allow expanded state changing.\n  final bool Function(bool)? onExpansionWillChange;\n\n  /// The widget that are displayed when the expansionWidget expands.\n  final Widget content;\n\n  /// Specifies if the expansionWidget is initially expanded (true) or collapsed (false, the default).\n  final bool initiallyExpanded;\n\n  /// Specifies whether the state of the content is maintained when the expansionWidget expands and collapses.\n  ///\n  /// When true, the content are kept in the tree while the expansionWidget is collapsed.\n  /// When false (default), the content are removed from the tree when the expansionWidget is\n  /// collapsed and recreated upon expansion.\n  final bool maintainState;\n\n  /// Specifies the alignment of [content], which are arranged in a column when\n  /// the expansionWidget is expanded.\n  ///\n  /// The internals of the expanded expansionWidget make use of a [Column] widget for\n  /// [content], and [Align] widget to align the column. The `expandedAlignment`\n  /// parameter is passed directly into the [Align].\n  ///\n  /// Modifying this property controls the alignment of the column within the\n  /// expanded expansionWidget.\n  final Alignment expandedAlignment;\n\n  @override\n  ExpansionWidgetState createState() => ExpansionWidgetState();\n}"}, {"structure_type": "function", "name": "cancel", "docstring": "", "module": "external_libs", "file_path": "external_libs/throttle_service.dart", "file_name": "throttle_service.dart", "line": 51, "line_from": 51, "line_to": 73, "snippet": "  static void cancel(String tag) {\n    _operations[tag]?.timer.cancel();\n    _operations.remove(tag);\n  }\n\n  static void cancelAll() {\n    for (final _ThrottleOperation operation in _operations.values) {\n      operation.timer.cancel();\n    }\n    _operations.clear();\n  }\n\n  static int count() => _operations.length;\n}\n\ntypedef EasyDebounceCallback = void Function();\n\nclass _EasyDebounceOperation {\n  _EasyDebounceOperation(this.callback, this.timer);\n\n  EasyDebounceCallback callback;\n  Timer timer;\n}"}, {"structure_type": "function", "name": "onReady;", "docstring": "", "module": "carousel_slider", "file_path": "external_libs/carousel_slider/carousel_controller.dart", "file_name": "carousel_controller.dart", "line": 13, "line_from": 13, "line_to": 26, "snippet": "  Future<void> get onReady;\n\n  Future<void> nextPage({Duration? duration, Curve? curve});\n\n  Future<void> previousPage({Duration? duration, Curve? curve});\n\n  void jumpToPage(int page);\n\n  Future<void> animateToPage(int page, {Duration? duration, Curve? curve});\n\n  void startAutoPlay();\n\n  void stopAutoPlay();\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "carousel_slider", "file_path": "external_libs/carousel_slider/carousel_slider.dart", "file_name": "carousel_slider.dart", "line": 12, "line_from": 12, "line_to": 409, "snippet": "typedef ExtendedIndexedWidgetBuilder = Widget Function(\n  BuildContext context,\n  int index,\n  int realIndex,\n);\n\nclass CarouselSlider extends StatefulWidget {\n  CarouselSlider({\n    required this.items,\n    required this.options,\n    this.disableGesture,\n    CarouselControllerHelper? carouselController,\n    super.key,\n  })  : itemBuilder = null,\n        itemCount = items != null ? items.length : 0,\n        _carouselController = carouselController != null\n            ? carouselController as CarouselControllerImpl\n            : CarouselControllerHelper() as CarouselControllerImpl;\n\n  CarouselSlider.builder({\n    required this.itemCount,\n    required this.itemBuilder,\n    required this.options,\n    this.disableGesture,\n    CarouselControllerHelper? carouselController,\n    super.key,\n  })  : items = null,\n        _carouselController = carouselController != null\n            ? carouselController as CarouselControllerImpl\n            : CarouselControllerHelper() as CarouselControllerImpl;\n\n  final CarouselOptions options;\n\n  final bool? disableGesture;\n\n  final List<Widget>? items;\n\n  final ExtendedIndexedWidgetBuilder? itemBuilder;\n\n  final CarouselControllerImpl _carouselController;\n\n  final int? itemCount;\n\n  @override\n  // ignore: no_logic_in_create_state\n  CarouselSliderState createState() => CarouselSliderState(_carouselController);\n}\n\nclass CarouselSliderState extends State<CarouselSlider>\n    with TickerProviderStateMixin {\n  CarouselSliderState(this.carouselController);\n\n  final CarouselControllerImpl carouselController;\n  Timer? timer;\n\n  CarouselOptions get options => widget.options;\n\n  CarouselState? carouselState;\n\n  PageController? pageController;\n\n  CarouselPageChangedReason _mode = CarouselPageChangedReason.controller;\n\n  set mode(CarouselPageChangedReason mode) => _mode = mode;\n\n  @override\n  void didUpdateWidget(CarouselSlider oldWidget) {\n    carouselState!.options = options;\n    carouselState!.itemCount = widget.itemCount;\n\n    // pageController needs to be re-initialized to respond to state changes\n    pageController = PageController(\n      viewportFraction: options.viewportFraction,\n      initialPage: carouselState!.realPage,\n    );\n    carouselState!.pageController = pageController;\n\n    // handle autoplay when state changes\n    handleAutoPlay();\n\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    carouselState =\n        CarouselState(options, clearTimer, resumeTimer, (m) => mode = m);\n\n    carouselState!.itemCount = widget.itemCount;\n    carouselController.state = carouselState;\n    carouselState!.initialPage = widget.options.initialPage;\n    carouselState!.realPage = options.enableInfiniteScroll\n        ? carouselState!.realPage + carouselState!.initialPage\n        : carouselState!.initialPage;\n    handleAutoPlay();\n\n    pageController = PageController(\n      viewportFraction: options.viewportFraction,\n      initialPage: carouselState!.realPage,\n    );\n\n    carouselState!.pageController = pageController;\n  }\n\n  Timer? getTimer() {\n    return catchAndReturn(() {\n      if (!widget.options.autoPlay) throw Exception(\"Autoplay is not enabled\");\n\n      return Timer.periodic(widget.options.autoPlayInterval, (_) {\n        if (!mounted) {\n          clearTimer();\n          return;\n        }\n\n        final ModalRoute<Object?>? route = ModalRoute.of(context);\n        if (route?.isCurrent == false) return;\n\n        final CarouselPageChangedReason previousReason = _mode;\n        mode = CarouselPageChangedReason.timed;\n\n        final int currentPage =\n            carouselState?.pageController?.page?.round() ?? 0;\n        int nextPage = currentPage + 1;\n        final int itemCount = widget.itemCount ?? widget.items?.length ?? 1;\n\n        if (nextPage >= itemCount &&\n            widget.options.enableInfiniteScroll == false) {\n          if (widget.options.pauseAutoPlayInFiniteScroll) {\n            clearTimer();\n            return;\n          }\n          nextPage = 0;\n        }\n\n        carouselState?.pageController\n            ?.animateToPage(\n              nextPage,\n              duration: widget.options.autoPlayAnimationDuration,\n              curve: widget.options.autoPlayCurve,\n            )\n            .then((_) => mode = previousReason);\n      });\n    });\n  }\n\n  void clearTimer() {\n    if (timer != null) {\n      timer?.cancel();\n      timer = null;\n    }\n  }\n\n  void resumeTimer() {\n    timer ??= getTimer();\n  }\n\n  void handleAutoPlay() {\n    final bool autoPlayEnabled = widget.options.autoPlay;\n\n    if (autoPlayEnabled && timer != null) return;\n\n    clearTimer();\n    if (autoPlayEnabled) {\n      resumeTimer();\n    }\n  }\n\n  Widget getGestureWrapper(Widget child) {\n    Widget wrapper;\n    if (widget.options.height != null) {\n      wrapper = SizedBox(height: widget.options.height, child: child);\n    } else {\n      wrapper =\n          AspectRatio(aspectRatio: widget.options.aspectRatio, child: child);\n    }\n\n    if (true == widget.disableGesture) {\n      return NotificationListener(\n        onNotification: (Notification notification) {\n          if (widget.options.onScrolled != null &&\n              notification is ScrollUpdateNotification) {\n            widget.options.onScrolled!(carouselState!.pageController!.page);\n          }\n          return false;\n        },\n        child: wrapper,\n      );\n    }\n\n    return RawGestureDetector(\n      behavior: HitTestBehavior.opaque,\n      gestures: {\n        _MultipleGestureRecognizer:\n            GestureRecognizerFactoryWithHandlers<_MultipleGestureRecognizer>(\n                _MultipleGestureRecognizer.new,\n                (_MultipleGestureRecognizer instance) {\n          instance\n            ..onStart = (_) {\n              onStart();\n            }\n            ..onDown = (_) {\n              onPanDown();\n            }\n            ..onEnd = (_) {\n              onPanUp();\n            }\n            ..onCancel = onPanUp;\n        }),\n      },\n      child: NotificationListener(\n        onNotification: (Notification notification) {\n          if (widget.options.onScrolled != null &&\n              notification is ScrollUpdateNotification) {\n            widget.options.onScrolled!(carouselState!.pageController!.page);\n          }\n          return false;\n        },\n        child: wrapper,\n      ),\n    );\n  }\n\n  Widget getCenterWrapper(Widget child) {\n    if (widget.options.disableCenter) {\n      return Container(\n        child: child,\n      );\n    }\n    return Center(child: child);\n  }\n\n  Widget getEnlargeWrapper(\n    Widget? child, {\n    double? width,\n    double? height,\n    double? scale,\n    required double itemOffset,\n  }) {\n    if (widget.options.enlargeStrategy == CenterPageEnlargeStrategy.height) {\n      return SizedBox(width: width, height: height, child: child);\n    }\n    if (widget.options.enlargeStrategy == CenterPageEnlargeStrategy.zoom) {\n      late Alignment alignment;\n      final bool horizontal = options.scrollDirection == Axis.horizontal;\n      if (itemOffset > 0) {\n        alignment = horizontal ? Alignment.centerRight : Alignment.bottomCenter;\n      } else {\n        alignment = horizontal ? Alignment.centerLeft : Alignment.topCenter;\n      }\n      return Transform.scale(scale: scale, alignment: alignment, child: child);\n    }\n    return Transform.scale(\n      scale: scale,\n      child: SizedBox(width: width, height: height, child: child),\n    );\n  }\n\n  void onStart() {\n    mode = CarouselPageChangedReason.manual;\n  }\n\n  void onPanDown() {\n    if (widget.options.pauseAutoPlayOnTouch) {\n      clearTimer();\n    }\n\n    mode = CarouselPageChangedReason.manual;\n  }\n\n  void onPanUp() {\n    if (widget.options.pauseAutoPlayOnTouch) {\n      resumeTimer();\n    }\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    clearTimer();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return getGestureWrapper(\n      PageView.builder(\n        padEnds: widget.options.padEnds,\n        scrollBehavior: ScrollConfiguration.of(context).copyWith(\n          scrollbars: false,\n          overscroll: false,\n          dragDevices: {\n            PointerDeviceKind.touch,\n            PointerDeviceKind.mouse,\n          },\n        ),\n        clipBehavior: widget.options.clipBehavior,\n        physics: widget.options.scrollPhysics,\n        scrollDirection: widget.options.scrollDirection,\n        pageSnapping: widget.options.pageSnapping,\n        controller: carouselState!.pageController,\n        reverse: widget.options.reverse,\n        itemCount:\n            widget.options.enableInfiniteScroll ? null : widget.itemCount,\n        onPageChanged: (int index) {\n          final int currentPage = getRealIndex(\n            index + carouselState!.initialPage,\n            carouselState!.realPage,\n            widget.itemCount,\n          );\n          widget.options.onPageChanged?.call(currentPage, _mode);\n        },\n        itemBuilder: (BuildContext context, int idx) {\n          final int index = getRealIndex(\n            idx + carouselState!.initialPage,\n            carouselState!.realPage,\n            widget.itemCount,\n          );\n\n          return AnimatedBuilder(\n            animation: carouselState!.pageController!,\n            child: (widget.items != null)\n                ? (widget.items!.isNotEmpty\n                    ? widget.items![index]\n                    : Container())\n                : widget.itemBuilder!(context, index, idx),\n            builder: (BuildContext context, child) {\n              double distortionValue = 1;\n              // if `enlargeCenterPage` is true, we must calculate the carousel item's height\n              // to display the visual effect\n              double itemOffset = 0;\n              if (widget.options.enlargeCenterPage != null &&\n                  (widget.options.enlargeCenterPage ?? false)) {\n                // pageController.page can only be accessed after the first build,\n                // so in the first build we calculate the itemoffset manually\n                final position = carouselState?.pageController?.position;\n                if (position != null &&\n                    position.hasPixels &&\n                    position.hasContentDimensions) {\n                  final page = carouselState?.pageController?.page;\n                  if (page != null) {\n                    itemOffset = page - idx;\n                  }\n                } else {\n                  final BuildContext storageContext = carouselState!\n                      .pageController!.position.context.storageContext;\n                  final double? previousSavedPosition =\n                      PageStorage.of(storageContext).readState(storageContext)\n                          as double?;\n                  if (previousSavedPosition != null) {\n                    itemOffset = previousSavedPosition - idx.toDouble();\n                  } else {\n                    itemOffset =\n                        carouselState!.realPage.toDouble() - idx.toDouble();\n                  }\n                }\n\n                final double enlargeFactor =\n                    options.enlargeFactor.clamp(0.0, 1.0);\n                final num distortionRatio =\n                    (1 - (itemOffset.abs() * enlargeFactor)).clamp(0.0, 1.0);\n                distortionValue =\n                    Curves.easeOut.transform(distortionRatio as double);\n              }\n\n              final double height = widget.options.height ??\n                  MediaQuery.of(context).size.width *\n                      (1 / widget.options.aspectRatio);\n\n              if (widget.options.scrollDirection == Axis.horizontal) {\n                return getCenterWrapper(\n                  getEnlargeWrapper(\n                    child,\n                    height: distortionValue * height,\n                    scale: distortionValue,\n                    itemOffset: itemOffset,\n                  ),\n                );\n              } else {\n                return getCenterWrapper(\n                  getEnlargeWrapper(\n                    child,\n                    width: distortionValue * MediaQuery.of(context).size.width,\n                    scale: distortionValue,\n                    itemOffset: itemOffset,\n                  ),\n                );\n              }\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _MultipleGestureRecognizer extends PanGestureRecognizer {}\n"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "draggable_scrollbar_positioned_list", "file_path": "external_libs/draggable_scrollbar_positioned_list/draggable_scrollbar_positioned_list.dart", "file_name": "draggable_scrollbar_positioned_list.dart", "line": 63, "line_from": 63, "line_to": 152, "snippet": "  final void Function({required bool dragging})? onDragging;\n\n  @override\n  DraggableScrollbarPositionedListState createState() =>\n      DraggableScrollbarPositionedListState();\n\n  static Widget buildScrollThumb({\n    required Widget scrollThumb,\n    required Color backgroundColor,\n    required Animation<double> thumbAnimation,\n    required bool alwaysVisibleScrollThumb,\n  }) {\n    if (alwaysVisibleScrollThumb) return scrollThumb;\n\n    return SlideFadeTransition(\n      key: const ValueKey('SlideFadeTransition2938492'),\n      animation: thumbAnimation,\n      child: scrollThumb,\n    );\n  }\n\n  static ScrollThumbBuilder _thumbArrowBuilder(\n    Key? scrollThumbKey,\n    bool alwaysVisibleScrollThumb,\n  ) {\n    return (\n      Color backgroundColor,\n      Animation<double> thumbAnimation,\n      double height,\n    ) {\n      // creates a ClipPath widget named scrollThumb that represents a scroll\n      // thumb used in a scrollbar. The scroll thumb is a rectangular container\n      // with rounded corners, and it uses an ArrowClipper as its clipper to\n      // give it an arrow-shaped appearance.\n      final ClipPath scrollThumb = ClipPath(\n        key: const Key(\"ScrollThumbBuilderClipPath\"),\n        child: Container(\n          key: scrollThumbKey,\n          alignment: Alignment.center,\n          height: 40,\n          width: 16,\n          decoration: BoxDecoration(\n            color: backgroundColor,\n            borderRadius: BorderRadius.circular(4),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              SvgPicture.asset(\n                'assets/images/svg/chevrons_left.svg',\n              ),\n              SvgPicture.asset(\n                'assets/images/svg/chevrons_right.svg',\n              ),\n            ],\n          ),\n        ),\n      );\n      // final ClipPath scrollThumb = ClipPath(\n      //   key: const Key(\"ScrollThumbBuilderClipPath\"),\n      //   // clipper: ArrowClipper(),\n      //   child: Container(\n      //     key: scrollThumbKey,\n      //     height: 50,\n      //     width: 50,\n      //     decoration: BoxDecoration(\n      //       color: backgroundColor,\n      //       borderRadius: const BorderRadius.only(\n      //         topLeft: Radius.circular(50),\n      //         bottomLeft: Radius.circular(50),\n      //         topRight: Radius.circular(50),\n      //       ),\n      //     ),\n      //     child: Icon(\n      //       Icons.unfold_more,\n      //       color: Colors.grey.shade100,\n      //     ),\n      //   ),\n      // );\n\n      return buildScrollThumb(\n        scrollThumb: scrollThumb,\n        backgroundColor: backgroundColor,\n        thumbAnimation: thumbAnimation,\n        alwaysVisibleScrollThumb: alwaysVisibleScrollThumb,\n      );\n    };\n  }\n}"}, {"structure_type": "function", "name": "initState", "docstring": "", "module": "circular_seek_bar-master", "file_path": "external_libs/circular_seek_bar-master/circular_seek_bar.dart", "file_name": "circular_seek_bar.dart", "line": 142, "line_from": 142, "line_to": 628, "snippet": "  void initState() {\n    super.initState();\n    _progress = widget.progress;\n  }\n\n  /// Reset CircularSeekBar's progress.\n  @override\n  void didUpdateWidget(CircularSeekBar oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.progress != widget.progress) {\n      _progress = widget.progress;\n    }\n  }\n\n  /// Get size of CircularSeekBar with RenderBox.\n  // Size _getSize(GlobalKey key) {\n  //   final RenderBox renderBox =\n  //       key.currentContext!.findRenderObject() as RenderBox;\n  //   Size size = renderBox.size;\n  //   return size;\n  // }\n\n  /// Converts the x and y coordinate values received by the onTapDown callback to progress.\n  // void _handleGesture(details) {\n  //   double dx = details.localPosition.dx;\n  //   double dy = details.localPosition.dy;\n  //   Size size = _getSize(_key);\n  //   double centerX = size.width / 2.0;\n  //   double centerY = size.height / 2.0;\n  //   double angle = _getTouchedDegrees(centerX, dx, centerY, dy);\n  //   double progress = (widget.dashWidth > 0 && widget.dashGap > 0)\n  //       ? _angleToDashedProgress(\n  //           angle > 0 ? angle : angle + 360,\n  //           widget.startAngle,\n  //           widget.sweepAngle,\n  //           widget.dashWidth,\n  //           widget.dashGap)\n  //       : _angleToProgress(angle > 0 ? angle : angle + 360, widget.startAngle,\n  //           widget.sweepAngle);\n  //   if (progress >= widget.minProgress && progress <= widget.maxProgress) {\n  //     setState(() {\n  //       _progress = progress;\n  //     });\n  //   }\n  // }\n\n  // /// Method to get relative angle of CircularSeekBar.\n  // double _getRelativeAngle(double angle, double startAngle) {\n  //   return (angle - startAngle) >= 0\n  //       ? (angle - startAngle)\n  //       : (360 - startAngle + angle);\n  // }\n\n  /// Convert (x, y) coordinates to an angle.\n  // double _getTouchedDegrees(\n  //     double centerX, double dx, double centerY, double dy) {\n  //   return _radiansToDegrees(atan2(centerX - dx, dy - centerY));\n  // }\n\n  /// Convert angle to progress.\n  // double _angleToProgress(double angle, double startAngle, double sweepAngle) {\n  //   double relativeAngle = _getRelativeAngle(angle, startAngle);\n  //   return (relativeAngle / sweepAngle) * 100;\n  // }\n\n  // /// Convert the angle of dashed seekbar to progress\n  // double _angleToDashedProgress(double angle, double startAngle,\n  //     double sweepAngle, double dashWidth, double dashGap) {\n  //   double relativeAngle = (angle - startAngle) >= 0\n  //       ? (angle - startAngle)\n  //       : (360 - startAngle + angle);\n  //   double dashSum = dashWidth + dashGap;\n\n  //   int trackDashCounts =\n  //       sweepAngle >= (sweepAngle ~/ dashSum) * dashSum + dashWidth\n  //           ? (sweepAngle ~/ dashSum) + 1\n  //           : (sweepAngle ~/ dashSum);\n  //   double totalTrackDashWidth = dashWidth * trackDashCounts;\n\n  //   for (int i = 0; i <= trackDashCounts; i++) {\n  //     double relativeDashStartAngle = dashSum * i;\n  //     double relativeDashEndAngle = (relativeDashStartAngle + dashWidth) % 360;\n\n  //     if (relativeAngle >= relativeDashStartAngle &&\n  //         relativeAngle <= relativeDashEndAngle) {\n  //       double totalFilledDashRatio =\n  //           (dashWidth * i) / totalTrackDashWidth.toDouble();\n  //       double totalHalfWidthDashRatio =\n  //           ((relativeAngle - dashSum * i) / dashWidth.toDouble()) /\n  //               trackDashCounts;\n\n  //       return _lerp(widget.minProgress, widget.maxProgress,\n  //           totalFilledDashRatio + totalHalfWidthDashRatio);\n  //     }\n  //   }\n  //   return -1;\n  // }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animation) {\n      return GestureDetector(\n        key: _key,\n        onTapDown: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        onPanUpdate: (details) {\n          if (widget.interactive) {\n          //  _handleGesture(details);\n          }\n        },\n        child: TweenAnimationBuilder(\n            duration: Duration(milliseconds: widget.animDurationMillis),\n            tween: Tween(begin: widget.minProgress, end: _progress!),\n            curve: widget.curves,\n            onEnd: widget.onEnd,\n            builder: (BuildContext context, double progress, __) {\n              widget.valueNotifier?.value = progress;\n              return CustomPaint(\n                size: Size(widget.width, widget.height),\n                painter: _SeekBarPainter(\n                  progress: progress,\n                  minProgress: widget.minProgress,\n                  maxProgress: widget.maxProgress,\n                  startAngle: widget.startAngle,\n                  sweepAngle: widget.sweepAngle,\n                  barWidth: widget.barWidth,\n                  trackColor: widget.trackColor,\n                  trackGradientColors: widget.trackGradientColors,\n                  progressColor: widget.progressColor,\n                  progressGradientColors: widget.progressGradientColors,\n                  strokeCap: widget.strokeCap,\n                  innerThumbRadius: widget.innerThumbRadius,\n                  innerThumbStrokeWidth: widget.innerThumbStrokeWidth,\n                  innerThumbColor: widget.innerThumbColor,\n                  outerThumbRadius: widget.outerThumbRadius,\n                  outerThumbStrokeWidth: widget.outerThumbStrokeWidth,\n                  outerThumbColor: widget.outerThumbColor,\n                  dashWidth: widget.dashWidth,\n                  dashGap: widget.dashGap,\n                ),\n                child: SizedBox(\n                  width: widget.width,\n                  height: widget.height,\n                  child: widget.child,\n                ),\n              );\n            }),\n      );\n    } else {\n      widget.valueNotifier?.value = _progress!;\n      return GestureDetector(\n        key: _key,\n        onTapDown: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        onPanUpdate: (details) {\n          if (widget.interactive) {\n           // _handleGesture(details);\n          }\n        },\n        child: CustomPaint(\n          size: Size(widget.width, widget.height),\n          painter: _SeekBarPainter(\n            progress: _progress!,\n            minProgress: widget.minProgress,\n            maxProgress: widget.maxProgress,\n            startAngle: widget.startAngle,\n            sweepAngle: widget.sweepAngle,\n            barWidth: widget.barWidth,\n            trackColor: widget.trackColor,\n            trackGradientColors: widget.trackGradientColors,\n            progressColor: widget.progressColor,\n            progressGradientColors: widget.progressGradientColors,\n            strokeCap: widget.strokeCap,\n            innerThumbRadius: widget.innerThumbRadius,\n            innerThumbStrokeWidth: widget.innerThumbStrokeWidth,\n            innerThumbColor: widget.innerThumbColor,\n            outerThumbRadius: widget.outerThumbRadius,\n            outerThumbStrokeWidth: widget.outerThumbStrokeWidth,\n            outerThumbColor: widget.outerThumbColor,\n            dashWidth: widget.dashWidth,\n            dashGap: widget.dashGap,\n          ),\n          child: SizedBox(\n            width: widget.width,\n            height: widget.height,\n            child: widget.child,\n          ),\n        ),\n      );\n    }\n  }\n}\n\nclass _SeekBarPainter extends CustomPainter {\n  /// Current value of seek bar.\n  final double progress;\n\n  /// Minimum value of seek bar.\n  final double minProgress;\n\n  /// Maximum value of seek bar.\n  final double maxProgress;\n\n  /// The Angle to start drawing this seek bar from\n  final double startAngle;\n\n  /// The Angle through which to draw the seek bar\n  final double sweepAngle;\n\n  /// The thickness of the seek bar.\n  final double barWidth;\n\n  /// Background track color of seek bar.\n  final Color trackColor;\n\n  /// Background track gradient colors of seek bar.\n  final List<Color> trackGradientColors;\n\n  /// Foreground progress color of seek bar.\n  final Color progressColor;\n\n  /// Foreground trackGradientColors of seek bar.\n  final List<Color> progressGradientColors;\n\n  /// Styles to use for arcs endings.\n  final StrokeCap strokeCap;\n\n  /// The radius of the seekbar inner thumb.\n  final double innerThumbRadius;\n\n  /// The stroke width of the seekbar inner thumb.\n  final double innerThumbStrokeWidth;\n\n  /// Color of the seekbar inner thumb.\n  final Color innerThumbColor;\n\n  /// The radius of the seekbar outer thumb.\n  final double outerThumbRadius;\n\n  /// The stroke width of the seekbar outer thumb.\n  final double outerThumbStrokeWidth;\n\n  /// Color of the seekbar outer thumb.\n  final Color outerThumbColor;\n\n  /// Dash width of seek bar\n  final double dashWidth;\n\n  /// Dash gap of seek bar.\n  final double dashGap;\n\n  /// The initial rotational offset 90\n  static const double angleOffset = 90;\n\n  _SeekBarPainter(\n      {required this.progress,\n      required this.minProgress,\n      required this.maxProgress,\n      required this.startAngle,\n      required this.sweepAngle,\n      required this.barWidth,\n      required this.trackColor,\n      required this.trackGradientColors,\n      required this.progressColor,\n      required this.progressGradientColors,\n      required this.strokeCap,\n      required this.innerThumbRadius,\n      required this.innerThumbStrokeWidth,\n      required this.innerThumbColor,\n      required this.outerThumbRadius,\n      required this.outerThumbStrokeWidth,\n      required this.outerThumbColor,\n      required this.dashWidth,\n      required this.dashGap});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    if (sweepAngle > 0.0) {\n      Paint trackPaint = Paint()\n        ..style = PaintingStyle.stroke\n        ..color = trackColor\n        ..strokeCap = strokeCap\n        ..strokeWidth = barWidth;\n\n      Paint progressPaint = Paint()\n        ..style = PaintingStyle.stroke\n        ..color = progressColor\n        ..strokeCap = strokeCap\n        ..strokeWidth = barWidth;\n\n      final Offset center = Offset(size.width / 2, size.height / 2);\n      final double largerThumbWidth =\n          (outerThumbRadius / 2 + outerThumbStrokeWidth / 2) >=\n                  (innerThumbRadius / 2 + innerThumbStrokeWidth / 2)\n              ? (outerThumbRadius / 2 + outerThumbStrokeWidth / 2)\n              : (innerThumbRadius / 2 + innerThumbStrokeWidth / 2);\n      final double seekBarMargin =\n          largerThumbWidth >= (barWidth / 2) ? largerThumbWidth : barWidth / 2;\n      final double radius = min(center.dx, center.dy) - seekBarMargin;\n      double realStartAngle = startAngle + angleOffset;\n\n      double startAngleWithOffsetRadian = _degreesToRadians(realStartAngle);\n      Rect rect = Rect.fromCenter(\n          center: center, width: 2 * radius, height: 2 * radius);\n\n      double sweepAngleRadian = _degreesToRadians(sweepAngle);\n\n      // Set gradients\n      if (trackGradientColors.isNotEmpty) {\n        Gradient trackGradient = SweepGradient(\n          center: Alignment.center,\n          startAngle: 0,\n          endAngle: sweepAngleRadian,\n          tileMode: TileMode.mirror,\n          colors: trackGradientColors,\n          transform: GradientRotation(\n              startAngleWithOffsetRadian - asin((barWidth / 2) / radius)),\n        );\n        trackPaint.shader = trackGradient.createShader(rect);\n      }\n\n      if (progressGradientColors.isNotEmpty) {\n        Gradient progressGradient = SweepGradient(\n          center: Alignment.center,\n          startAngle: 0,\n          endAngle: sweepAngleRadian,\n          tileMode: TileMode.mirror,\n          colors: progressGradientColors,\n          transform: GradientRotation(\n              startAngleWithOffsetRadian - asin((barWidth / 2) / radius)),\n        );\n\n        progressPaint.shader = progressGradient.createShader(rect);\n      }\n\n      if (dashWidth > 0 && dashGap > 0) {\n        double dashSum = dashWidth + dashGap;\n        double dashWidthRadian = _degreesToRadians(dashWidth);\n        double dashSumRadian = _degreesToRadians(dashSum);\n\n        int trackDashCounts =\n            sweepAngle >= (sweepAngle ~/ dashSum) * dashSum + dashWidth\n                ? (sweepAngle ~/ dashSum) + 1\n                : (sweepAngle ~/ dashSum);\n        int progressDashCounts =\n            (trackDashCounts * _lerpRatio(minProgress, maxProgress, progress))\n                .floor();\n        double fullProgressRatio =\n            (progressDashCounts / trackDashCounts.toDouble());\n\n        // Draw track dashes.\n        for (int i = 0; i < trackDashCounts; i++) {\n          canvas.drawArc(\n            rect,\n            startAngleWithOffsetRadian + dashSumRadian * i,\n            dashWidthRadian,\n            false,\n            trackPaint,\n          );\n        }\n\n        // Draw progress dashes.\n        for (int i = 0; i < progressDashCounts; i++) {\n          canvas.drawArc(\n            rect,\n            startAngleWithOffsetRadian + dashSumRadian * i,\n            dashWidthRadian,\n            false,\n            progressPaint,\n          );\n        }\n\n        canvas.drawArc(\n          rect,\n          startAngleWithOffsetRadian + dashSumRadian * (progressDashCounts),\n          dashWidthRadian *\n              (_lerpRatio(minProgress, maxProgress, progress) -\n                  fullProgressRatio) *\n              trackDashCounts,\n          false,\n          progressPaint,\n        );\n\n        double totalTrackDashWidth = dashWidth * trackDashCounts;\n        double totalRatio = _lerpRatio(minProgress, maxProgress, progress);\n        double totalFilledAngleRatio =\n            (dashWidth * progressDashCounts) / totalTrackDashWidth.toDouble();\n        double totalHalfWidthAngleRatio = totalRatio - totalFilledAngleRatio;\n        double halfWidthAngleRatio = totalHalfWidthAngleRatio * trackDashCounts;\n\n        double halfWidthProgressAngle =\n            _lerp(0, dashWidth, halfWidthAngleRatio);\n        double filledProgressAngle = trackDashCounts >= progressDashCounts + 1\n            ? dashSum * progressDashCounts\n            : dashSum * (progressDashCounts - 1) + dashWidth;\n        double progressAngle = filledProgressAngle + halfWidthProgressAngle;\n\n        double thumbX = center.dx -\n            sin(_degreesToRadians(startAngle + progressAngle)) * radius;\n        double thumbY = center.dy +\n            cos(_degreesToRadians(startAngle + progressAngle)) * radius;\n        Offset thumbCenter = Offset(thumbX, thumbY);\n\n        canvas.drawCircle(\n            thumbCenter,\n            outerThumbRadius,\n            Paint()\n              ..color = outerThumbColor\n              ..style = PaintingStyle.stroke\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = outerThumbStrokeWidth);\n\n        canvas.drawCircle(\n            thumbCenter,\n            innerThumbRadius,\n            Paint()\n              ..color = innerThumbColor\n              ..style = PaintingStyle.fill\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = innerThumbStrokeWidth);\n      } else {\n        double progressAngle = _lerp(\n            0, sweepAngle, _lerpRatio(minProgress, maxProgress, progress));\n        double progressAngleRadian = _degreesToRadians(progressAngle);\n\n        canvas.drawArc(rect, startAngleWithOffsetRadian, sweepAngleRadian,\n            false, trackPaint);\n        canvas.drawArc(rect, startAngleWithOffsetRadian, progressAngleRadian,\n            false, progressPaint);\n\n        double thumbX = center.dx -\n            sin(_degreesToRadians(startAngle + progressAngle)) * radius;\n        double thumbY = center.dy +\n            cos(_degreesToRadians(startAngle + progressAngle)) * radius;\n\n        Offset thumbCenter = Offset(thumbX, thumbY);\n\n        canvas.drawCircle(\n            thumbCenter,\n            outerThumbRadius,\n            Paint()\n              ..color = outerThumbColor\n              ..style = PaintingStyle.stroke\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = outerThumbStrokeWidth);\n\n        canvas.drawCircle(\n            thumbCenter,\n            innerThumbRadius,\n            Paint()\n              ..color = innerThumbColor\n              ..style = PaintingStyle.fill\n              ..strokeCap = StrokeCap.round\n              ..strokeWidth = innerThumbStrokeWidth);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant _SeekBarPainter oldDelegate) {\n    return oldDelegate.progress != progress ||\n        oldDelegate.minProgress != minProgress ||\n        oldDelegate.maxProgress != maxProgress ||\n        oldDelegate.startAngle != startAngle ||\n        oldDelegate.sweepAngle != sweepAngle ||\n        oldDelegate.barWidth != barWidth ||\n        oldDelegate.trackColor != trackColor ||\n        oldDelegate.trackGradientColors != trackGradientColors ||\n        oldDelegate.progressColor != progressColor ||\n        oldDelegate.progressGradientColors != progressGradientColors ||\n        oldDelegate.strokeCap != strokeCap ||\n        oldDelegate.innerThumbRadius != innerThumbRadius ||\n        oldDelegate.innerThumbStrokeWidth != innerThumbStrokeWidth ||\n        oldDelegate.innerThumbColor != innerThumbColor ||\n        oldDelegate.outerThumbRadius != outerThumbRadius ||\n        oldDelegate.outerThumbStrokeWidth != outerThumbStrokeWidth ||\n        oldDelegate.outerThumbColor != outerThumbColor ||\n        oldDelegate.dashWidth != dashWidth ||\n        oldDelegate.dashGap != dashGap;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "expandable_bottom_sheet", "file_path": "external_libs/expandable_bottom_sheet/expandable_bottom_sheet.dart", "file_name": "expandable_bottom_sheet.dart", "line": 42, "line_from": 42, "line_to": 382, "snippet": "  final void Function()? onIsExtendedCallback;\n\n  final void Function()? onIsContractedCallback;\n\n  final bool enableToggle;\n\n  final bool isDraggable;\n  bool isExpanded;\n\n  ExpandableBottomSheetState? expandableBottomSheetState;\n\n  // // ignore: no_logic_in_create_state\n  // ExpandableBottomSheetState createState() {\n  //   expandableBottomSheetState = ExpandableBottomSheetState();\n  //   return expandableBottomSheetState;\n  // }\n  @override\n  ExpandableBottomSheetState createState() => ExpandableBottomSheetState();\n}\n\nclass ExpandableBottomSheetState extends State<ExpandableBottomSheet>\n    with TickerProviderStateMixin {\n  final GlobalKey _contentKey = GlobalKey(debugLabel: 'contentKey');\n  final GlobalKey _headerKey = GlobalKey(debugLabel: 'headerKey');\n  final GlobalKey _footerKey = GlobalKey(debugLabel: 'footerKey');\n\n  late AnimationController _controller;\n\n  double _draggableHeight = 0;\n  double? _positionOffset;\n  double _startOffsetAtDragDown = 0;\n  double? _startPositionAtDragDown = 0;\n\n  double _minOffset = 0;\n  double _maxOffset = 0;\n  double _animationMinOffset = 0;\n\n  AnimationStatus _oldStatus = AnimationStatus.dismissed;\n\n  bool _useDrag = true;\n  bool _callCallbacks = false;\n\n  void expand() {\n    _afterUpdateWidgetBuild(false);\n    _callCallbacks = true;\n    widget.isExpanded = true;\n    _animateToTop();\n  }\n\n  void contract() {\n    _afterUpdateWidgetBuild(false);\n    _callCallbacks = true;\n    _animateToBottom();\n  }\n\n  ExpansionStatus get expansionStatus {\n    if (_positionOffset == null) return ExpansionStatus.contracted;\n    if (_positionOffset == _maxOffset) return ExpansionStatus.contracted;\n    if (_positionOffset == _minOffset) return ExpansionStatus.expanded;\n    return ExpansionStatus.middle;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this);\n    _controller.addStatusListener(_handleAnimationStatusUpdate);\n    WidgetsBinding.instance\n        .addPostFrameCallback((_) => _afterUpdateWidgetBuild(true));\n   \n  }\n  \n\n  @override\n  Widget build(BuildContext context) {\n    WidgetsBinding.instance\n        .addPostFrameCallback((_) => _afterUpdateWidgetBuild(false));\n    return Column(\n      children: <Widget>[\n        Expanded(\n          child: Stack(\n            children: <Widget>[\n              Align(\n                alignment: Alignment.topLeft,\n                child: InkWell(\n                  onTap: () => context.navigatorPop<void>(),\n                  child: widget.background,\n                ),\n              ),\n              AnimatedBuilder(\n                animation: _controller,\n                builder: (_, Widget? child) {\n                  if (_controller.isAnimating) {\n                    _positionOffset = _animationMinOffset +\n                        _controller.value * _draggableHeight;\n                  }\n                  return Positioned(\n                    top: _positionOffset,\n                    right: 0,\n                    left: 0,\n                    child: child!,\n                  );\n                },\n                child: GestureDetector(\n                  onTap: _toggle,\n                  onVerticalDragDown: widget.isDraggable ? _dragDown : (_) {},\n                  onVerticalDragUpdate:\n                      widget.isDraggable ? _dragUpdate : (_) {},\n                  onVerticalDragEnd: widget.isDraggable ? _dragEnd : (_) {},\n                  child: Padding(\n                    padding: const EdgeInsets.only(top: 40),\n                    child: Column(\n                      mainAxisSize: MainAxisSize.min,\n                      children: <Widget>[\n                        Container(\n                          key: _headerKey,\n                          child: widget.persistentHeader ?? Container(),\n                        ),\n                        Container(\n                          key: _contentKey,\n                          child: widget.expandableContent,\n                        ),\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n        Container(\n          key: _footerKey,\n          child: widget.persistentFooter ?? Container(),\n        ),\n      ],\n    );\n  }\n\n  void _handleAnimationStatusUpdate(AnimationStatus status) {\n    if (status == AnimationStatus.completed) {\n      if (_oldStatus == AnimationStatus.forward) {\n        setState(() {\n          _draggableHeight = _maxOffset - _minOffset;\n          _positionOffset = _minOffset;\n        });\n        if (widget.onIsExtendedCallback != null && _callCallbacks) {\n          widget.onIsExtendedCallback!();\n        }\n      }\n      if (_oldStatus == AnimationStatus.reverse) {\n        setState(() {\n          _draggableHeight = _maxOffset - _minOffset;\n          _positionOffset = _maxOffset;\n        });\n        if (widget.onIsContractedCallback != null && _callCallbacks) {\n          widget.onIsContractedCallback!();\n        }\n      }\n    }\n  }\n\n  void _afterUpdateWidgetBuild(bool isFirstBuild) {\n    final double headerHeight = _headerKey.currentContext!.size!.height;\n    final double footerHeight = _footerKey.currentContext!.size!.height;\n    final double contentHeight = _contentKey.currentContext!.size!.height;\n\n    final double checkedPersistentContentHeight =\n        (widget.persistentContentHeight < contentHeight)\n            ? widget.persistentContentHeight\n            : contentHeight;\n\n    _minOffset =\n        context.size!.height - headerHeight - contentHeight - footerHeight;\n    _maxOffset = context.size!.height -\n        headerHeight -\n        footerHeight -\n        checkedPersistentContentHeight;\n\n    if (!isFirstBuild) {\n      _positionOutOfBounds();\n    } else {\n      setState(() {\n        _positionOffset = _maxOffset;\n        _draggableHeight = _maxOffset - _minOffset;\n      });\n    }\n  }\n\n  void _positionOutOfBounds() {\n    if (_positionOffset! < _minOffset) {\n      //the extend is larger than contentHeight\n      _callCallbacks = false;\n      _animateToMin();\n    } else {\n      if (_positionOffset! > _maxOffset) {\n        //the extend is smaller than persistentContentHeight\n        _callCallbacks = false;\n        _animateToMax();\n      } else {\n        _draggableHeight = _maxOffset - _minOffset;\n      }\n    }\n  }\n\n  void _animateOnIsAnimating() {\n    if (_controller.isAnimating) {\n      _controller.stop();\n    }\n  }\n\n  void _toggle() {\n    if (widget.enableToggle) {\n      if (expansionStatus == ExpansionStatus.expanded) {\n        _callCallbacks = true;\n        _animateToBottom();\n      }\n      if (expansionStatus == ExpansionStatus.contracted) {\n        _callCallbacks = true;\n        _animateToTop();\n      }\n    }\n  }\n\n  void _dragDown(DragDownDetails details) {\n    if (_controller.isAnimating) {\n      _useDrag = false;\n    } else {\n      _useDrag = true;\n      _startOffsetAtDragDown = details.localPosition.dy;\n      _startPositionAtDragDown = _positionOffset;\n    }\n  }\n\n  void _dragUpdate(DragUpdateDetails details) {\n    if (!_useDrag) return;\n    final double offset = details.localPosition.dy;\n    final double newOffset =\n        _startPositionAtDragDown! + offset - _startOffsetAtDragDown;\n    if (_minOffset <= newOffset && _maxOffset >= newOffset) {\n      setState(() {\n        _positionOffset = newOffset;\n      });\n    } else {\n      if (_minOffset > newOffset) {\n        setState(() {\n          _positionOffset = _minOffset;\n        });\n      }\n      if (_maxOffset < newOffset) {\n        setState(() {\n          _positionOffset = _maxOffset;\n        });\n      }\n    }\n  }\n\n  void _dragEnd(DragEndDetails details) {\n    if (_startPositionAtDragDown == _positionOffset || !_useDrag) return;\n    if (details.primaryVelocity! < -250) {\n      //drag up ended with high speed\n      _callCallbacks = true;\n      _animateToTop();\n    } else {\n      if (details.primaryVelocity! > 250) {\n        //drag down ended with high speed\n        _callCallbacks = true;\n        _animateToBottom();\n      } else {\n        if (_positionOffset == _maxOffset &&\n            widget.onIsContractedCallback != null) {\n          widget.onIsContractedCallback!();\n        }\n        if (_positionOffset == _minOffset &&\n            widget.onIsExtendedCallback != null) {\n          widget.onIsExtendedCallback!();\n        }\n      }\n    }\n  }\n\n  void _animateToTop() {\n    // booksC.isBottomSheetExpanded.value = true;\n    _animateOnIsAnimating();\n    _controller.value = (_positionOffset! - _minOffset) / _draggableHeight;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.forward;\n    _controller.animateTo(\n      .001,\n      duration: widget.animationDurationExtend,\n      curve: widget.animationCurveExpand,\n    );\n  }\n\n  void _animateToBottom() {\n    // booksC.isBottomSheetExpanded.value = false;\n    _animateOnIsAnimating();\n\n    _controller.value = (_positionOffset! - _minOffset) / _draggableHeight;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.reverse;\n    _controller.animateTo(\n      0.999,\n      duration: widget.animationDurationContract,\n      curve: widget.animationCurveContract,\n    );\n  }\n\n  void _animateToMax() {\n    _animateOnIsAnimating();\n\n    _controller.value = 1.0;\n    _draggableHeight = _positionOffset! - _maxOffset;\n    _animationMinOffset = _maxOffset;\n    _oldStatus = AnimationStatus.reverse;\n    _controller.animateTo(\n      0.001,\n      duration: widget.animationDurationExtend,\n      curve: widget.animationCurveExpand,\n    );\n  }\n\n  void _animateToMin() {\n    _animateOnIsAnimating();\n\n    _controller.value = 1.0;\n    _draggableHeight = _positionOffset! - _minOffset;\n    _animationMinOffset = _minOffset;\n    _oldStatus = AnimationStatus.forward;\n    _controller.animateTo(\n      0.0001,\n      duration: widget.animationDurationContract,\n      curve: widget.animationCurveContract,\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "external_libs/animate_do/zooms.dart", "file_name": "zooms.dart", "line": 21, "line_from": 21, "line_to": 94, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  ZoomInState createState() => ZoomInState();\n}\n\nclass ZoomInState extends State<ZoomIn> with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> fade;\n  late Animation<double> opacity;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n    fade = Tween(begin: 0.001, end: widget.from)\n        .animate(CurvedAnimation(curve: Curves.easeOut, parent: controller!));\n\n    opacity = Tween<double>(begin: 0, end: 1).animate(\n      CurvedAnimation(parent: controller!, curve: const Interval(0, 0.65)),\n    );\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: fade,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.scale(\n          scale: fade.value,\n          child: Opacity(\n            opacity: opacity.value,\n            child: widget.child,\n          ),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "external_libs/animate_do/fades.dart", "file_name": "fades.dart", "line": 20, "line_from": 20, "line_to": 85, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n\n  @override\n  FadeInState createState() => FadeInState();\n}\n\nclass FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n\n  bool disposed = false;\n\n  late Animation<double> animation;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n    animation = CurvedAnimation(curve: Curves.easeOut, parent: controller!);\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: animation,\n      builder: (BuildContext context, Widget? child) {\n        return Opacity(\n          opacity: animation.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "external_libs/animate_do/bounces.dart", "file_name": "bounces.dart", "line": 21, "line_from": 21, "line_to": 93, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  BounceInDownState createState() => BounceInDownState();\n}\n\nclass BounceInDownState extends State<BounceInDown>\n    with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> animation;\n  late Animation<double> opacity;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n\n    opacity = Tween<double>(begin: 0, end: 1).animate(\n      CurvedAnimation(parent: controller!, curve: const Interval(0, 0.65)),\n    );\n\n    animation = Tween<double>(begin: widget.from * -1, end: 0)\n        .animate(CurvedAnimation(parent: controller!, curve: Curves.bounceOut));\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: controller!,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.translate(\n          offset: Offset(0, animation.value),\n          child: Opacity(opacity: opacity.value, child: widget.child),\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "animate_do", "file_path": "external_libs/animate_do/slides.dart", "file_name": "slides.dart", "line": 21, "line_from": 21, "line_to": 88, "snippet": "  final Widget child;\n  final Duration duration;\n  final Duration delay;\n  final void Function(AnimationController)? controller;\n  final bool manualTrigger;\n  final bool animate;\n  final double from;\n\n  @override\n  SlideInUpState createState() => SlideInUpState();\n}\n\nclass SlideInUpState extends State<SlideInUp>\n    with SingleTickerProviderStateMixin {\n  AnimationController? controller;\n  bool disposed = false;\n  late Animation<double> animation;\n\n  @override\n  void dispose() {\n    disposed = true;\n    controller!.dispose();\n    super.dispose();\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = AnimationController(duration: widget.duration, vsync: this);\n\n    animation = Tween<double>(begin: widget.from, end: 0)\n        .animate(CurvedAnimation(parent: controller!, curve: Curves.easeOut));\n\n    if (!widget.manualTrigger && widget.animate) {\n      Future.delayed(widget.delay, () {\n        if (!disposed) {\n          controller?.forward();\n        }\n      });\n    }\n\n    if (widget.controller is Function) {\n      widget.controller!(controller!);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (widget.animate && widget.delay.inMilliseconds == 0) {\n      controller?.forward();\n    }\n\n    if (!widget.animate) {\n      controller?.animateBack(0);\n    }\n\n    return AnimatedBuilder(\n      animation: controller!,\n      builder: (BuildContext context, Widget? child) {\n        return Transform.translate(\n          offset: Offset(0, animation.value),\n          child: widget.child,\n        );\n      },\n    );\n  }\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "external_libs/flutter_animated_dialog/src/custom_dialog_transitions.dart", "file_name": "custom_dialog_transitions.dart", "line": 20, "line_from": 20, "line_to": 57, "snippet": "  Widget build(BuildContext context) {\n    final double turnsValue = turns.value;\n    final Matrix4 transform = Matrix4.identity()\n      ..setEntry(3, 2, 0.0006)\n      ..rotateY(turnsValue);\n    return Transform(\n      transform: transform,\n      alignment: FractionalOffset.center,\n      child: child,\n    );\n  }\n}\n\nclass CustomRotationTransition extends AnimatedWidget {\n  const CustomRotationTransition({\n    super.key,\n    required Animation<double> turns,\n    this.alignment = Alignment.center,\n    this.child,\n  }) : super(listenable: turns);\n\n  Animation<double> get turns => listenable as Animation<double>;\n\n  final Alignment? alignment;\n\n  final Widget? child;\n\n  @override\n  Widget build(BuildContext context) {\n    final double turnsValue = turns.value;\n    final Matrix4 transform = Matrix4.rotationZ(turnsValue * math.pi);\n    return Transform(\n      transform: transform,\n      alignment: alignment,\n      child: child,\n    );\n  }\n}"}, {"structure_type": "function", "name": "Builder", "docstring": "", "module": "src", "file_path": "external_libs/flutter_animated_dialog/src/animated_dialog.dart", "file_name": "animated_dialog.dart", "line": 53, "line_from": 53, "line_to": 289, "snippet": "      final Widget pageChild = Builder(builder: builder);\n      return SafeArea(\n        top: false,\n        child: Builder(\n          builder: (BuildContext context) {\n            return Theme(data: theme, child: pageChild);\n          },\n        ),\n      );\n    },\n    barrierDismissible: barrierDismissible,\n    barrierLabel: \"Close dialog\",\n    barrierColor: barrierColor ?? Colors.black54,\n    transitionDuration: duration ?? const Duration(milliseconds: 400),\n    transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      switch (animationType) {\n        case DialogTransitionType.fade:\n          return FadeTransition(opacity: animation, child: child);\n        case DialogTransitionType.slideFromRight:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromLeft:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(-1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromRightFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromLeftFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(-1, 0),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromTop:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(0, -1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromTopFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(0, -1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.slideFromBottom:\n          return SlideTransition(\n            transformHitTests: false,\n            position: Tween<Offset>(\n              begin: const Offset(0, 1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: child,\n          );\n        case DialogTransitionType.slideFromBottomFade:\n          return SlideTransition(\n            position: Tween<Offset>(\n              begin: const Offset(0, 1),\n              end: Offset.zero,\n            ).chain(CurveTween(curve: curve)).animate(animation),\n            child: FadeTransition(\n              opacity: animation,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.scale:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: child,\n          );\n        case DialogTransitionType.fadeScale:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: FadeTransition(\n              opacity: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.scaleRotate:\n          return ScaleTransition(\n            alignment: alignment,\n            scale: CurvedAnimation(\n              parent: animation,\n              curve: Interval(\n                0,\n                0.50,\n                curve: curve,\n              ),\n            ),\n            child: CustomRotationTransition(\n              alignment: alignment,\n              turns: Tween<double>(begin: 1, end: 2).animate(\n                CurvedAnimation(\n                  parent: animation,\n                  curve: Interval(0, 1, curve: curve),\n                ),\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.rotate:\n          return CustomRotationTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: 1, end: 2).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: child,\n          );\n        case DialogTransitionType.fadeRotate:\n          return CustomRotationTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: 1, end: 2).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: FadeTransition(\n              opacity: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.rotate3D:\n          return Rotation3DTransition(\n            alignment: alignment,\n            turns: Tween<double>(begin: math.pi, end: 2.0 * math.pi).animate(\n              CurvedAnimation(\n                parent: animation,\n                curve: Interval(0, 1, curve: curve),\n              ),\n            ),\n            child: FadeTransition(\n              opacity: Tween<double>(begin: 0, end: 1).animate(\n                CurvedAnimation(\n                  parent: animation,\n                  curve: const Interval(0.5, 1, curve: Curves.elasticOut),\n                ),\n              ),\n              child: child,\n            ),\n          );\n        case DialogTransitionType.size:\n          return Align(\n            alignment: alignment,\n            child: SizeTransition(\n              sizeFactor: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              axis: axis ?? Axis.vertical,\n              child: child,\n            ),\n          );\n        case DialogTransitionType.sizeFade:\n          return Align(\n            alignment: alignment,\n            child: SizeTransition(\n              sizeFactor: CurvedAnimation(\n                parent: animation,\n                curve: curve,\n              ),\n              child: FadeTransition(\n                opacity: CurvedAnimation(\n                  parent: animation,\n                  curve: curve,\n                ),\n                child: child,\n              ),\n            ),\n          );\n        case DialogTransitionType.none:\n          return child;\n      }\n    },"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "external_libs/flutter_animated_dialog/src/animated_dialog.dart", "file_name": "animated_dialog.dart", "line": 338, "line_from": 338, "line_to": 497, "snippet": "  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final DialogThemeData dialogTheme = DialogTheme.of(context);\n    final List<Widget> children = <Widget>[];\n    String? label = semanticLabel;\n\n    if (title != null) {\n      children.add(\n        Padding(\n          padding: titlePadding ?? EdgeInsets.fromLTRB(24, 24, 24, content == null ? 20.0 : 0.0),\n          child: DefaultTextStyle(\n            style: (titleTextStyle ?? dialogTheme.titleTextStyle ?? theme.textTheme.titleLarge)!,\n            child: Semantics(\n              namesRoute: true,\n              container: true,\n              child: title,\n            ),\n          ),\n        ),\n      );\n    } else {\n      switch (defaultTargetPlatform) {\n        case TargetPlatform.iOS:\n          label = semanticLabel;\n        case TargetPlatform.android:\n        case TargetPlatform.fuchsia:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n        case TargetPlatform.linux:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n        case TargetPlatform.macOS:\n          label = semanticLabel;\n        case TargetPlatform.windows:\n          label = semanticLabel ?? MaterialLocalizations.of(context).alertDialogLabel;\n      }\n    }\n\n    if (content != null) {\n      children.add(\n        Flexible(\n          child: Padding(\n            padding: contentPadding!,\n            child: DefaultTextStyle(\n              style: (contentTextStyle ?? dialogTheme.contentTextStyle ?? theme.textTheme.titleMedium)!,\n              child: content!,\n            ),\n          ),\n        ),\n      );\n    }\n\n    if (bottomWidget != null) {\n      children.add(bottomWidget!);\n    } else if (actions != null) {\n      children.add(\n        ButtonBarTheme(\n          data: ButtonBarTheme.of(context),\n          // ignore: deprecated_member_use\n          child: ButtonBar(\n            children: actions!,\n          ),\n        ),\n      );\n    }\n\n    Widget dialogChild = IntrinsicWidth(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: children,\n      ),\n    );\n\n    if (label != null) {\n      dialogChild = Semantics(\n        namesRoute: true,\n        label: label,\n        child: dialogChild,\n      );\n    }\n\n    dialogChild = CustomDialog(\n      backgroundColor: backgroundColor,\n      elevation: elevation,\n      minWidth: minWidth,\n      shape: shape,\n      child: dialogChild,\n    );\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(\n      value: SystemUiOverlayStyle.light.copyWith(\n        statusBarIconBrightness: Brightness.light,\n        statusBarColor: Colors.transparent,\n        systemNavigationBarColor: Colors.white,\n        systemNavigationBarIconBrightness: Brightness.dark,\n      ),\n      child: dialogChild,\n    );\n  }\n}\n\nclass CustomDialog extends StatelessWidget {\n  const CustomDialog({\n    super.key,\n    this.backgroundColor,\n    this.elevation,\n    this.insetAnimationDuration = const Duration(milliseconds: 100),\n    this.insetAnimationCurve = Curves.decelerate,\n    this.minWidth = 280.0,\n    this.shape,\n    this.child,\n  });\n\n  final Color? backgroundColor;\n\n  final double? elevation;\n\n  final Duration? insetAnimationDuration;\n\n  final Curve? insetAnimationCurve;\n\n  final double? minWidth;\n\n  final ShapeBorder? shape;\n\n  final Widget? child;\n\n  static const RoundedRectangleBorder _defaultDialogShape = RoundedRectangleBorder(\n    borderRadius: BorderRadius.all(Radius.circular(2)),\n  );\n  static const double _defaultElevation = 24;\n\n  @override\n  Widget build(BuildContext context) {\n    final DialogThemeData dialogTheme = DialogTheme.of(context);\n    return AnimatedPadding(\n      padding: MediaQuery.of(context).viewInsets + const EdgeInsets.symmetric(horizontal: 40, vertical: 24),\n      duration: insetAnimationDuration!,\n      curve: insetAnimationCurve!,\n      child: MediaQuery.removeViewInsets(\n        removeLeft: true,\n        removeTop: true,\n        removeRight: true,\n        removeBottom: true,\n        context: context,\n        child: Center(\n          child: ConstrainedBox(\n            constraints: BoxConstraints(minWidth: minWidth ?? 280.0),\n            child: Material(\n              color: backgroundColor ?? dialogTheme.backgroundColor,\n              elevation: elevation ?? dialogTheme.elevation ?? _defaultElevation,\n              shape: shape ?? dialogTheme.shape ?? _defaultDialogShape,\n              type: MaterialType.card,\n              child: child,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}"}, {"structure_type": "function", "name": "child;", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 10, "line_from": 10, "line_to": 23, "snippet": "  final Widget child;\n\n  final ValueNotifier<Set<Element>?>? elementNotifier;\n\n  @override\n  State<StatefulWidget> createState() => _RegistryWidgetState();\n}\n\nclass RegisteredElementWidget extends ProxyWidget {\n  const RegisteredElementWidget({super.key, required super.child});\n\n  @override\n  Element createElement() => _RegisteredElement(this);\n}"}, {"structure_type": "function", "name": "build", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 29, "line_from": 29, "line_to": 45, "snippet": "  Widget build(BuildContext context) => _InheritedRegistryWidget(\n        state: this,\n        child: widget.child,\n      );\n}\n\nclass _InheritedRegistryWidget extends InheritedWidget {\n  const _InheritedRegistryWidget({\n    required this.state,\n    required super.child,\n  });\n\n  final _RegistryWidgetState state;\n\n  @override\n  bool updateShouldNotify(InheritedWidget oldWidget) => true;\n}"}, {"structure_type": "function", "name": "notifyClients", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/element_registry.dart", "file_name": "element_registry.dart", "line": 51, "line_from": 51, "line_to": 84, "snippet": "  void notifyClients(ProxyWidget oldWidget) {}\n\n  late _RegistryWidgetState _registryWidgetState;\n\n  @override\n  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    final inheritedRegistryWidget =\n        dependOnInheritedWidgetOfExactType<_InheritedRegistryWidget>()!;\n    _registryWidgetState = inheritedRegistryWidget.state;\n    _registryWidgetState.registeredElements.add(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final inheritedRegistryWidget =\n        dependOnInheritedWidgetOfExactType<_InheritedRegistryWidget>()!;\n    _registryWidgetState = inheritedRegistryWidget.state;\n    _registryWidgetState.registeredElements.add(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n  }\n\n  @override\n  void unmount() {\n    _registryWidgetState.registeredElements.remove(this);\n    _registryWidgetState.widget.elementNotifier?.value =\n        _registryWidgetState.registeredElements;\n    super.unmount();\n  }\n}"}, {"structure_type": "function", "name": "jumpTo", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/scrollable_positioned_list.dart", "file_name": "scrollable_positioned_list.dart", "line": 119, "line_from": 119, "line_to": 178, "snippet": "  void jumpTo({required int index, double alignment = 0}) {\n    _scrollableListState?._jumpTo(index: index, alignment: alignment);\n  }\n\n  Future<void> scrollTo({\n    required int index,\n    double alignment = 0,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    List<double> opacityAnimationWeights = const [40, 20, 40],\n  }) {\n    assert(_scrollableListState != null);\n    assert(opacityAnimationWeights.length == 3);\n    assert(duration > Duration.zero);\n    return _scrollableListState!._scrollTo(\n      index: index,\n      alignment: alignment,\n      duration: duration,\n      curve: curve,\n      opacityAnimationWeights: opacityAnimationWeights,\n    );\n  }\n\n  void _attach(_ScrollablePositionedListState scrollableListState) {\n    assert(_scrollableListState == null);\n    _scrollableListState = scrollableListState;\n  }\n\n  void _detach() {\n    _scrollableListState = null;\n  }\n}\n\nclass ScrollOffsetController {\n  Future<void> animateScroll({\n    required double offset,\n    required Duration duration,\n    Curve curve = Curves.linear,\n  }) async {\n    final currentPosition =\n        _scrollableListState!.primary.scrollController.offset;\n    final newPosition = currentPosition + offset;\n    await _scrollableListState!.primary.scrollController.animateTo(\n      newPosition,\n      duration: duration,\n      curve: curve,\n    );\n  }\n\n  _ScrollablePositionedListState? _scrollableListState;\n\n  void _attach(_ScrollablePositionedListState scrollableListState) {\n    assert(_scrollableListState == null);\n    _scrollableListState = scrollableListState;\n  }\n\n  void _detach() {\n    _scrollableListState = null;\n  }\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/scrollable_positioned_list.dart", "file_name": "scrollable_positioned_list.dart", "line": 188, "line_from": 188, "line_to": 544, "snippet": "  void Function() startAnimationCallback = () {};\n\n  bool _isTransitioning = false;\n\n  late AnimationController _animationController =\n      AnimationController(vsync: this);\n\n  double previousOffset = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    final ItemPosition? initialPosition =\n        PageStorage.of(context).readState(context) as ItemPosition?;\n    primary = _ListDisplayDetails(\n      const ValueKey('Ping'),\n      widget.itemScrollController?.scrollController ??\n          ScrollController(keepScrollOffset: false),\n    );\n    secondary = _ListDisplayDetails(\n      const ValueKey('Pong'),\n      ScrollController(keepScrollOffset: false),\n    );\n    primary\n      ..target = initialPosition?.index ?? widget.initialScrollIndex\n      ..alignment = initialPosition?.itemLeadingEdge ?? widget.initialAlignment;\n    if (widget.itemCount > 0 && primary.target > widget.itemCount - 1) {\n      primary.target = widget.itemCount - 1;\n    }\n    widget.itemScrollController?._attach(this);\n    widget.scrollOffsetController?._attach(this);\n    primary.itemPositionsNotifier.itemPositions.addListener(_updatePositions);\n    secondary.itemPositionsNotifier.itemPositions.addListener(_updatePositions);\n    primary.scrollController.addListener(() {\n      final currentOffset = primary.scrollController.offset;\n      final offsetChange = currentOffset - previousOffset;\n      previousOffset = currentOffset;\n      if (!_isTransitioning |\n          (widget.scrollOffsetNotifier?.recordProgrammaticScrolls ?? false)) {\n        widget.scrollOffsetNotifier?.changeController.add(offsetChange);\n      }\n    });\n  }\n\n  @override\n  void activate() {\n    super.activate();\n    widget.itemScrollController?._attach(this);\n    widget.scrollOffsetController?._attach(this);\n  }\n\n  @override\n  void deactivate() {\n    widget.itemScrollController?._detach();\n    widget.scrollOffsetController?._detach();\n    super.deactivate();\n  }\n\n  @override\n  void dispose() {\n    primary.itemPositionsNotifier.itemPositions\n        .removeListener(_updatePositions);\n    secondary.itemPositionsNotifier.itemPositions\n        .removeListener(_updatePositions);\n    // _animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(ScrollablePositionedList oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.itemScrollController?._scrollableListState == this) {\n      oldWidget.itemScrollController?._detach();\n    }\n    if (widget.itemScrollController?._scrollableListState != this) {\n      widget.itemScrollController?._detach();\n      widget.itemScrollController?._attach(this);\n    }\n\n    if (widget.itemCount == 0) {\n      setState(() {\n        primary.target = 0;\n        secondary.target = 0;\n      });\n    } else {\n      if (primary.target > widget.itemCount - 1) {\n        setState(() {\n          primary.target = widget.itemCount - 1;\n        });\n      }\n      if (secondary.target > widget.itemCount - 1) {\n        setState(() {\n          secondary.target = widget.itemCount - 1;\n        });\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final cacheExtent = _cacheExtent(constraints);\n        return Listener(\n          onPointerDown: (_) => _stopScroll(canceled: true),\n          child: Stack(\n            children: <Widget>[\n              PostMountCallback(\n                key: primary.key,\n                callback: startAnimationCallback,\n                child: FadeTransition(\n                  opacity: ReverseAnimation(opacity),\n                  child: NotificationListener<ScrollNotification>(\n                    onNotification: (_) => _isTransitioning,\n                    child: PositionedList(\n                      itemBuilder: widget.itemBuilder,\n                      separatorBuilder: widget.separatorBuilder,\n                      itemCount: widget.itemCount,\n                      positionedIndex: primary.target,\n                      controller: primary.scrollController,\n                      itemPositionsNotifier: primary.itemPositionsNotifier,\n                      scrollDirection: widget.scrollDirection,\n                      reverse: widget.reverse,\n                      cacheExtent: cacheExtent,\n                      alignment: primary.alignment,\n                      physics: widget.physics,\n                      shrinkWrap: widget.shrinkWrap,\n                      addSemanticIndexes: widget.addSemanticIndexes,\n                      semanticChildCount: widget.semanticChildCount,\n                      padding: widget.padding,\n                      addAutomaticKeepAlives: widget.addAutomaticKeepAlives,\n                      addRepaintBoundaries: widget.addRepaintBoundaries,\n                    ),\n                  ),\n                ),\n              ),\n              if (_isTransitioning)\n                PostMountCallback(\n                  key: secondary.key,\n                  callback: startAnimationCallback,\n                  child: FadeTransition(\n                    opacity: opacity,\n                    child: NotificationListener<ScrollNotification>(\n                      onNotification: (_) => false,\n                      child: PositionedList(\n                        itemBuilder: widget.itemBuilder,\n                        separatorBuilder: widget.separatorBuilder,\n                        itemCount: widget.itemCount,\n                        itemPositionsNotifier: secondary.itemPositionsNotifier,\n                        positionedIndex: secondary.target,\n                        controller: secondary.scrollController,\n                        scrollDirection: widget.scrollDirection,\n                        reverse: widget.reverse,\n                        cacheExtent: cacheExtent,\n                        alignment: secondary.alignment,\n                        physics: widget.physics,\n                        shrinkWrap: widget.shrinkWrap,\n                        addSemanticIndexes: widget.addSemanticIndexes,\n                        semanticChildCount: widget.semanticChildCount,\n                        padding: widget.padding,\n                        addAutomaticKeepAlives: widget.addAutomaticKeepAlives,\n                        addRepaintBoundaries: widget.addRepaintBoundaries,\n                      ),\n                    ),\n                  ),\n                ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n\n  double _cacheExtent(BoxConstraints constraints) => max(\n        (widget.scrollDirection == Axis.vertical\n                ? constraints.maxHeight\n                : constraints.maxWidth) *\n            _screenScrollCount,\n        widget.minCacheExtent ?? 0,\n      );\n\n  void _jumpTo({required int index, required double alignment}) {\n    _stopScroll(canceled: true);\n    if (index > widget.itemCount - 1) {\n      index = widget.itemCount - 1;\n    }\n    setState(() {\n      primary.scrollController.jumpTo(0);\n      primary\n        ..target = index\n        ..alignment = alignment;\n    });\n  }\n\n  Future<void> _scrollTo({\n    required int index,\n    required double alignment,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    required List<double> opacityAnimationWeights,\n  }) async {\n    if (index > widget.itemCount - 1) {\n      index = widget.itemCount - 1;\n    }\n    if (_isTransitioning) {\n      final scrollCompleter = Completer<void>();\n      _stopScroll(canceled: true);\n      SchedulerBinding.instance.addPostFrameCallback((_) async {\n        await _startScroll(\n          index: index,\n          alignment: alignment,\n          duration: duration,\n          curve: curve,\n          opacityAnimationWeights: opacityAnimationWeights,\n        );\n        scrollCompleter.complete();\n      });\n      await scrollCompleter.future;\n    } else {\n      await _startScroll(\n        index: index,\n        alignment: alignment,\n        duration: duration,\n        curve: curve,\n        opacityAnimationWeights: opacityAnimationWeights,\n      );\n    }\n  }\n\n  Future<void> _startScroll({\n    required int index,\n    required double alignment,\n    required Duration duration,\n    Curve curve = Curves.linear,\n    required List<double> opacityAnimationWeights,\n  }) async {\n    final direction = index > primary.target ? 1 : -1;\n    final itemPosition = primary.itemPositionsNotifier.itemPositions.value\n        .firstWhereOrNull((itemPosition) => itemPosition.index == index);\n    if (itemPosition != null) {\n      final localScrollAmount = itemPosition.itemLeadingEdge *\n          primary.scrollController.position.viewportDimension;\n      await primary.scrollController.animateTo(\n        primary.scrollController.offset +\n            localScrollAmount -\n            alignment * primary.scrollController.position.viewportDimension,\n        duration: duration,\n        curve: curve,\n      );\n    } else {\n      final scrollAmount = _screenScrollCount *\n          primary.scrollController.position.viewportDimension;\n      final startCompleter = Completer<void>();\n      final endCompleter = Completer<void>();\n      startAnimationCallback = () {\n        SchedulerBinding.instance.addPostFrameCallback((_) {\n          startAnimationCallback = () {};\n          _animationController.dispose();\n          _animationController =\n              AnimationController(vsync: this, duration: duration)..forward();\n          opacity.parent = _opacityAnimation(opacityAnimationWeights)\n              .animate(_animationController);\n          secondary.scrollController.jumpTo(\n            -direction *\n                (_screenScrollCount *\n                        primary.scrollController.position.viewportDimension -\n                    alignment *\n                        secondary.scrollController.position.viewportDimension),\n          );\n\n          startCompleter.complete(\n            primary.scrollController.animateTo(\n              primary.scrollController.offset + direction * scrollAmount,\n              duration: duration,\n              curve: curve,\n            ),\n          );\n          endCompleter.complete(\n            secondary.scrollController\n                .animateTo(0, duration: duration, curve: curve),\n          );\n        });\n      };\n      setState(() {\n        secondary\n          ..target = index\n          ..alignment = alignment;\n        _isTransitioning = true;\n      });\n      await Future.wait<void>([startCompleter.future, endCompleter.future]);\n      _stopScroll();\n    }\n  }\n\n  void _stopScroll({bool canceled = false}) {\n    if (!_isTransitioning) {\n      return;\n    }\n\n    if (canceled) {\n      if (primary.scrollController.hasClients) {\n        primary.scrollController.jumpTo(primary.scrollController.offset);\n      }\n      if (secondary.scrollController.hasClients) {\n        secondary.scrollController.jumpTo(secondary.scrollController.offset);\n      }\n    }\n    if (mounted) {\n      setState(() {\n        if (opacity.value >= 0.5) {\n          final temp = primary;\n          primary = secondary;\n          secondary = temp;\n        }\n        _isTransitioning = false;\n        opacity.parent = const AlwaysStoppedAnimation<double>(0);\n      });\n    }\n  }\n\n  Animatable<double> _opacityAnimation(List<double> opacityAnimationWeights) {\n    const startOpacity = 0.0;\n    const endOpacity = 1.0;\n    return TweenSequence<double>(<TweenSequenceItem<double>>[\n      TweenSequenceItem<double>(\n        tween: ConstantTween<double>(startOpacity),\n        weight: opacityAnimationWeights[0],\n      ),\n      TweenSequenceItem<double>(\n        tween: Tween<double>(begin: startOpacity, end: endOpacity),\n        weight: opacityAnimationWeights[1],\n      ),\n      TweenSequenceItem<double>(\n        tween: ConstantTween<double>(endOpacity),\n        weight: opacityAnimationWeights[2],\n      ),\n    ]);\n  }\n\n  void _updatePositions() {\n    final itemPositions =\n        primary.itemPositionsNotifier.itemPositions.value.where(\n      (position) =>\n          position.itemLeadingEdge < 1 && position.itemTrailingEdge > 0,\n    );\n    if (itemPositions.isNotEmpty) {\n      PageStorage.of(context).writeState(\n        context,\n        itemPositions.reduce(\n          (value, element) =>\n              value.itemLeadingEdge < element.itemLeadingEdge ? value : element,\n        ),\n      );\n    }\n    widget.itemPositionsNotifier?.itemPositions.value = itemPositions;\n  }\n}"}, {"structure_type": "function", "name": "updateRenderObject", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 70, "line_from": 70, "line_to": 348, "snippet": "  void updateRenderObject(\n    BuildContext context,\n    CustomRenderShrinkWrappingViewport renderObject,\n  ) {\n    renderObject\n      ..axisDirection = axisDirection\n      ..crossAxisDirection = crossAxisDirection ??\n          Viewport.getDefaultCrossAxisDirection(context, axisDirection)\n      ..anchor = anchor\n      ..offset = offset\n      ..cacheExtent = cacheExtent\n      ..cacheExtentStyle = cacheExtentStyle\n      ..clipBehavior = clipBehavior;\n  }\n}\n\n/// A render object that is bigger on the inside and shrink wraps its children\n/// in the main axis.\n///\n/// [RenderShrinkWrappingViewport] displays a subset of its children according\n/// to its own dimensions and the given [offset]. As the offset varies, different\n/// children are visible through the viewport.\n///\n/// [RenderShrinkWrappingViewport] differs from [RenderViewport] in that\n/// [RenderViewport] expands to fill the main axis whereas\n/// [RenderShrinkWrappingViewport] sizes itself to match its children in the\n/// main axis. This shrink wrapping behavior is expensive because the children,\n/// and hence the viewport, could potentially change size whenever the [offset]\n/// changes (e.g., because of a collapsing header).\n///\n/// [RenderShrinkWrappingViewport] cannot contain [RenderBox] children directly.\n/// Instead, use a [RenderSliverList], [RenderSliverFixedExtentList],\n/// [RenderSliverGrid], or a [RenderSliverToBoxAdapter], for example.\n///\n/// See also:\n///\n///  * [RenderViewport], a viewport that does not shrink-wrap its contents.\n///  * [RenderSliver], which explains more about the Sliver protocol.\n///  * [RenderBox], which explains more about the Box protocol.\n///  * [RenderSliverToBoxAdapter], which allows a [RenderBox] object to be\n///    placed inside a [RenderSliver] (the opposite of this class).\nclass CustomRenderShrinkWrappingViewport extends CustomRenderViewport {\n  /// Creates a viewport (for [RenderSliver] objects) that shrink-wraps its\n  /// contents.\n  ///\n  /// The [offset] must be specified. For testing purposes, consider passing a\n  /// [ViewportOffset.zero] or [ViewportOffset.fixed].\n  CustomRenderShrinkWrappingViewport({\n    super.axisDirection,\n    required super.crossAxisDirection,\n    required super.offset,\n    double anchor = 0.0,\n    super.children,\n    super.center,\n    super.cacheExtent,\n  }) : _anchor = anchor;\n\n  double _anchor;\n\n  @override\n  double get anchor => _anchor;\n\n  @override\n  bool get sizedByParent => false;\n\n  double lastMainAxisExtent = -1;\n\n  @override\n  set anchor(double value) {\n    if (value == _anchor) return;\n    _anchor = value;\n    markNeedsLayout();\n  }\n\n  late double _shrinkWrapExtent;\n\n  /// This value is set during layout based on the [CacheExtentStyle].\n  ///\n  /// When the style is [CacheExtentStyle.viewport], it is the main axis extent\n  /// of the viewport multiplied by the requested cache extent, which is still\n  /// expressed in pixels.\n  double? _calculatedCacheExtent;\n\n  /// While List in a wrapping container, eg. ListView\uff0cthe mainAxisExtent will\n  /// be infinite. This time need to change mainAxisExtent to this value.\n  final double _maxMainAxisExtent = double.maxFinite;\n\n  @override\n  void performLayout() {\n    if (center == null) {\n      assert(firstChild == null);\n      _minScrollExtent = 0.0;\n      _maxScrollExtent = 0.0;\n      _hasVisualOverflow = false;\n      offset.applyContentDimensions(0, 0);\n      return;\n    }\n\n    assert(center!.parent == this);\n\n    final BoxConstraints constraints = this.constraints;\n    if (firstChild == null) {\n      switch (axis) {\n        case Axis.vertical:\n          assert(constraints.hasBoundedWidth);\n          size = Size(constraints.maxWidth, constraints.minHeight);\n        case Axis.horizontal:\n          assert(constraints.hasBoundedHeight);\n          size = Size(constraints.minWidth, constraints.maxHeight);\n      }\n      offset.applyViewportDimension(0);\n      _maxScrollExtent = 0.0;\n      _shrinkWrapExtent = 0.0;\n      _hasVisualOverflow = false;\n      offset.applyContentDimensions(0, 0);\n      return;\n    }\n\n    double mainAxisExtent;\n    final double crossAxisExtent;\n    switch (axis) {\n      case Axis.vertical:\n        assert(constraints.hasBoundedWidth);\n        mainAxisExtent = constraints.maxHeight;\n        crossAxisExtent = constraints.maxWidth;\n      case Axis.horizontal:\n        assert(constraints.hasBoundedHeight);\n        mainAxisExtent = constraints.maxWidth;\n        crossAxisExtent = constraints.maxHeight;\n    }\n\n    if (mainAxisExtent.isInfinite) {\n      mainAxisExtent = _maxMainAxisExtent;\n    }\n\n    final centerOffsetAdjustment = center!.centerOffsetAdjustment;\n\n    double correction = 0;\n    double effectiveExtent = 0;\n    do {\n      correction = _attemptLayout(\n        mainAxisExtent,\n        crossAxisExtent,\n        offset.pixels + centerOffsetAdjustment,\n      );\n      if (correction != 0.0) {\n        offset.correctBy(correction);\n      } else {\n        switch (axis) {\n          case Axis.vertical:\n            effectiveExtent = constraints.constrainHeight(_shrinkWrapExtent);\n          case Axis.horizontal:\n            effectiveExtent = constraints.constrainWidth(_shrinkWrapExtent);\n        }\n        // *** Difference from [RenderViewport].\n        final top = _minScrollExtent + mainAxisExtent * anchor;\n        final bottom = _maxScrollExtent - mainAxisExtent * (1.0 - anchor);\n\n        final double maxScrollOffset = math.max(math.min(0, top), bottom);\n        final double minScrollOffset = math.min(top, maxScrollOffset);\n\n        final bool didAcceptViewportDimension =\n            offset.applyViewportDimension(effectiveExtent);\n        final bool didAcceptContentDimension =\n            offset.applyContentDimensions(minScrollOffset, maxScrollOffset);\n        if (didAcceptViewportDimension && didAcceptContentDimension) {\n          break;\n        }\n      }\n    } while (int.tryParse(\"1\") == 1);\n    switch (axis) {\n      case Axis.vertical:\n        size =\n            constraints.constrainDimensions(crossAxisExtent, effectiveExtent);\n      case Axis.horizontal:\n        size =\n            constraints.constrainDimensions(effectiveExtent, crossAxisExtent);\n    }\n  }\n\n  double _attemptLayout(\n    double mainAxisExtent,\n    double crossAxisExtent,\n    double correctedOffset,\n  ) {\n    assert(!mainAxisExtent.isNaN);\n    assert(mainAxisExtent >= 0.0);\n    assert(crossAxisExtent.isFinite);\n    assert(crossAxisExtent >= 0.0);\n    assert(correctedOffset.isFinite);\n    _minScrollExtent = 0.0;\n    _maxScrollExtent = 0.0;\n    _hasVisualOverflow = false;\n    _shrinkWrapExtent = 0.0;\n\n    // centerOffset is the offset from the leading edge of the RenderViewport\n    // to the zero scroll offset (the line between the forward slivers and the\n    // reverse slivers).\n    final centerOffset = mainAxisExtent * anchor - correctedOffset;\n    final reverseDirectionRemainingPaintExtent =\n        centerOffset.clamp(0.0, mainAxisExtent);\n    final forwardDirectionRemainingPaintExtent =\n        (mainAxisExtent - centerOffset).clamp(0.0, mainAxisExtent);\n\n    switch (cacheExtentStyle) {\n      case CacheExtentStyle.pixel:\n        _calculatedCacheExtent = cacheExtent;\n      case CacheExtentStyle.viewport:\n        _calculatedCacheExtent = mainAxisExtent * cacheExtent!;\n    }\n\n    final fullCacheExtent = mainAxisExtent + 2 * _calculatedCacheExtent!;\n    final centerCacheOffset = centerOffset + _calculatedCacheExtent!;\n    final reverseDirectionRemainingCacheExtent =\n        centerCacheOffset.clamp(0.0, fullCacheExtent);\n    final forwardDirectionRemainingCacheExtent =\n        (fullCacheExtent - centerCacheOffset).clamp(0.0, fullCacheExtent);\n\n    final leadingNegativeChild = childBefore(center!);\n\n    if (leadingNegativeChild != null) {\n      // negative scroll offsets\n      final result = layoutChildSequence(\n        child: leadingNegativeChild,\n        scrollOffset: math.max(mainAxisExtent, centerOffset) - mainAxisExtent,\n        overlap: 0,\n        layoutOffset: forwardDirectionRemainingPaintExtent,\n        remainingPaintExtent: reverseDirectionRemainingPaintExtent,\n        mainAxisExtent: mainAxisExtent,\n        crossAxisExtent: crossAxisExtent,\n        growthDirection: GrowthDirection.reverse,\n        advance: childBefore,\n        remainingCacheExtent: reverseDirectionRemainingCacheExtent,\n        cacheOrigin: (mainAxisExtent - centerOffset)\n            .clamp(-_calculatedCacheExtent!, 0.0),\n      );\n      if (result != 0.0) return -result;\n    }\n\n    // positive scroll offsets\n    return layoutChildSequence(\n      child: center,\n      scrollOffset: math.max(0, -centerOffset),\n      overlap: leadingNegativeChild == null ? math.min(0, -centerOffset) : 0.0,\n      layoutOffset: centerOffset >= mainAxisExtent\n          ? centerOffset\n          : reverseDirectionRemainingPaintExtent,\n      remainingPaintExtent: forwardDirectionRemainingPaintExtent,\n      mainAxisExtent: mainAxisExtent,\n      crossAxisExtent: crossAxisExtent,\n      growthDirection: GrowthDirection.forward,\n      advance: childAfter,\n      remainingCacheExtent: forwardDirectionRemainingCacheExtent,\n      cacheOrigin: centerOffset.clamp(-_calculatedCacheExtent!, 0.0),\n    );\n  }\n\n  @override\n  bool get hasVisualOverflow => _hasVisualOverflow;\n\n  @override\n  void updateOutOfBandData(\n    GrowthDirection growthDirection,\n    SliverGeometry childLayoutGeometry,\n  ) {\n    switch (growthDirection) {\n      case GrowthDirection.forward:\n        _maxScrollExtent += childLayoutGeometry.scrollExtent;\n      case GrowthDirection.reverse:\n        _minScrollExtent -= childLayoutGeometry.scrollExtent;\n    }\n    if (childLayoutGeometry.hasVisualOverflow) _hasVisualOverflow = true;\n    _shrinkWrapExtent += childLayoutGeometry.maxPaintExtent;\n    growSize = _shrinkWrapExtent;\n  }\n\n  @override\n  String labelForChild(int index) => 'child $index';\n}"}, {"structure_type": "function", "name": "slivers.where", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 404, "line_from": 404, "line_to": 551, "snippet": "              slivers.where((Widget child) => child.key == center).length == 1,\n        ),\n        assert(\n          cacheExtentStyle != CacheExtentStyle.viewport || cacheExtent != null,\n        ),\n        super(children: slivers);\n\n  /// The direction in which the [offset]'s [ViewportOffset.pixels] increases.\n  ///\n  /// For example, if the [axisDirection] is [AxisDirection.down], a scroll\n  /// offset of zero is at the top of the viewport and increases towards the\n  /// bottom of the viewport.\n  final AxisDirection axisDirection;\n\n  /// The direction in which child should be laid out in the cross axis.\n  ///\n  /// If the [axisDirection] is [AxisDirection.down] or [AxisDirection.up], this\n  /// property defaults to [AxisDirection.left] if the ambient [Directionality]\n  /// is [TextDirection.rtl] and [AxisDirection.right] if the ambient\n  /// [Directionality] is [TextDirection.ltr].\n  ///\n  /// If the [axisDirection] is [AxisDirection.left] or [AxisDirection.right],\n  /// this property defaults to [AxisDirection.down].\n  final AxisDirection? crossAxisDirection;\n\n  /// The relative position of the zero scroll offset.\n  ///\n  /// For example, if [anchor] is 0.5 and the [axisDirection] is\n  /// [AxisDirection.down] or [AxisDirection.up], then the zero scroll offset is\n  /// vertically centered within the viewport. If the [anchor] is 1.0, and the\n  /// [axisDirection] is [AxisDirection.right], then the zero scroll offset is\n  /// on the left edge of the viewport.\n  final double anchor;\n\n  /// Which part of the content inside the viewport should be visible.\n  ///\n  /// The [ViewportOffset.pixels] value determines the scroll offset that the\n  /// viewport uses to select which part of its content to display. As the user\n  /// scrolls the viewport, this value changes, which changes the content that\n  /// is displayed.\n  ///\n  /// Typically a [ScrollPosition].\n  final ViewportOffset offset;\n\n  /// The first child in the [GrowthDirection.forward] growth direction.\n  ///\n  /// Children after [center] will be placed in the [axisDirection] relative to\n  /// the [center]. Children before [center] will be placed in the opposite of\n  /// the [axisDirection] relative to the [center].\n  ///\n  /// The [center] must be the key of a child of the viewport.\n  final Key? center;\n\n  /// {@macro flutter.rendering.RenderViewportBase.cacheExtent}\n  ///\n  /// See also:\n  ///\n  ///  * [cacheExtentStyle], which controls the units of the [cacheExtent].\n  final double? cacheExtent;\n\n  /// {@macro flutter.rendering.RenderViewportBase.cacheExtentStyle}\n  final CacheExtentStyle cacheExtentStyle;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Given a [BuildContext] and an [AxisDirection], determine the correct cross\n  /// axis direction.\n  ///\n  /// This depends on the [Directionality] if the `axisDirection` is vertical;\n  /// otherwise, the default cross axis direction is downwards.\n  static AxisDirection getDefaultCrossAxisDirection(\n    BuildContext context,\n    AxisDirection axisDirection,\n  ) {\n    switch (axisDirection) {\n      case AxisDirection.up:\n        assert(\n          debugCheckHasDirectionality(\n            context,\n            why:\n                \"to determine the cross-axis direction when the viewport has an 'up' axisDirection\",\n            alternative:\n                \"Alternatively, consider specifying the 'crossAxisDirection' argument on the Viewport.\",\n          ),\n        );\n        return textDirectionToAxisDirection(Directionality.of(context));\n      case AxisDirection.right:\n        return AxisDirection.down;\n      case AxisDirection.down:\n        assert(\n          debugCheckHasDirectionality(\n            context,\n            why:\n                \"to determine the cross-axis direction when the viewport has a 'down' axisDirection\",\n            alternative:\n                \"Alternatively, consider specifying the 'crossAxisDirection' argument on the Viewport.\",\n          ),\n        );\n        return textDirectionToAxisDirection(Directionality.of(context));\n      case AxisDirection.left:\n        return AxisDirection.down;\n    }\n  }\n\n  @override\n  CustomRenderViewport createRenderObject(BuildContext context);\n\n  @override\n  ViewportElement createElement() => ViewportElement(this);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty<AxisDirection>('axisDirection', axisDirection))\n      ..add(\n        EnumProperty<AxisDirection>(\n          'crossAxisDirection',\n          crossAxisDirection,\n          defaultValue: null,\n        ),\n      )\n      ..add(DoubleProperty('anchor', anchor))\n      ..add(DiagnosticsProperty<ViewportOffset>('offset', offset));\n    if (center != null) {\n      properties.add(DiagnosticsProperty<Key>('center', center));\n    } else if (children.isNotEmpty && children.first.key != null) {\n      properties.add(\n        DiagnosticsProperty<Key>(\n          'center',\n          children.first.key,\n          tooltip: 'implicit',\n        ),\n      );\n    }\n    properties\n      ..add(DiagnosticsProperty<double>('cacheExtent', cacheExtent))\n      ..add(\n        DiagnosticsProperty<CacheExtentStyle>(\n          'cacheExtentStyle',\n          cacheExtentStyle,\n        ),\n      );\n  }\n}"}, {"structure_type": "function", "name": "mount", "docstring": "", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/wrapping.dart", "file_name": "wrapping.dart", "line": 565, "line_from": 565, "line_to": 612, "snippet": "  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    _updateCenter();\n  }\n\n  @override\n  void update(MultiChildRenderObjectWidget newWidget) {\n    super.update(newWidget);\n    _updateCenter();\n  }\n\n  void _updateCenter() {\n    if (widget.center != null) {\n      renderObject.center = children\n          .singleWhere((Element element) => element.widget.key == widget.center)\n          .renderObject as RenderSliver?;\n    } else if (children.isNotEmpty) {\n      renderObject.center = children.first.renderObject as RenderSliver?;\n    } else {\n      renderObject.center = null;\n    }\n  }\n\n  @override\n  void debugVisitOnstageChildren(ElementVisitor visitor) {\n    children.where((Element e) {\n      final RenderSliver renderSliver = e.renderObject! as RenderSliver;\n      return renderSliver.geometry!.visible;\n    }).forEach(visitor);\n  }\n}\n\nclass CustomSliverPhysicalContainerParentData\n    extends SliverPhysicalContainerParentData {\n  /// The position of the child relative to the zero scroll offset.\n  ///\n  /// The number of pixels from from the zero scroll offset of the parent sliver\n  /// (the line at which its [SliverConstraints.scrollOffset] is zero) to the\n  /// side of the child closest to that offset. A [layoutOffset] can be null\n  /// when it cannot be determined. The value will be set after layout.\n  ///\n  /// In a typical list, this does not change as the parent is scrolled.\n  ///\n  /// Defaults to null.\n  double? layoutOffset;\n\n  GrowthDirection? growthDirection;\n}"}, {"structure_type": "function", "name": "child;", "docstring": "The widget below this widget in the tree.", "module": "src", "file_path": "external_libs/scrollable_positioned_list/src/post_mount_callback.dart", "file_name": "post_mount_callback.dart", "line": 13, "line_from": 13, "line_to": 34, "snippet": "  final Widget child;\n\n  /// Callback to call when the element for this widget is mounted.\n  final void Function()? callback;\n\n  @override\n  StatelessElement createElement() => _PostMountCallbackElement(this);\n\n  @override\n  Widget build(BuildContext context) => child;\n}\n\nclass _PostMountCallbackElement extends StatelessElement {\n  _PostMountCallbackElement(PostMountCallback super.widget);\n\n  @override\n  void mount(Element? parent, Object? newSlot) {\n    super.mount(parent, newSlot);\n    final PostMountCallback postMountCallback = widget as PostMountCallback;\n    postMountCallback.callback?.call();\n  }\n}"}, {"structure_type": "function", "name": "dismiss", "docstring": "", "module": "services", "file_path": "external_libs/services/keyboard_service.dart", "file_name": "keyboard_service.dart", "line": 24, "line_from": 24, "line_to": 43, "snippet": "  static void dismiss({BuildContext? context, FocusNode? focusNode}) =>\n      catchVoid(() {\n        final BuildContext anyContext = (context != null && context.mounted)\n            ? context\n            : QuranMajeed.globalContext;\n\n        if (!isVisible(anyContext)) return;\n\n        SystemChannels.textInput.invokeMethod<void>('TextInput.hide');\n\n        // Focus handling\n        if (focusNode != null) {\n          if (focusNode.hasFocus || focusNode.hasPrimaryFocus) {\n            focusNode.unfocus();\n          }\n        } else {\n          FocusScope.of(anyContext).unfocus();\n        }\n      });\n}"}, {"structure_type": "function", "name": "toggleLoading", "docstring": "", "module": "base", "file_path": "base/base_presenter.dart", "file_name": "base_presenter.dart", "line": 19, "line_from": 19, "line_to": 96, "snippet": "  Future<void> toggleLoading({required bool loading});\n\n  // Function to add user message\n  Future<void> addUserMessage(String message);\n\n  // Function to handle stream events\n  @protected\n  Future<void> handleStreamEvents<T>({\n    required Stream<Either<String, T>> stream,\n    required void Function(T) onData,\n    required StreamSubscription<Either<String, T>>? subscription,\n  }) async {\n    await subscription?.cancel();\n    subscription = stream.listen(\n      (result) => result.fold(addUserMessage, onData),\n      onError: (Object e) => logDebugStatic('Error in handleStreamEvents:', e.toString()),\n      onDone: () async => subscription?.cancel(),\n    );\n  }\n\n  // Function to execute a task with loading state\n  @protected\n  Future<void> executeTaskWithLoading(FutureOr<void> Function() task) async {\n    await toggleLoading(loading: true);\n    await task();\n    await toggleLoading(loading: false);\n  }\n\n  // Function to execute a use case that only shows a message\n  @protected\n  Future<void> executeMessageOnlyUseCase(\n    FutureOr<Either<String, String>> Function() task, {\n    bool showMessage = true,\n    VoidCallback? onSuccess,\n  }) async {\n    await toggleLoading(loading: true);\n    final Either<String, String> result = await task();\n    await result.fold(addUserMessage, (message) async {\n      if (showMessage) await addUserMessage(message);\n      onSuccess?.call();\n    });\n    await toggleLoading(loading: false);\n  }\n\n  // Function to parse data from Either with user message\n  @protected\n  Future<void> parseDataFromEitherWithUserMessage<T>({\n    required FutureOr<Either<String, T>> Function() task,\n    required void Function(T) onDataLoaded,\n    bool showLoading = false,\n    T? valueOnError,\n  }) async {\n    if (showLoading) await toggleLoading(loading: true);\n    final Either<String, T> result = await task();\n    result.fold(\n      (message) {\n        addUserMessage(message);\n        if (valueOnError != null) onDataLoaded(valueOnError);\n      },\n      onDataLoaded,\n    );\n    if (showLoading) await toggleLoading(loading: false);\n  }\n\n  // Function to map data from Either with user message\n  @protected\n  Future<T?> mapDataFromEitherWithUserMessage<T>({\n    required FutureOr<Either<String, T>> Function() task,\n    bool showLoading = false,\n  }) async {\n    T? data;\n    if (showLoading) await toggleLoading(loading: true);\n    final Either<String, T> result = await task();\n    if (showLoading) await toggleLoading(loading: false);\n    result.fold(addUserMessage, (d) => data = d);\n    return data;\n  }\n}"}, {"structure_type": "function", "name": "fontExists", "docstring": "", "module": "utility", "file_path": "utility/font_manager.dart", "file_name": "font_manager.dart", "line": 21, "line_from": 21, "line_to": 151, "snippet": "  Future<bool> fontExists(int pageNumber, String fontDir) async {\n    final File fontFile = File('$fontDir/${FontConstants.getFontFileName(pageNumber)}');\n    return fontFile.exists();\n  }\n\n  // Get font file path\n  String getFontPath(int pageNumber, String fontDir) {\n    return '$fontDir/${FontConstants.getFontFileName(pageNumber)}';\n  }\n\n  // Load and register a font\n  Future<String> loadAndRegisterFont(int pageNumber, String fontDir) async {\n    // Check if font is already loaded\n    if (_loadedFonts.containsKey(pageNumber)) {\n      // Update LRU queue (move to front)\n      _fontUsageQueue.remove(pageNumber);\n      _fontUsageQueue.insert(0, pageNumber);\n      return _loadedFonts[pageNumber]!;\n    }\n\n    final String fontFamily = FontConstants.getFontFamilyForPage(pageNumber);\n    final String fontPath = getFontPath(pageNumber, fontDir);\n\n    try {\n      // Check if font file exists\n      final File fontFile = File(fontPath);\n      if (!await fontFile.exists()) {\n        logErrorStatic('Font file does not exist: $fontPath', _tag);\n        return FontConstants.defaultFontFamily;\n      }\n\n      // Read font file bytes\n      final Uint8List fontBytes = await fontFile.readAsBytes();\n      if (fontBytes.isEmpty) {\n        logErrorStatic('Font file is empty: $fontPath', _tag);\n        return FontConstants.defaultFontFamily;\n      }\n\n      // Load font using the Flutter font loader\n      final font = FontLoader(fontFamily);\n      font.addFont(Future.value(ByteData.view(fontBytes.buffer)));\n      await font.load();\n\n      // Manage cache size\n      if (_loadedFonts.length >= FontConstants.maxFontCacheSize && _fontUsageQueue.isNotEmpty) {\n        final int oldestPage = _fontUsageQueue.removeLast();\n        _loadedFonts.remove(oldestPage);\n      }\n\n      // Add to cache\n      _loadedFonts[pageNumber] = fontFamily;\n      _fontUsageQueue.insert(0, pageNumber);\n\n      logInfoStatic('Successfully loaded font for page $pageNumber', _tag);\n      return fontFamily;\n    } catch (e, s) {\n      logErrorStatic('Error loading font for page $pageNumber: $e\\n$s', _tag);\n      return FontConstants.defaultFontFamily;\n    }\n  }\n\n  // Preload fonts for upcoming pages\n  Future<void> preloadFonts(int currentPage, int totalPages, String fontDir) async {\n    // Preload next N fonts\n    for (int i = 1; i <= FontConstants.fontsToPreload; i++) {\n      final int pageToLoad = currentPage + i;\n      if (pageToLoad <= totalPages && !_loadedFonts.containsKey(pageToLoad)) {\n        final bool exists = await fontExists(pageToLoad, fontDir);\n        if (exists) {\n          // Load in background with lower priority\n          unawaited(_loadFontInBackground(pageToLoad, fontDir));\n        }\n      }\n    }\n\n    // Optionally preload previous pages as well\n    for (int i = 1; i <= FontConstants.fontsToPreload; i++) {\n      final int pageToLoad = currentPage - i;\n      if (pageToLoad > 0 && !_loadedFonts.containsKey(pageToLoad)) {\n        final bool exists = await fontExists(pageToLoad, fontDir);\n        if (exists) {\n          // Load in background with lower priority\n          unawaited(_loadFontInBackground(pageToLoad, fontDir));\n        }\n      }\n    }\n  }\n\n  // Helper to load a font in the background\n  Future<void> _loadFontInBackground(int pageNumber, String fontDir) async {\n    try {\n      final String fontFamily = FontConstants.getFontFamilyForPage(pageNumber);\n      final String fontPath = getFontPath(pageNumber, fontDir);\n\n      // Read font file bytes\n      final File fontFile = File(fontPath);\n      final Uint8List fontBytes = await fontFile.readAsBytes();\n\n      // Load font\n      final font = FontLoader(fontFamily);\n      font.addFont(Future.value(ByteData.view(fontBytes.buffer)));\n      await font.load();\n\n      // Manage cache size\n      if (_loadedFonts.length >= FontConstants.maxFontCacheSize && _fontUsageQueue.isNotEmpty) {\n        final int oldestPage = _fontUsageQueue.removeLast();\n        _loadedFonts.remove(oldestPage);\n      }\n\n      // Add to cache\n      _loadedFonts[pageNumber] = fontFamily;\n      _fontUsageQueue.add(pageNumber); // Add to end since it's preloaded\n    } catch (e) {\n      logErrorStatic('Error preloading font for page $pageNumber: $e', _tag);\n    }\n  }\n\n  // Clear all loaded fonts from cache\n  void clearFontCache() {\n    _loadedFonts.clear();\n    _fontUsageQueue.clear();\n  }\n}\n\n// Helper extension to mark futures as unawaited\nvoid unawaited(Future<void> future) {\n  // Explicitly handle errors so they don't get lost\n  future.catchError((error, stackTrace) {\n    logErrorStatic('Unawaited future error: $error\\n$stackTrace', 'unawaited');\n  });\n}"}, {"structure_type": "function", "name": "BaseUiState>", "docstring": "", "module": "utility", "file_path": "utility/ui_helper.dart", "file_name": "ui_helper.dart", "line": 18, "line_from": 18, "line_to": 142, "snippet": "  static Future<void> onMessage<T extends BaseUiState>(\n    Obs<T> uiStateStream,\n  ) async {\n    StreamSubscription<T>? subscription;\n    await doOnPageLoaded(() {\n      try {\n        subscription = uiStateStream.listen(\n          (uiState) => showMessage(message: uiState.userMessage),\n          onDone: () => subscription?.cancel(),\n          onError: (e) => subscription?.cancel(),\n          cancelOnError: true,\n        );\n      } catch (e) {\n        logErrorStatic(e, _fileName);\n        subscription?.cancel();\n        subscription = null;\n      }\n    });\n  }\n\n  static bool onScrollNotification({\n    required ScrollNotification scrollNotification,\n    required void Function({required bool toTop}) onScrolled,\n  }) {\n    if (scrollNotification is! ScrollUpdateNotification) return false;\n    final bool reachedAtTop = scrollNotification.metrics.pixels == 0;\n    onScrolled(toTop: reachedAtTop);\n    return false;\n  }\n\n  static Future<void> doOnPageLoaded(void Function() onLoaded) async {\n    // Takes a callback function onLoaded as a parameter. When called, this\n    // method schedules the onLoaded callback to be executed after the current\n    // frame has finished rendering, by adding it to the end of the post-frame\n    // callbacks list using WidgetsBinding.instance.addPostFrameCallback.\n    //\n    // To add a slight delay to the execution of the onLoaded callback, the\n    // method also uses Future.delayed to wait for 64 milliseconds before\n    // invoking the callback. The entire method is wrapped in a\n    // catchFutureOrVoid function which catches any exceptions thrown during the\n    // execution of the callback and handles them appropriately.\n    await catchFutureOrVoid(() async {\n      WidgetsBinding.instance.addPostFrameCallback((timeStamp) async {\n        onLoaded();\n      });\n    });\n  }\n\n  static void doOnPageDestroy(VoidCallback onDestroy) {\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      onDestroy();\n    });\n  }\n\n  static Future<void> toggleFullScreen({required bool makeFullScreen}) async {\n    await catchFutureOrVoid(() async {\n      await SystemChrome.setEnabledSystemUIMode(\n        SystemUiMode.manual,\n        overlays: makeFullScreen ? [] : SystemUiOverlay.values,\n      );\n    });\n  }\n\n  /// Listens to the scroll events and triggers the provided callback function when scrolled.\n  ///\n  /// The [scrollController] is an instance of [ItemScrollController] that controls the scrolling behavior.\n  /// The [onScrolled] is a callback function that takes a boolean parameter [toTop] indicating whether the scroll is towards the top or not.\n  ///\n  /// Example usage:\n  /// ```dart\n  /// await UiHelper.listenToScroll(\n  ///   scrollController: myScrollController,\n  ///   onScrolled: ({required bool toTop}) {\n  ///     // Handle scroll event\n  ///   },\n  /// );\n  /// ```\n  static Future<void> listenToScroll({\n    required ItemScrollController scrollController,\n    required void Function({required bool toTop}) onScrolled,\n  }) async {\n    await UiHelper.doOnPageLoaded(() async {\n      onScrolled(toTop: false);\n\n      if (!scrollController.isAttached) return;\n      final ScrollController? rootScrollController =\n          scrollController.scrollController;\n      if (rootScrollController == null) return;\n      if (!rootScrollController.hasClients) return;\n\n      rootScrollController.addListener(() {\n        Throttle.throttle(\n          _onListScrollingToTopThrottleTag,\n          480.inMilliseconds,\n          () {\n            final bool scrollingFromBottomToTop =\n                rootScrollController.position.userScrollDirection.name ==\n                    'reverse';\n            onScrolled(toTop: scrollingFromBottomToTop);\n          },\n        );\n      });\n    });\n  }\n\n  static const String _onListScrollingToTopThrottleTag =\n      'onListScrollingToTopThrottleTag';\n}\n\nclass UpgradeAppDialogContainer extends StatelessWidget {\n  const UpgradeAppDialogContainer({\n    super.key,\n    required this.child,\n  });\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    return UpgradeAlert(\n      upgrader: Upgrader(),\n      child: child,\n    );\n  }\n}"}, {"structure_type": "function", "name": "logError", "docstring": "Logs an error message with the provided [exception].\n\nIf [showLog] is false, nothing will be logged.\n\nExample usage:\n\n```dart\n\nfinal error = Exception('Something went wrong');\nthis.logError();\n\n[MyClass] [ERROR] - 2023-04-08 11:30:00\nException: Something went wrong\n#0 main (file:///path/to/main.dart:10:11)\n\n```\n", "module": "utility", "file_path": "utility/logger_utility.dart", "file_name": "logger_utility.dart", "line": 122, "line_from": 122, "line_to": 171, "snippet": "  void logError(Object? exception) {\n    // to avoid runtimeType.toString() in release mode\n    // as this can hamper performance, we use showLog\n    // to check if we are in debug mode or not\n    if (!showLog) return;\n    // we are logging only in debug mode, so the performance hit can be ignored\n    // ignore: no_runtimeType_toString\n    logErrorStatic(exception, runtimeType.toString());\n  }\n\n  /// Logs a debug message with the provided [object].\n  ///\n  /// If [showLog] is false, nothing will be logged.\n  ///\n  /// Example usage:\n  ///\n  /// ```dart\n  ///\n  /// this.logDebug('This is a debug message');\n  ///\n  /// [MyClass] [DEBUG] - 2023-04-08 11:30:00\n  /// This is a debug message\n  ///\n  /// ```\n  ///\n  void logDebug(Object object) {\n    // to avoid runtimeType.toString() in release mode\n    // as this can hamper performance, we use showLog\n    // to check if we are in debug mode or not\n    if (!showLog) return;\n    // we are logging only in debug mode, so the performance hit can be ignored\n    // ignore: no_runtimeType_toString\n    logDebugStatic(object, runtimeType.toString());\n  }\n}\n\n/// A utility class for logging messages\nclass Logger {\n  static void info(String message, [String tag = '']) {\n    logInfoStatic(message, tag);\n  }\n\n  static void error(String message, [String tag = '']) {\n    logErrorStatic(message, tag);\n  }\n\n  static void debug(String message, [String tag = '']) {\n    logDebugStatic(message, tag);\n  }\n}"}, {"structure_type": "function", "name": "navigatorPush<T>", "docstring": "", "module": "utility", "file_path": "utility/utility.dart", "file_name": "utility.dart", "line": 43, "line_from": 43, "line_to": 155, "snippet": "  Future<T?> navigatorPush<T>(Widget page) async {\n    try {\n      if (!mounted) return null;\n      final CupertinoPageRoute<T> route = CupertinoPageRoute<T>(builder: (context) => page);\n      return Navigator.push<T>(this, route);\n    } catch (e) {\n      logError(\"Failed to navigate to ${e.runtimeType} -> $e\");\n      return null;\n    }\n  }\n\n  // Generic navigation method with custom transition\n  void customNavigatorPush(BuildContext context, Widget nextPage) {\n    Navigator.push(\n      context,\n      PageRouteBuilder(\n        transitionDuration: const Duration(milliseconds: 500),\n        pageBuilder: (context, animation, secondaryAnimation) => nextPage,\n        transitionsBuilder: (context, animation, secondaryAnimation, child) {\n          Offset begin = const Offset(0.0, 1.0);\n          Offset end = Offset.zero;\n          Tween<Offset> tween = Tween(begin: begin, end: end);\n          Animation<Offset> offsetAnimation = animation.drive(tween);\n\n          return SlideTransition(\n            position: offsetAnimation,\n            child: child,\n          );\n        },\n      ),\n    );\n  }\n\n  Future<T?> navigatorPushReplacement<T>(Widget page) async {\n    try {\n      if (!mounted) return null;\n      final CupertinoPageRoute<T> route = CupertinoPageRoute<T>(builder: (context) => page);\n      return Navigator.pushReplacement(this, route);\n    } catch (e) {\n      logError(\"Failed to navigate to ${e.runtimeType} -> $e\");\n      return null;\n    }\n  }\n\n  Future<T?> showBottomSheetLegacy<T>(Widget bottomSheet) async {\n    return Get.bottomSheet<T>(\n      bottomSheet,\n      isScrollControlled: true,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n    );\n  }\n\n  Future<T?> showBottomSheet<T>(\n    Widget bottomSheet,\n    BuildContext context,\n  ) async {\n    if (!mounted) return null;\n    final T? result = await showModalBottomSheet<T>(\n      context: context,\n      builder: (_) => bottomSheet,\n      backgroundColor: Colors.transparent,\n      isScrollControlled: true,\n      enableDrag: true,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.only(\n          topLeft: Radius.circular(twentyPx),\n          topRight: Radius.circular(twentyPx),\n        ),\n      ),\n    );\n    return result;\n  }\n\n  void navigatorPop<T>({T? result}) {\n    if (!mounted) return;\n    Navigator.pop(this, result);\n  }\n}\n\nFuture<T?> showSlideDownDialog<T>({\n  required Widget content,\n  required BuildContext context,\n  bool barrierDismissible = true,\n  Duration transitionDuration = const Duration(milliseconds: 300),\n  Color? barrierColor,\n}) async {\n  if (!context.mounted) return null;\n\n  final T? result = await showGeneralDialog<T>(\n    context: context,\n    barrierDismissible: barrierDismissible,\n    barrierColor: barrierColor ?? Colors.black.withOpacityInt(0.4),\n    barrierLabel: '',\n    transitionDuration: transitionDuration,\n    transitionBuilder: (context, animation, __, Widget child) {\n      return SlideTransition(\n        position: Tween<Offset>(\n          begin: const Offset(0, -1), // Top to bottom\n          end: Offset.zero,\n        ).animate(animation),\n        child: child,\n      );\n    },\n    pageBuilder: (context, animation, __) => content,\n  );\n\n  return result;\n}"}, {"structure_type": "function", "name": "Function", "docstring": "", "module": "utility", "file_path": "utility/utility.dart", "file_name": "utility.dart", "line": 1238, "line_from": 1238, "line_to": 1266, "snippet": "  required void Function(String) onError,\n}) async {\n  try {\n    if (!await file.exists()) {\n      onError(\"Downloaded file is incomplete. Please try again.\");\n      return false;\n    }\n\n    // Try to read the first few bytes to verify file integrity\n    try {\n      await file.openRead(0, 1024).first;\n      return true;\n    } catch (e) {\n      logErrorStatic(\"Error validating file integrity: $e\", \"FileValidation\");\n      await file.delete();\n      if (context?.mounted ?? false) {\n        onError(\"Downloaded file is corrupted. Please try again.\");\n      }\n      return false;\n    }\n  } catch (e) {\n    logErrorStatic(\"Error validating downloaded file: $e\", \"FileValidation\");\n    await file.delete();\n    if (context?.mounted ?? false) {\n      onError(\"Failed to validate downloaded file. Please try again.\");\n    }\n    return false;\n  }\n}"}]